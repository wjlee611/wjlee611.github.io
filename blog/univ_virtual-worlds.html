<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>웅덩이</title><link rel="canonical" href="https://wjlee611.github.io/blog/univ_virtual-worlds"/><meta name="next-head-count" content="4"/><link rel="icon" href="/images/icon_circle.png"/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" rel="stylesheet"/><meta name="description" content="웅덩이"/><meta name="apple-mobile-web-app-title" content="웅덩이"/><meta name="application-name" content="웅덩이"/><meta name="theme-color" content="#009c39"/><meta name="google-site-verification" content="vhQ9DaDdUJcSBHKI_U6tAtE61zwz2i2pLQXyZ62GRLk"/><meta name="naver-site-verification" content="07764cc1a8eda55b4bdf78cf846d6811d042b9ee"/><link rel="preload" href="/_next/static/media/a37cf3809adb2c63-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/dd50543ba70be8e9-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/c372a630cbda84f2-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/c244cd6be2a69a75.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c244cd6be2a69a75.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-401a9806b070f31a.js" defer=""></script><script src="/_next/static/chunks/main-6b74302918225334.js" defer=""></script><script src="/_next/static/chunks/pages/_app-01dc60c7ef7ccbd8.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bcategory%5D-351fbf15b2ed9865.js" defer=""></script><script src="/_next/static/zjlLyPj8az7Fp8gQlOqTr/_buildManifest.js" defer=""></script><script src="/_next/static/zjlLyPj8az7Fp8gQlOqTr/_ssgManifest.js" defer=""></script></head><body class="text-primary transition-[background] bg-white dark:bg-[#1A1C23]"><script>
            const theme = localStorage.getItem("theme");
            const getUserTheme = () => {
             if(theme){
              return theme
             } 
             return window.matchMedia('(prefers-color-scheme: dark)').matches
             ? 'dark'
             : 'light'
          }
          document.body.dataset.theme = getUserTheme();
          </script><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="__className_e7b8b0 text-center transition-all "><header class="fixed top-0 left-0 right-0 mx-anuo w-screen h-12 md:h-16 flex justify-between items-center px-2 md:px-10 backdrop-blur bg-blue-200 bg-opacity-20 z-50"><div class="h-full flex items-center"><a class="h-full aspect-square flex justify-center items-center text-3xl select-none cursor-pointer" href="/">🫧</a><nav class="h-full hidden md:flex space-x-8 overflow-hidden ml-10"><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-black dark:text-white " href="/">Portfolio</a></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-blue-500 " href="/blog">Blog</a><div class="hidden md:flex w-full h-[2px] bg-blue-500 absolute bottom-0 left-0 blur-[2px]"></div></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-black dark:text-white " href="/arkhive">Arkhive</a></li></nav></div><div class="flex items-center h-full"><button aria-label="Toggle Dark Mode" type="button" class="flex h-9 w-9 items-center justify-center rounded-lg transition-all text-secondary hover:bg-secondary "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="h-6 w-6 text-yellow-400 drop-shadow-base"></svg></button><button class="flex md:hidden items-center justify-center w-16 h-full text-2xl text-black dark:text-white"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.5 11.5A.5.5 0 0 1 5 11h10a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 1 3h10a.5.5 0 0 1 0 1H1a.5.5 0 0 1-.5-.5z"></path></svg></button></div></header><main class="inline-block w-full relative pt-16 px-8 max-w-5xl 2xl:max-w-7xl" style="opacity:1;transform:none"><div class="flex flex-col mt-8 pb-16"><h3 class="mt-10 mb-5 text-xl bg-gradient-to-r from-blue-700 to-blue-400 bg-clip-text font-bold text-transparent">// 대학 - 가상세계</h3><ul class="flex flex-col items-center space-y-3"><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/final_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">AI</h4><span>게임에서의 AI, 그 중 pathfinding 방식에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-11 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/final_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Animation</h4><span>애니메이션이 처리되는 과정을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-11 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/final_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Rendering Pipeline</h4><span>랜더링 과정에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-09 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/mid_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Matrix and Transformations</h4><span>행렬에 대한 기본적인 내용과 이를 이용한 공간상에서의 변환에 대해 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-23 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/mid_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Vector</h4><span>벡터에 대한 기본적인 내용에 대해 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-23 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/mid_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Modeling</h4><span>모델을 저장하는 방법에 대해 알아봅나디.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-23 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/mid_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Unity Engine</h4><span>유니티 게임 엔진에 대한 기초적인 이론을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-23 </span></a></ul></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"AI","description":"게임에서의 AI, 그 중 pathfinding 방식에 대해 알아봅니다.","icon":"","image":"","tags":["Pathfinding","Greedy","BSF","A*","Planning"],"draft":false,"date":"2023-12-11 / 20:48","content":"\n## Basic Pathfinding\n\n경로 찾기 알고리즘을 평가하는 요소는 다음과 같습니다.\n\n- 해가 존재하는 문제에 대해 해를 구할 수 있는가? (Complete)\n- 최적해를 보장할 수 있는가? (Optimal)\n- 시간, 공간 복잡도가 복잡한가? (Time, Space)\n\n여러 알고리즘을 알아보며 평가해봅시다.\n\n### Greedy\n\n당장의 이득이 큰 선택을 이어가는 방식입니다.\n예로 들어 현재 위치에서 목적지 까지의 거리가 최소화되는 방향으로 이동하는 방식이 그리디 정책입니다.\n\n하지만, 최적해를 보장하지 못한다는 문제가 있습니다.\n\n### BFS\n\n그리디 방식보다는 Graph를 탐색하는 기법을 활용하는 것이 최적해를 찾을 수 있습니다.\n그 중 Breadth First Search 방식은 최적해를 보장할 수 있습니다.\n\n하지만, BFS는 모든 경로를 기록해야 하기 때문에 공간 복잡도가 높으며 시간 복잡도 또한 높게 측정됩니다.\n\n\u003ctip\u003e\n  **vs. DFS**\n  Depth First Search 방식은 일반적으로 BFS보다 시간, 공간 복잡도 측면에서 효율적입니다.\n  하지만, 이 역시 Greedy만큼 심각하지는 않지만, 역시 최적해를 보장할 수 없습니다.\n  또한, graph에 cycle이 존재하는 경우에는 해를 구하지 못하는 경우도 생깁니다.\n\n  | Algorithm | Complete | Optimal | Time | Space |\n  |---|---|---|---|---|\n  | BFS | Y | Y | $O(min(N, B^L))$ | $O(min(N,B^L))$ |\n  | DFS | Y | N | $O(B^{L_{MAX}})$ | $O(L_{MAX})$ |\n\u003c/tip\u003e\n\n\u003ctip\u003e\n  **vs. Greedy**\n  그리디와 BFS는 사실 비슷합니다.\n  ![231211-215115](/posts/final_03/231211-215115.png)\n\u003c/tip\u003e\n\n### A*\n\n위에서 BFS와 Greedy 방식이 비슷하다 했었는데, 다른 부분은 priority queue를 사용하는 것이 차이입니다.\n\n그렇다면, BFS에서 먼저 pop되는 노드의 기준은 무엇일까요?\n처음부터 현재까지의 탐색 거리 중 가장 짧은 거리를 **g**라고 했을 때, g가 가장 작은 노드가 선택되게 됩니다.\n\nGreedy에서 먼저 pop되는 노드의 기준은 무엇일까요?\n현재 지점부터 목표 거리까지 거리가 최소가 될 거 같은 휴리스틱한 거리를 **h**라고 했을 때, h가 가장 작은 노드가 선택되게 됩니다.\n\nA*는 BFS와 Greedy의 장점만을 모은 알고리즘으로, **f = g + h** 라 했을 때, f가 가장 작은 노드를 선택하여 경로를 탐색합니다.\n즉, 빠르게 탐색하면서도 최적해를 보장할 수 있게 됩니다.\n하지만, 메모리를 너무 많이 사용한다는 단점도 있습니다.\n\n의사 코드는 아래와 같습니다.\n\n```java:A*\nINIT priority-queue Q\nINSERT start node N to Q\nwhile (Q is not empty) {\n  REMOVE best N from Q that has lowest f(N)\n  if (N is goal) break\n  for (next node N' in Succ(N)) {\n    if (N' is visited first ||\n        previously expanded with f(N') \u003e f(N) ||\n        currently in Q with f(N') \u003e f(N)\n        ) {\n      INSERT N' into Q or UPDATE N' within Q\n    }\n  } \n}\n```\n\n즉, 특이하게도 A* 목표 노드를 발견해도 종료하지 않습니다.\nGoal state가 priority-queue에서 pop되었을 때만 종료하게 됩니다.\n\n---\n\n## Modified Pathfinding\n\n지금까지는 정적인 장애물만 피해갔지만, 이런 경우에는 어떡해야 할까요?\n\n- 동적인 장애물이 있을 경우\n- 이동 경로를 부드럽게 움직이게 하고 싶을 경우\n\n![231211-221920](/posts/final_03/231211-221920.png)\n\n이동 경로를 부드럽게 하고싶은 경우에는 선형 보간을 사용하는 방식으로 해결할 수 있습니다.\n\n동적인 장애물이 있는 경우에는 장애물이 움직인다고 A* 알고리즘을 다시 돌리는 행위는 너무 비효율적입니다.\n따라서 A*에 약간의 Greedy 함이 추가되면 좋을 거 같습니다... 만, 어떻게 해야할까요?\n\n### Inadmissible\n\nA*가 최적해를 구할 수 있는 조건은 휴리스탁한 길이 h가 실제 길이보다 같거나 짧아야한다는 admissible이 지켜졌기 때문입니다.\n그렇다면 h가 inadmissible 하다면?\n\n기존 휴리스틱 h에 $\\alpha$를 곱하여 inadmissible 하게 만들어봅시다.\n\n$$\nh'(n) = \\alpha \\cdot h(n)\n$$\n\n휴리스틱한 거리가 실제 거리보다 길어질만큼 $\\alpha$를 곱하여 inadmissible하게 만들었습니다.\n하지만, 효율성을 챙길 수 있습니다.\n왜냐하면, f가 동일하다고 했을 때, $\\alpha$를 곱한다면 f'의 값은 원래의 h가 작았던 경로가 더 작게 나올 것입니다.\n\n즉, $\\alpha$값을 높임으로서 효율적인 탐색을 지향하지만, 그리디의 특성을 일부 챙길 수 있게 되었습니다.\n(물론 이 과정에서 최적해는 구하지 못할 수 있습니다)\n\n### Hierarchical Planning\n\n처음부터 전체적으로 세부적인 경로를 구하는 것이 아닌, 초기에는 듬성듬성한 탐색 경로를 설정하고, 나중에 세부적인 탐색 경로를 2차적으로 설정하는 방법입니다.\n\n![231211-221544](/posts/final_03/231211-221544.png)\n\n위에 소개된 두 방법은 일반적으로 비용이 저렴하며, 실제 필요한 영역만 탐색하기 때문에 효율적이고, 동적인 환경에 더 적응성이 강하다는 장점이 있습니다.\n하지만, 최적해를 보장하지 못한다는 단점이 있습니다.\n\n### Dynamic Planning\n\n전체 경로를 planning 하는 것이 아니라, 일부 경로만 planning하고, planning 한 경로의 끝에 다다를 때 쯤, 다음 경로를 planning 하는 방식입니다.\n\n동적인 환경에 대한 적응성이 더욱 뛰어납니다.\n하지만, 극단적인 경우에 한 스탭만 planning 하는 경우에는 그리디 방식과 동일해집니다.\n\n---\n\n## Reactive Planning\n\n위에서 언급한 Dynamic Planning의 극단적인 경우입니다.\n즉, 최적성을 보장하지는 않지만, 빠르고, 자연스러운 움직임을 추구해야 하는 경우 사용하는 알고리즘 입니다.\n\n### Potential Field Planning\n\n잠재적인 힘의 공간을 이용한 planning 방식입니다.\n경로 탐색 공간을 두 가지 힘에 의해 좌우되는 공간으로 변형해봅시다.\n\nF는 장애물에서 멀어지려는 힘을 가하는 공간이고, G는 목표지점으로 향하는 힘을 가하는 공간이라고 가정해봅시다.\n이 떄, F+G인 공간에서 물리 시뮬레이션을 한다면?\n매 순간마다 위치와 속도를 얻을 수 있고, 그 방향으로 움직인다면 자연스러운 선택을 유도할 수 있습니다.\n\n![231211-222259](/posts/final_03/231211-222259.png)\n\n하지만 문제가 많습니다.\n\n- 파라미터가 너무 많음\n  힘, 가파르기, 속도, 질량 등 물리 시뮬레이션을 위한 파라미터가 너무 많이 필요합니다.\n\n- 목표의 충돌\n\n    ![231211-222520](/posts/final_03/231211-222520.png)\n\n    장애물을 피하려는 목표와 부드럽게 움직이려는 목표의 충돌로 부자연스러운 움직임을 보일 수 있습니다.\n\n- 국소 최적해\n\n    ![231211-222543](/posts/final_03/231211-222543.png)\n\n    목적지로 이동하지 못하고 갇힐 수도 있습니다.\n\n### Flocking Models\n\n경로를 파악해야 하는 객체, 즉 이동하는 객체가 집단일 경우에는 어떨까요?\n집단 내부에서 규칙을 정해서 따르도록 하는 힘의 함수를 만드는 것이 도움이 됩니다.\n\n![231211-222714](/posts/final_03/231211-222714.png)\n\n- Separation\n  일종의 personal space 개념으로 남들과 약간의 거리를 두고 싶은 정도의 힘 입니다.\n- Alignment\n  남들과 같은 방향으로 같이 가려는 힘 입니다.\n- Cohesion\n  집단에 속하려고 서로 응집하려는 힘 입니다.\n- Avoidance\n  장애물을 회피하려는 방향으로 가려는 힘 입니다.\n\n이런 4가지 힘의 행동 규칙에 가중치를 부여하여 집단의 이동을 결정하면 간단한 규칙들의 합으로 군중의 복잡한 움직임을 모방할 수 있습니다.\n가중치를 부여하는 방식에 따라 우선순위가 낮은 규칙은 적용되지 않을 수도 있고, 모든 규칙이 고루 영향을 미치도록 할 수도 있습니다.\n\n정리하자면, 복잡한 군중 행동을 단순하게 표현할 수 있고, 여러 행동양식을 만들어 낼 수 있다는 장점이 있지만,\n가중치 조절이 쉽지 않으며, 앞서 봤던 Potential Field의 영향도 받을 수 있다는 단점이 있습니다.","slug":"univ_virtual-worlds/final_03","readingMinutes":11,"wordCount":874},{"title":"Animation","description":"애니메이션이 처리되는 과정을 알아봅니다.","icon":"","image":"","tags":["Kinematics","Quaternion","Rotation Matrix","Splines","Lagrange Polynomial","Bezier Curve"],"draft":false,"date":"2023-12-11 / 17:53","content":"\n## Kinematics\n\n관절(Joints)와 뼈대(Links)의 트리구조의 계층적 모델로 표현 가능하며, 힘에 대한건 고려하지 않고, 관절의 각도만 고려하게 됩니다.\n\n연산 순서에 따라 Forward, Inverse Kinematics로 구분되는데, 어떤식으로 다른지 알아봅시다.\n\n- Forward\n\n    ![231211-180201](/posts/final_02/231211-180201.gif)\n\n    local coordinate 관점\n\n- Inverse\n\n    ![231211-180202](/posts/final_02/231211-180202.gif)\n\n    global coordinate 관점\n\n사실상 동일합니다.\n\n3차원의 경우 회전은 각 축을 중심으로 하는 3개의 회전으로 분리(Eular angles)하여 계산합니다.\n\n![231211-180643](/posts/final_02/231211-180643.png)\n\n각 관절과 뼈대는 트리구조로 표현된다고 했었는데, 각 관절의 회전과 뼈대의 길이를 DFS 방식으로 탐색하며 계산한다면 원하는 부분의 움직임을 계산할 수 있습니다.\n\n---\n\n## Rotation\n\n![231211-180857](/posts/final_02/231211-180857.png)\n\n지금까지 3차원에서의 회전은 Eular angles를 연산하여 계산했었습니다.\n하지만, 이 방식에는 치명적인 단점이 존재합니다.\n\n- 연산 순서에 따라 결과가 달라진다.\n- Gimbal lock 현상이 발생한다.\n\n\u003ctip\u003e\n  `Gimbal lock`\n  \u003cbr /\u003e\n  가장 안쪽에 있는 축(Gimbal)과 가장 밖에있는 축이 평행하게 되어버리면 회전의 자유도의 손실이 발생하는 현상.\n  [예시 영상](https://youtu.be/zc8b2Jo7mno?si=c-oq07BEsga7V98i\u0026t=58)\n\u003c/tip\u003e\n\n따라서 이를 해결할 두 가지 3차원 회전방법을 알아보겠습니다.\n\n### Quaternion\n\n4개의 파라미터로 4차원 공간의 구의 좌표(4원수)를 사용합니다.\n\n$$\nq = (w, x, y, z) \\\\\n{}\\\\\nw^2 + x^2 + y^2 + z^2 = 1\n$$\n\n쿼터니언은 복소수의 확장판으로 엄밀한 정의는 다음과 같습니다.\n\n$$\nw + ix + jy + kz = (w,x,y,z) = (w,v) \\\\\n{}\\\\\ni^2 = j^2 = k^2 = ijk = -1\n$$\n\n![231211-183507](/posts/final_02/231211-183507.png)\n\n즉, 교환법칙이 성립되지 않으며, 허수부의 연산을 표로 그려보면 다음과 같습니다.\n\n| x | 1 | i | j | k |\n|---|---|---|---|---|\n| **1** | 1 | i | j | k |\n| **i** | i | -1 | k | -j |\n| **j** | j | -k | -1 | i |\n| **k** | k | j | -i | -1 |\n\n이제 쿼터니언의 여러 연산을 알아봅시다.\n\n- Add, Sub\n  ![231211-184240](/posts/final_02/231211-184240.png)\n\n- Mul\n  ![231211-184321](/posts/final_02/231211-184321.png)\n\n- Conjugate (켤레 복소수)\n  ![231211-184501](/posts/final_02/231211-184501.png)\n\n- Norm (크기)\n  ![231211-184516](/posts/final_02/231211-184516.png)\n\n- Mul Identity (곱셈 항등원)\n  ![231211-184538](/posts/final_02/231211-184538.png)\n\n- Mul Inverse (곱셈 항등원의 역)\n  ![231211-184559](/posts/final_02/231211-184559.png)\n\n근데 쿼터니언이 왜 회전과 관련이 있는걸까요?\n다음을 보며 이해해봅시다.\n\n![231211-185645](/posts/final_02/231211-185645.png)\n\n오일러 공식에 의한 회전은 가장 아름다운 수식으로 알려진 만큼 유명해서 익숙할 겁니다.\n\n![231211-185900](/posts/final_02/231211-185900.png)\n\n실제로 전에 다뤄본대로 변환 행렬의 원소가 실수부와 허수부의 변환된 좌표로 나오게 됩니다.\n\n![231211-190100](/posts/final_02/231211-190100.png)\n\n위 개념을 확장하면 쿼터니언을 사용하면 3차원의 회전을 다룰 수 있다는 사실을 알 수 있습니다.\n\n![231211-190242](/posts/final_02/231211-190242.png)\n\n즉, 회전하고자 하는 좌표를 순허수 쿼터니언으로 변환하고,\n특정 축(**유닛 벡터**)을 기준으로 회전각을 곱해주면 회전된 좌표가 순허수 쿼터니언의 형태로 나오게 됩니다.\n\n### Rotation Matrix\n\n9개의 파라미터로 3차원 회전을 달성하는 3by3 행렬입니다.\n\n$$\nR = \\begin{bmatrix}\nu_1 \u0026 v_1 \u0026 w_1 \\\\\nu_2 \u0026 v_2 \u0026 w_2 \\\\\nu_3 \u0026 v_3 \u0026 w_3 \\\\\n\\end{bmatrix} = \\begin{bmatrix}\nu \u0026 v \u0026 w \\\\\n\\end{bmatrix}\n$$\n\n여기서 u, v, w는 단위벡터이고, det(R) = 1 인 회전 행렬입니다.\n\n파라미터가 9개나 되는데 굳이 rotation matrix를 사용하는 이유는 무엇일까요?\n쿼터니언은 부호가 반대가 되는 경우가 있기 때문입니다.\n\n$$\nR_q(p) = R_{-q}(p)\n$$\n\n즉, 하나의 회전을 2개의 방법으로 표현할 수 있기 때문입니다.\n반면에 rotation matrix는 하나의 회전이 유니크한 matrix 하나로 정의되기에 사용합니다.\n\n물론, 쿼터니언-회전행렬간 변환 연산도 있습니다.\n\n---\n\n## Splines\n\n애니메이션의 움직임을 부드럽게 하려면 어떻게 해야할까요?\n수학적인 함수를 사용해서 시간 분할(간격)에 관계없이 애니메이션(위치)를 얻거나, 아주 잘게 쪼갠 미리 계산된 값(위치)를 사용하는 방법이 있을 것입니다.\n\n다항식으로 이루어진 curve를 polynomial curve 라고 하는데 단순히 다항식을 사용하면 문제가 있습니다.\n특정 점(위치)를 지나는 다항식을 계산하기가 어렵고, 차수가 높아질수록 불가능에 가까워집니다.\n\n따라서 다음과 같은 방식을 사용해볼 수 있겠습니다.\n\n### Lagrange Polynomial\n\n라그랑주 다항식은 아래와 같이 생겼습니다.\n\n$$\nx(t) = L_0(t)x_0 + L_1(t)x_1 + ... + L_n(t)x_n \\\\\n{}\\\\\nL_k(t_i) = \\left\\{\\begin{matrix}\n1 \\; if \\; k=i \\\\\n0 \\; if \\; k \\neq i\n\\end{matrix}\\right.\n$$\n\n![231211-201931](/posts/final_02/231211-201931.png)\n\n즉, $x(t_0) = x_0$, $x(t_1) = x_1$ 과 같이 값이 나오기 때문에 원하는 함수 모양을 잡기 쉽습니다.\n그러나, 차수가 높아질수록 L이 출렁이는, 일명 Oscillation 현상이 발생하기 때문에 keyframe particle motion에 적용하기에는 부적절합니다.\n\n### Spline Interpolation\n\n그렇다면 아래와 같이 해결해볼 수 있을 거 같습니다.\n\n![231211-202159](/posts/final_02/231211-202159.png)\n\n여기서 3차를 사용하는 이유는 2차는 평면상의 곡선만 표현할 수 있기에 공간의 움직임을 표현하기에는 부적절하고, 4차는 Oscillation 현상이 발생하기 때문에 부적절하기 때문입니다.\n하지만 이 역시 문제가 있습니다.\n\n우선 연걸지점이 미분 불가능할 수 있기에 움직임이 부자연스러울 수 있습니다.\n또한, 일반적인 다항함수의 기저($t^3$ ~ $t^0$)로는 직관적으로 다항식이 어떤 모양인지 알 수 없습니다.\n\n### Bezier Curve\n\n우선 기저만 봤을 때 함수의 모양을 직관적으로 확인할 수 있도록 Bernstein 기저 함수를 사용할 수 있겠습니다.\n\n$$\nB_i^n = (_nC_i)(1-t)^{n-i}t^i\n$$\n\nBernstein 기저 함수의 특징은 아래와 같습니다.\n\n![231211-203158](/posts/final_02/231211-203158.png)\n\n이 기저를 이용한 3차 다항식은 아래와 같습니다.\n\n$$\np(t) = B_0^3(t)b_0 + B_1^3(t)b_1 + B_2^3(t)b_2 + B_3^3(t)b_3 \\\\\n{}\\\\\n= (1-t)^3b_0 + 3t(1-t)^2b_1 + 3t^2(1-t)b_2 + t^3b_3\n$$\n\n여기서 b의 값을 알면 함수의 모양을 예측할 수 있는데, 함수 p가 Bezier curve 입니다.\n\n![231211-203320](/posts/final_02/231211-203320.png)\n\n이 때의 $b_i$를 control point라고 부릅니다.\n\n베지어 곡선의 특징은 다음과 같습니다.\n\n- **End point interpolation**\n\n    항상 $p(0) = b_0$, $p(1) = b_3$ 입니다.\n    즉, 시점과 종점을 바로 알 수 있습니다.\n\n- **Convex hull**\n\n    항상 control points가 만드는 가장 작은 다각형(볼록한 모양) 내부에 베지어 곡선이 위치합니다.\n\n    ![231211-203617](/posts/final_02/231211-203617.png)\n\n    이 특성은 곡선이 교차되는 지점을 구할 때, 계산 범위를 한정지어 효과적으로 계산할 수 있도록 도와줍니다.\n\n- **Affine inveriance**\n\n    동일한 control points는 반드시 1개의 베지어 곡선만 생성합니다.\n    즉, control points를 transform 하는 경우에는 동일한 transform이 베지어 곡선에 적용되는 효과를 갖습니다.\n\n- **Tangent vectors**\n\n    시점, 종점의 탄젠트 벡터는 각 시/종점과 인접한 control point의 차이의 3배로 표현됩니다.\n\n    ![231211-203942](/posts/final_02/231211-203942.png)\n\n    여기서 Spline Interpolation의 또 다른 문제였던 연결지점이 부자연스러울 경우를 예방할 수 있겠죠?\n\n    ![231211-204538](/posts/final_02/231211-204538.png)\n\n    끝 점의 탄젠트 벡터의 방향을 일치하도록 설정하면 됩니다.\n    다르게 표현하면, 각 곡선 조각의 끝에 탄젠트 벡터가 있다면, 이를 이용해서 조각에 해당하는 베지어 커브를 그릴 수 있습니다.\n\n- **Subdivision**\n\n    베지어 곡선위의 임의의 점으로 곡선을 분할하면 분할된 곡선 역시 베지어 곡선이 됩니다.\n\n- **De Casteljau's algorithm**\n\n    시점 $t_k=u$ 일 때의 위치는 u:1-u로 내분하는 방식으로 구할 수 있습니다.\n\n    ![231211-204228](/posts/final_02/231211-204228.png)","slug":"univ_virtual-worlds/final_02","readingMinutes":11,"wordCount":896},{"title":"Rendering Pipeline","description":"랜더링 과정에 대해 알아봅니다.","icon":"","image":"","tags":["Geometry processing","Projection","Lighting","Shading","Reflection","Polygon","Rasterization","Antialiasing","Texture"],"draft":false,"date":"2023-12-09 / 23:30","content":"\n![231210-002735](/posts/final_01/231210-002735.png)\n\n랜더링은 3D 세상의 정보를 2D의 영상으로 변환하는 과정을 의미합니다.\n그 변환 과정을 세밀하게 알아봅시다.\n\n## Geometry processing\n\n공간상의 좌표를 모니터의 좌표로 변환하기 위해서 좌표를 변환하는 과정이 필요한데, 그 순서와 변환법을 알아보겠습니다.\n\n### Viewing-transform\n\n![231209-233923](/posts/final_01/231209-233923.png)\n\n공간상의 좌표를 View plane 상에서 바라보는 곳의 좌표로 우선 변환합니다.\n\n![231209-234611](/posts/final_01/231209-234611.png)\n\n여기서 P는 카메라의 위치, N은 바라본 위치상의 평면(View plane)의 normal vector 입니다.\n이 때, 사각 뿔 도형의 $P_{ref}$ 지점을 바라본다고 한다면, 법선 벡터 N은 $P_0 - P_{ref}$로 구할 수 있습니다.\n\n여기서 View plane의 법선 벡터를 구했다고 View plane을 확정할 수는 없습니다.\n왜냐하면 N을 축으로 회전이 가능하기 때문이죠.\n따라서 View-up vector V를 정의합니다.\n\n![231209-234059](/posts/final_01/231209-234059.png)\n\n위에서 N, V를 구했다면, view space의 세 축을 정의할 수 있습니다.\n\n$$\nn = \\frac{N}{||N||} \\\\\n{}\\\\\nu = \\frac{V \\times n}{||V||} \\\\\n{}\\\\\nv = n \\times u\n$$\n\n이제 view space의 축의 벡터를 구했으니, world space의 물체를 view space로 좌표 변환이 가능합니다.\n2차원을 예시로 들어보겠습니다.\n\n![231209-235335](/posts/final_01/231209-235335.png)\n\n2차원의 물제의 좌표를 우선 homogeneous coordinate로 표현합니다.\n\n![231209-235404](/posts/final_01/231209-235404.png)\n\n그리고 view coordinate를 word coordinate의 원점으로 이동시킵니다.\n\n![231209-235416](/posts/final_01/231209-235416.png)\n\n그리고 view coordinate를 rotation 하여 축을 일치시킵니다.\n\n위 과정은 하나의 행렬로 표현 가능합니다.\n\n$$\nB' = \\begin{bmatrix}\nu_x \u0026 u_y \u0026 0 \\\\\nv_x \u0026 v_y \u0026 0 \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{bmatrix} \\cdot \\begin{bmatrix}\n1 \u0026 0 \u0026 -x_o \\\\\n0 \u0026 1 \u0026 -y_o \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{bmatrix} \\cdot B\n$$\n\n여기서 회전 방향이 시계방향이기 때문에 회전 백터가 Row 벡터로 이루어짐을 알아둡시다.\n\n### Projection\n\n좌표를 이동했다면, 3차원 물체를 2차원 View plane에 투영(projection)해야 합니다.\n투영하는 방법에는 소실점이 있는 Perspective projection과 소실점이 없는(무한한 거리에 있는) Orthographic projection 2가지 방법이 있습니다.\n\n- **Perspective projection**\n\n    ![231210-000508](/posts/final_01/231210-000508.png)\n\n    이 투영법은 닮음의 성질을 이용해서 투영합니다.\n    즉, 아래와 같이 좌표가 view space에서 view plane으로 변환됩니다.\n\n    $$\n    (x,y,z) \\Rightarrow (-d\\frac{x}{z}, -d\\frac{y}{z})\n    $$\n\n    하지만, 이는 선형 변환이 아니므로, 계산의 효율을 위해 homogeneous coordinate로 변환하여 선형 변환으로 만들어줍시다.\n\n    $$\n    \\begin{bmatrix}\n    1 \u0026 0 \u0026 0 \u0026 0 \\\\\n    0 \u0026 1 \u0026 0 \u0026 0 \\\\\n    0 \u0026 0 \u0026 -1/d \u0026 0\n    \\end{bmatrix} \n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    1\n    \\end{bmatrix} = \n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    -z/d\n    \\end{bmatrix}\n    $$\n\n    여기서 결과로 나온 벡터의 모든 원소를 $-z/d$로 나눠주면 $(-d\\frac{x}{z}, -d\\frac{y}{z})$를 얻을 수 있습니다.\n    (homogeneous coordinate의 사용 안하는 좌표를 1로 바꿔주는 연산과 동일합니다)\n\n    컴퓨팅 능력을 끌어올리기 위해 정사각행렬로 변환하면 식을 아래와 같이 표현할 수도 있습니다.\n\n    $$\n    \\begin{bmatrix}\n    1 \u0026 0 \u0026 0 \u0026 0 \\\\\n    0 \u0026 1 \u0026 0 \u0026 0 \\\\\n    0 \u0026 0 \u0026 1 \u0026 0 \\\\\n    0 \u0026 0 \u0026 -1/d \u0026 0\n    \\end{bmatrix} \n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    1\n    \\end{bmatrix} = \n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    -z/d\n    \\end{bmatrix} \\Rightarrow (-d\\frac{x}{z}, -d\\frac{y}{z})\n    $$\n\n- **Orthographic projection**\n\n    ![231210-001519](/posts/final_01/231210-001519.png)\n\n    이 방식은 그저 z축의 정보을 사용하지 않으면 알아서 투영될 것입니다.\n\n    $$\n    \\begin{bmatrix}\n    1 \u0026 0 \u0026 0 \u0026 0 \\\\\n    0 \u0026 1 \u0026 0 \u0026 0 \\\\\n    0 \u0026 0 \u0026 0 \u0026 1 \\\\\n    \\end{bmatrix} \n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    1\n    \\end{bmatrix} = \n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    1\n    \\end{bmatrix} \\Rightarrow (x, y)\n    $$\n\n### Clipping \u0026 Normalize\n\n\u003ctip\u003e\n  `View Frustum`\n  \u003cbr /\u003e\n  ![231210-001840](/posts/final_01/231210-001840.png)\n  공간상에서 화면에 실질적으로 보여지는 영역을 의미하며, 절두체 형식으로 공간이 잘리게 됩니다.\n  최소로 카메라에 인식되는 평면을 near clipping plane, 최대는 far clipping plane 이라고 합니다.\n\u003c/tip\u003e\n\n![231210-002108](/posts/final_01/231210-002108.png)\n\n화면에서 보이지 않는 영역은 랜더링하지 않기 위해 clipping 하는 과정이 필요합니다.\n\n![231210-002343](/posts/final_01/231210-002343.png)\n\n하지만, 절두체는 계산하기가 힘들기 때문에 near clipping plane을 확장시켜 정사각형으로 만들어준 뒤 clipping 과정이 들어가게 됩니다.\n\n이후에는 모니터의 해상도에 맞게 변환을 편리하게 하기 위해 좌표를 [-1, 1] 사이로 normalize 하는 과정이 추가됩니다.\n\n아래는 위의 모든 과정을 요약한 Geometry processing 과정입니다.\n\n![231210-002534](/posts/final_01/231210-002534.png)\n\n---\n\n## Lighting and shading\n\n이 단계 역시 **Geometry processing 단계에서 수행**되지만, 분량이 많으므로 별도로 다뤄보겠습니다.\n\n빛을 인식한다는 것은 광원으로부터 나온 빛이 물체와 부딪혀 흡수되지 않은 반사된 빛을 눈이 감지하는 과정을 의미합니다.\n하지만 빛의 진행과 반사를 모두 추적하는 것은 연산량이 매우 많이 필요하기 때문에 이를 단순화 하기 위해 광원의 종류와 반사의 종류를 나누어 연산합니다.\n\n### Light sources\n\n광원의 종류에 따라 광원을 수식으로 표현해보겠습니다.\n\n\u003cnotice\u003e\n  색상을 표현하기 위해 RGB값을 모두 연산해야 하지만, 수식으로 나타낼 때는 벡터 I로 한 번에 표현합니다.\n  $$\n  I = \\begin{bmatrix}\n  I_R \\\\\n  I_G \\\\\n  I_B \\\\\n  \\end{bmatrix} \n  $$\n\u003c/notice\u003e\n\n- **Point lights**\n\n    ![231210-003440](/posts/final_01/231210-003440.png)\n    \n    점광원으로 일반 적인 광원입니다.\n    빛의 강도는 거리의 제곱에 반비례하며, 수식적으로는 아래와 같이 표현됩니다.\n\n    $$\n    I(p, p_0) = \\frac{1}{|p-p_0|^2}I(p_0)\n    $$\n\n    하지만, 이렇게 처리하는 경우 실제로 거리에 따른 표현이 잘 되지는 않습니다.\n    따라서 제곱항만 넣는 것이 아닌, 다항식으로 처리됩니다.\n\n    $$\n    I(p, p_0) = \\frac{1}{k_c + k_ld + k_qd^2}I(p_0)\n    $$\n\n- **Distant lights**\n\n    ![231211-162941](/posts/final_01/231211-162941.png)\n\n    방향성 광원(무한히 멀리있는 광원)으로, 점광원과 차이점은 위치를 고려하지 않는다는 점입니다.\n    점광원은 위치에 따라 입사각이 달라졌다면, 방향성 광원은 방향에 따라서만 입사각이 달라지게 됩니다.\n    위 식에서 $p_0$ = [x y z 1]$^T$ 였다면, 방향성 광원에서는 $p_0$ = [x y z 0]$^T$ 입니다.\n\n- **Spotlights**\n\n    ![231211-163031](/posts/final_01/231211-163031.png)\n\n    점광원 + 원뿔로, 점광원과 비슷하지만, 원뿔 영역에 해당하는 부분에만 빛이 비춰집니다.\n    수식적으로 아래와 같습니다.\n\n    $$\n    I = cos^e \\phi = (s\\cdot I_s)^e\n    $$\n\n    여기서 $\\phi$는 0과 $\\theta$ 사이의 값이고, e값이 커질수록 중심부가 강하게 스포트라이트 됩니다.\n\n    ![231211-164403](/posts/final_01/231211-164403.png)\n\n- **Ambient lights**\n\n    배경 광원으로 공간 전체에 은은하게 퍼져있는 빛입니다.\n    즉, Intensity만 전체적으로 더해주면 됩니다.\n\n### Interaction with Materials\n\n빛과 상호작용하는 물질에 따라 흡수, 투과, 반사되는 정도가 달라지는데 여기선 반사에 대해서만 다뤄보도록 합니다.\n(반사를 해야 물체가 눈에 보이겠죠?)\n\n반사는 Phong reflection model로 표현되는데 이는 정반사(Specular) + 난반사(Diffuse) + 배경 의 3요소로 표현됩니다.\n하나하나 알아봅시다.\n\n- **Ambient reflection**\n\n    배경 반사는 물리적 실체가 있는 구성요소는 아니고, 랜더링시 전체적으로 퍼진 빛을 시뮬레이션하기 위해 계산하며 아래와 같습니다.\n\n    $$\n    I_a = k_aL_a\n    $$\n\n    여기서 $k_a$는 반사 계수로 0과 1 사이의 값을 가지며, 1이면 배경 빛을 모두 반사합니다.\n\n- **Diffuse reflection**\n\n    난반사는 빛의 입사각과 관계 없이 모든 방향으로 반사한다고 가정하기 때문에 입사하는 빛의 양만 알면 반사량을 계산할 수 있습니다.\n\n    $$\n    I_d = k_d(N\\cdot L)L_d\n    $$\n\n    여기서 N은 표면의 수직 단위벡터, L은 빛 소스($L_d$) 로의 방향 단위벡터 입니다.\n    즉, 사이각을 계산하는 항이 추가된 것입니다. (**Position dependent**)\n\n- **Specular reflection**\n\n    정반사는 입사각과 동일한 반사각으로 빛을 반사합니다.\n    즉, 관찰자가 어디있는지에 따라 반사된 빛의 밝기가 다르게 느껴지게 됩니다. (**View, Position dependent**)\n\n    $$\n    I_s = k_s(cos\\alpha)^nL_s = k_s(V\\cdot R)^nL_s\n    $$\n\n    여기서 R은 반사되는 방향 단위벡터, V는 view 방향 단위벡터 입니다.\n    또한 $\\alpha$는 R, V 사이의 각도입니다.\n\n    ![231211-170153](/posts/final_01/231211-170153.png)\n\n    또한 n은 일종의 상수인데, 거울의 경우에는 n이 거의 무한한 값이고, 금속은 100~500 사이 정도로 표현됩니다.\n\n### Polygonal Shading\n\n![231211-170419](/posts/final_01/231211-170419.png)\n\n지금까지 위 그림과 같이 빛을 반사까지 했습니다.\n그렇다면 이제 폴리곤 덩어리에 색칠을 해야 하는데, 그 방식도 여럿 존재합니다.\n각 방식과 장단점을 알아봅시다.\n\n- **Flat shading**\n\n    ![231211-170816](/posts/final_01/231211-170816.png)\n\n    면 단위로 색칠하는 방식으로 특정 면의 법선 벡터 n을 구하면 해당 면을 하나의 색상으로 칠하는 방식입니다.\n    계산량은 가장 적지만, 다른 면과 매끄럽게 연결되지 않는다는 단점이 있습니다.\n\n- **Gouraud shading**\n\n    vertex 단위로 색칠하는 방식으로 면의 꼭짓점의 법선 벡터들을 구하고, 꼭짓점들의 색상을 칠합니다.\n    면의 내부는 꼭짓점의 색상을 선형 보간하는 방식으로 계산합니다.\n\n    이 때, 꼭짓점은 점이기 때문에 법선 벡터를 바로 구할 수는 없습니다.\n\n    ![231211-171148](/posts/final_01/231211-171148.png)\n\n    따라서 개발자가 임의로 지정해주거나, 주변 면의 법선 벡터의 평균을 사용해서 구하는 방식을 사용합니다.\n\n    계산량은 보통이지만, 면과 면이 부드럽게 연결됩니다.\n    하지만, vertex의 보간으로 계산하기 때문에 면 중앙에만 하이라이트로 비춰지는 빛을 표현할 수는 없습니다.\n\n- **Phone shading**\n\n    픽셀 단위로 색칠하는 방법으로 꼭짓점의 법선 벡터를 구하는 것 까지는 동일합니다.\n    하지만, 색칠을 할 때는 픽셀별로 법선 벡터를 선형 보간하는 방식으로 구한 후, 픽셀의 법선 벡터를 이용해서 색상을 칠합니다.\n\n    따라서 계산량은 가장 많지만, 가장 사실적으로 빛을 묘사할 수 있습니다.\n\n    ![231211-171436](/posts/final_01/231211-171436.png)\n\n    물론, 반사되는 빛 표현만 사실적으로 하는 것이지, 실루엣까지 부드럽게 할 수는 없습니다.\n    실루엣을 부드럽게 하려면 vertex 개수 자체를 늘리는 방법을 사용해야 합니다.\n\n---\n\n## Rasterization\n\n모든 객체는 아래의 세가지의 조합으로 표현할 수 있습니다.\n\n- Points\n- Line segments\n- Triangles\n\n예로 들어 곡선은 짧은 직선을 어려개로 근사할 수 있고, 폴리곤 덩어리와 곡면 역시 여러 삼각형으로 근사할 수 있습니다.\n\n하지만, 위 세 요소를 수학적으로 기술했다고 해도, 화면에 띄우는 과정에서 Aliasing 현상이 나타나게 됩니다.\n\n선을 기준으로 여러 근사 알고리즘과 Aliasing 현상을 알아보도록 합시다.\n\n- **Point Sampling**\n\n    ![231211-172416](/posts/final_01/231211-172416.png)\n\n    각 픽셀의 중심부가 직선 범위 내부이면 1, 아니면 0으로 처리합니다.\n    연산량이 가장 적이만 문제가 많습니다.\n\n- **Bresenhan Line**\n\n    ![231211-172343](/posts/final_01/231211-172343.png)\n\n    인접한 픽셀이 둘 다 켜지는 방식을 방지하는 알고리즘으로, row, column 별로 1개만 1이 되도록 강제합니다.\n\n- **Box Filtering - Antialiasing**\n\n    ![231211-172713](/posts/final_01/231211-172713.png)\n\n    각 픽셀이 직선에 얼마나 포함되는지에 대한 정보를 바탕으로 \\[0, 1\\] 사이로 찰하게 합니다.\n    Antialiasing이 아닌 방식에 비해서는 느리지만, 그래도 빠른 편이며, 나름 정확하게 표현할 수 있습니다.\n\n- **Weighted Filtering - Antialiasing**\n\n    ![231211-172915](/posts/final_01/231211-172915.png)\n\n    가우시안 필터링 기법을 사용하여 가중치를 부여(중심부의 weight가 큼)한 평균을 계산하여 칠합니다.\n    가장 느리지만, 가장 묘사가 잘 됩니다.\n\n### Hidden Surface Elimination\n\n시각에 따라 보이지 않는 폴리곤 덩어리를 랜더링하면 성능이 떨어질 것입니다.\n따라서 보이지 않는 부분은 랜더링 대상에서 제외시키는 방법들을 알아봅시다.\n\n- **Back-face Culling**\n\n    ![231211-173323](/posts/final_01/231211-173323.png)\n\n    간단하게 설명하면 뒤를 바라보는 면은 랜더링 대상에서 제외시키는 방법입니다.\n    view 방향 단위벡터(v)와 면의 법선 단위벡터(n)를 이용해서 $n \\cdot v$로 계산하여 양수라면 랜더링, 음수면 제외하는 방식으로 동작합니다.\n\n    주의할 점은 법선 벡터를 계산할 때, 꼭짓점의 좌표를 이용해서 $(p_1-p_0) \\times (p_2-p_0)$ 와 같이 계산해야 하는데, 시계방향, 반시계방향으로 죄표를 넣으면 법선 벡터의 방향이 달라지게 됨을 주의합시다.\n\n- **Depth Buffer (Z-Buffer)**\n\n    ![231211-173721](/posts/final_01/231211-173721.png)\n\n    진짜 무식한 방법이지만, Back-face culling보다 성능 좋은 방법입니다.\n\n    1. 우선, Z-buffer를 무한대로, Frame buffer를 배경색으로 초기화 합니다.\n\n        $$\n        Z(x,y) = \\infty \\\\\n        C(x,y) = c_0\n        $$\n\n    2. depth가 작아지면, 즉 더욱 view plane에 가깝다면 (**z(x, y) \\\u003c Z(x, y)**) Z, Frame buffer를 업데이트 합니다.\n\n        $$\n        Z(x,y) = z(x,y) \\\\\n        C(x,y) = c(x,y)\n        $$\n    \n    심지어 속도도 빠릅니다.\n    하지만, 메모리를 많이 쓴다는 단점은 있습니다.\n\n    ![231211-174248](/posts/final_01/231211-174248.png)\n\n    하지만 오늘날은 메모리 용량도 많기 때문에 Z-Buffer 방식을 사용합니다.\n\n---\n\n## Texture mapping\n\n간단하게 텍스쳐를 폴리건 표면에 붙이는 방법만 알아봅시다.\n\n1. 폴리건에 붙이고자 하는 텍스쳐 이미지를 \\[0, 1\\]로 normalize 합니다.\n2. world coordinate(폴리건)과 texture coordinate(텍스쳐)의 대응관계를 찾습니다.\n3. 대응관계에 따라 normalize된 텍스쳐의 좌표를 변환하여 폴리건 위에 씌웁니다.\n\n일부 수학적 3차원 도형의 경우 2개의 좌표로도 표현이 가능한데, 이를 텍스쳐 좌표에서 활용하면 됩니다.\n\n이 과정에서 샘플링이 누적되며 오류가 중첩되어 Aliasing 현상이 발생할 수 있습니다.\n\n또한, 텍스쳐를 이용해서 세부 음영 묘사를 할 수 있는 트릭을 사용할 수 있습니다.\n즉, 폴리건은 간단히 만들고, 세부 음영 묘사는 텍스쳐로 수행하여 성능을 높이는 최적화 방법입니다.\n\n![231211-174923](/posts/final_01/231211-174923.png)\n\n하지만, 가장자리 실루엣은 세부적으로 묘사가 안됩니다.\n(vertex를 늘리는 방법 외엔...)\n\n마지막으로, 배경을 텍스쳐로 입혀서 반사를 구현하는 최적화 방식 또한 있습니다.","slug":"univ_virtual-worlds/final_01","readingMinutes":20,"wordCount":1619},{"title":"Matrix and Transformations","description":"행렬에 대한 기본적인 내용과 이를 이용한 공간상에서의 변환에 대해 다뤄봅니다.","icon":"","image":"","tags":["Matrix","Transform","Translate","Basis","Linear Map","Homogeneous Coordinates"],"draft":false,"date":"2023-10-23 / 22:09","content":"\n## Matrix\n\n$$\n\\begin{pmatrix}\na_{11} \u0026 a_{12} \u0026 ... \u0026 a_{1n} \\\\\na_{21} \u0026 a_{22} \u0026 ... \u0026 a_{2n} \\\\\n... \u0026 ... \u0026 ... \u0026 ... \\\\\na_{m1} \u0026 a_{m2} \u0026 ... \u0026 a_{mn} \\\\\n\\end{pmatrix}\n$$\n\nm-by-n matrix, 또는 **m행(Row) n열(Column)** 의 행렬이라고 부른다.\n\n여기서 하나의 **행** 만으로 이루어진 행렬을 `Row vectors`, \n한 **열**로만 이루어진 행렬을 `Column vectors` 라고 부른다.\n\n### Transpose\n\n$$\n(A^T)_{ij} = A_{ji}\n$$\n\n각 행과 열을 뒤집은 행렬을 전치행렬 이라고 부른다.\n\n### Square Matrix\n\n행과 열의 개수가 같은 행렬을 의미한다.\n\n### Identity Matrix\n\n$$\n\\begin{pmatrix}\n1 \u0026 0 \\\\\n0 \u0026 1 \\\\\n\\end{pmatrix}\n, \\;\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \\\\\n0 \u0026 1 \u0026 0 \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{pmatrix}\n$$\n\n위와 같이 Square Matrix인데 대각선만 1이고, 나머지는 0으로 채워진 행렬을 의미한다.\n\n\u003e AI = IA = A\n\n이 행렬의 가장 큰 특징은 행렬 A에 Identity Matrix를 곱하면 다시 행렬 A가 나온다는 것이다.\n\n### Scalar Multiplication \u0026 Addition\n\n백터에 스칼라 곱을 하거나, 백터간 합이나 차를 구할 때는 [**이전 포스트**](https://wjlee611.github.io/blog/univ_virtual-worlds/mid_03)에서 벡터의 연산을 했을 때와 동일하게 **각 원소에 대해 연산**을 진행하면 된다.\n\n### Matrix Multiplication\n\n![231023-222141](/posts/mid_04/231023-222141.png)\n\n행렬간 곱 연산은 위의 이미지와 같이 계산된다.\n여기서 주의할 점은 **앞의 행렬의 `열`** 의 개수와 **뒤의 행렬의 `행`** 의 개수가 일치해야 한다는 점이다.\n\n---\n\n## Transformations\n\n### Basis\n\n변환에 앞서 기저에 대해 알 필요가 있다.\n선형 독립인 벡터들이 공간을 생성(span)할 때, 그 벡터의 집합을 기저(basis)라고 한다.\n\n\u003ctip\u003e\n`선형 독립 (Linear Independent)`\n\u003cbr /\u003e\nN차원에서 어떤 하나의 벡터가 나머지 N-1개의 벡터의 **선형 결합으로 표현할 수 없는 경우**, N개의 벡터들이 선형 독립이라고 한다.\n즉, 벡터간 의존성이 없어야 한다.\n\u003c/tip\u003e\n\n벡터가 공간을 생성한다는 의미를 잘 모를 수 있는데, 예로 들어보자.\n\n![231023-230449](/posts/mid_04/231023-230449.png)\n\nv는 한 평면위의 벡터이다.\n이 상태에서 $v_1, \\; v_2$의 값을 [-$\\infty$, $\\infty$] 범위로 임의 조정한다고 가정해보자.\n그럼 v는 어떤 범위의 종점 좌표를 가질 수 있을까?\n바로 벡터 a, b가 속한 평면의 모든 좌표를 가질 수 있을 것이다.\n\n즉, **평행하지 않은 벡터의 선형 결합으로 공간을 생성**할 수 있는 것이다.\n\n그렇다면 두 벡터가 평행하지 않는다는 조건도 이해가 될 것이다.\n만약 두 벡터가 **평행**하다, 즉, **하나의 벡터로 다른 벡터를 표현**할 수 있다, 다른 말로 두 벡터가 **선형 의존**이라면, v는 직선상에만 존재할 수 있기 때문이다.\n\n그럼 다시 basis 얘기로 돌아와서, basis의 선형 결합으로 basis가 span하는 공간의 모든 벡터를 표현할 수 있다는 것을 이해했다.\n이 때 성립하는 증명이 있다.\n\n\u003e 같은 basis의 선형결합으로 표현되는 벡터는 표현 방법이 1개로 유일하다.\n\n위의 증명된 내용 덕분에, basis의 선형 결합 시 사용하는 weight를 좌표로써 활용할 수 있는 것이다.\n그렇기에 basis를 바꾼다는 건 좌표값을 바꾸는 것일 뿐, 벡터 그 자체를 바꾸는게 아니다.\n\n### Linear Map\n\n선형 사상이란 벡터의 기저를 바꿀 때, 즉 **벡터 공간이 바뀔 때 변형시에 선형성이 유지되는 변환 함수($F$)** 를 말한다.\n\n예로 들어 아래는 선형 사상이다.\n![231023-232038](/posts/mid_04/231023-232038.png)\n\n하지만, 이 경우는 선형 사상이 아니다.\n![231023-232104](/posts/mid_04/231023-232104.png)\n\n음? 그런데 이게 기저가 바뀌는거랑 무슨 상관이냐고?\n이제 기저를 선형 사상(변환 함수)에 대입해보며 알아보자.\n\n$$\n\\widehat{\\textrm{v}} = F\\textrm{v} \\\\\n{} \\\\\n\\begin{pmatrix}\n\\widehat{v_1} \\\\\n\\widehat{v_2} \\\\\n\\widehat{v_3}\n\\end{pmatrix} =\n\\begin{bmatrix}\nf_{11} \u0026 f_{12} \u0026 f_{13} \\\\\nf_{21} \u0026 f_{22} \u0026 f_{23} \\\\\nf_{31} \u0026 f_{32} \u0026 f_{33} \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\nv_1 \\\\\nv_2 \\\\\nv_3\n\\end{pmatrix} \n$$\n\n이해를 돕기 위해 $v_1$, $v_2$, $v_3$을 $x$, $y$, $z$ 라고 생각해보자.\n\n이제 ($v_1$, $v_2$, $v_3$) 대신에 (1, 0, 0) 을 대입해보자.\n이 때, (1, 0, 0)은 x축을 가리키는 기저의 원소이다.\n\n\n$$\n\\begin{pmatrix}\n\\widehat{v_1} \\\\\n\\widehat{v_2} \\\\\n\\widehat{v_3}\n\\end{pmatrix} =\n\\begin{bmatrix}\nf_{11} \u0026 f_{12} \u0026 f_{13} \\\\\nf_{21} \u0026 f_{22} \u0026 f_{23} \\\\\nf_{31} \u0026 f_{32} \u0026 f_{33} \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{pmatrix} =\n\\begin{pmatrix}\nf_{11} \\\\\nf_{21} \\\\\nf_{31}\n\\end{pmatrix} \n$$\n\n즉, 선형 사상($F$) 로 인해 기저 x(1, 0, 0)는 $(f_{11}, \\; f_{21}, \\; f_{31})^T$로 변환되었다.\n\n여기서 알 수 있는 것은 선형 사상, **Linear Function $F$의 i번째 열 벡터는 i번째 축의 기저벡터가 어디로 대응**되는가를 알려준다.\n또한, 위의 변환 과정은 선형성이 유지된다.\n\n참고로 선형성이 유지되는 특성 덕분에 여러 선형 사상을 한 번에 처리하는 것 또한 가능해진다.\n\n\u003e A(B(C(D(x)))) = ABCDx = $\\textrm{x}^TD^TC^TB^TA^T$\n\n### 2D Linear Transformations\n\n우선 회전을 살펴보자.\n\n![231023-234010](/posts/mid_04/231023-234010.png)\n\n선형 사상을 이용한 기저의 변환을 어느정도 이해했다면 이제 변형식이 왜 이렇게 생겼는지도 이해할 수 있을 것이다.\n\n예로 들어 (1,0) 즉 x축의 기저벡터를 $\\theta$ 만큼 회전시킨 좌표는 ($cos \\theta$, $sin \\theta$)가 되는데, 이는 위에서 언급한 \"선형 사상, **Linear Function $F$의 i번째 열 벡터는 i번째 축의 기저벡터가 어디로 대응**되는가를 알려준다\" 와 완벽히 일치한다.\n\n\u003ctip\u003e\n  즉, 앞으로의 변환은 각 축의 기저 벡터가 어떻게 변하는지를 파악하고, 해당 **변화 후의 값을 이용**해서 선형 사상 함수를 작성하면 된다.\n\u003c/tip\u003e\n\n이런 내용을 염두하고 다른 변환들도 살펴보자.\n\n![231023-235906](/posts/mid_04/231023-235906.png)\n\n![231024-000043](/posts/mid_04/231024-000043.png)\n\n![231024-000102](/posts/mid_04/231024-000102.png)\n\n### Affine Maps\n\n2D Translation을 가능케하는 Transformations 이 있을까?\n\n![231024-000319](/posts/mid_04/231024-000319.png)\n\n없다.\n그 이유는 **이동은 선형 변환이 아니**라서 이를 표현할 선형 사상 함수가 없기 때문이다.\n\n즉, Affine Map은 Linear map + Translation 으로 표현할 수 밖에 없다.\n왜냐면 Affine은 Linear하지 않기 때문이다.\n\n### Homogeneous Coordinates\n\n그렇다면 Transform과 Translate를 동시에 처리할 수 있는 방법이 없을까?\n바로 Homogeneous Coordinates를 이용하면 된다.\n\n이게 뭐냐면, 2차원의 Homogeneous Coordinates는 3차원의 벡터가 된다는 건데, 예시를 들어보자.\n\n$$\n\\begin{pmatrix}\nwx' \\\\\nwy' \\\\\nw\n\\end{pmatrix} =\n\\begin{bmatrix}\n1 \u0026 0 \u0026 t_x \\\\\n0 \u0026 1 \u0026 t_y \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\nwx \\\\\nwy \\\\\nw\n\\end{pmatrix}\n$$\n\n적당하게 w 기저를 하나 더 만들어서 차원을 높였다.\n이 때, ($wx$, $wy$, $w$)를 Homogeneous Coordinates 라고 하는데, 이제 여기에 계산의 편의를 위해 $w$에 1을 대입해보자.\n\n$$\n\\begin{pmatrix}\nx' \\\\\ny' \\\\\n1\n\\end{pmatrix} =\n\\begin{bmatrix}\n1 \u0026 0 \u0026 t_x \\\\\n0 \u0026 1 \u0026 t_y \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\nx \\\\\ny \\\\\n1\n\\end{pmatrix} = \n\\begin{pmatrix}\nx + t_x \\\\\ny + t_y \\\\\n1\n\\end{pmatrix}\n$$\n\n결과는?\n놀랍게도 Transformations 한 방식과 동일하게 진행되었는데 결과는 Translate 한 결과가 나왔다.\n이를 이용하면 2D 에서의 모든 변형은 다음과 같은 4개의 행렬의 곱으로 표현이 가능해진다.\n\n![231024-002119](/posts/mid_04/231024-002119.png)\n\n즉, 좌상단의 2x2 행렬은 Transform을 위한 부분이고, 우상단의 2x1 행렬은 Translate를 위한 부분이다.\n\n참고용으로 3D에 대한 Homogeneous Coordinates도 남겨놓겠다.\n![231024-002347](/posts/mid_04/231024-002347.png)\n\n### Compound Transformations\n\nLinear Map의 마지막에 언급한 사실에 근거해 이제 모든 변환은 합성 변환으로 치환할 수 있다.\n\n\u003e A(B(C(D(x)))) = ABCDx = $\\textrm{x}^TD^TC^TB^TA^T$\n\n그렇게 하면 ABCDx 이 행렬곱을 정리하기만 하면 A~D 까지의 모든 변환을 한 번에 수행하는 결과를 얻을 수 있으니 연산량이 매우 감소하게 된다.\n\n\u003cnotice\u003e\n  단, 연산 순서에 주의해야 한다.\n  \u003cbr /\u003e\n  ![231024-002828](/posts/mid_04/231024-002828.png)\n\u003c/notice\u003e\n\n이제 연산량이 어떻게 변하는지 예시를 살펴보자.\n\n![231024-003050](/posts/mid_04/231024-003050.png)\n\n이를 응용하면 특정 방향으로만 스케일링 하는 것도 구현할 수 있다.\n\n![231024-003225](/posts/mid_04/231024-003225.png)","slug":"univ_virtual-worlds/mid_04","readingMinutes":11,"wordCount":1032},{"title":"Vector","description":"벡터에 대한 기본적인 내용에 대해 다뤄봅니다.","icon":"","image":"","tags":["Vector","Points"],"draft":false,"date":"2023-10-23 / 20:12","content":"\n\u003cnotice\u003e\n  Vector와 Points는 (1, 2, 3) 과 같이 숫자로된 좌표로 표현된다는 점에서는 비슷하다.\n  \u003cbr /\u003e\n  하지만, `Points`는 **공간의 위치**를 나타내지만, `Vector`은 **방향과 크기**를 나타낸다는 점이서 다르다.\n  (벡터는 위치 개념이 없음. 상대적인 방향과 크기만을 가질 뿐) \n\u003c/notice\u003e\n\n## Vector Algebra\n\n### Scalar Multiplication\n\n![231023-204033](/posts/mid_03/231023-204033.png)\n\n해당 방향으로 크기만 증가하는 연산이다.\n**벡터의 각 성분에 크기 c만큼 각각 곱해주면** 된다.\n\n### Addition\n\n![231023-204232](/posts/mid_03/231023-204232.png)\n\nA 벡터의 종점에 B 벡터의 시점을 이어붙이는 연산으로, 그 값은 A 벡터의 시점 \u0026rarr; B 벡터의 종점이 된다.\n평행 사변형법으로도 계산할 수 있으며, **벡터의 각 성분끼리 더하면** 된다.\n\n### Substraction\n\n![231023-204432](/posts/mid_03/231023-204432.png)\n\n벡터에 -1을 스칼라 곱을 한 후, Addition을 한 결과와 같은 연산이다.\n**벡터의 각 성분을 빼주면** 된다.\n\n### Length \u0026 Direction\n\n![231023-204636](/posts/mid_03/231023-204636.png)\n\n벡터의 크기($L$)와 x축에 대한 방향($\\theta$)는 다음과 같다.\n\n\u003e $L = \\sqrt{x^2 + y^2}$\n\u003e\n\u003e $\\theta = tan^{-1}\\frac{y}{x}$\n\n\u003ctip\u003e\n  크기가 1인 벡터를 `단위벡터` 라고 하며, 벡터를 단위벡터로 변환하는 것을 **Normalization** 이라고 한다.\n  백터를 Normalization 하는 법은 **벡터의 각 성분을 $L$로 나눠주면** 된다.\n\u003c/tip\u003e\n\n### Linear Combination\n\n벡터들을 선형결합 하는 것을 의미한다.\n\n\u003e $b = c_1v_1 + c_2v_2 + ... + c_kv_k$\n\n이는 $v_1$, $v_2$, ..., $v_k$의 선형 결합이며, 상수 c를 weight라고 부른다.\n\n이 weight 값에 따라 다른 명칭으로 불리기도 한다.\n\n- `Affine Combination`\n  weight의 합이 반드시 1이 되는 선형결합.\n\n- `Convex Combination`\n  weight이 모두 양수이고, 합이 반드시 1이 되는 선형결합.\n\n### Dot product (내적)\n\n![231023-211310](/posts/mid_03/231023-211310.png)\n\n내적의 연산 결과는 스칼라가 되는데 우선 식부터 살펴보자.\n\n\u003e $\\overrightarrow{a} \\cdot \\overrightarrow{b} = a_1b_1 + a_2b_2 = \\begin{Vmatrix} \\overrightarrow{a} \\end{Vmatrix} \\begin{Vmatrix} \\overrightarrow{b} \\end{Vmatrix} cos \\theta$\n\n내적은 사잇각을 알아내는데 사용할 수 있는데, 그런데 내적 그 자체는 무슨 의미를 가질까?\n유닛벡터에 대해 다음과 같은 내적값은 다음과 같은 의미를 갖는다.\n\n- `1`\n  두 벡터가 **같은 방향으로 평행**하다\n\n- `-1`\n  두 벡터가 **정 반대 방향으로 평행**하다\n\n- `0`\n  두 벡터가 **수직**한다\n\n- `\u003e0`\n  두 벡터가 **같은 방향**이다\n\n- `\u003c0`\n  두 벡터가 **다른 방향**이다\n\n### Projection\n\n내적을 응용하면 한 벡터를 다른 벡터에 사상한 벡터를 얻을 수 있다.\n\n![231023-212348](/posts/mid_03/231023-212348.png)\n\n$\\overrightarrow{a'}$ 벡터의 길이는 **$\\begin{Vmatrix} \\overrightarrow{a} \\end{Vmatrix} cos \\theta$** 와 같다.\n또한 $\\overrightarrow{a'}$ 벡터의 단위벡터는 **$\\frac{1}{||\\overrightarrow{b}||} \\overrightarrow{b}$** 이다.\n\n따라서 둘을 곱한 다음의 식이 벡터 a를 벡터 b에 사상한 벡터가 된다.\n\n![231023-213605](/posts/mid_03/231023-213605.png)\n\n### Cross produce (외적)\n\n![231023-213718](/posts/mid_03/231023-213718.png)\n\n\u003e $\\overrightarrow{a} \\times \\overrightarrow{b} = \\begin{Vmatrix} \\overrightarrow{a} \\end{Vmatrix} \\begin{Vmatrix} \\overrightarrow{b} \\end{Vmatrix} sin \\theta \\cdot \\overrightarrow{n}$\n\u003e\n\u003e 여기서 $\\overrightarrow{n}$은 벡터 a, b에 수직한 유닛 벡터\n\n외적 두 벡터의 수직인 벡터로, 그 크기는 두 벡터가 이루는 평행사변형의 넓이이다.\n\n계산은 아래와 같이 하면 된다.\n\n$$\n\\begin{pmatrix}\na_1 \\\\\na_2 \\\\\na_3\n\\end{pmatrix} \\times\n\\begin{pmatrix}\nb_1 \\\\\nb_2 \\\\\nb_3\n\\end{pmatrix} =\n\\begin{pmatrix}\na_2b_3 - a_3b_2 \\\\\na_3b_1 - a_1b_3 \\\\\na_1b_2 - a_2b_1\n\\end{pmatrix}\n$$\n\n### Normal Vector\n\n한 평면에 대한 수직 단위벡터로 외적을 이용하면 구할 수 있다.\n\n![231023-214703](/posts/mid_03/231023-214703.png)\n\n---\n\n## Points Algebra\n\nPoints 는 더하거나, 스칼라곱에 대한 정의가 없다.\n하지만, 특수 상황에서는 의미를 갖는데, 그것들에 대해 알아보자.\n\n### Point - Point\n\n![231023-210346](/posts/mid_03/231023-210346.png)\n\nPoint B에서 Point A를 뺴면, 그 결과는 A\u0026rarr;B `Vector`가 된다.\n\n### Point + Vector\n\n![231023-210527](/posts/mid_03/231023-210527.png)\n\nPoint에 Vector를 더하거나 빼면 다른 `Point`가 된다.\n\n### Affine Combination\n\n위에서 언급했 듯, Points 는 더하거나, 스칼라곱에 대한 정의가 없다.\n하지만, 스칼라 곱 중에서 그 weight의 합이 1이 되는 경우 내분, 또는 외분의 의미를 갖게된다.","slug":"univ_virtual-worlds/mid_03","readingMinutes":6,"wordCount":506},{"title":"Modeling","description":"모델을 저장하는 방법에 대해 알아봅나디.","icon":"","image":"","tags":["Coordinate Systems","Polygonal Meshes"],"draft":false,"date":"2023-10-23 / 19:47","content":"\n## Coordinate Systems\n\n어떤 데이터든 간에 3D 공간상에 표현하기 위해서는 좌표 시스템을 먼저 구현해야 한다.\n그래야 공간상의 좌표의 조합으로 모델을 생성할 수 있기 때문이다.\n\n![231023-195004](/posts/mid_02/231023-195004.png)\n\n개발 환경에 따라 왼손 좌표계를 쓰거나 오른손 좌표계를 쓰는데, 참고로 유니티는 왼손 좌표계를 사용한다.\n따라서 유니티 관련 포스트는 모두 왼손 좌표계 기준으로 기술될 예정이다.\n\n---\n\n## Polygonal Meshes\n\n![231023-195154](/posts/mid_02/231023-195154.png)\n\n모든 3D 오브젝트를 삼각형 평면을 이어붙힌 형태로 표현하는 기법으로, 가장 많이 사용되는 방식이다.\n이런 데이터를 저장하는 방식에는 크게 3가지로 나뉘는데 각각 어떤식으로 데이터를 관리하는지 살펴보자.\n\n\u003ctip\u003e\n  mesh들은 OBJ, 3DS, POV 등의 확장자로 관리되는데,\n  OBJ의 경우 아래와 같은 정보를 저장한다.\n  - vertex의 좌표\n  - 각 vertex의 택스쳐 좌표\n  - 각 vertex의 수직 vertex\n  - 위의 vertex들로 표현돤 face\n\u003c/tip\u003e\n\n### Vertex-Vertex\n\n![231023-195357](/posts/mid_02/231023-195357.png)\n\n오직 점들만 데이터로 관리하는 자료구조를 사용한다.\n각 vertex의 **좌표**와 인접한(연결된) **vertex**를 저장한다.\n\n면에 대한 정보는 저장하지 않기에 추가적인 연산을 통해 얻어낼 수 밖에 없다.\n그렇기에 용량은 가장 작지만, 연산에 대한 부담이 있는 모델이다.\n\n### Face-Vertex\n\n![231023-195627](/posts/mid_02/231023-195627.png)\n\n점과 면을 데이터로 관리하는 자료구조를 사용하며, 가장 많이 사용되는 방식이다.\n`face`는 face를 구성하고 있는 **vertex**들의 집합으로 관리되고,\n`vertex`는 vertex의 **좌표**와 인접한 **faces**들의 집합으로 관리된다.\n\n### Winged Edge\n\n![231023-195936](/posts/mid_02/231023-195936.png)\n\n점과 면, 추가로 모서리의 데이터로 관리하는 자료구조를 사용하며, mesh를 변화시켜야 할 상황에 유용하게 사용할 수 있다.\n`face`는 face를 구성하고 있는 **edge**들의 집합으로 관리되고,\n`vertex`는 vertex에 연결된 **edge**들의 집합으로 관리된다.\n마지막으로 `edge`는 **시점, 종점의 좌표**와 **분할하는 면**, 그리고 연결된 edge 중 4개의 edge로 관리되는데,\n4개의 edge는 **시점에 연결된 back CCW, back CW, 종점에 연결된 front CCW, front CW** 순으로 관리된다. (그림 참고)","slug":"univ_virtual-worlds/mid_02","readingMinutes":4,"wordCount":241},{"title":"Unity Engine","description":"유니티 게임 엔진에 대한 기초적인 이론을 알아봅니다.","icon":"","image":"","tags":["Unity","Resource Management","Game Loop","Delta Time"],"draft":false,"date":"2023-10-23 / 17:46","content":"\n## Engine Architecture\n\n정말 말도안되게 깊고 넓은 레이어가 있는데, 간략하게 무슨 역할만을 하는지 살펴보자.\n~~(괜히 게임이 종합 예술이 아닌...)~~\n\n- Platform Independence Layer\n  디바이스에 상관없이 구동시키기 위한 레이어\n\n- Core systems\n  각종 코어 유틸리티들의 집합.\n  메모리 관리, 수학 라이브러리, 자체 자료구조 알고리즘 등.\n\n- Resource Manager\n  각종 에셋글의 생성과 관리, 배치 등의 총괄적인 관리를 담당.\n  **생성은 개발단계**에서, **배치는 런타임**에 관리된다.\n\n- Rendering Engine\n  에셋 등 데이터를 픽셀로 랜더링.\n  Projection, Shading, Texture sampling 등이 여기서 처리됨.\n\n- Scene Graph/Culling Optimization\n  시야에 안보이는 부분을 잘라내여 보이는 부분만 랜더링하도록 최적화.\n\n- Visual Effects\n  광원, 명암 등, 이미지(비주얼) 향상을 위한 후처리 과정.\n\n- Collision and Physics\n  충돌 및 물리 계산.\n\n- Animation\n  에셋들의 물리법칙을 에외한 움직임.\n\n- Human Interface Devices (HID)\n  사용자 입력, 움직임 등의 장치 관리.\n\n- Gameplay Foundation systems\n  게임 개발 환경 제공.\n\n---\n\n## Resource Management\n\n리소스에는 Meshes, audio, animation 등등 여러 raw resources 가 존재하는데, 각 리소스가 어떻게 처리되어야 하는지는 각 리소스의 Metadata를 참고하면 알 수 있다.\n\n리소스 생성과정은 다음과 같다.\n1. Maya, Photoshop 등과 같은 서드파티 앱에서 Export 한다.\n2. 이후 유니티가 game-ready 에셋인 `prefeb`으로 변환하기 위해 리소스 컴파일러가 구동된다.\n3. 추가로 여러 리소스를 하나의 패키지로 합치기 위해 링커도 제공한다.\n\n### Runtime\n\n유니티가 런타임에 어떻게 리소스를 관리하는지 개념적으로 알아보자.\n\n우선 유니티는 동일한 리소스는 특정 시각에 반드시 **1개**만 메모리에 올라오도록 보장한다.\n무슨 말이냐면 원할 때 리소스가 불러와지고, 이게 중복되어 불러와져 메모리 낭비를 하지 않게끔 해준다는 뜻인데, 이는 유니티의 **로딩 정책** 덕분에 가능해졌다.\n\n![231023-181333](/posts/mid_01/231023-181333.png)\n\n유니티는 리소스를 `비동기 로드`하기 때문에 로드해야 할 시점보다 미리 로딩한다.\n예로 들어 Level 1 에서는 A, B, C 리소스가 필요한데, 레벨 실행 전에 먼저 필요한 리소스의 목록을 파악해서 로딩하고, 로딩이 완료된 후에 레벨을 진행하는 방식으로 진행된다.\n\n이 때, 각 리소스별로 `Reference count`를 둬서 쓸데없는 중복 로딩이나, 필요 없는 리소스를 메모리에서 제거하기도 한다.\nref count가 0보다 큰데 로딩되지 않은 리소스는 로딩하고, ref count가 0인데 로딩된 리소스는 언로드 하도록 하는 것이다.\n\n메모리에서 제거하는 원리는, GC(Garbage Collector)가 일정 주기로 ref count가 0인 리소스를 제거한다.\n`System.GC.Collect()` 를 이용하면 수동적으로 GC를 호출할 수 있지만, 가능하면 그러지 말자.\n\n정리하면 런타임에 리소스 매니저는 아래의 역할을 수행할 수 있어야 한다.\n1. 동일한 리소스는 특정 시각에 메모리에 1개만 올라오도록 보장\n2. 각 리소스의 생명주기를 관리\n3. prefeb과 같은 여러군데 흩어진 리소스의 묶음을 관리할 수 있어야 한다\n4. 리소스간 참조의 무결성을 보장해야 한다\n5. 이미 로드된 리소스의 메모리 사용량도 관리해야 한다\n\n### Location\n\n리소스가 어디에 존재하는지에 따라 런타임시 로드 방식이 달라진다.\n\n- AssetBundles\n  유니티 플레이어 외부의 리소스로, 보통 웹서버 상에 존재하는 리소스이다.\n  `AssetBundle.LoadAsset()` 으로 불러올 수 있다.\n\n- Resource folders\n  유니티 플레이어 내부의 리소스로, Project view의 Resources 폴더에 존재하는 리소스이다.\n  `Resources.Load()` 로 불러올 수 있다.\n\n---\n\n## Game Loop\n\n매 프레임 상태 변경을 하거나, 사용자 입력을 받거나, 화면 랜더링을 위한 무한 루프를 의미한다.\n1초에 얼마나 루프가 돌아가는지를 나타내는 척도가 FPS인데, 엄밀히 말하면 화면이 그려지는 횟수지만, 한 루프에 한 번 화면이 업데이트되니 거의 같이 사용할 수 있다.\n\n유니티에선 거의 대부분의 클래스가 `MonoBehavior`를 상속하여 정의하는데, 여기에서 `Update()` 함수가 프레임당 한 번 호출이 이루어진다.\n\n그 외에도 override할 수 있는 다른 함수 몇 개 더 알아보자.\n\n- `Start()`\n  첫 프레임 업데이트시 호출되는 함수.\n\n- `LateUpdate()`\n  Update() 함수가 종료되고나서 호출되는 함수.\n\n- `OnDestory()`\n  소멸자 비스무리한 함수.\n  마지막 프레임의 업데이트가 완료되고 나서 호출되는 함수.\n\n### Delta Time\n\n두 인접한 프레임 사이의 시간이 얼마나 흘렀는가를 나타내는 값으로, 보통 그 값은 FPS의 역수이다.\n즉, 30FPS 게임에서의 $\\Delta t$는 1/30 seconds, 즉, 3.33ms이다.\n\n두 프레임 사이의 시간이므로 물리 시뮬레이션시 시간 변화율로서 동작하게 되는데, 물리량을 수식화 하면 다음과 같다.\n\n| 의미 | 수식 |\n|---|---|\n| Position | $p_{t+\\Delta t} = p_t + v_t \\cdot \\Delta t$ |\n| Velocity | $v_{t+\\Delta t} = v_t + a_t \\cdot \\Delta t$ |\n| Acceleration | $a_{t+\\Delta t} = f_{ext}/m$ |\n\n즉, $\\Delta t$가 너무 크거나 일정하지 않으면 물리량에 오차가 커질 수 밖에 없다.\n만약 델타값을 고정시키고, 이를 게임 루프에 의존해서 증가시킨다면 컴퓨터 사양에 따라 다르게 동작하는 현상이 발생할 수 있다.\n\n따라서, 유니티는 **CPU**의 `high-resolution timer`를 이용해서 델타값을 구하기 때문에 현실세계와 유사한 플레이 경험을 얻을 수 있도록 합니다.","slug":"univ_virtual-worlds/mid_01","readingMinutes":8,"wordCount":640},{"title":"대학 - 가상세계","description":"3학년 2학기 가상세계 수업 아카이브","icon":"","image":"","tags":[],"draft":false,"date":"2023-10-23 / 17:44","content":"\n","slug":"univ_virtual-worlds/index","readingMinutes":0,"wordCount":2}]},"__N_SSG":true},"page":"/blog/[category]","query":{"category":"univ_virtual-worlds"},"buildId":"zjlLyPj8az7Fp8gQlOqTr","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>