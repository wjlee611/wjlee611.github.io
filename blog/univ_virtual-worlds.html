<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>웅덩이</title><link rel="canonical" href="https://wjlee611.github.io/blog/univ_virtual-worlds"/><meta name="next-head-count" content="4"/><link rel="icon" href="/images/icon_circle.png"/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" rel="stylesheet"/><meta name="description" content="웅덩이"/><meta name="apple-mobile-web-app-title" content="웅덩이"/><meta name="application-name" content="웅덩이"/><meta name="theme-color" content="#009c39"/><meta name="google-site-verification" content="vhQ9DaDdUJcSBHKI_U6tAtE61zwz2i2pLQXyZ62GRLk"/><meta name="naver-site-verification" content="07764cc1a8eda55b4bdf78cf846d6811d042b9ee"/><link rel="preload" href="/_next/static/media/a37cf3809adb2c63-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/dd50543ba70be8e9-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/c372a630cbda84f2-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/c244cd6be2a69a75.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c244cd6be2a69a75.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-401a9806b070f31a.js" defer=""></script><script src="/_next/static/chunks/main-6b74302918225334.js" defer=""></script><script src="/_next/static/chunks/pages/_app-01dc60c7ef7ccbd8.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bcategory%5D-351fbf15b2ed9865.js" defer=""></script><script src="/_next/static/jxN_3xkEGn7F8-if3KEMa/_buildManifest.js" defer=""></script><script src="/_next/static/jxN_3xkEGn7F8-if3KEMa/_ssgManifest.js" defer=""></script></head><body class="text-primary transition-[background] bg-white dark:bg-[#1A1C23]"><script>
            const theme = localStorage.getItem("theme");
            const getUserTheme = () => {
             if(theme){
              return theme
             } 
             return window.matchMedia('(prefers-color-scheme: dark)').matches
             ? 'dark'
             : 'light'
          }
          document.body.dataset.theme = getUserTheme();
          </script><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="__className_e7b8b0 text-center transition-all "><header class="fixed top-0 left-0 right-0 mx-anuo w-screen h-12 md:h-16 flex justify-between items-center px-2 md:px-10 backdrop-blur bg-blue-200 bg-opacity-20 z-50"><div class="h-full flex items-center"><a class="h-full aspect-square flex justify-center items-center text-3xl select-none cursor-pointer" href="/">🫧</a><nav class="h-full hidden md:flex space-x-8 overflow-hidden ml-10"><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-black dark:text-white " href="/">Portfolio</a></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-blue-500 " href="/blog">Blog</a><div class="hidden md:flex w-full h-[2px] bg-blue-500 absolute bottom-0 left-0 blur-[2px]"></div></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-black dark:text-white " href="/arkhive">Arkhive</a></li></nav></div><div class="flex items-center h-full"><button aria-label="Toggle Dark Mode" type="button" class="flex h-9 w-9 items-center justify-center rounded-lg transition-all text-secondary hover:bg-secondary "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="h-6 w-6 text-yellow-400 drop-shadow-base"></svg></button><button class="flex md:hidden items-center justify-center w-16 h-full text-2xl text-black dark:text-white"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.5 11.5A.5.5 0 0 1 5 11h10a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 1 3h10a.5.5 0 0 1 0 1H1a.5.5 0 0 1-.5-.5z"></path></svg></button></div></header><main class="inline-block w-full relative pt-16 px-8 max-w-5xl 2xl:max-w-7xl" style="opacity:1;transform:none"><div class="flex flex-col mt-8 pb-16"><h3 class="mt-10 mb-5 text-xl bg-gradient-to-r from-blue-700 to-blue-400 bg-clip-text font-bold text-transparent">// 대학 - 가상세계</h3><ul class="flex flex-col items-center space-y-3"><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/mid_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Matrix and Transformations</h4><span>행렬에 대한 기본적인 내용과 이를 이용한 공간상에서의 변환에 대해 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-23 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/mid_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Vector</h4><span>벡터에 대한 기본적인 내용에 대해 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-23 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/mid_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Modeling</h4><span>모델을 저장하는 방법에 대해 알아봅나디.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-23 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/mid_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Unity Engine</h4><span>유니티 게임 엔진에 대한 기초적인 이론을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-23 </span></a></ul></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Matrix and Transformations","description":"행렬에 대한 기본적인 내용과 이를 이용한 공간상에서의 변환에 대해 다뤄봅니다.","icon":"","image":"","tags":["Matrix","Transform","Translate","Basis","Linear Map","Homogeneous Coordinates"],"draft":false,"date":"2023-10-23 / 22:09","content":"\n## Matrix\n\n$$\n\\begin{pmatrix}\na_{11} \u0026 a_{12} \u0026 ... \u0026 a_{1n} \\\\\na_{21} \u0026 a_{22} \u0026 ... \u0026 a_{2n} \\\\\n... \u0026 ... \u0026 ... \u0026 ... \\\\\na_{m1} \u0026 a_{m2} \u0026 ... \u0026 a_{mn} \\\\\n\\end{pmatrix}\n$$\n\nm-by-n matrix, 또는 **m행(Row) n열(Column)** 의 행렬이라고 부른다.\n\n여기서 하나의 **행** 만으로 이루어진 행렬을 `Row vectors`, \n한 **열**로만 이루어진 행렬을 `Column vectors` 라고 부른다.\n\n### Transpose\n\n$$\n(A^T)_{ij} = A_{ji}\n$$\n\n각 행과 열을 뒤집은 행렬을 전치행렬 이라고 부른다.\n\n### Square Matrix\n\n행과 열의 개수가 같은 행렬을 의미한다.\n\n### Identity Matrix\n\n$$\n\\begin{pmatrix}\n1 \u0026 0 \\\\\n0 \u0026 1 \\\\\n\\end{pmatrix}\n, \\;\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \\\\\n0 \u0026 1 \u0026 0 \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{pmatrix}\n$$\n\n위와 같이 Square Matrix인데 대각선만 1이고, 나머지는 0으로 채워진 행렬을 의미한다.\n\n\u003e AI = IA = A\n\n이 행렬의 가장 큰 특징은 행렬 A에 Identity Matrix를 곱하면 다시 행렬 A가 나온다는 것이다.\n\n### Scalar Multiplication \u0026 Addition\n\n백터에 스칼라 곱을 하거나, 백터간 합이나 차를 구할 때는 [**이전 포스트**](https://wjlee611.github.io/blog/univ_virtual-worlds/mid_03)에서 벡터의 연산을 했을 때와 동일하게 **각 원소에 대해 연산**을 진행하면 된다.\n\n### Matrix Multiplication\n\n![231023-222141](/posts/mid_04/231023-222141.png)\n\n행렬간 곱 연산은 위의 이미지와 같이 계산된다.\n여기서 주의할 점은 **앞의 행렬의 `열`** 의 개수와 **뒤의 행렬의 `행`** 의 개수가 일치해야 한다는 점이다.\n\n---\n\n## Transformations\n\n### Basis\n\n변환에 앞서 기저에 대해 알 필요가 있다.\n선형 독립인 벡터들이 공간을 생성(span)할 때, 그 벡터의 집합을 기저(basis)라고 한다.\n\n\u003ctip\u003e\n`선형 독립 (Linear Independent)`\n\u003cbr /\u003e\nN차원에서 어떤 하나의 벡터가 나머지 N-1개의 벡터의 **선형 결합으로 표현할 수 없는 경우**, N개의 벡터들이 선형 독립이라고 한다.\n즉, 벡터간 의존성이 없어야 한다.\n\u003c/tip\u003e\n\n벡터가 공간을 생성한다는 의미를 잘 모를 수 있는데, 예로 들어보자.\n\n![231023-230449](/posts/mid_04/231023-230449.png)\n\nv는 한 평면위의 벡터이다.\n이 상태에서 $v_1, \\; v_2$의 값을 [-$\\infty$, $\\infty$] 범위로 임의 조정한다고 가정해보자.\n그럼 v는 어떤 범위의 종점 좌표를 가질 수 있을까?\n바로 벡터 a, b가 속한 평면의 모든 좌표를 가질 수 있을 것이다.\n\n즉, **평행하지 않은 벡터의 선형 결합으로 공간을 생성**할 수 있는 것이다.\n\n그렇다면 두 벡터가 평행하지 않는다는 조건도 이해가 될 것이다.\n만약 두 벡터가 **평행**하다, 즉, **하나의 벡터로 다른 벡터를 표현**할 수 있다, 다른 말로 두 벡터가 **선형 의존**이라면, v는 직선상에만 존재할 수 있기 때문이다.\n\n그럼 다시 basis 얘기로 돌아와서, basis의 선형 결합으로 basis가 span하는 공간의 모든 벡터를 표현할 수 있다는 것을 이해했다.\n이 때 성립하는 증명이 있다.\n\n\u003e 같은 basis의 선형결합으로 표현되는 벡터는 표현 방법이 1개로 유일하다.\n\n위의 증명된 내용 덕분에, basis의 선형 결합 시 사용하는 weight를 좌표로써 활용할 수 있는 것이다.\n그렇기에 basis를 바꾼다는 건 좌표값을 바꾸는 것일 뿐, 벡터 그 자체를 바꾸는게 아니다.\n\n### Linear Map\n\n선형 사상이란 벡터의 기저를 바꿀 때, 즉 **벡터 공간이 바뀔 때 변형시에 선형성이 유지되는 변환 함수($F$)** 를 말한다.\n\n예로 들어 아래는 선형 사상이다.\n![231023-232038](/posts/mid_04/231023-232038.png)\n\n하지만, 이 경우는 선형 사상이 아니다.\n![231023-232104](/posts/mid_04/231023-232104.png)\n\n음? 그런데 이게 기저가 바뀌는거랑 무슨 상관이냐고?\n이제 기저를 선형 사상(변환 함수)에 대입해보며 알아보자.\n\n$$\n\\widehat{\\textrm{v}} = F\\textrm{v} \\\\\n{} \\\\\n\\begin{pmatrix}\n\\widehat{v_1} \\\\\n\\widehat{v_2} \\\\\n\\widehat{v_3}\n\\end{pmatrix} =\n\\begin{bmatrix}\nf_{11} \u0026 f_{12} \u0026 f_{13} \\\\\nf_{21} \u0026 f_{22} \u0026 f_{23} \\\\\nf_{31} \u0026 f_{32} \u0026 f_{33} \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\nv_1 \\\\\nv_2 \\\\\nv_3\n\\end{pmatrix} \n$$\n\n이해를 돕기 위해 $v_1$, $v_2$, $v_3$을 $x$, $y$, $z$ 라고 생각해보자.\n\n이제 ($v_1$, $v_2$, $v_3$) 대신에 (1, 0, 0) 을 대입해보자.\n이 때, (1, 0, 0)은 x축을 가리키는 기저의 원소이다.\n\n\n$$\n\\begin{pmatrix}\n\\widehat{v_1} \\\\\n\\widehat{v_2} \\\\\n\\widehat{v_3}\n\\end{pmatrix} =\n\\begin{bmatrix}\nf_{11} \u0026 f_{12} \u0026 f_{13} \\\\\nf_{21} \u0026 f_{22} \u0026 f_{23} \\\\\nf_{31} \u0026 f_{32} \u0026 f_{33} \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{pmatrix} =\n\\begin{pmatrix}\nf_{11} \\\\\nf_{21} \\\\\nf_{31}\n\\end{pmatrix} \n$$\n\n즉, 선형 사상($F$) 로 인해 기저 x(1, 0, 0)는 $(f_{11}, \\; f_{21}, \\; f_{31})^T$로 변환되었다.\n\n여기서 알 수 있는 것은 선형 사상, **Linear Function $F$의 i번째 열 벡터는 i번째 축의 기저벡터가 어디로 대응**되는가를 알려준다.\n또한, 위의 변환 과정은 선형성이 유지된다.\n\n참고로 선형성이 유지되는 특성 덕분에 여러 선형 사상을 한 번에 처리하는 것 또한 가능해진다.\n\n\u003e A(B(C(D(x)))) = ABCDx = $\\textrm{x}^TD^TC^TB^TA^T$\n\n### 2D Linear Transformations\n\n우선 회전을 살펴보자.\n\n![231023-234010](/posts/mid_04/231023-234010.png)\n\n선형 사상을 이용한 기저의 변환을 어느정도 이해했다면 이제 변형식이 왜 이렇게 생겼는지도 이해할 수 있을 것이다.\n\n예로 들어 (1,0) 즉 x축의 기저벡터를 $\\theta$ 만큼 회전시킨 좌표는 ($cos \\theta$, $sin \\theta$)가 되는데, 이는 위에서 언급한 \"선형 사상, **Linear Function $F$의 i번째 열 벡터는 i번째 축의 기저벡터가 어디로 대응**되는가를 알려준다\" 와 완벽히 일치한다.\n\n\u003ctip\u003e\n  즉, 앞으로의 변환은 각 축의 기저 벡터가 어떻게 변하는지를 파악하고, 해당 **변화 후의 값을 이용**해서 선형 사상 함수를 작성하면 된다.\n\u003c/tip\u003e\n\n이런 내용을 염두하고 다른 변환들도 살펴보자.\n\n![231023-235906](/posts/mid_04/231023-235906.png)\n\n![231024-000043](/posts/mid_04/231024-000043.png)\n\n![231024-000102](/posts/mid_04/231024-000102.png)\n\n### Affine Maps\n\n2D Translation을 가능케하는 Transformations 이 있을까?\n\n![231024-000319](/posts/mid_04/231024-000319.png)\n\n없다.\n그 이유는 **이동은 선형 변환이 아니**라서 이를 표현할 선형 사상 함수가 없기 때문이다.\n\n즉, Affine Map은 Linear map + Translation 으로 표현할 수 밖에 없다.\n왜냐면 Affine은 Linear하지 않기 때문이다.\n\n### Homogeneous Coordinates\n\n그렇다면 Transform과 Translate를 동시에 처리할 수 있는 방법이 없을까?\n바로 Homogeneous Coordinates를 이용하면 된다.\n\n이게 뭐냐면, 2차원의 Homogeneous Coordinates는 3차원의 벡터가 된다는 건데, 예시를 들어보자.\n\n$$\n\\begin{pmatrix}\nwx' \\\\\nwy' \\\\\nw\n\\end{pmatrix} =\n\\begin{bmatrix}\n1 \u0026 0 \u0026 t_x \\\\\n0 \u0026 1 \u0026 t_y \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\nwx \\\\\nwy \\\\\nw\n\\end{pmatrix}\n$$\n\n적당하게 w 기저를 하나 더 만들어서 차원을 높였다.\n이 때, ($wx$, $wy$, $w$)를 Homogeneous Coordinates 라고 하는데, 이제 여기에 계산의 편의를 위해 $w$에 1을 대입해보자.\n\n$$\n\\begin{pmatrix}\nx' \\\\\ny' \\\\\n1\n\\end{pmatrix} =\n\\begin{bmatrix}\n1 \u0026 0 \u0026 t_x \\\\\n0 \u0026 1 \u0026 t_y \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\nx \\\\\ny \\\\\n1\n\\end{pmatrix} = \n\\begin{pmatrix}\nx + t_x \\\\\ny + t_y \\\\\n1\n\\end{pmatrix}\n$$\n\n결과는?\n놀랍게도 Transformations 한 방식과 동일하게 진행되었는데 결과는 Translate 한 결과가 나왔다.\n이를 이용하면 2D 에서의 모든 변형은 다음과 같은 4개의 행렬의 곱으로 표현이 가능해진다.\n\n![231024-002119](/posts/mid_04/231024-002119.png)\n\n즉, 좌상단의 2x2 행렬은 Transform을 위한 부분이고, 우상단의 2x1 행렬은 Translate를 위한 부분이다.\n\n참고용으로 3D에 대한 Homogeneous Coordinates도 남겨놓겠다.\n![231024-002347](/posts/mid_04/231024-002347.png)\n\n### Compound Transformations\n\nLinear Map의 마지막에 언급한 사실에 근거해 이제 모든 변환은 합성 변환으로 치환할 수 있다.\n\n\u003e A(B(C(D(x)))) = ABCDx = $\\textrm{x}^TD^TC^TB^TA^T$\n\n그렇게 하면 ABCDx 이 행렬곱을 정리하기만 하면 A~D 까지의 모든 변환을 한 번에 수행하는 결과를 얻을 수 있으니 연산량이 매우 감소하게 된다.\n\n\u003cnotice\u003e\n  단, 연산 순서에 주의해야 한다.\n  \u003cbr /\u003e\n  ![231024-002828](/posts/mid_04/231024-002828.png)\n\u003c/notice\u003e\n\n이제 연산량이 어떻게 변하는지 예시를 살펴보자.\n\n![231024-003050](/posts/mid_04/231024-003050.png)\n\n이를 응용하면 특정 방향으로만 스케일링 하는 것도 구현할 수 있다.\n\n![231024-003225](/posts/mid_04/231024-003225.png)","slug":"univ_virtual-worlds/mid_04","readingMinutes":11,"wordCount":1032},{"title":"Vector","description":"벡터에 대한 기본적인 내용에 대해 다뤄봅니다.","icon":"","image":"","tags":["Vector","Points"],"draft":false,"date":"2023-10-23 / 20:12","content":"\n\u003cnotice\u003e\n  Vector와 Points는 (1, 2, 3) 과 같이 숫자로된 좌표로 표현된다는 점에서는 비슷하다.\n  \u003cbr /\u003e\n  하지만, `Points`는 **공간의 위치**를 나타내지만, `Vector`은 **방향과 크기**를 나타낸다는 점이서 다르다.\n  (벡터는 위치 개념이 없음. 상대적인 방향과 크기만을 가질 뿐) \n\u003c/notice\u003e\n\n## Vector Algebra\n\n### Scalar Multiplication\n\n![231023-204033](/posts/mid_03/231023-204033.png)\n\n해당 방향으로 크기만 증가하는 연산이다.\n**벡터의 각 성분에 크기 c만큼 각각 곱해주면** 된다.\n\n### Addition\n\n![231023-204232](/posts/mid_03/231023-204232.png)\n\nA 벡터의 종점에 B 벡터의 시점을 이어붙이는 연산으로, 그 값은 A 벡터의 시점 \u0026rarr; B 벡터의 종점이 된다.\n평행 사변형법으로도 계산할 수 있으며, **벡터의 각 성분끼리 더하면** 된다.\n\n### Substraction\n\n![231023-204432](/posts/mid_03/231023-204432.png)\n\n벡터에 -1을 스칼라 곱을 한 후, Addition을 한 결과와 같은 연산이다.\n**벡터의 각 성분을 빼주면** 된다.\n\n### Length \u0026 Direction\n\n![231023-204636](/posts/mid_03/231023-204636.png)\n\n벡터의 크기($L$)와 x축에 대한 방향($\\theta$)는 다음과 같다.\n\n\u003e $L = \\sqrt{x^2 + y^2}$\n\u003e\n\u003e $\\theta = tan^{-1}\\frac{y}{x}$\n\n\u003ctip\u003e\n  크기가 1인 벡터를 `단위벡터` 라고 하며, 벡터를 단위벡터로 변환하는 것을 **Normalization** 이라고 한다.\n  백터를 Normalization 하는 법은 **벡터의 각 성분을 $L$로 나눠주면** 된다.\n\u003c/tip\u003e\n\n### Linear Combination\n\n벡터들을 선형결합 하는 것을 의미한다.\n\n\u003e $b = c_1v_1 + c_2v_2 + ... + c_kv_k$\n\n이는 $v_1$, $v_2$, ..., $v_k$의 선형 결합이며, 상수 c를 weight라고 부른다.\n\n이 weight 값에 따라 다른 명칭으로 불리기도 한다.\n\n- `Affine Combination`\n  weight의 합이 반드시 1이 되는 선형결합.\n\n- `Convex Combination`\n  weight이 모두 양수이고, 합이 반드시 1이 되는 선형결합.\n\n### Dot product (내적)\n\n![231023-211310](/posts/mid_03/231023-211310.png)\n\n내적의 연산 결과는 스칼라가 되는데 우선 식부터 살펴보자.\n\n\u003e $\\overrightarrow{a} \\cdot \\overrightarrow{b} = a_1b_1 + a_2b_2 = \\begin{Vmatrix} \\overrightarrow{a} \\end{Vmatrix} \\begin{Vmatrix} \\overrightarrow{b} \\end{Vmatrix} cos \\theta$\n\n내적은 사잇각을 알아내는데 사용할 수 있는데, 그런데 내적 그 자체는 무슨 의미를 가질까?\n유닛벡터에 대해 다음과 같은 내적값은 다음과 같은 의미를 갖는다.\n\n- `1`\n  두 벡터가 **같은 방향으로 평행**하다\n\n- `-1`\n  두 벡터가 **정 반대 방향으로 평행**하다\n\n- `0`\n  두 벡터가 **수직**한다\n\n- `\u003e0`\n  두 벡터가 **같은 방향**이다\n\n- `\u003c0`\n  두 벡터가 **다른 방향**이다\n\n### Projection\n\n내적을 응용하면 한 벡터를 다른 벡터에 사상한 벡터를 얻을 수 있다.\n\n![231023-212348](/posts/mid_03/231023-212348.png)\n\n$\\overrightarrow{a'}$ 벡터의 길이는 **$\\begin{Vmatrix} \\overrightarrow{a} \\end{Vmatrix} cos \\theta$** 와 같다.\n또한 $\\overrightarrow{a'}$ 벡터의 단위벡터는 **$\\frac{1}{||\\overrightarrow{b}||} \\overrightarrow{b}$** 이다.\n\n따라서 둘을 곱한 다음의 식이 벡터 a를 벡터 b에 사상한 벡터가 된다.\n\n![231023-213605](/posts/mid_03/231023-213605.png)\n\n### Cross produce (외적)\n\n![231023-213718](/posts/mid_03/231023-213718.png)\n\n\u003e $\\overrightarrow{a} \\times \\overrightarrow{b} = \\begin{Vmatrix} \\overrightarrow{a} \\end{Vmatrix} \\begin{Vmatrix} \\overrightarrow{b} \\end{Vmatrix} sin \\theta \\cdot \\overrightarrow{n}$\n\u003e\n\u003e 여기서 $\\overrightarrow{n}$은 벡터 a, b에 수직한 유닛 벡터\n\n외적 두 벡터의 수직인 벡터로, 그 크기는 두 벡터가 이루는 평행사변형의 넓이이다.\n\n계산은 아래와 같이 하면 된다.\n\n$$\n\\begin{pmatrix}\na_1 \\\\\na_2 \\\\\na_3\n\\end{pmatrix} \\times\n\\begin{pmatrix}\nb_1 \\\\\nb_2 \\\\\nb_3\n\\end{pmatrix} =\n\\begin{pmatrix}\na_2b_3 - a_3b_2 \\\\\na_3b_1 - a_1b_3 \\\\\na_1b_2 - a_2b_1\n\\end{pmatrix}\n$$\n\n### Normal Vector\n\n한 평면에 대한 수직 단위벡터로 외적을 이용하면 구할 수 있다.\n\n![231023-214703](/posts/mid_03/231023-214703.png)\n\n---\n\n## Points Algebra\n\nPoints 는 더하거나, 스칼라곱에 대한 정의가 없다.\n하지만, 특수 상황에서는 의미를 갖는데, 그것들에 대해 알아보자.\n\n### Point - Point\n\n![231023-210346](/posts/mid_03/231023-210346.png)\n\nPoint B에서 Point A를 뺴면, 그 결과는 A\u0026rarr;B `Vector`가 된다.\n\n### Point + Vector\n\n![231023-210527](/posts/mid_03/231023-210527.png)\n\nPoint에 Vector를 더하거나 빼면 다른 `Point`가 된다.\n\n### Affine Combination\n\n위에서 언급했 듯, Points 는 더하거나, 스칼라곱에 대한 정의가 없다.\n하지만, 스칼라 곱 중에서 그 weight의 합이 1이 되는 경우 내분, 또는 외분의 의미를 갖게된다.","slug":"univ_virtual-worlds/mid_03","readingMinutes":6,"wordCount":506},{"title":"Modeling","description":"모델을 저장하는 방법에 대해 알아봅나디.","icon":"","image":"","tags":["Coordinate Systems","Polygonal Meshes"],"draft":false,"date":"2023-10-23 / 19:47","content":"\n## Coordinate Systems\n\n어떤 데이터든 간에 3D 공간상에 표현하기 위해서는 좌표 시스템을 먼저 구현해야 한다.\n그래야 공간상의 좌표의 조합으로 모델을 생성할 수 있기 때문이다.\n\n![231023-195004](/posts/mid_02/231023-195004.png)\n\n개발 환경에 따라 왼손 좌표계를 쓰거나 오른손 좌표계를 쓰는데, 참고로 유니티는 왼손 좌표계를 사용한다.\n따라서 유니티 관련 포스트는 모두 왼손 좌표계 기준으로 기술될 예정이다.\n\n---\n\n## Polygonal Meshes\n\n![231023-195154](/posts/mid_02/231023-195154.png)\n\n모든 3D 오브젝트를 삼각형 평면을 이어붙힌 형태로 표현하는 기법으로, 가장 많이 사용되는 방식이다.\n이런 데이터를 저장하는 방식에는 크게 3가지로 나뉘는데 각각 어떤식으로 데이터를 관리하는지 살펴보자.\n\n\u003ctip\u003e\n  mesh들은 OBJ, 3DS, POV 등의 확장자로 관리되는데,\n  OBJ의 경우 아래와 같은 정보를 저장한다.\n  - vertex의 좌표\n  - 각 vertex의 택스쳐 좌표\n  - 각 vertex의 수직 vertex\n  - 위의 vertex들로 표현돤 face\n\u003c/tip\u003e\n\n### Vertex-Vertex\n\n![231023-195357](/posts/mid_02/231023-195357.png)\n\n오직 점들만 데이터로 관리하는 자료구조를 사용한다.\n각 vertex의 **좌표**와 인접한(연결된) **vertex**를 저장한다.\n\n면에 대한 정보는 저장하지 않기에 추가적인 연산을 통해 얻어낼 수 밖에 없다.\n그렇기에 용량은 가장 작지만, 연산에 대한 부담이 있는 모델이다.\n\n### Face-Vertex\n\n![231023-195627](/posts/mid_02/231023-195627.png)\n\n점과 면을 데이터로 관리하는 자료구조를 사용하며, 가장 많이 사용되는 방식이다.\n`face`는 face를 구성하고 있는 **vertex**들의 집합으로 관리되고,\n`vertex`는 vertex의 **좌표**와 인접한 **faces**들의 집합으로 관리된다.\n\n### Winged Edge\n\n![231023-195936](/posts/mid_02/231023-195936.png)\n\n점과 면, 추가로 모서리의 데이터로 관리하는 자료구조를 사용하며, mesh를 변화시켜야 할 상황에 유용하게 사용할 수 있다.\n`face`는 face를 구성하고 있는 **edge**들의 집합으로 관리되고,\n`vertex`는 vertex에 연결된 **edge**들의 집합으로 관리된다.\n마지막으로 `edge`는 **시점, 종점의 좌표**와 **분할하는 면**, 그리고 연결된 edge 중 4개의 edge로 관리되는데,\n4개의 edge는 **시점에 연결된 back CCW, back CW, 종점에 연결된 front CCW, front CW** 순으로 관리된다. (그림 참고)","slug":"univ_virtual-worlds/mid_02","readingMinutes":4,"wordCount":241},{"title":"Unity Engine","description":"유니티 게임 엔진에 대한 기초적인 이론을 알아봅니다.","icon":"","image":"","tags":["Unity","Resource Management","Game Loop","Delta Time"],"draft":false,"date":"2023-10-23 / 17:46","content":"\n## Engine Architecture\n\n정말 말도안되게 깊고 넓은 레이어가 있는데, 간략하게 무슨 역할만을 하는지 살펴보자.\n~~(괜히 게임이 종합 예술이 아닌...)~~\n\n- Platform Independence Layer\n  디바이스에 상관없이 구동시키기 위한 레이어\n\n- Core systems\n  각종 코어 유틸리티들의 집합.\n  메모리 관리, 수학 라이브러리, 자체 자료구조 알고리즘 등.\n\n- Resource Manager\n  각종 에셋글의 생성과 관리, 배치 등의 총괄적인 관리를 담당.\n  **생성은 개발단계**에서, **배치는 런타임**에 관리된다.\n\n- Rendering Engine\n  에셋 등 데이터를 픽셀로 랜더링.\n  Projection, Shading, Texture sampling 등이 여기서 처리됨.\n\n- Scene Graph/Culling Optimization\n  시야에 안보이는 부분을 잘라내여 보이는 부분만 랜더링하도록 최적화.\n\n- Visual Effects\n  광원, 명암 등, 이미지(비주얼) 향상을 위한 후처리 과정.\n\n- Collision and Physics\n  충돌 및 물리 계산.\n\n- Animation\n  에셋들의 물리법칙을 에외한 움직임.\n\n- Human Interface Devices (HID)\n  사용자 입력, 움직임 등의 장치 관리.\n\n- Gameplay Foundation systems\n  게임 개발 환경 제공.\n\n---\n\n## Resource Management\n\n리소스에는 Meshes, audio, animation 등등 여러 raw resources 가 존재하는데, 각 리소스가 어떻게 처리되어야 하는지는 각 리소스의 Metadata를 참고하면 알 수 있다.\n\n리소스 생성과정은 다음과 같다.\n1. Maya, Photoshop 등과 같은 서드파티 앱에서 Export 한다.\n2. 이후 유니티가 game-ready 에셋인 `prefeb`으로 변환하기 위해 리소스 컴파일러가 구동된다.\n3. 추가로 여러 리소스를 하나의 패키지로 합치기 위해 링커도 제공한다.\n\n### Runtime\n\n유니티가 런타임에 어떻게 리소스를 관리하는지 개념적으로 알아보자.\n\n우선 유니티는 동일한 리소스는 특정 시각에 반드시 **1개**만 메모리에 올라오도록 보장한다.\n무슨 말이냐면 원할 때 리소스가 불러와지고, 이게 중복되어 불러와져 메모리 낭비를 하지 않게끔 해준다는 뜻인데, 이는 유니티의 **로딩 정책** 덕분에 가능해졌다.\n\n![231023-181333](/posts/mid_01/231023-181333.png)\n\n유니티는 리소스를 `비동기 로드`하기 때문에 로드해야 할 시점보다 미리 로딩한다.\n예로 들어 Level 1 에서는 A, B, C 리소스가 필요한데, 레벨 실행 전에 먼저 필요한 리소스의 목록을 파악해서 로딩하고, 로딩이 완료된 후에 레벨을 진행하는 방식으로 진행된다.\n\n이 때, 각 리소스별로 `Reference count`를 둬서 쓸데없는 중복 로딩이나, 필요 없는 리소스를 메모리에서 제거하기도 한다.\nref count가 0보다 큰데 로딩되지 않은 리소스는 로딩하고, ref count가 0인데 로딩된 리소스는 언로드 하도록 하는 것이다.\n\n메모리에서 제거하는 원리는, GC(Garbage Collector)가 일정 주기로 ref count가 0인 리소스를 제거한다.\n`System.GC.Collect()` 를 이용하면 수동적으로 GC를 호출할 수 있지만, 가능하면 그러지 말자.\n\n정리하면 런타임에 리소스 매니저는 아래의 역할을 수행할 수 있어야 한다.\n1. 동일한 리소스는 특정 시각에 메모리에 1개만 올라오도록 보장\n2. 각 리소스의 생명주기를 관리\n3. prefeb과 같은 여러군데 흩어진 리소스의 묶음을 관리할 수 있어야 한다\n4. 리소스간 참조의 무결성을 보장해야 한다\n5. 이미 로드된 리소스의 메모리 사용량도 관리해야 한다\n\n### Location\n\n리소스가 어디에 존재하는지에 따라 런타임시 로드 방식이 달라진다.\n\n- AssetBundles\n  유니티 플레이어 외부의 리소스로, 보통 웹서버 상에 존재하는 리소스이다.\n  `AssetBundle.LoadAsset()` 으로 불러올 수 있다.\n\n- Resource folders\n  유니티 플레이어 내부의 리소스로, Project view의 Resources 폴더에 존재하는 리소스이다.\n  `Resources.Load()` 로 불러올 수 있다.\n\n---\n\n## Game Loop\n\n매 프레임 상태 변경을 하거나, 사용자 입력을 받거나, 화면 랜더링을 위한 무한 루프를 의미한다.\n1초에 얼마나 루프가 돌아가는지를 나타내는 척도가 FPS인데, 엄밀히 말하면 화면이 그려지는 횟수지만, 한 루프에 한 번 화면이 업데이트되니 거의 같이 사용할 수 있다.\n\n유니티에선 거의 대부분의 클래스가 `MonoBehavior`를 상속하여 정의하는데, 여기에서 `Update()` 함수가 프레임당 한 번 호출이 이루어진다.\n\n그 외에도 override할 수 있는 다른 함수 몇 개 더 알아보자.\n\n- `Start()`\n  첫 프레임 업데이트시 호출되는 함수.\n\n- `LateUpdate()`\n  Update() 함수가 종료되고나서 호출되는 함수.\n\n- `OnDestory()`\n  소멸자 비스무리한 함수.\n  마지막 프레임의 업데이트가 완료되고 나서 호출되는 함수.\n\n### Delta Time\n\n두 인접한 프레임 사이의 시간이 얼마나 흘렀는가를 나타내는 값으로, 보통 그 값은 FPS의 역수이다.\n즉, 30FPS 게임에서의 $\\Delta t$는 1/30 seconds, 즉, 3.33ms이다.\n\n두 프레임 사이의 시간이므로 물리 시뮬레이션시 시간 변화율로서 동작하게 되는데, 물리량을 수식화 하면 다음과 같다.\n\n| 의미 | 수식 |\n|---|---|\n| Position | $p_{t+\\Delta t} = p_t + v_t \\cdot \\Delta t$ |\n| Velocity | $v_{t+\\Delta t} = v_t + a_t \\cdot \\Delta t$ |\n| Acceleration | $a_{t+\\Delta t} = f_{ext}/m$ |\n\n즉, $\\Delta t$가 너무 크거나 일정하지 않으면 물리량에 오차가 커질 수 밖에 없다.\n만약 델타값을 고정시키고, 이를 게임 루프에 의존해서 증가시킨다면 컴퓨터 사양에 따라 다르게 동작하는 현상이 발생할 수 있다.\n\n따라서, 유니티는 **CPU**의 `high-resolution timer`를 이용해서 델타값을 구하기 때문에 현실세계와 유사한 플레이 경험을 얻을 수 있도록 합니다.","slug":"univ_virtual-worlds/mid_01","readingMinutes":8,"wordCount":640},{"title":"대학 - 가상세계","description":"3학년 2학기 가상세계 수업 아카이브","icon":"","image":"","tags":[],"draft":false,"date":"2023-10-23 / 17:44","content":"\n","slug":"univ_virtual-worlds/index","readingMinutes":0,"wordCount":2}]},"__N_SSG":true},"page":"/blog/[category]","query":{"category":"univ_virtual-worlds"},"buildId":"jxN_3xkEGn7F8-if3KEMa","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>