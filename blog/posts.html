<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>웅덩이</title><link rel="canonical" href="https://wjlee611.github.io/blog/posts"/><meta name="next-head-count" content="4"/><link rel="icon" href="/images/icon_circle.png"/><meta name="description" content="웅덩이"/><meta name="apple-mobile-web-app-title" content="웅덩이"/><meta name="application-name" content="웅덩이"/><meta name="theme-color" content="#009c39"/><meta name="google-site-verification" content="vhQ9DaDdUJcSBHKI_U6tAtE61zwz2i2pLQXyZ62GRLk"/><meta name="naver-site-verification" content="07764cc1a8eda55b4bdf78cf846d6811d042b9ee"/><link rel="preload" href="/_next/static/media/2aaf0723e720e8b9-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/a34bb536bf9c15e6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a34bb536bf9c15e6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-7a7e500878b44665.js" defer=""></script><script src="/_next/static/chunks/main-3ec6cf69632cecc3.js" defer=""></script><script src="/_next/static/chunks/pages/_app-29b68604a306ce05.js" defer=""></script><script src="/_next/static/chunks/pages/blog/posts-78e15f8e1861ec88.js" defer=""></script><script src="/_next/static/1HfKky-wT2nKQVLmy4XOF/_buildManifest.js" defer=""></script><script src="/_next/static/1HfKky-wT2nKQVLmy4XOF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="__className_20951f text-center transition-all "><header class="fixed top-0 left-0 right-0 mx-anuo w-screen h-16 flex justify-between md:justify-start px-10 backdrop-blur bg-blue-200 bg-opacity-20 z-50"><a class="h-16 aspect-square flex justify-center items-center text-3xl mr-10 select-none cursor-pointer" href="/">🫧</a><nav class="h-full hidden md:flex space-x-8 overflow-hidden"><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0  " href="/">Portfolio</a></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 text-blue-500 " href="/blog">Blog</a><div class="hidden md:flex w-full h-[2px] bg-blue-500 absolute bottom-0 left-0 blur-[2px]"></div></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0  " href="/arkhive">Arkhive</a></li></nav><button class="flex md:hidden items-center justify-center w-16 h-16 text-2xl"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.5 11.5A.5.5 0 0 1 5 11h10a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 1 3h10a.5.5 0 0 1 0 1H1a.5.5 0 0 1-.5-.5z"></path></svg></button></header><main class="inline-block w-full relative pt-16 px-8 max-w-5xl 2xl:max-w-7xl" style="opacity:1;transform:none"><div class="flex flex-col mt-8 pb-16"><h3 class="mt-10 mb-5 text-xl bg-gradient-to-r from-blue-700 to-blue-400 bg-clip-text font-bold text-transparent">// 전체 포스트</h3><ul class="flex flex-col items-center space-y-3"><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 transition-colors relative" href="/blog/flutter/003_dart_basic"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Dart 언어 기초</h4><span>Dart 언어에 대한 기초지식을 정리해봤습니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-14 / 17:09</span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 transition-colors relative" href="/blog/flutter/002_project_initalize"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">플러터 프로젝트 만들기</h4><span>플러터 프로젝트 생성 가이드 입니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-14 / 16:09</span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 transition-colors relative" href="/blog/flutter/001_installation"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">플러터 시작하기</h4><span>플러터 설치 및 VSCode 세팅 가이드입니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-13 / 21:09</span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 transition-colors relative" href="/blog/univ_ai/mid_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">상태공간 &amp; 탐색</h4><span>상태공간과 탐색의 의미와 예시를 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-12 / 15:09</span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 transition-colors relative" href="/blog/univ_design-pattern/mid_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Observer Pattern</h4><span>Observer 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-11 / 10:09</span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 transition-colors relative" href="/blog/univ_design-pattern/mid_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Strategy Pattern</h4><span>Strategy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-11 / 09:09</span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 transition-colors relative" href="/blog/univ-mmds/230906"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">분산 파일관리 시스템</h4><span>분산 파일관리 시스템에 관련한 기초 지식을 배웁니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-06 / 12:09</span></a></ul></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Dart 언어 기초","description":"Dart 언어에 대한 기초지식을 정리해봤습니다.","icon":"","image":"","tags":["Dart"],"draft":false,"date":"2023-09-14 / 17:09","content":"\n\u003cwarning\u003e\n  제가 생각하기에 **너무 기초지식**이다 하는 부분은 과감하게 **제외**했습니다.\n  다만, 기초지식이다 하더라도 `개념적으로 매우 중요`하거나 `많이들 알려주지 않는 내용`은 포함하였습니다.\n\u003c/warning\u003e\n\n## variables\n\n변수 네이밍 방법은 다음과 같습니다.\n\n```dart:.dart\n  \u003c제어자\u003e \u003c타입\u003e \u003c변수이름\u003e = \u003c값\u003e;\n```\n\n타입은 int, String 과 같은 타입들이 오거나, `var` 와 같은 타입 추론 키워드도 사용할 수 있습니다.\n제어자에는 `final`, `const`, `late`, `static` 와 같은 키워드가 오게 됩니다.\n\n### var\n\ndart에선 var는 타입 추론 키워드로 사용되는 예약어입니다.\n따라서 `\u003c값\u003e`에 어떤 데이터가 오는지에 따라 변수의 타입이 결정됩니다.\n단, 값을 지정하지 않을 때는 `dynamic` 타입으로 자동 결정됩니다.\n\n\u003ctip\u003e\n  `dynamic?`\n  타입 안정성이 보장되지 않지만, 모든 타입의 데이터를 할당할 수 있도록 해줍니다.\n  보통 json 파일을 파싱할 때 임시로 데이터 형식을 지정할 때 많이 사용합니다.\n\u003c/tip\u003e\n\n### final vs const\n\n`final`과 `const` 둘 모두 데이터의 불변성을 보장하고 싶을 때 사용하는 키워드 라는 점에서는 공통점을 갖습니다.\n또한, 이 키워드를 사용한다면 타입을 굳이 지정하지 않아도 알아서 `var`로 타입을 지정하는 효과가 있습니다.\n하지만 둘 사이의 중요한 차이점이 있습니다.\n\n`final`은 런타임에 값이 지정됩니다.\n따라서 메모리상의 `heap 영역`에 데이터가 저장됩니다.\n그렇기에 생명주기는 스코프 내부로 한정되기 떄문에 flutter 에서 **build 메서드**가 호출될 때 이 부분은 `반복적`으로 메모리에 올라왔다 내려갔다를 반복하게 됩니다.\n\n`const`는 컴파일타임에 값이 지정됩니다.\n특이한 점인 const 키워드로 지정된 데이터는 메모리상에 별도로 적재되지 않고, `컴파일된 코드의 상수 풀(constant pool)`상에 저장됩니다.\n따라서 별도의 인스턴스가 생성되지 않고, 생명주기도 프로그램 수명과 동잃하기에 flutter 에서 **build 메서드**가 호출될 때 이 부분은 `다시 랜더링되지 않습니다`.\n\n### late\n\ndart는 **null-safety** 언어입니다.\n따라서 `\u003c타입\u003e?` 와 같이 `?`로 null값이 가능하다고 지정해 주지 않는한 변수 선언시(혹은 인스턴스 생성시) 반드시 값을 지정해야 합니다.\n하지만, `late`의 경우에는 인스턴스 생성 시점에 null값을 허용하지만, 이후에 `단 한번` 값을 할당할 수 있도록 해주는 키워드입니다.\n\n물론, null값이 임시 허용이 되는만큼 사용에 주의가 필요합니다.\n\n### static\n\n`static`은 클래스가 로드될 때 값이 지정됩니다.\n따라서 heap영역이 아닌 `클래스 자체 메모리 영역`에 저장됩니다.\n그렇기에 일반 메서드에선 static 변수에 접근할 수 있지만, static 메서드에선 일반 변수에 접근할 수 없습니다.\n하지만 그렇기에 클래스를 인스턴스화 하지 않아도 바로 접근이 가능합니다.\n\n---\n\n## function\n\ndart는 사실 js를 대체하기 위해 나온 언어라고 합니다.\n그래서일까요, dart의 모든 데이터 타입도 사실은 모두 `Object`입니다.\n\n뿐만 아니라, `변수에 함수를 할당`하거나, `익명 함수`, `람다 함수` 모두 사용 가능합니다.\n\n### named parameter\n\n보통 함수의 파라미터는 아래와 같이 작성하곤 합니다.\n\n```dart:.dart\n  void myFunction(int num) {\n    ...\n  }\n  ...\n  myFunction(1);\n```\n\n하지만 입력받고자 하는 파라미터가 많아진다면, 인자를 넘겨줄 때 어느 자리에 어느 데이터를 넘겨야 할지 알기가 어렵습니다.\n특히 flutter에서는 위젯을 만들 때 인자를 십수개씩 넘기는 경우가 많죠...\n\n그렇기에 `named parameter` 기능을 제공합니다. (마치 js에서 객체를 인자로 넘기 듯)\n\n```dart:.dart\n  void myFunction({required int myNum}) {\n    ...\n  }\n  ...\n  myFunction(myNum: 1);\n```\n\n이렇게 하면 함수 호출이나, 클래스 생성자 호출시 어느 인자에 어느 데이터를 넘겨야 하는지 명확해집니다.\n\n물론, 위 두 방식을 `혼합`하여 사용할 수도 있습니다.\n\n```dart:.dart\n  void myFunction(String str, {required int val}) {\n    ...\n  }\n  ...\n  myFunction(\"string\", myNum: 1);\n```\n\n---\n\n## class\n\n### constructor\n\n```dart:.dart\nclass Car {\n  final String color;\n  int wheels;\n  String? name;\n\n  Car({\n    required this.color,\n    required this.wheels,\n    this.name,\n  });\n}\n```\n\n기본적으로 생성자는 위와 같이 정의할 수 있습니다.\n`named parameter` 형식으로도 사용이 가능합니다. (대부분의 flutter 위젯은 위와 같이 정의합니다)\n\n### named constructor\n\n```dart:.dart\nCar {\n  final String color;\n  late int wheels;\n  String? name;\n\n  Car.fourWheels({required this.color, this.name}) {\n    this.wheels = 4;\n  }\n}\n```\n\n클래스를 생성할 때 특별한 기능을 붙인채로 인스턴스화 할 수 있도록 `named constructor`를 지원합니다.\n보통 초기상태를 위한 `.init`, 모델링을 위한 `.fromJson`와 같이 쓰이곤 합니다.\n(참고로 이 때 factory 키워드를 이용해서 싱글톤 패턴으로 많이 구현하는데 이는 다음에 소개하겠습니다)\n\n### initializer list\n\n위에 `wheels`을 별도로 초기화하기 위해 late 한정자를 사용했는데요, 보기가 안좋습니다.\n`final` 멤버변수는 생성자 body에서 값을 지정할 수 없기에 저런식으로 표현했는데요,\n`initializer list`를 이용하면 final 멤버변수도 생성자 호출시 별도로 처리할 수 있습니다.\n\n```dart:.dart\nclass Car {\n  final String color;\n  final int wheels;\n  String? name;\n\n  Car.prototype({required this.color}) : wheels = 4 {\n    this.name = 'proto';\n  }\n}\n```\n\n`:`를 붙여 `: wheels = 4`와 같이 사용할 수 있습니다.\n또한, 뒤에 body를 붙여 추가작업 또한 할 수 있습니다.\n\ninitializer **list**에서 알 수 있듯 `wheels = 4` 와 같은 initializer를 `,`를 이용해서 여려개 연달아 초기화할 수 있습니다.\n\n### redirecting constructor\n\n```dart:.dart\nclass Car {\n  final String color;\n  final int wheels;\n  String? name;\n\n  Car({\n    required this.color,\n    required this.wheels,\n    this.name,\n  });\n\n  Car.fourWheels({required String color, String? name})\n      : this(\n          color: color,\n          wheels: 4,\n          name: name,\n        );\n}\n```\n\n기존의 생성자를 `this`로 호출하여 named constructor를 구현한 방식입니다.\n다만, 이 경우에는 생성자의 body를 구현할 수 없습니다.\n","slug":"flutter/003_dart_basic","readingMinutes":9,"wordCount":703},{"title":"플러터 프로젝트 만들기","description":"플러터 프로젝트 생성 가이드 입니다.","icon":"","image":"","tags":["Flutter","Getting started"],"draft":false,"date":"2023-09-14 / 16:09","content":"\n## 시작 전 주의사항\n\n\u003cnotice\u003e\n  이 포스트에선 플러터 프로젝트를 생성하는 방법을 다뤄봅니다.\n  따라서 플러터 SDK 설치나, 관련 환경설정이 안되신 분은 [**`플러터 시작하기`**](https://wjlee611.github.io/blog/flutter/001_installation)를 꼭 읽어보시고 다시 와주시기 바랍니다.\n\u003c/notice\u003e\n\n\u003cnotice\u003e\n  본 블로그의 플러터 개발환경은 `VSCode`와 `터미널`로 고정됩니다.\n  따라서 다른 개발환경에 대한 정보는 없으므로 이 점 참고 부탁드립니다.\n\u003c/notice\u003e\n\n## 프로젝트 생성\n\n프로젝트 생성을 위해 우선 본인이 프로젝트를 관리할 폴더로 이동해주세요.\n제 경우에는 깃허브로 버전관리를 하는 프로젝트의 경우 `~/Documents/GitHub` 폴더에서 일괄적으로 관리하는 편입니다.\n\n```bash:Terminal\ncd ~/Documents/GitHub\n```\n\n이후에는 아래의 명령어로 플러터 프로젝트를 생성합니다.\n\n```bash:Terminal\nflutter create \u003cproj_name\u003e\n```\n\n이 때, 프로젝트를 생성할 때 알아두면 유용한 (거의 필수) 몇 가지 옵션을 소개드립니다.\n\n### --org\n\n이 옵션을 지정하면 프로젝트를 생성할 때 패키지명을 지정할 수 있습니다.\n\n```bash:Terminal\nflutter create \u003cproj_name\u003e --org \u003cpackage_name\u003e\n```\n\n\u003cnotice\u003e\n  \\\u003cpackage_name\\\u003e이 100% 동일하게 패키지 이름이 되는 것은 아닙니다.\n  옵션명에서 유추할 수 있듯 기관의 이름을 적는 것입니다.\n\n  따라서 진짜 패키지 이름은 `\u003cpackage_name\u003e.\u003cproj_name\u003e` 형식이 됩니다.\n\u003c/notice\u003e\n\n예로들어 아래와 같이 프로젝트를 생성했다고 가정해봅시다.\n\n![230914-164837](/posts/002_project_initalize/230914-164837.png)\n\n이 경우에는 프로젝트명 - `gdsc_study` / 패키지명 - `com.gmail.wjlee611` 입니다.\n따라서 프로젝트에서 실제로 적용되는 패키지명은 아래와 같아집니다.\n\n![230914-165226](/posts/002_project_initalize/230914-165226.png)\n\n\u003e Android - `com.gmail.wjlee611.gdsc_study`\n\u003e iOS - `com.gmail.wjlee611.gdscStudy`\n\n같은 명령어라도 다른 패키지명이 생성되니 나중에 앱을 배포할 때 반드시 패키지명을 확인하도록 합시다.\n\n### -i swift\n\n기본적으로 생성되는 iOS 코드는 `Objective-C` 입니다.\n하지만 이 옵션을 추가하면 `Swift`로 생성되게 됩니다.\n\n### -a kotlin\n\n기본적으로 생성되는 Android 코드는 `Java` 입니다.\n하지만 이 옵션을 추가하면 `Kotlin`으로 생성되게 됩니다.\n\n\n","slug":"flutter/002_project_initalize","readingMinutes":3,"wordCount":223},{"title":"플러터 시작하기","description":"플러터 설치 및 VSCode 세팅 가이드입니다.","icon":"","image":"","tags":["Flutter","VSCode","Package manager"],"draft":false,"date":"2023-09-13 / 21:09","content":"\n## 들어가며...\n\n이 포스트에선 플러터(Flutter) 개발을 시작할 때 세팅해야할 전 과정에 대해 설명합니다.\nFlutter SDK 설치부터 에뮬레이터 세팅, VSCode 세팅, 추가로 유용한 단축키에 대해서 알아봅니다.\n다만, 단축키는 운영체제, 에디터 환경, 설정에 따라 다를 수 있으니 이점 참고 바랍니다.\n\n\u003cnotice\u003e\n  **이미 설치를 완료하신 분들도 시간 내셔서 [**`VSCode 세팅`**](https://wjlee611.github.io/blog/flutter/001_installation#vscode-%EC%84%B8%ED%8C%85)부터 읽어보시는 것을 강력 추천드립니다.**\n\u003c/notice\u003e\n\n블로그 주인장은 M1 Mac 환경에서 세팅하였기에 리눅스 계열 세팅방법을 기준으로 다뤄봅니다만,\n윈도우 머신에서의 세팅도 다뤄볼 겁니다. (다만, 실제 테스트는 하지 않았기에 오류가 있을지도 모릅니다)\n\n참고로 아래의 모든 설치과정은 [**노마드코더**](https://nomadcoders.co/flutter-for-beginners)의 강좌를 정리한 자료입니다.\n\n- https://nomadcoders.co/flutter-for-beginners/lectures/4133\n- https://nomadcoders.co/flutter-for-beginners/lectures/4142\n\n---\n\n## Flutter SDK 설치\n\nFlutter SDK를 설치할 때 방법이 크게 두 가지로 나뉩니다.\n첫 번째는 Flutter 공식 사이트에서 제공하는 방식을 따라가는 방법\n두 번째는 패키지 매니저를 이용해서 설치하는 방법\n\n제 개인적인 생각에는 패키지 매니저를 이용하는 방법이 더 간단해 보입니다.\n첫 번째 방법을 따라하려면 환경 PATH도 설정해야 하기에 좀 무서워 보이기 때문이죠...\n~_(그리고 제가 이 방법밖에 안해보기도 했구요...)_~\n\n그래도 일단은 두 방법 모두 소개해 드리겠습니다.\n\n### 공식 사이트\n\n1. [**플러터 공식 페이지**](https://flutter.dev)로 접속합니다.\n\n2. `Get started`로 들어갑니다.\n   ![230913-211858](/posts/001_installation/230913-211858.png)\n\n3. 본인 운영체제에 맞는 Flutter SDK를 설치합니다.\n   ![230913-212121](/posts/001_installation/230913-212121.png)\n\n   이후에는 공식 사이트에서 제공하는 문서를 천천히 따라하시면 됩니다.\n\n---\n\n### 패키지 매니저 (MacOS)\n\n1. [**Homebrew**](https://brew.sh/)에 들어갑니다.\n   ![230913-214251](/posts/001_installation/230913-214251.png)\n\n\u003cnotice\u003e\n  _참고로 Homebrew는 MacOS에서 사용할 수 있는 **대부분의 개발자도구를 터미널로 설치할 수 있는 강력한 도구**입니다._\n  _Flutter가 아니더라도 **반드시** 설치하는게 정신건강에 이롭습니다._\n\u003c/notice\u003e\n\n2. `터미널`을 열어줍니다.\n\n3. 아래의 명령어를 입력하여 Homebrew를 설치합니다.\n   (공식 사이트에서 복사하는 것을 권장합니다)\n\n```bash:Terminal\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n4. 아래의 명령어로 Flutter SDK를 설치합니다.\n\n```bash:Terminal\nbrew install --cask flutter\n```\n\n---\n\n### 패키지 매니저 (Windows)\n\n1. [**Chocolatey - individual**](https://chocolatey.org/install#individual)에 들어갑니다.\n   ![230913-213419](/posts/001_installation/230913-213419.png)\n\n2. `PowerShell`을 관리자 권한으로 실행합니다.\n\n3. 아래의 명령어를 입력하여 Chocolatey를 설치합니다.\n\n```shell:PowerShell\nGet-ExecutionPolicy\n```\n\n만약 `Restricted` 라고 뜬다면 아래의 명령어 중 하나를 입력하면 됩니다.\n\n```shell:PowerShell\nSet-ExecutionPolicy AllSigned\n또는\nSet-ExecutionPolicy Bypass -Scope Process\n```\n\n그 이후에 아래의 긴- 명령어를 입력합니다.\n(공식 사이트에서 복사하는 것을 권장합니다)\n\n```shell:PowerShell\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n```\n\n`Chocolatey` 설치가 완료되었다면 `choco` 라는 명령어가 실행 가능할 겁니다.\n\n4. 아래의 명령어로 Flutter SDK를 설치합니다.\n\n```shell:PowerShell\nchoco install flutter\n```\n\n### 설치 확인 방법 (1)\n\n터미널 창에 `flutter` 를 입력해봅시다.\n`Command not found` 와 같은 에러를 제외하고 뭐라도 뜬다면 설치가 완료된 것입니다.\n\n---\n\n## 애뮬레이터 설치\n\n아래의 공식 문서를 통해 설치하는 것이 가장 바람직합니다.\n설명도 친절해서 왠만하면 설치하는데 문제가 없을겁니다. (아예 없진 않음...)\n관련 링크를 아래에 정리합니다.\n\n🫧[**MacOS - ios setup**](https://docs.flutter.dev/get-started/install/macos#ios-setup)\n🫧[**MacOS - android setup**](https://docs.flutter.dev/get-started/install/macos#android-setup)\n\n🫧[**Windows - android setup**](https://docs.flutter.dev/get-started/install/windows#android-setup)\n\n### 설치 확인 방법 (2)\n\n터미널 창에 `flutter doctor` 를 입력해봅시다.\n![230913-220216](/posts/001_installation/230913-220216.png)\n\nSDK, 애뮬레이터, 에디터까지 발생하는 문제사항을 한 눈에 파악할 수 있습니다.\n\n\u003ctip\u003e\n  참고로 최초 실행시 안드로이드 라이센스에 동의하라는 에러 혹은 경고가 나타날 수 있습니다. \n  그럴 땐 당황하지 마시고 아래의 명령어를 입력하면 됩니다.\n  (_설치할 때 꼼꼼히 읽어보면 이런 내용도 있다는 걸 확인할 수 있죠..._)\n\n  \u003cbr /\u003e\n\n  ```bash:Terminal\n  flutter doctor --android-licenses\n  ```\n\u003c/tip\u003e\n\n### Troubleshooting\n\n간혹가다 Xcode `command line tools`에서 문제가 발생하는 경우가 있습니다.\n명령어 라인 도구는 Xcode를 설치할 때 자동적으로 설치됩니다.\n\n하지만 제 경우에는 Xcode를 설치하기 전에 아래의 명령어로 미리 설치한 적이 있었습니다.\n\n```bash:Terminal\nxcode-select --install\n```\n\n명령어 라인 도구를 먼저 설치하고 Xcode를 설치하면 가끔 정상동작하지 않는 에러가 발생하는 거 같습니다.\n이런 경우에는 명령어 라인 도구를 제거하고 다시 설치하면 해결됩니다.\n\n---\n\n## VSCode 세팅\n\n사실 마켓플레이스에서 `Flutter`, `Dart` 확장을 설치하기만 하면 개발할 준비가 끝나긴 합니다.\n하지만, 개발 편의성과 코드 통일을 위해서 필요한, 혹은 유용한 `확장`과 `setting.json`을 공유할까 합니다.\n\n### setting.json\n\n아래와 같은 키값을 추가하면 개발에 있어 편의성이 증진됩니다.\n하지만, 설정을 건드릴 땐, 본인의 설정과 충돌이 생기는지 반드시 확인한 후에 추가하시는 것을 권장합니다.\n\n참고로, setting.json은 `명령 팔레트`를 열고 `settings.json`을 검색하면 바로 나옵니다.\n또 참고로, 명령 팔레트는 `Command(Window) + Shift + P` 명령어 조합으로 열 수 있습니다.\n\n```json:settings.json showLineNumbers\n{\n  ...\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll\": true\n  },\n  \"dart.previewFlutterUiGuides\": true,\n}\n```\n\n`Line 3-5`의 설정은 자동으로 필요한 모든 곳에 `const` 키워드를 삽입해주는 설정입니다.\nflutter에서 const를 사용하는 것은 매우 중요한데 그 이유에 대해서는 다음에 설명하도록 하겠습니다.\n일단은 가능하다면 반드시 const를 붙이는게 좋고, 이를 자동으로 붙여줄 수 있다는 것만 기억합니다.\n\n`Line 6`의 설정은 flutter 위젯을 트리 구조로 선으로 연결해주는 설정입니다.\n![230913-222546](/posts/001_installation/230913-222546.png)\n\nflutter은 위젯의 depth가 깊어지는 단점이 있는데 이를 어느정도 극복하게 해주는 유용한 설정입니다.\n\n### Error Lens\n\n![230913-223129](/posts/001_installation/230913-223129.png)\n\nError Lens는 코드 문제의 원인을 에디터상에 바로 띄워주는 확장입니다.\n실시간으로 무슨 에러가 있는지 한 눈에 확인할 수 있는게 개인적으로 매우 만족하면서 사용하고 있습니다.\n\n![230913-223528](/posts/001_installation/230913-223528.png)\n\n개인적으로 눈뽕(?) 방지를 위해 `line` 이 아닌, `message` 로 설정하는 것을 추천드립니다.\n\n![230913-224036](/posts/001_installation/230913-224036.png)\n\n또한, 분석 레벨에서 `info` 는 제거해주시는 것을 추천 드립니다.\n\nflutter의 경우 info가 중첩되서 뜨는 경우가 많기에 위 두 세팅을 바꾸지 않으면 아래와 같은 눈뽕(?)을 자주 겪게 될 지도 모릅니다...\n![230913-223954](/posts/001_installation/230913-223954.png)\n\n### Image preview\n\n![230913-224456](/posts/001_installation/230913-224456.png)\n\nImage preview는 로컬, 네트워크 이미지를 미리보기 형식으로 띄워주는 확장입니다.\nFE 개발 입장에서 이미지나 svg, icon을 사용할 일이 많은데, 이를 미리볼 수 있다는 것 만으로도 많은 시간을 절약할 수 있습니다.\n\n---\n\n## VSCode 단축키\n\n개발 시간을 줄여주는 유용한 단축키 및 snippets 를 소개합니다.\n\n### Code Action\n\n![230913-224956](/posts/001_installation/230913-224956.png)\n\nflutter 개발을 하다보면 중간에 위젯을 다른 위젯으로 감싸거나, 부모 위젯을 통째로 드러내야 하는 경우가 잦은데,\n이를 일일이 코드를 잘라내고 붙여넣기 하는건 매우 귀찮은 작업입니다.\n\n하지만 이 기능을 수행하는데 있어 Code Action은 매우 유용한 도구들을 제공합니다.\n\n기능을 수행하고자 하는 위젯의 좌측에 `💡(전구) 모양 아이콘`을 클릭하면 해당 위젯에서 수행할 수 있는 여러 기능들을 보여줍니다.\n\n또는 `Command(Window) + .` 단축키로 빠르게 Code Action에 접근할 수 있습니다.\n매우매우 자주쓰는 기능이니 본인 에디터 환경에 맞는 단축키를 외우도록 합시다.\n~_(사실 외울 필요도 없이 쓰다보면 손가락이 알아서 움직이게 된다는...)_~\n\n### Intellisense\n\n쉽게 말하면 `코드 추천 + 자동완성` 기능입니다.\n\n코드를 입력하다 보면 자동으로 코드를 추천해줄텐데, 실수로 이를 꺼버리는 일이 발생합니다.\n이 경우 코드를 지웠다가 다시 치는 것 보단, `Option(Alt) + Space`로 다시 활성화 시키는 것이 더 유용합니다.\n\n### st + (intellisense)\n\n![230913-230035](/posts/001_installation/230913-230035.png)\n\n플러터의 위젯의 대부분은 Stateful, Stateless 위젯을 상속 받습니다.\n그에 따라 여러 메서드를 override해서 사용해야만 하는데요,\n이 모든 코드를 일일이 입력하는 것도, 기억하는 것도 쉽지 않습니다.\n\n이 경우에는 `st`를 입력하고 intellisense 기능을 이용하면 VSCode가 알아서\nStateful, Stateless 위젯의 필수 부분을 알아서 완성해주고,\n클래스 이름과 관련한 부분 모두를 선택한 상태로 사용자의 입력을 기다리게 됩니다.\n\n따라서 사용자는 아래의 절차를 밟으면 간단하게 위젯 하나를 생성할 수 있게 됩니다.\n\n1. st + (intellisense)\n2. 원하는 부모위젯(Stateful, Stateless) 선택\n3. 원하는 클래스 이름 입력\n\n## 마무리\n\n지금까지 Flutter SDK 설치부터 VSCode 단축키까지 개발에 앞서 필요한 모든 준비단계를 알아봤습니다.\n추가로 필요한 설정이나 기능은 알아보시고 추가하여 사용하신다면, 개발이 조금이라도 더 즐거워지리라 생각됩니다.\n\n긴 글 읽어주셔서 감사드리고, 모두 알찬 `Flutt-er` 생활 되시길 바랍니다!\n","slug":"flutter/001_installation","readingMinutes":14,"wordCount":1023},{"title":"상태공간 \u0026 탐색","description":"상태공간과 탐색의 의미와 예시를 알아봅니다.","icon":"","image":"","tags":[],"draft":false,"date":"2023-09-12 / 15:09","content":"\n## 상태공간\n\n문제 해결 과정에서 초기 상태로부터 도달할 수 있는 모든 상태들의 집합을 의미한다.\n한 마디로 `문제의 해가 될 가능성`이 있는 모든 상태들의 집합을 의미한다.\n\n## 탐색\n\n상태공간에서 최적의 해를 찾기위해 공간을 체계적으로 찾아보는 것을 의미한다.\n탐색은 아래와 같은 방식으로 크게 구분지을 수 있다.\n\n1. 맹목적 탐색\n2. 정보이용 탐색\n\n이렇게 구분짓는 이유는 탐색의 방식에 따라 달라지는데,\n탐색 방식이 다양해 질 수 밖에 없는 이유는 일반적인 문제에서는 상태공간이 매우 크기 때문에\n미리 공간 그래프를 그릴 수 없어 탐색 과정에서 그래프를 생성할 수 밖에 없기 때문이다.\n\n---\n\n## 맹목적 탐색\n\n정해진 순서에 따라 상태공간 그래프를 점차 생성해 가면서 해를 탐색하는 방법을 의미한다.\n\n### 깊이 우선 탐색 (Depth-first search)\n","slug":"univ_ai/mid_01","readingMinutes":2,"wordCount":109},{"title":"Observer Pattern","description":"Observer 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Observer Pattern","interface"],"draft":false,"date":"2023-09-11 / 10:09","content":"\n## Strategy Pattern\n\n[**저번 포스트**](https://wjlee611.github.io/blog/univ_design-pattern/mid_01)에서 배운 `Strategy 디자인 패턴`을 이용해서 한 가지 예를 살펴보자.\n\n```java:WeatherData.java {7} showLineNumbers\npublic class WeatherData {\n  public void measurementsChanged() {\n    float temp = getTemperature();\n    float humidity = getHumidity();\n    float pressure = getPressure();\n\n     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n    currentConditionsDisplay.update(temp, humidity, pressure);\n    statisticsDisplay.update(temp, humidity, pressure);\n    forecastDisplay.update(temp, humidity, pressure);\n  }\n}\n```\n\n이 코드는 `Display`장치들이 `WeatherData`에서 제공하는 데이터를 이용하려는 코드이다.\n\n예로 들어 `forecastDisplay`에서 날씨 정보를 출력하기 위해서는\n`WeatherData`에서 `forecastDisplay.update()` 메서드를 호출해야\n날씨 정보가 비로소 `forecastDisplay`로 전달되는 것이다.\n\n### 문제점\n\n여기서 문제가 발생한다.\n만약 새로운 장치 futureDisplay를 구현하려면 Strategy Pattern을 사용하는 코드는 아래와 같은 코드수정이 필요해진다.\n\n1. update() 전략을 갖고있는 인터페이스로 구현한 전략(Display) 클래스를 만든다.\n2. `Line 7`에 새로운 장치를 등록한다.\n\n지금 당장은 문제될게 없어 보이지만, 만약 당신이 WeatherData를 `라이브러리화 해서 배포`하는 입장일 경우를 고려해보자.\n`사용자`는 단지 새로운 Display를 추가하여 바로 날씨 정보를 받아오고 싶을 것이다.\n하지만, 위와 같은 코드라면 사용자는 라이브러리 파일을 뜯어서 WeatherData 클래스 내부에\n직접적으로 `새로운 Display를 의존성 주입`을 해줘야만 할 것이다.\n\n이 경우는 꽤나 치명적이다.\n생각해보면 우리가 사용하는 대부분의 라이브러리는 이런 과정을 겪지 않으니 말이다.\n\n따라서 이런 문제를 해결하기 위한 디자인 패턴이 필요하다.\n\n## Observer Pattern\n\nObserver Pattern의 정의는 다음과 같다.\n\n\u003e 객체들이 1:N의 관계를 갖을 때, 한 객체의 상태가 변하면 다른 모든 객체들에 업데이트 통지가 떨어지는 관계로,\n\u003e `객체(Subject)`와 `객체들(Observers)`간의 `종속성이 없는 관계`를 의미한다.\n\n코드로 살펴보며 이해해보자.\n\n### interface\n\n```java:IObserverPattern.java {1-5, 7-9}\npublic interface Subject {\n    public void registerObserver(Observer o);\n    public void removeObserver(Observer o);\n    public void notifyObservers();\n}\n\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\n\npublic interface DisplayElement {\n    public void display();\n}\n```\n\n위 코드는 Observer Pattern에서 사용하는 인터페이스이다.\n`1`의 입장인 클래스(Subject)는 `Subject 인터페이스`를 구현해야 하고,\n`N`의 입장인 클래스(Observers)는 `Observer 인터페이스`를 구현해야 한다.\n\n### Subject class\n\n```diff-java:WeatherData.java {24, 35}\n  public class WeatherData implements Subject {\n+   private ArrayList\u003cObserver\u003e observers;\n\n    public WeatherData() {\n      observers = new ArrayList\u003cObserver\u003e();\n    }\n\n+   @implements\n+   public void registerObserver(Observer o) {\n+     observers.add(o);\n+   }\n+\n+   @implements\n+   public void removeObserver(Observer o) {\n+     int i = observers.indexOf(o);\n+     if (i \u003c 0) return;\n+     observers.remove(i);\n+   }\n+\n+   @implements\n+   public void notifyObservers() {\n+     for (int i=0; i\u003cobservers.length; i++) {\n+       Observer o = observers.get(i);\n+       o.update(temp, humidity, pressure);\n+     }\n+   }\n\n    public void setMeasurements(float temp, float humidity, float pressure) {\n      this.temp = temp;\n      this.humidity = humidity;\n      this.pressure = pressure;\n      measurementsChanged();\n    }\n\n    // 더이상 WeatherData 클래스는 수정할 일이 없어진다.\n    public void measurementsChanged() {\n+     notifyObservers()\n-     float temp = getTemperature();\n-     float humidity = getHumidity();\n-     float pressure = getPressure();\n-\n-     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n-     currentConditionsDisplay.update(temp, humidity, pressure);\n-     statisticsDisplay.update(temp, humidity, pressure);\n-     forecastDisplay.update(temp, humidity, pressure);\n    }\n  }\n```\n\nSubject class의 역할은 Observer의 `구독과 해지`하는 역할을 담당하고,\n구독된 Observers에게 `본인의 변경사항을 알려`주는 역할을 한다.\n\n본인의 변경사항을 알려주기 위해 `Observer는 update 전략`을 포함하고 있어야 한다.\n\n이제 Subject 클래스는 `구독된 Observer를 배열로 관리`하고, `관리되고 있는 Observer를 대상`으로 `변경사항을 emit(update)`하기 때문에\n**더이상 Subject 클래스를 수정할 필요가 없어진다.**\n\n### Observer class\n\n```java:FutureDisplay.java {6-8}\npublic class FutureDisplay implements Observer, DisplayElement {\n  private Subject weatherData;\n\n  public FutureDisplay(Subject weatherData) {\n    this.weatherData = weatherData;\n    // Observer가 Subject를 구독한다.\n    // 비로소 Subject가 update를 쏴줄 수 있다.\n    weatherData .registerObserver(this);\n  }\n\n  public void update(float temp, float humidity, float pressure) {\n    this.temp = temp;\n    this.humidity = humidity;\n    this.pressure = pressure;\n    display();\n  }\n\n  @implements\n  public void display() {\n    // ...\n  }\n}\n```\n\nObserver는 생성시 자동으로 `Subject를 구독`하게 되고,\n구독했기에 Subject의 상태 변경시 자동으로 Observer를 업데이트 할 수 있다.\n_Subject의 observers 배열에 추가되어 관리됨_\n\n\u003e 여기서 눈여겨 봐야 할 점은 `Observer의 update` 전략 메서드는 `Subject`에서,\n\u003e `Subject의 register, remove` 전략 메서드는 `Observer`에서 호출된다는 점이다.\n\u003e 서로 `크로스`되어 메서드를 호출한다는 점을 주목하자.\n\n### main (사용자 입장)\n\n```diff-java:WeatherStation.java {5-6}\n  public class WeatherStation {\n    public static void main(String[] args) {\n      WeatherData weatherData = new WeatherData();\n\n      // another displays\n+     FutureDisplay futureDisplay = new FutureDisplay(weatherData);\n\n      weatherData.setMeasurements(80, 65, 30.4f);\n      weatherData.setMeasurements(82, 70, 29.2f);\n      weatherData.setMeasurements(78, 90, 29.3f);\n    }\n  }\n```\n\n사용자 입장에서는 새로운 Display객체 생성시 WeatherData를 의존성 주입만 해주면,\n그 뒤의 모든 과정은 Observer Pattern에 의해 자동으로 업데이트가 가능해진다.\n\n## 결론\n\n`의존성이 없어`야 하지만 `여러 클래스와 관계`를 가져야하고,\n동시에 `코드가 수정되는 일이 적어`야만 하는 클래스는\nObserver Pattern을 그 클리스와 관계를 갖는 여러 클래스에 적용하는 것이 좋다.\n","slug":"univ_design-pattern/mid_02","readingMinutes":7,"wordCount":693},{"title":"Strategy Pattern","description":"Strategy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Strategy Pattern","extends","implements"],"draft":false,"date":"2023-09-11 / 09:09","content":"\n## 상속\n\n### extends\n\n오리 시뮬레이터를 만든다고 가정해보자.\n그렇다면 일단 오리 객체를 만들어야 할 것이다.\n\n```java:Duck.java {5}\nclass Duck() {\n  quack() {};\n  swim() {};\n  fly() {};\n  display() {};\n  // other duck-like methods\n}\n```\n\n그리고 여러 종류의 오리는 이 `Duck` 클래스를 상속받아서 사용하면 될 것이다.\n\n```java:Ducks.java {2-3, 7-8}\nclass MallardDuck extends Duck {\n  @override\n  display() {};\n}\n\nclass RedheadDuck extends Duck {\n  @override\n  display() {};\n}\n```\n\n물론 생김새는 다르기에 일부 메서드는 `override`해서 사용해야 할 것이다.\n이 때 자식 클래스와 부모 클래스는 `is a` 관계를 갖는다고 말한다.\n_e.g. MallardDuck is a Duck_\n\n### implements (interface)\n\n이제 고무 오리를 만들어보자.\n\n```java:Ducks.java {4-7}\nclass RubberDuck extends Duck {\n  @override\n  display() {}\n  @override\n  quack() {}\n  @override\n  fly() {}\n}\n```\n\n고무 오리는 `꽥` 소리를 내지 않고 `삑`소리를 내기 때문에 `quack()` 메서드 역시 override 해야한다.\n또한, 날지도 않기에 `fly()` 메서드 역시 override 해야한다.\n\nDecoyDuck을 또 만든다면?\n이 역시 quack, fly 메서드를 override 해야한다.\n\n이렇게 모든 Duck들이 공유하지 않는 속성은 매번 override 해야하는 문제점이 있다.\n\n이 때, `interface`를 사용하면 이 문제를 해결할 수 있다.\n\n```diff-java:DucksWithInterfece.java {12, 18}\n  class Duck() {\n    swim() {};\n    display() {};\n  }\n+ interface Flyable() {\n+   fly();\n+ }\n+ interface Quackable() {\n+   quack();\n+ }\n\n  class MallardDuck extends Duck implements Flyable, Quackable {\n+   fly() {};\n+   quack() {};\n    @override\n    display() {};\n  }\n  class RubberDuck extends Duck implements Quackable {\n+   quack() {};\n    @override\n    display() {};\n  }\n```\n\n이렇게 변할 수 있는 부분은 interface로 띄어내면 쓸데없이 메서드를 override할 일이 줄어든다.\n이 때 구현 클래스와 인터페이스는 `has a` 관계를 갖는다고 한다.\n_e.g. RubberDuck has a Quackable_\n\n_참고:_\n_class, interfece의 차이는 사실 거의 없다._\n\n### interface 다형성\n\n하지만 위 방식 역시 문제가 존재한다.\nMallardDuck, RedheadDuck 두 오리 모두 같은 quack 메서드로 동작해야 하지만,\n이를 implements 하는 과정에서 두 메서드를 중복해서 구현해야 한다는 문제점이 발생한다.\n\n이를 해결하기 위해서는 인터페이스의 다형성의 원리를 이용하는게 좋다.\n\n```diff-java:DucksWithPolymorphism.java {18, 20-24}\n  interface QuackBehavior {\n    quack();\n  }\n+ class Quack implements QuackBehavior {\n    @override\n    quack() {'꽥'};\n  }\n+ class Squack implements QuackBehavior {\n    @override\n    quack() {'삑'};\n  }\n+ class MuteQuack implements QuackBehavior {\n    @override\n    quack() {};\n  }\n\n  class Duck {\n    QuackBehavior quackBehavior;\n\n    performQuack() {\n      // delegate to the behavior class\n      // 한 마디로 짬때리기...\n      quackBehavior.quack();\n    }\n    // ...\n  }\n\n  class MallardDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Quack 객체를 지정할 수 있다.\n+     quackBehavior = new Quack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(꽥)를 사용할 수 있음.\n    // ...\n  }\n  class RubberDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Squack 객체를 지정할 수 있다.\n+     quackBehavior = new Squack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(삑)를 사용할 수 있음.\n    // ...\n  }\n```\n\n이렇게 하면 필요한 부분에만 기능을 추가할 수 있고, 코드의 재사용성도 올라간다.\n뿐만 아니라 새로운 기능 (예로 들어 새로운 울음 소리)의 추가도 쉬워진다.\n\n## Strategy Pattern\n\n위에서 알아본 적절한 상속관계를 준수한 패턴을 `Strategy Pattern` 라고 한다.\n정확한 정의는 다음과 같다.\n\n\u003e 객체들이 할 수 있는 행위 각각에 대해 `전략 클래스 (Quack, Squack)`를 생성하고,\n\u003e `유사한 행위들을 캡슐화` 하는 `인터페이스 (QuackBehavior)`를 정의하여,\n\u003e 객체의 행위를 동적으로 바꾸고 싶은 경우 `직접 행위를 수정하지 않고 (performQuack())`\n\u003e 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.\n\n간단히 말해서 객체가 할 수 있는 행위들을 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것만으로 행위의 수정이 가능하도록 만든 패턴이다.\n\n## 결론\n\n`has a (구현)`관계가 `is a (상속)`관계보다 낫다.\n\n상속은 뭘 상속해야 하는지 일일이 파악해야 하는 귀찮음이 있기 때문이다.\n하지만, 구현은 필요한 기능만 가져다 쓰면 되기에 사용및 개발적 측면에서 좋고,\n새로운 기능은 인터페이스를 추가로 구현하면 끝이기에 유지보수 측면에서도 좋다.\n\n따라서 단순히 상속을 이용한 객체지향 프로그래밍 보단,\n전략 패턴을 적용한 코딩 습관을 기르도록 하자.\n","slug":"univ_design-pattern/mid_01","readingMinutes":6,"wordCount":594},{"title":"분산 파일관리 시스템","description":"분산 파일관리 시스템에 관련한 기초 지식을 배웁니다.","icon":"","image":"","tags":[],"draft":false,"date":"2023-09-06 / 12:09","content":"\n## header 2\n\nasd\n","slug":"univ-mmds/230906","readingMinutes":1,"wordCount":6}]},"__N_SSG":true},"page":"/blog/posts","query":{},"buildId":"1HfKky-wT2nKQVLmy4XOF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>