<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>웅덩이</title><link rel="canonical" href="https://wjlee611.github.io/blog/posts"/><meta name="next-head-count" content="4"/><link rel="icon" href="/images/icon_circle.png"/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" rel="stylesheet"/><meta name="description" content="웅덩이"/><meta name="apple-mobile-web-app-title" content="웅덩이"/><meta name="application-name" content="웅덩이"/><meta name="theme-color" content="#009c39"/><meta name="google-site-verification" content="vhQ9DaDdUJcSBHKI_U6tAtE61zwz2i2pLQXyZ62GRLk"/><meta name="naver-site-verification" content="07764cc1a8eda55b4bdf78cf846d6811d042b9ee"/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/b454a7b610da9638.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b454a7b610da9638.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-401a9806b070f31a.js" defer=""></script><script src="/_next/static/chunks/main-6b74302918225334.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c8492b7109a908de.js" defer=""></script><script src="/_next/static/chunks/pages/blog/posts-c7ce4e4b0ccc937b.js" defer=""></script><script src="/_next/static/IJm44Ue2CpfgF7XV88rGl/_buildManifest.js" defer=""></script><script src="/_next/static/IJm44Ue2CpfgF7XV88rGl/_ssgManifest.js" defer=""></script></head><body class="text-primary transition-[background] bg-white dark:bg-[#1A1C23]"><script>
            const theme = localStorage.getItem("theme");
            const getUserTheme = () => {
             if(theme){
              return theme
             } 
             return window.matchMedia('(prefers-color-scheme: dark)').matches
             ? 'dark'
             : 'light'
          }
          document.body.dataset.theme = getUserTheme();
          </script><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="__className_e3a9ed text-center transition-all "><header class="fixed top-0 left-0 right-0 mx-anuo w-screen h-12 md:h-16 flex justify-between items-center px-2 md:px-10 backdrop-blur bg-blue-200 bg-opacity-20 z-50"><div class="h-full flex items-center"><a class="h-full aspect-square flex justify-center items-center text-3xl select-none cursor-pointer" href="/">🫧</a><nav class="h-full hidden md:flex space-x-8 overflow-hidden ml-10"><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-black dark:text-white " href="/">Portfolio</a></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-blue-500 " href="/blog">Blog</a><div class="hidden md:flex w-full h-[2px] bg-blue-500 absolute bottom-0 left-0 blur-[2px]"></div></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-black dark:text-white " href="/arkhive">Arkhive</a></li></nav></div><div class="flex items-center h-full"><button aria-label="Toggle Dark Mode" type="button" class="flex h-9 w-9 items-center justify-center rounded-lg transition-all text-secondary hover:bg-secondary "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="h-6 w-6 text-yellow-400 drop-shadow-base"></svg></button><button class="flex md:hidden items-center justify-center w-16 h-full text-2xl text-black dark:text-white"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.5 11.5A.5.5 0 0 1 5 11h10a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 1 3h10a.5.5 0 0 1 0 1H1a.5.5 0 0 1-.5-.5z"></path></svg></button></div></header><main class="inline-block w-full relative pt-16 px-8 max-w-5xl 2xl:max-w-7xl" style="opacity:1;transform:none"><div class="flex flex-col mt-8 pb-16"><h3 class="mt-10 mb-5 text-xl bg-gradient-to-r from-blue-700 to-blue-400 bg-clip-text font-bold text-transparent">// 전체 포스트</h3><ul class="flex flex-col items-center space-y-3"><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/mid_06"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Filtering in the Frequency Domain</h4><span>주파수 도메인에서의 필터링에 대해 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-18 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/mid_05"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Filtering and Convolution</h4><span>Filtering 과 Convolution 의 동작방식과 차이를 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-17 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/mid_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Color Image</h4><span>색상과 관련된 용어와 변환을 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-16 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/mid_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Intensity Transformations</h4><span>이미지 밝기 변환에 대한 내용을 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-16 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/mid_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Singal Processing Fundamentals</h4><span>신호 처리에 대한 기초적인 정보입니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-15 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/mid_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Digital Image Fundamentals</h4><span>디지털 이미지에 대한 기초적인 정보입니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-15 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_06"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Adapter &amp; Facade Pattern</h4><span>Adapter 그리고 Facade 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-11 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_05"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Command Pattern</h4><span>Command 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-10 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Singleton Pattern</h4><span>Singleton 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-08 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Decorator Pattern</h4><span>Decorator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-08 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/005_dart_expert"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Dart 언어 마스터</h4><span>Dart 언어에 대한 보다 심화된 내용을 정리해봤습니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-25 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/004_dart_advanced"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Dart 언어 심화</h4><span>Dart 언어에 대한 심화된 내용을 정리해봤습니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-15 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/003_dart_basic"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Dart 언어 기초</h4><span>Dart 언어에 대한 기초지식을 정리해봤습니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-14 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/002_project_initalize"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">플러터 프로젝트 만들기</h4><span>플러터 프로젝트 생성 가이드 입니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-14 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/001_installation"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">플러터 시작하기</h4><span>플러터 설치 및 VSCode 세팅 가이드입니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-13 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Observer Pattern</h4><span>Observer 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-11 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Strategy Pattern</h4><span>Strategy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-11 </span></a></ul></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Filtering in the Frequency Domain","description":"주파수 도메인에서의 필터링에 대해 다뤄봅니다.","icon":"","image":"","tags":["Fourier Transform","Frequency Domain","Highpass","Lowpass"],"draft":false,"date":"2023-10-18 / 21:11","content":"\n## Fourier Transform\n\n푸리에 변환을 간단하게 말하면 시간, 공간 도메인의 주기를 갖는 사인파의 합을 주파수 도메인의 함수로의 변환을 말한다.\n\n\u003ctip\u003e\n  `도메인 간의 관계`\n  \u003cbr /\u003e\n  ![231018-211849](/posts/mid_06/231018-211849.png)\n  \u003cbr /\u003e\n  시간 도메인이 길다는 의미는 주파수가 낮다는 뜻이다.\n  따라서 푸리에 변환시 저주파수 영역에서 값이 크게 나타난다.\n  반대의 경우도 마찬가지.\n  \u003cbr /\u003e\n  [**`전에 헷갈렸던 내용`**](https://wjlee611.github.io/blog/univ_com-vision/mid_02#sampling)으로 다시 돌아가서 보면 이해될 것.\n\u003c/tip\u003e\n\n### Property\n\n이제 영상을 푸리에 변환을 통해 주파수 도메인으로 변화를 시킬건데, 그 결과물을 분석하는 법을 알아보자.\n\n![231018-212424](/posts/mid_06/231018-212424.png)\n\nDC, 즉, 원점에 가까워 질 수록 주파수가 낮은 영역, 멀 수록 주파수가 높은 영역을 나타내는데,\n영상에서의 주파수는 변화율이라고 보면 된다.\n즉, 주파수가 크다 라는 의미는 영상이 변화하는 부분이 많다는 뜻이다.\n\n![231018-213206](/posts/mid_06/231018-213206.png)\n\n이 변환결과를 보고 이해해보자.\n\n우선 주파수 데이터를 보면 먼 곳이 어둡다.\n즉 영상 전체적으로 확확 변하는 부분이 적다는 뜻이다.\n\n그런데 X 모양으로는 밝은 것을 볼 수 있다.\n이 뜻은 해당 방향과 수직한 방향으로 변화가 많다는 것을 의미한다.\n실제로 원본 영상을 보면 같은 방향으로 홈도 파져있고, 변화가 많은 모습을 확인할 수 있다.\n\n그리고 미세하게 세로 방향으로 점선과 같은 무늬가 있다.\n이는 원본 영상에서 가로 방향으로 긴 무언가가 변화가 큼을 의미한다.\n실제로 원본 영상에는 가로로 흰 실같은 무언가가 있다.\n\n마지막으로 주파스 데이터 전체적으로 노이즈가 있다.\n이는 원본 영상에서도 노이즈가 있다는 뜻이다.\n\n---\n\n## Frequency Domain Filtering\n\n이제 푸리에 변환을 이용해서 주파수 도메인으로 변환된 영상을 이용한 필터링을 해보자.\n\n이 것이 가능한 이유는 LTI System 이기에 가능한 것이다.\nLTI System과 푸리에 변환을 이용한 연산의 단순화에 대한 내용은 [**`여기`**](https://wjlee611.github.io/blog/univ_com-vision/mid_02)에서 확인하자.\n\n![231018-214840](/posts/mid_06/231018-214840.png)\n\n앞으로 살펴볼 필터링에 대해 이 영상과 주파수 영상을 사용할 예정이다.\n여기서 주파수 영상의 얇은 흰 원 부분은 무시하자.\n일종의 $D_0$로 반지름을 나타내는 것인데, 원본 영상을 푸리에 변환 할 경우에는 나오지 않는다.\n\n### Ideal Lowpass Filter\n\n![231018-214145](/posts/mid_06/231018-214145.png)\n\n원본 영상을 푸리에 변환을 하고, 그 주파수 영상에 대해 위 사진의 흰색 영역만 살리고 나머지는 검게 만든 후 다시 역 푸리에 변환을 해볼 것이다.\n이 때, 위의 흰색 영역을 보면 낮은 주파수 영역만을 통과시킴을 알 수 있다.\n즉, 고주파수 영역, 변화량이 많은 영역을 없앤다는 뜻인데, 변화량이 많은 영역을 없앤다?\n즉, 영상을 뿌옇게 만들어 변화량이 적어지도록 하겠다는 의미이다.\n\n정리하면 Lowpass filter를 통과시키면 영상 전반적으로 Smoothing filter처리를 한 결과를 얻을 수 있다.\n\n해당 주파수 필터는 다음과 같이 정의할 수 있는데,\n\n$$\nH(u,v) = \\left\\{\\begin{matrix}\n1 \\;\\; if \\;\\; D(u,v) \\leq D_0 \\\\\n0 \\;\\; if \\;\\; D(u,v) \u003e D_0 \n\\end{matrix}\\right.\n$$\n\n이렇게 이상적으로 0과 1이 나뉘는 필터를 Ideal Lowpass filter라고 부른다.\n\n![231018-215052](/posts/mid_06/231018-215052.png)\n\n상단부터 지그재그 모양으로 $D_0$가 5, 15, 30, 80, 230 값으로 통과시키는 주파수 대역을 점점 늘린 변환 결과이다.\n\n$D_0$ = 5, 즉 매우 낮은 주파수를 갖는 대역만 통과시킨 영상은 영상이 매우 Smoothing 처리된 것을 확인할 수 있다.\n이게 무슨 의미냐면 그정도의 낮은 변화율로는 원본 영상의 가파른 변화를 표현하지 못하고,\n변환된 영상 정도의 완만한 변화율만 표현 가능하다는 뜻이다.\n\n따라서 $D_0$의 값을 키울수록 높은 변화도 표현 가능해져 점점 영상이 선명해지는 것을 볼 수 있다.\n다르게 말하면 **$D_0$ 값이 클수록 필터링 강도가 약해진다**.\n\n이때 주의깊게 볼 점은 변환된 영상에서 뭔가 일렁이는 듯한 노이즈가 생겼다는 점이다.\n왜 이런게 생긴걸까?\n\n바로 Ideal filter 특성 때문에 고주파수 영역을 깔끔하게 날려버렸기 때문에 세밀한 변화를 묘사하지 못해 화질이 떨어진 것이다.\n이를 개선할 수 없을까?\n\n### Butterworth Lowpass Filter\n\n\\'가능.\\' 당연히 개선할 수 있다.\n주파수 영역을 필터링할 때 적절하게 고주파수 영역을 통과시킨다면 화질 개선이 가능한데, 그 방법이 Butterworth 방식이다.\n\n![231018-215943](/posts/mid_06/231018-215943.png)\n\n약간의 곡률을 추가함으로서 일부 고주파수 영역을 통과시킨다.\n이 그래프를 구현하는 식은 다음과 같이 생겼다.\n\n$$\nH(u,v) = \\frac{1}{1+[D(u,v) / D_0]^{2n}}\n$$\n\n실제로 개선이 되었을까?\n\n![231018-220523](/posts/mid_06/231018-220523.png)\n\nSmoothing 효과는 살짝 약해졌지만, 확실이 울렁이는 듯한 노이즈는 제거되었다.\n약간의 화질 개선이 이루어 진 것이다.\n\n### Gaussian Lowpass Filter\n\n![231018-220657](/posts/mid_06/231018-220657.png)\n\n$$\nH(u,v) = e^{-D^2(u,v)/2D_0^2}\n$$\n\n위에 두 필터보다 성능이 좋은 가우시안 필터도 있다.\n그런데 Butterworth와 육안으로 구별되는 정도는 아니다.\n\n---\n\n### Highpass Filter\n\nLowpass는 영상을 뿌옇게 만들었는데, 반대로 Highpass는?\n그렇다. 영상을 더 샤프하게 만든다.\n정확하게 말하면 변화가 큰 부분만을 남기기에 Laplacian filter와 유사한 기능을 수행한다.\n\n![231018-221102](/posts/mid_06/231018-221102.png)\n\n위에서 부터 차례대로 Ideal, Butterworth, Gaussian Highpass Filter이다.\n함수를 구하는 방법은 그저 1에서 Lowpass 함수를 빼주면 된다.\n(Butterworth의 경우에는 $D$(분모) 와 $D_0$(분자)의 위치를 변환하면 된다)\n\n![231018-221329](/posts/mid_06/231018-221329.png)\n\nIdeal Highpass의 결과이다.\n역시 $D_0$값을 키울수록 필터의 강도가 약해진다.\n그렇기에 노이즈 역시 줄어든다.\n\n![231018-221426](/posts/mid_06/231018-221426.png)\n\n같은 필터 강도의 결과이다. 왼쪽부터 차례대로 Ideal, Butterworth, Gaussian Highpass이다.\n이번엔 Butterworth와 Gaussian도 육안으로 차이가 난다.\n여기서도 마찬가지로 Gaussian filter가 노이즈가 없고 깔끔하다.","slug":"univ_com-vision/mid_06","readingMinutes":9,"wordCount":672},{"title":"Filtering and Convolution","description":"Filtering 과 Convolution 의 동작방식과 차이를 다뤄봅니다.","icon":"","image":"","tags":["Kernel","Filtering","Convolution"],"draft":false,"date":"2023-10-17 / 21:51","content":"\n## Kernel\n\nFiltering과 Convolution에 적용할 데이터를 Kernel 이라고 부른다.\n즉, 원본 영상에 어떤 커널을 Filtering 혹은 Convolution 하느냐에 따라 다른 출력물이 나오는 것이다.\n\n커널에 적용방식은 뒤에 Filtering과 Convolution에서 다룰 예정이니 참고만 하고 나중에 다시오자.\n\n### Moving Average (Smoothing)\n\n가로, 세로가 N인 배열의 원소가 모두 $1/N^2$ 로 채워진 커널이다.\n이 커널을 적용하면 이미지가 뿌옇게 변하게 된다.\n\n### Laplacian\n\n3$\\times$3 배열에 중심이 -4, 상하좌우가 1, 나머지가 0으로 채워진 커널이다.\n이 커널을 적용하면 이미지 주변부가 강조되고, 중심부는 약화된다.\n\nLaplacian을 적용한 필터를 원본 이미지에서 빼는 방식으로 Sharping Filter를 구현할 수 있다.\n\n### Shift\n\n중심으로부터 n만큼 떨어진 거리에 1, 나머지는 0으로 채우면 Filtering의 경우 해당 방향의 반대 방향으로 영상이 이동한다.\n예로 들어 3$\\times$3 배열 중 가운데 왼쪽만 1, 나머지는 0인 커널로 영상을 Filtering시 영상은 오른쪽으로 1픽셀 Shift된다.\n\n---\n\n## Filtering\n\n![231017-225146](/posts/mid_05/231017-225146.png)\n\n영상의 주변부의 값을 이용해 변형시키는 과정을 필터링이라고 한다.\n필터링 과정은 [**`LTI System`**](https://wjlee611.github.io/blog/univ_com-vision/mid_02#lti-system)에서 이루어진다.\n\n이 필터링은 크게 Correlation Filtering (just Filtering)과 Convolution Filtering (just Convolution)으로 나뉘게 되는데,\n두 방식의 차이를 비교해보며 위에서 소개한 두 커널을 적용하면 이미지가 어떤식으로 바뀌는지 알아보자.\n\n### Filtering (Correlation)\n\n$$\ng(m,n) = f(m,n) * h(m,n) \\\\\n= \\sum_{k=m-a}^{m+a}\\sum_{l=n-a}^{n+a}f[k,l]\\times h[m-k,n-l]\n$$\n\n필터링은 `커널의 변형이 없이` 연산된다.\n\n위 수식을 보면 픽셀별로 주변 $a$만큼의 픽셀의 값을 참고하여 연산이 진행됨을 알 수 있는데, 이를 아래 그림으로 살펴보자.\n이 때 사용한 커널은 위에서 언급한 `Moving Average` 커널이다.\n\n![filtering_gif](/posts/mid_05/moving_average_filtering.gif)\n\n위 영상은 커널사이즈가 3$\\times$3 ($a=1$)인 Moving Average Kernel을 Filtering 한 결과이다.\n전반적으로 화면이 뿌옇게 변하는 영상을 얻을 수 있다.  \n\n### Convolution\n\n$$\ng(m,n) = f(m,n) * h(m,n) \\\\\n= \\sum_{k=m-a}^{m+a}\\sum_{l=n-a}^{n+a}f[k,l]\\times h[n-k,m-l]\n$$\n\n자세히 보면 h의 **m, n**의 위치가 Filtering과 `반대`이다.\n즉, 컨볼루전은 `커널이 대각선 반전`되어 연산된다.\n\n![231018-204207](/posts/mid_05/231018-204207.png)\n\n좌상단은 원본 영상, 우상단은 그 원본 영상에 Laplacian 커널을 Convolution한 결과이다.\n좌상단 영상에서 우상단 영상을 빼면 좌하단과 같이 영상의 윤곽선이 선명해지는 Sharping Filter를 구현할 수 있다.\n그런데 이게 어떻게 가능한걸까?\n\n이걸 가능케 하기 위해선 우선 사람이 빛을 인지할 때 그 민감도를 인지하는 법을 알아야 한다.\n\n![231018-204430](/posts/mid_05/231018-204430.png)\n\n사람이 밝은 빛을 보다가 어두운 빛을 보면은 원색보다 더 어둡게 느끼고,\n어두운 빛을 보다가 밝은 빛을 보면은 원색보다 더 밝게 느끼는 현상이 발생하는데, 이를 이용하는 것이다.\n\n구현할 때 빛의 밝기 `변화`에 초점을 맞춰보자.\n변화, 즉, 미분을 이용하는 것이다.\n\n\u003e 밝아진다 \u0026rarr; 기울기가 양의 기울기 \u0026rarr; 기울기가 증가함\n\n그림으로 살펴보자.\n\n![231018-204831](/posts/mid_05/231018-204831.png)\n\n밝기가 감소하기 시작하는 부분의 밝기는 높여주고, 감소가 끝나는 부분의 밝기는 높여주면 선명해지는 효과가 있다.\n그런데 2번 미분한 값을 보자.\n우리가 원하는 변화량과 정확히 반대의 값을 갖는다.\n\n즉, `2차 미분값을 원본 영상에서 빼주면`, 우리가 원하는 Sharping Filter를 구현할 수 있다.\n\n그런데 영상처리에서 미분계산이 너무 코스트가 크지 않을까 걱정이 된다.\n\n$$\nf'(x) = \\frac{df}{dx} = \\frac{f(x + \\Delta x) - f(x)}{x + \\Delta x - x}\n$$\n\n하지만, 실제로 그렇지 않다.\n디지털에서 영상 처리를 할 때는 Quantization를 했기 때문에 $\\Delta x$의 매우 작은 값은 1이 된다.\n따라서 다음과 같은 식으로 정리된다.\n\n$$\n\\frac{df}{dx} = f(x + 1) - f(x) \\\\\n{} \\\\\n\\frac{d^2f}{dx^2} = f(x + 1) - 2f(x) + f(x - 1) \n$$\n\n이 값은 사실 각각 `h[0, -1, 1]` / `h[1, -2, 1]`의 컨볼루전과 같다.\n따라서 1차원 영상의 경우에는 영상에 `h[1, -2, 1]` 커널을 컨볼루전 하면 된다.\n\n2차원은 위 방식을 편미분을 사용하여 비슷한 방식으로 진행하면 된다.\n`x에 대한 편미분` + `y에 대한 편미분` 값을 더하면 다음과 같은 3 $\\times$ 3 배열이 나오는데, 이 배열을 컨볼루전하면 원하는 Laplacian Filter를 구현할 수 있다.\n\n![231018-210553](/posts/mid_05/231018-210553.png)\n\n## Boundary (Edge)\n\nFiltering 부분에서 gif영상으로 봤을 때 가장자리는 데이터를 채워주지 못했다.\n그 이유는 커널 중심을 가장자리 영역으로 잡았을 때, 영상 외부의 값을 참조해야 값을 계산해야 하기 때문이다.\n\n이런 부분에 대한 해결책으로 간단하게 3가지만 알아보자.\n\n![231018-210916](/posts/mid_05/231018-210916.png)\n\n`zero padding` 방식은 없는 영상 영역을 0으로 채우고 하는 간단한 기법이다.\n\n`boundary value repetition`은 최외각 픽셀의 데이터를 반복하여 채우는 간단한 기법이다.\n\n`mirroring`은 마치 거울이 있는것 처럼 픽셀값을 반사하여 채우는 기법이다.","slug":"univ_com-vision/mid_05","readingMinutes":8,"wordCount":594},{"title":"Color Image","description":"색상과 관련된 용어와 변환을 다뤄봅니다.","icon":"","image":"","tags":["RGB","HSI"],"draft":false,"date":"2023-10-16 / 23:05","content":"\n## Color\n\n![231017-141752](/posts/mid_04/231017-141752.png)\n\n하얀색 빛은 RGB 색상의 빛을 모두 합칠 때 나타난다는 건 많이들 알고있을 것이다.\n하지만, 빛의 삼원색과 색상의 합을 두고는 의문이 든다.\n왜 마젠타와 노란색을 섞으면 밝아지는 것이 아닌 어두워지는 걸까.. 하고.\n\n색상이 보인다 라는 것은 사물이 `해당 색상의 빛을 반사`하고 `나머지 색상의 빛을 흡수`하기 때문이다.\n마젠타는 RB의 빛의 혼합이다. 즉 Green 색을 흡수한다는 뜻이다.\n노랑은 RG의 빛의 혼합이다. 즉 Blue 색을 흡수한다는 뜻이다.\n따라서 마젠타와 노랑을 섞은 색은 Green, Blue 색을 흡수한다는 뜻이니 R만 반사할 것이다.\n그렇기에 밝아지는게 아닌 어두워져서 Red 색상을 띄게 되는 것이다.\n\n### RGB Model\n\n![231017-142916](/posts/mid_04/231017-142916.png)\n\nRGB 모델은 아주 익숙한 색상 모델이다.\n빛의 삼원색인 Red, Green, Blue 색상의 빛의 밝기로 색상을 표현한다.\n\n### HSI Model\n\n![231017-143217](/posts/mid_04/231017-143217.png)\n\nHSI 모델은 생소하지만, 활용성이 뛰어난 색상 모델이다.\nHue, Saturation, Intensity의 3요소로 색상을 표현한다.\n\n`Hue`는 색상을 표현하는 각도로 `색조` 라고도 부른다.\n0$\\degree$는 Red, 180$\\degree$는 Cyan 등 각도 하나만으로 모든 색상을 나타내게 된다.\n\n`Saturation`은 색상의 포함 정도로 `채도` 라고도 부른다.\nSaturation값이 클수록 색상을 많이 함유하고 있다는 뜻이다.\n따라서 Saturation이 0이 되면 색상이 존재하지 않는, Gray 색상이 되어버린다.\n\n`Intensity`는 빛의 세기를 표현하는 정도로 `강도` 라도도 부른다.\nIntensity값이 클수록 빛이 강하다는 뜻이니 흰색에 가까워진다.\n\n### RGB vs HSI\n\n두 모델간의 가장 큰 차이라면 '빛의 밝기가 색상에 영향을 주는 가' 이다.\n\nRGB는 각 채널을 같은 비율로 늘리고 줄이는 방식으로 빛의 밝기를 조절한다.\n따라서 빛의 밝기가 변하면 다른 색상이라고 취급된다.\n\n하지만 HSI는 빛의 밝기를 I채널에서 관리한다.\n따라서 빛의 밝기가 변해도 같은 색상으로 취급된다. (정확히는 H, S값이 변하지 않는다)\n\n두 모델간 차이를 확인하기 위한 이미지이니 참고하자.\n\n![231017-211125](/posts/mid_04/231017-211125.png)\n\n---\n\n## Pseudocolor Image Processing\n\n흑백 데이터를 사람이 보기 쉽게 컬러로 대응시키는 과정을 의미한다.\n\n### Intensity Slicing\n\n![231017-211341](/posts/mid_04/231017-211341.png)\n\nIntensity 값을 기준으로 다르게 색상일 입히는 방식이다.\nSlicing plane을 여러개 두면 여러 색상으로 여러 범위의 색상을 입힐 수도 있다.\n\n![231017-211515](/posts/mid_04/231017-211515.png)\n\n---\n\n## Color Transformations\n\n기본적으로 앞서 배웠던 영상 변환과 같은 공식을 사용해서 변환한다.\n\n$$\ng(x,y) = T[f(x,y)]\n$$\n\n하지만 수식적인 부분은 뒤로 미뤄두고 어떤 채널을 어떻게 변화하면 영상이 어떻게 변화하는지를 중점적으로 알아보자.\n\n### Intensity\n\n![231017-212214](/posts/mid_04/231017-212214.png)\n\n위 영상은 Intensity만 30% 줄인 영상이다.\n\n![231017-212235](/posts/mid_04/231017-212235.png)\n\n그 결과 RGB 모델은 모든 채널이 30% 감소했지만,\nHSI 모델은 I 채널만 30% 감소한 모습을 볼 수 있다.\n\n### Color Complements\n\n![231017-212435](/posts/mid_04/231017-212435.png)\n\n위 영상은 보색으로 색상을 반전시킨 영상이다.\n그 결과 RGB 모델은 각 색상 채널이 상하반전된 모습을 취하게 되었다.\n\nHSI 모델은 색상이 반전되었기에,\nHue는 180$\\degree$만큼 shift된 모습의 그래프를 보이게 되었고, Intensity 역시 반전되었다.\n하지만, S는 역시 변화가 없다.\n\n---\n\n## Tone and Color Correction\n\n이번엔 색상과 밝기 등을 수정하면서 어떻게 하면 영상을 보기좋게 만들 수 있는지 알아보자.\n\n![231017-214520](/posts/mid_04/231017-214520.png)\n\nRGB 채널에 ease 커브를 줄 경우 어두운 부분은 더 어둡게, 밝은 부분은 더 밝게 만들 수 있다.\n하지만 역시 밝기만 건드렸기 때문에 H, S값의 변화는 없다.\n\n![231017-214624](/posts/mid_04/231017-214624.png)\n\n전체적으로 너무 밝은 영상의 경우에는 곡률을 아래로 주게 될 경우\n영상 톤을 전체적으로 어둡게 바꿀 수 있다.\n\n![231017-214711](/posts/mid_04/231017-214711.png)\n\n반대의 경우도 가능하다.\n\n![231017-215001](/posts/mid_04/231017-215001.png)\n\n색상별로 톤 변화를 줄 수 있다.\n이 경우 색상도 바뀐다.\n\n본인 기준 특이하다고 생각되었던건 특정 색상을 어둡게 커브를 줬더니 영상에서는 오히려 해당 색이 많이 보이도록 조정되었다는 점이 인상적이었다.\n\n---\n\n## Color Slicing\n\n특정 색상영역을 추출하는 기법이다.\n예로들어 피부색을 추출하고 싶다면, 피부색과 오차범위에 해당하는 색상만을 선택하여 남기는 작업을 수행하게 된다.\n\n특정 영역을 선별하는 공식은 아래 2가지 방법이 있다.\n\n$$\ns_i = \\left\\{\\begin{matrix}\n0.5 \\;\\; if[|r_j-a_j| \u003e \\frac{W}{2}]_{any \\; 1 \\leq j \\leq n} \\\\\nr_i \\;\\; otherwise\n\\end{matrix}\\right.\n$$\n\nRGB 3채널을 기준으로($n=3$) 픽셀의 색상($r_j$)과 기준값($a_j$)의 차이가 오차범위($W/2$)보다 크면 0.5로 세팅하고,\n오차범위 내부, 즉, 추출하고자 하는 색상 영역이면 원색상을 유지한다.\n\n이 때, 허용범위는 RGB 스페이스에서 `정육면체` 모양으로 구성되게 된다.\n따라서 실제 원했던 색상영역보다 약간 더(꼭짓점 부분) 색상을 포함할 수 있다.\n\n\u003cbr /\u003e\n\n$$\ns_i = \\left\\{\\begin{matrix}\n0.5 \\;\\; if\\sum_{j=1}^{n}(r_j-a_j)^2 \u003e R_0^2, \\\\\nr_i \\;\\; otherwise\n\\end{matrix}\\right.\n$$\n\nRGB 3채널을 기준으로($n=3$) 픽셀의 색상($r_j$)과 기준값($a_j$)의 차이가 오차범위($R_0$)보다 크면 0.5로 세팅하고,\n오차범위 내부, 즉, 추출하고자 하는 색상 영역이면 원색상을 유지한다.\n\n이 때, 허용범위는 RGB 스페이스에서 `구` 모양으로 구성되게 된다.\n따라서 실제 원했던 색상영역을 정확하게 표현할 수 있다.\n\n![231017-214142](/posts/mid_04/231017-214142.png)\n\n왼쪽은 첫번째 방법으로, 오른쪽은 두번째 방법으로 Slicing한 영상이다.\n더 나아보이는 방식으로 취사선택하면 될 거 같다.","slug":"univ_com-vision/mid_04","readingMinutes":9,"wordCount":638},{"title":"Intensity Transformations","description":"이미지 밝기 변환에 대한 내용을 다뤄봅니다.","icon":"","image":"","tags":["Transform Function","Histogram","Equalization"],"draft":false,"date":"2023-10-16 / 21:09","content":"\n## Transform Functions\n\n입력 영상에 대해 밝기값(에너지 레벨)의 변화를 가하고 싶다면 단순히 픽셀값의 데이터에 변화를 가하면 된다.\n\n$$\ns = T(r)\n$$\n\n하지만, 특정 데이터를 어떻게 변화시키는지에 따라 출력 영상이 달라지고, 거기에서 얻을 수 있는 정보도 달라진다.\n그 데이터를 변화시키는 기준인 변환 함수의 종류와, 그 결과를 알아보자.\n\n\u003cnotice\u003e\n  얻을 수 있는 정보가 달라진다는 표현을 사용했는데,\n  **강조**하고싶은 정보가 달라진다는 것이지 **실제** 정보량 자체는 변하지 않는다.\n  물론 임의로 특정 밝기 영역을 0으로 만든다면 정보량이 줄어들 수는 있다.\n  하지만 **물리적인 정보량은 절대 늘어나지 않는다**. (사람 눈에 보기 편하게 바꿀 뿐)\n\u003c/notice\u003e\n\n### Basic\n\n![231016-212632](/posts/mid_03/231016-212632.png)\n\n이제부터 그래프를 해석하는 능력이 중요해진다.\n예로 들어 `Log` 함수를 변환 함수로 선택한다면 `전반적으로 영상이 밝아짐`을 알 수 있어야 한다.\n$y=-x$ 형태의 `Negative` 함수를 선택한다면 영상 명암이 아래와같이 `반전`될 것이다.\n\n![231016-213010](/posts/mid_03/231016-213010.png)\n\n### Power-Law (Gamma)\n\n위의 기본 함수로는 세부적으로 변화시키기 힘들것이다.\n하지만 아래의 함수를 이용하면 상수값($\\gamma$)를 변화시켜 변환을 세부적으로 처리할 수 있게된다.\n\n$$\ns = cr^\\gamma\n$$\n\n감마값이 커질수록 변환된 영상이 어두워지는 특징이 있다.\n\n![231016-213224](/posts/mid_03/231016-213224.png)\n\n감마 함수는 Gamma correction에 자주 사용되곤 하는데,\n이게 뭐냐면, 출력 장치의 빛의 세기를 조정해 원본 영상과 같은 영상을 디스플레이 할 수 있도록 하는 과정이다.\n\n![231016-213529](/posts/mid_03/231016-213529.png)\n\n### Piecewise-Linear\n\n선형 커브를 여러 범위로 쪼갠 함수로\n특정 범위의 값을 확장하거나, 임의의 값으로 변경할 때 사용한다.\n\n![231016-214238](/posts/mid_03/231016-214238.png)\n\n함수가 좌상단과 같이 주어질 경우 우상단의 이미지가 좌하단의 이미지처럼 변환된다.\n특정 범위의 값을 확장시켜 비슷한 레벨의 빛을 분산시켜 차이를 만든 것이다.\n\n$\\overline{(r_1,s_1)(r_2,s_2)}$의 기울기를 수직으로 만들면 `Threshold` 함수라고 불리우게 되는데,\n그렇게 되면 특정 범위 이하의 빛은 검은색, 이상의 빛은 흰색으로 이분된다.\n\n이러한 처리 기법을 `Contrast Stretching` 라고 부른다.\n\n![231016-214728](/posts/mid_03/231016-214728.png)\n\n이렇게 함수가 주어진 경우에는 영상이 다음과 같이 변환된다.\n\n![231016-214753](/posts/mid_03/231016-214753.png)\n\n특정 부분을 제외한 나머지 영역을 죽이거나, 특정 부분만을 강조할 때 사용하는데,\n이런 처리 기법을 `Intensity-Level Slicing` 라고 부른다.\n\n---\n\n## Histogram Processing\n\n\u003ctip\u003e\n  `Histogram`\n  데이터의 분포를 한 눈에 볼 수 있는 그림 혹은 그래프\n\u003c/tip\u003e\n\n영상의 에너지 레벨 분포를 알고싶다면 다음과 같은 과정으로 구할 수 있다.\n\n$$\nh(r_k) = n_k\n$$\n\n여기서 $r_k$는 k번째 gray level(에너지 레벨 0~255)를 나타내고,\n$n_k$는 그 에너리 레벨을 갖는 픽셀의 개수를 의미한다.\n코드로 구현한다면 다음과 같이 구현할 수도 있을것이다.\n\n```cpp:.cpp\nunsigned int Histogram[256] = {0};\n\nfor (h=0; h\u003cH; h++) {\n  for (w=0; w\u003cW; w++) {\n    Histogram[img[w][h]]++;\n  }\n}\n```\n\n하지만 단순 픽셀 수를 세기만 한다면, 매우 큰 영상의 경우 평균적인 빛의 밝기가 어두움에도 값이 크게 나오는 문제가 발생할 수 있다.\n따라서 영상 크기에 따라 자료해석의 차이를 없애도록 영상 크기로 나누어 확률로서 일반화하게 된다.\n\n$$\np(r_k) = \\frac{n_k}{WH}\n$$\n\n이걸 왜 하는건지 알아보기 전에 우선 서로 다른 영상별로 수집된 히스토그램을 살펴보자.\n\n![231016-220848](/posts/mid_03/231016-220848.png)\n\n히스토그램의 분포를 살펴보면 모든 영역에 골고루 분배된 영상이 가장 보기 좋음을 알 수 있다.\n그렇다면 히스토그램 분포를 분산시키는게 영상 품질 개선에 도움이 된다는 것을 알게 되었다.\n\n### Equalization\n\n그렇다면 히스토그램 분포를 골고루 분배할 수 있을까?\n\n![231016-221610](/posts/mid_03/231016-221610.png)\n\n결론부터 말하면 이렇게 이상적으로 분배는 불가능하다.\n0이었던 데이터를 0과 1로 적절히 분산하는 방법이 없기 때문이다.\n\n![231016-222414](/posts/mid_03/231016-222414.png)\n\n이렇게 구현하는 것이 최선일 것이다.\n\n구현에 있어 중요한 점은 **일정 범위 내**의 변환 전과 변환 후의 `확률 분포는 같아야 한다`는 점이다.\n예로 들어 변환 전의 범위 `0~1`은 변환 후의 범위 `0~3`으로 대응되는데, `각 구간의 확률의 합은 동일`함을 알 수 있다.\n이 사실을 식으로 일반화 하면 다음과 같아진다.\n\n$$\n\\sum_{i=0}^{r}p_r(i) = \\sum_{i=0}^{s}p_s(i)\n$$\n\n이를 연속적인 값으로 표현하기 위해 적분식으로 변환하면 다음과 같아진다.\n\n$$\n\\int_{0}^{r}p_r(w)dw = \\int_{0}^{s}p_s(w)dw\n$$\n\n여기서 다시 상기해보자면 $p_r$은 원본 히스토그램 분포(확률 함수)이고, $p_s$는 목표로 하는 히스토그램 분포이다.\n이상적인 확률 함수는 다음 그림과 같을 것이다.\n\n![231016-222950](/posts/mid_03/231016-222950.png)\n\n해당 함수는 $p_s = \\frac{1}{L-1}$ 로 표현 가능한데 이를 위의 적분식에 대입하면 다음과 같이 정리할 수 있다.\n\n$$\n\\int_{0}^{r}p_r(w)dw = \\int_{0}^{s}p_s(w)dw = \\int_{0}^{s}\\frac{1}{L-1}dw = \\frac{s}{L-1} \\\\\n{} \\\\\ns = T(r) = (L-1)\\int_{0}^{r}p_r(w)dw\n$$\n\n이제 이 공식을 이용해서 프로그래밍하기 위해 다시 불연속적인 값의 합으로 바꿔보자.\n\n$$\ns_k = T(r_k) = (L-1)\\sum_{j=0}^{k}p_r(r_j)\n$$\n($k$는 일정 범위에 해당하는 x축의 값이다.)\n\n이 때, $p_r(r_j)$는 위에서 히스토그램의 확률로서 일반화 한 식을 대입하면 된다.\n즉 최종 변환식은 다음과 같다.\n\n$$\ns_k = T(r_k) = \\frac{L-1}{MN}\\sum_{j=0}^{k}n_j \\; , \\;\\; k=0, 1, ..., L-1\n$$\n\n아래 표를 기준으로 연습을 해보자.\n\n| $r_k$ | $n_k$ | $p_r(r_k) = n_k/MN$ | s_k\n|---|---|---|---|\n| $r_0$ = 0 | 790 | 0.19 | $s_0$ = 1.33 \u0026rarr; 1 |\n| $r_1$ = 1 | 1023 | 0.25 | $s_1$ = 3.08 \u0026rarr; 3 |\n| $r_2$ = 2 | 850 | 0.21 | $s_2$ = 4.55 \u0026rarr; 5 |\n| $r_3$ = 3 | 656 | 0.16 | $s_3$ = 5.67 \u0026rarr; 6 |\n| $r_4$ = 4 | 329 | 0.08 | $s_4$ = 6.23 \u0026rarr; 6 |\n| $r_5$ = 5 | 245 | 0.06 | $s_5$ = 6.65 \u0026rarr; 7 |\n| $r_6$ = 6 | 122 | 0.03 | $s_6$ = 6.86 \u0026rarr; 7 |\n| $r_7$ = 7 | 81 | 0.02 | $s_7$ = 7.00 \u0026rarr; 7 |\n$L=8$\n\n$$\ns_0 = T(r_0) = (8-1)\\sum_{j=0}^{0}p_r(r_j) = 7 \\times 0.19 = 1.33 \\\\\ns_1 = T(r_1) = (8-1)\\sum_{j=0}^{1}p_r(r_j) = 7 \\times (0.19 + 0.25) = 3.08 \\\\\n$$\n\n즉, $s_0$가 1이기 때문에, $r_0$(0)에 존재하던 에너지 레벨을 1로 올리고,\n$s_1$가 3이기 때문에, $r_0$(1)에 존재하던 에너지 레벨을 3로 올리는 과정을 거치면 Equalization을 달성할 수 있다.\n\n이련 변환의 경우 히스토그램과 $T(r)$의 그래프는 다음과 같은 모양을 갖게 된다.\n\n![231016-225134](/posts/mid_03/231016-225134.png)\n\n이런 경우 Equalization을 진행한 영상은 원본 영상에 비해 물리적인 정보량은 줄어들게 된다.\n하지만, 사람의 눈으로 보기에는 더 보기 좋은 영상이 된다.\n\n서로 다른 영상에 대해 Equalization을 적용한 예시와 그 $T(r)$ 함수를 살펴보자.\n\n![231016-225624](/posts/mid_03/231016-225624.png)\n![231016-225636](/posts/mid_03/231016-225636.png)\n\n여기서 알 수 있는 점은 원본의 히스토그램 분포가 빽빽하게 모여있을 수록 변환된 영상의 히스토그램 분포에 빈공간이 많이 생긴다는 것이다. (정보량의 손실이 많아진다)\n\n### Specification\n\n하지만 히스토그램을 이용한 Equalization이 만능인 것은 아니다.\n\n![231016-225928](/posts/mid_03/231016-225928.png)\n\n이런 영상처럼 너무 극단으로 몰린 경우에 적용한 결과는 다음과 같이 나올 수 있는데,\n\n![231016-230011](/posts/mid_03/231016-230011.png)\n\n이런 경우에는 단순히 $p_s = \\frac{1}{L-1}$ 를 사용하여 변환 함수를 구하는 것 보다,\n사용자 정의 함수 $p_z$를 만들어서 처리하는게 더 좋은 영상을 만들 수 있다.\n\n![231016-230350](/posts/mid_03/231016-230350.png)","slug":"univ_com-vision/mid_03","readingMinutes":11,"wordCount":936},{"title":"Singal Processing Fundamentals","description":"신호 처리에 대한 기초적인 정보입니다.","icon":"","image":"","tags":["LTI System","Convolution","Fourier Transform"],"draft":false,"date":"2023-10-15 / 21:57","content":"\n## LTI System\n\nLinear Time Invariant System은 다음과 같은 성질을 갖는다.\n\n1. Linear\n  선형성을 유지한다.\n\n  \u003ctip\u003e\n    `선형성`\n\n    $$\n    H[a_if_i(x,y) + a_jf_j(x,y)] \\\\\n    = a_iH[f_i(x,y)] + a_jH[f_j(x,y)] \\\\\n    = a_ig_i(x,y) + a_jg_j(x,y)\n    $$\n  \u003c/tip\u003e\n\n2. Time Invariant\n  시간에 대해 불변성을 갖는다.\n  즉, 시간이 변해도 delay만 있을 뿐, 동일한 input에 대해 동일한 output을 내보낸다.\n\n### System Response\n\n신호 처리를 위해 신호를 디지털화 한 다음 변환(filter)을 가해서 다시 연속적인 신호로 변환하기 위한 과정을 살펴보자.\n\n![231015-222017](/posts/mid_02/231015-222017.png)\n\n우선 신호를 특정 구간에서 일정한 값으로 근사한다.\n그리고 특정 구간에 대해 근사된 데이터에 변환(filter)를 가한다. \n(참고로 filtering에 대해선 추후에 소개할 예정. 지금은 LTI System을 이용해서 신호를 변환하는 과정만 살펴보자.)\n\n그렇게 변환된 데이터를 다시 연속적인 신호로 변환하기 위해선 LTI System에 Pulse를 적용한 결과를 응용하면 된다.\n\n![231015-222538](/posts/mid_02/231015-222538.png)\n\n넓이가 1인 Pulse를 LTI System에 통과시키면 위와 같은 그래프로 변형된다고 하자.\n이 때, LTI System은 선형성을 유지하고 시간 불변성을 갖기 때문에 Pulse의 세기가 커지거나, 시간이 shift돼도,\nLTI System을 통과해도 그 변화가 유지된다.\n\n그렇기에 위에서 변환된 데이터를 특정 구간에 대해 Pulse라고 생각한다면,\n그 데이터를 LTI System에 통과시키면 다음과 같이 변환될 것이다.\n\n![231015-222954](/posts/mid_02/231015-222954.png)\n\n## Convolution\n\n위에서 언급한 Pulse에 대해 단위 시간(T)를 0에 가깝게 보내면 연속적인 신호에 대한 Pulse가 되는데, 이를 Impulse라고 한다.\n이런 Impulse를 LTI System에 통과시키면 위에서 봤던 그래프 형태로 나오게 되는데, 이를 임펄스 반응 이라고 하고, $h(t)$ 라고 하자.\n\n![231015-223956](/posts/mid_02/231015-223956.png)\n\n입력 신호 $f$와 출력 신호 $y$는 다음과 같은 관계를 갖게 된다.\n\n$$\ny(t) = f(t) * h(t)\n$$\n\n즉, LTI System의 출력($y$)은 시스텝의 임펄스 반응($h$)과 입력($f$)의 Convolution이다.\n\n## Fourier Transform\n\n![231015-224927](/posts/mid_02/231015-224927.png)\n\n푸리에 변환의 기본적인 아이디어는 주기적인 어떠한 함수는 모두 sin파 또는 cos파의 합으로 표현(근사)될 수 있다에서 출발한다.\n\n푸리에 변환을 거치면 시간에 대한 함수가 주파수에 대한 함수로 변환되는데,\n시간 축이 주파수 축으로 변환된다는 뜻이다.\n단적인 예로, 주기가 $2\\pi$이고, 크기가 1인 sin함수는 크기가 1이고, $u=1 (2\\pi)$인 Impulse 형태로 그려진다.\n\n\u003ctip\u003e\n  `푸리에 변환`\n  $$\n  F(u) = \\int_{-\\infty}^{\\infty} f(x)e^{-i2\\pi ux}dx\n  $$\n\n  `역 푸리에 변환`\n  $$\n  f(x) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} F(u)e^{iux}dx\n  $$\n\u003c/tip\u003e\n\n그런데 왜 푸리에 변환을 알아야 할까?\n바로 푸리에 변환을 사용하면 Convolution 연산이 매우 간단한 형태로 변환되기 때문이다.\n\n$$\nG(u) = \\int_{-\\infty}^{\\infty}g(x)e^{-i2\\pi ux}dx \\\\\n= \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(\\tau)h(x-\\tau)e^{-i2\\pi ux}dx \\\\\n= \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}[f(\\tau)e^{-i2\\pi u\\tau}d\\tau][h(x-\\tau)e^{-i2\\pi u(x-\\tau)}dx] \\\\\n= \\int_{-\\infty}^{\\infty}[f(\\tau)e^{-i2\\pi u\\tau}d\\tau]\\int_{-\\infty}^{\\infty}[h(x')e^{-i2\\pi ux'}dx'] \\\\ \n= F(u)H(u)\n$$\n\n즉, 기존 도메인($x$)에서의 Convolution 연산이 푸리에 변환된 주파수 도메인($u$)에서는 단순 곱셈으로 표현된다.\n\n![231015-230238](/posts/mid_02/231015-230238.png)\n\n따라서 Convolution 연산을 간단하게 하기 위해서는 일단 푸리에 변환 후 곱연산을 수행해서 다시 역 푸리에 변환을 거치는 과정을 수행하는게 좋다.\n\n### Sampling\n\n[**`이전 포스트`**](https://wjlee611.github.io/blog/univ_com-vision/mid_01#aliasing)에서 Sampling이 적으면 Aliasing이 발생한다고 했었는데, 그 이유을 알아보자.\n\n![231015-230835](/posts/mid_02/231015-230835.png)\n\n왼쪽은 시간 도메인 기준으로 입력 신호에 적절하게 샘플링된 Impulse를 Convolution하면 좌하단처럼 샘플링이 이루어진다.\n오른쪽은 왼쪽을 푸리에 변환한 결과로 Convolution 대신 곱연산한 결과이다.\n\n~~(본인도 이해는 안되지만)~~ 여기서 중요한 것은 샘플링이 촘촘할 수록\n푸리에 변환된 스펙트럼이 듬성듬성 해진다는 점이다.\n\n만약, 샘플링이 적은수가 되었다면 우하단의 입력 신호의 스펙트럼 봉우리(?)가 오버랩될 것이다.\n오버랩 되는 경우 원본을 복구할 수 없기에 Aliasing이 발생하는 것이다.","slug":"univ_com-vision/mid_02","readingMinutes":6,"wordCount":449},{"title":"Digital Image Fundamentals","description":"디지털 이미지에 대한 기초적인 정보입니다.","icon":"","image":"","tags":["Sampling","Quantization","Interpolation"],"draft":false,"date":"2023-10-15 / 20:05","content":"\n## Sampling \u0026 Quantization\n\n연속적인 자연계의 현상을 기록하기 위해서는 이미지를 불 연속적인 형태. 즉, 디지털로 변환해야 한다.\n\n예로 들어 이미지의 좌표가 100.32라면? 반올림을 하던지 적당히 100과 같은 불 연속적인 값으로 치환해야 하며,\n에너지레벨 역시 이와 같은 방식으로 디지털화 해야한다.\n\n이렇게 자연계의 연속적인(무한한) 값을 `디지털화 하기 위해 유한하게` 자르는 과정을 `Sampling`이라 하고,\n무한 소수의 데이터를 `양자화시켜 비트에 저장할 수 있게` 자르는 과정을 `Quantization`라고 한다.\n\n![231015-201653](/posts/mid_01/231015-201653.png)\n\n**좌상단**의 이미지 중에서 $\\overline{AB}$ 를 디지털화 해본다면,\n**우상단**의 그래프처럼 에너지레벨(빛의 밝기)이 표현될 것이다. (지글지글 거리는 것은 센서의 한계로인한 노이즈)\n샘플링을 일정 구간으로 잘라 네모난 점으로 표현하면 **좌하단**의 이미지처럼 될 것이고,\n이를 양자화하면 **우하단**의 이미지처렴 변화하여 디지털로 저장할 수 있게 된다.\n\n![231015-202204](/posts/mid_01/231015-202204.png)\n\n이런 방식으로 2차원 이미지를 디지털화 하면 위와 같은 모양이 될텐데,\n연속적인 데이터를 불연속적인 데이터로 변환하면서 어쩔 수 없는 데이터의 손실이 발생할 수 있다.\n\n\u003ctip\u003e\n  픽셀의 가로축은 x축, 세로축은 y축이며,\n  x좌표는 늘 보던 좌표계와 마찬가지로 오른쪽으로 갈 수록 커지지만,\n  y좌표는 반대로 내려갈수록 커진다. **(y축 반전 주의)**\n  \u003cbr /\u003e\n  M행 N열(M$\\times$N)의 이미지는 다음과 같은 배열에 저장할 수 있다.\n\n  $$\n  f(x,y) = \\begin{bmatrix}\n  f(0,0) \u0026 f(0,1) \u0026 ... \u0026 f(0,N-1) \\\\\n  f(1,0) \u0026 f(1,1) \u0026 ... \u0026 f(1,N-1) \\\\\n  ... \u0026 ... \u0026 ... \u0026 ... \\\\\n  f(M-1,0) \u0026 f(M-1,1) \u0026 ... \u0026 f(M-1,N-1) \\\\\n  \\end{bmatrix}\n  $$\n\u003c/tip\u003e\n\n### Aliasing\n\n![231015-205116](/posts/mid_01/231015-205116.png)\n\n샘플링을 위 이미지와 같이 극단적으로 적게 할 경우, 조건이 없다면 원본 데이터를 유추할 수 없게 된다.\n또는 변화량이 너무 큰 경우에도 위와 같은 Aliasing 현상이 발생할 수 있다.\n예로 들어서 선풍기를 영상으로 찍으면 멈춰있는 듯한 현상이 그런 경우이다.\n\n### Quantization Level\n\n![231015-204846](/posts/mid_01/231015-204846.png)\n\n양자화를 얼마나 세밀하게 할지를 Quantization Level이 결정한다.\n레벨이 적을수록 듬성듬성 양자화하게 되고(점선 간격이 늘어남), 이는 화질 저하로 이어진다.\n하지만 용량은 절약될 것이다.\n\n### Size (Storage bits)\n\n이렇게 저장된 영상의 크기를 구해보자.\n\n\u003cnotice\u003e\n  이미지의 화질은 M$\\times$N으로 가정하고,\n  각 픽셀은 0~255, 즉, 8 bits의 에너지 레벨을 갖는다고 가정하자.\n\u003c/notice\u003e\n\n단색 이미지(Gray Image)의 경우 1픽셀은 8bits가 필요하기에 1byte.\n이 픽셀이 M$\\times$N개 있으니 M$\\times$Nbytes.\n컬러 이미지의 경우 RGB 3개의 색상 채널이 있으니 3을 곱해서 M$\\times$N$\\times$3bytes 가 된다.\n\n위 계산 결과는 하나의 이미지에 대한 사이즈로, 동영상의 경우에는 30프레임의 경우 추가로 30을 더 곱해줘야 할 것이다.\n\n### Saturation\n\n![231015-203543](/posts/mid_01/231015-203543.png)\n\n센서까지 차이가 있던 데이터가 샘플링 과정에서 차이가 없어지는, Saturation 현상이 발생할 수 있다.\n\n### Gray Level\n\n![231015-203931](/posts/mid_01/231015-203931.png)\n![231015-203946](/posts/mid_01/231015-203946.png)\n\nGray Level이 높을 수록 에너지 레벨을 세분화해서 표현할 수 있다.\n따라서 디스플레이 장치가 좋지 않아서 Gray Level이 낮을 경우 같은 이미지라도 위 사진처럼 다르게 표현될 수 있다.\n\n## Interpolation\n\n디지털화된 이미지의 사잇값을 적절히 채워 실제 데이터를 추측하는 과정,\n또는, 저화질의 영상의 픽셀값을 채워 고화질로 바꾸거나, 영상의 회전, 축소시 픽셀값을 추측하는 과정을 Interpolation 라고 한다.\n\n### Pixel math\n\n보통 아래와 같은 행렬간의 연산 혹은 픽셀별 계산으로 처리된다.\n\n$$\n\\begin{bmatrix}\na_{11} \u0026 a_{12} \\\\\na_{21} \u0026 a_{22} \\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nb_{11} \u0026 b_{12} \\\\\nb_{21} \u0026 b_{22} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11} + b_{11} \u0026 a_{12} + b_{12} \\\\\na_{21} + b_{21} \u0026 a_{22} + b_{22} \\\\\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\na_{11} \u0026 a_{12} \\\\\na_{21} \u0026 a_{22} \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nb_{11} \u0026 b_{12} \\\\\nb_{21} \u0026 b_{22} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11}b_{11} + a_{12}b_{21} \u0026 a_{11}b_{12} + a_{12}b_{22} \\\\\na_{21}b_{11} + a_{22}b_{21} \u0026 a_{21}b_{12} + a_{22}b_{22} \\\\\n\\end{bmatrix}\n$$\n\n단, 보통 픽셀값은 0~255 사이의 값을 갖기 때문에, overflow, underflow에 대해 적절하게 처리해줘야 한다.\n\n### Linear\n\n$H[f(x,y)] = g(x,y)$ 와 같은 변환 함수 $H$가 있을 때,\n아래의 특성을 만족하면 $H$가 선형이라고 한다.\n\n$$\nH[a_if_i(x,y) + a_jf_j(x,y)] \\\\\n= a_iH[f_i(x,y)] + a_jH[f_j(x,y)] \\\\\n= a_ig_i(x,y) + a_jg_j(x,y)\n$$\n\n즉 연산 순서에 상관없다면 선형이라 하며, 대부분의 이미지 처리 연산은 선형이다.\n\n### Image Rotation\n\n![231015-212235](/posts/mid_01/231015-212235.png)\n\n특정 픽셀을 $\\theta$만큼 반 시계방향으로 회전시킬 경우 아래와 같은 연산을 가해주면 된다.\n\n$$\n\\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n=\nR(\\theta)\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ncos\\theta \u0026 -sin\\theta \\\\\nsin\\theta \u0026 cos\\theta\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n$$\n\n하지만, 이 경우에는 원점을 중심으로 회전되기 때문에,\n영상을 중심으로 회전시켜야 하는 경우에는 다음과 같은 스탭을 거쳐야 한다.\n\n1. 영상을 중심으로 평행 이동 시킨다.\n2. 삼각함수를 이용해 영상을 회전시킨다.\n3. 다시 영상을 원위치로 평행 이동 시킨다.\n\n하지만, 위 연산은 선형이기 때문에 각 픽셀별로 아래 하나의 연산으로 처리해도 상관없다.\n\n$$\n\\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ncos\\theta \u0026 -sin\\theta \\\\\nsin\\theta \u0026 cos\\theta\n\\end{bmatrix}\n\\begin{bmatrix}\nx - W/2\\\\\ny - H/2\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nW/2\\\\\nH/2\n\\end{bmatrix}\n$$\n\n\u003cnotice\u003e\n  영상 변환을 하기 위해서는 `변환 후(x, y)`의 좌표를 연산을 통해 `변환 전(x', y')`의 좌표를 구하고,\n  그 좌표의 데이터를 가져와 Quantization하여 변환 후의 좌표에 대입하는 과정을 거쳐야 한다.\n\u003c/notice\u003e\n\n### Image Interpolation\n\n![231015-214108](/posts/mid_01/231015-214108.png)\n\n검은색 input 영상을 흰색 output 영상으로 upscaling하거나, 영상 회전과 같이\n변환 후의 영상의 좌표가 픽셀에 정확히 들어가지 않는 경우, 검은색 픽셀값을 이용해 흰색 픽셀값을 추측해야 한다.\n추측하는 방식에는 보통 아래와 같은 방법들이 있다.\n\n1. Replication\n  이전 픽셀값의 데이터를 그대로 사용하는 방법이다.\n2. Nearest Neighbor\n  본인과 가까운 픽셀의 데이터를 그대로 사용하는 방법이다.\n\n위 두 방법의 경우 Interpolation은 가능하지만, 이미지 화질의 개선이 이루어지지는 않는다.\n적당한 화질 개선을 위해서는 아래의 방법을 고려해볼 수 있다.\n\n3. (Bi)linear Interpolation\n  근처 픽셀값을 이용해 평균 데이터를 계산하여 사용하는 방법이다.\n\n![231015-214947](/posts/mid_01/231015-214947.png)\n\n$$\nq_1 = (1-a)p_1 + ap_2 \\\\\nq_2 = (1-a)p_3 + ap_4 \\\\\n{} \\\\ \nq = (1-b)q_1 + bq_2\n$$\n","slug":"univ_com-vision/mid_01","readingMinutes":10,"wordCount":824},{"title":"Adapter \u0026 Facade Pattern","description":"Adapter 그리고 Facade 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Adapter Pattern","Facade Pattern"],"draft":false,"date":"2023-10-11 / 17:13","content":"\n## Adapter Pattern\n\n### 필요성\n\n개발하다 보면, 이전에 개발했던 코드가 있는데, 새로 개발된 코드 사양에 맞게 변경시켜야 하는 상황이 많을 것이다.\n마음같아선 새로 짜고 싶지만, dependency가 높은 코드나 배포가 진행된 코드의 경우 수정하는데 부담이 클 수 밖에 없다.\n이런 경우에 오래된 코드를 새로운 코드 사양에 맞게 변형시켜줘야 할 필요성이 생기는데, 이 때 `Adapter Pattern`을 사용하게 된다.\n\n### 예시\n\n예를 들어보기 위해 우리의 오랜 친구(?) Duck 시뮬레이터를 다시 불러와보자.\n\n```java:Duck.java\npublic interface Duck {\n  public void quack();\n  public void fly();\n}\n```\n\n이제 새로운 동물을 시뮬레이터에 추가해보자. 바로 Turkey!\n\n```java:Turkey.java\npublic interface Turkey {\n  public void gobble();\n  public void fly();\n}\n```\n\n인터페이스를 보면 알겠지만, 울음 소리가 다르다.\n따라서 기존에 많은 곳에서 사용되었던 quack() 메서드를 사용하는 곳에선 Turkey 인터페이스를 구현한 클래스의 인스턴스를 사용할 수가 없게된다.\n이 경우 **코드의 재사용성**을 높이기 위해 `Adapter`를 구현해서 사용하게 된다!\n\n```java:TurkeyAdapter.java {1 8-10}\npublic class TurkeyAdapter implements Duck {\n  Turkey turkey;\n\n  public TurkeyAdapter(Turkey turkey) {\n    this.turkey = turkey;\n  }\n\n  public void quack() {\n    turkey.gobble();\n  }\n\n  public void fly() {\n    turkey.fly();\n  }\n}\n```\n\n이렇게 TurkeyAdapter를 만들어주면 이 어댑터의 인스턴스는 Duck 취급을 받기에 quack() 메서드를 사용하는 부분에 이 인스턴스를 넣을 수 있다.\n즉, Turkey를 Duck 처럼 사용할 수 있다는 뜻이다!\n\n```java:DuckSimulator.java {6}\npublic class DuckSimulator {\n  public static void main(String[] args) {\n    MallardDuck duck = new MallardDuck(); // implement Duck\n    WildTurkey turkey = new WildTurkey(); // inplement Turkey\n\n    Duck turkeyAdapter = new TurkeyAdapter(turkey);\n\n    // 둘 다 가능.\n    duck.quack();\n    turkeyAdapter.quack(); // 내부적으로 turkey.gobble() 호출\n  }\n}\n```\n\n### IRL\n\n실제로 Adapter Pattern이 적용되는 사례를 살펴보자.\n\njava에서 일련의 객체를 나타낼 때 `Iterator`를 많이들 사용하는데, 예전에 Iterator가 없을 때는 `Enumerators`을 사용했다고 한다.\n버전업이 되고 Iterator를 사용하는게 권장됐는데, legacy system에서는 아직도 Enumerators를 사용했기에 이를 강제할 수는 없었다.\n따라서 이를 위해 EnumerationAdapter를 만들었다고 한다.\n\n```java:Enumerators.java\npublic interface Enumerators {\n  public boolean hasMoreElements();\n  public T nextElement();\n}\n```\n\n```java:Iterator.java\npublic interface Iterator {\n  public boolean hasNext();\n  public T next();\n  public void remove();\n}\n```\n\n```java:EnumerationAdapter.java\npublic class EnumerationAdapter implements Iterator {\n  Enumerators enumerators;\n\n  public EnumerationAdapter(Enumerators enumerators) {\n    this.enumerators = enumerators;\n  }\n\n  public boolean hasNext() {\n    return enumerators.hasMoreElements();\n  }\n\n  public T next() {\n    return enumerators.nextElement();\n  }\n\n  public void remove() {\n    throw new UnsupportedOperationException();\n  }\n}\n```\n\n","slug":"univ_design-pattern/mid_06","readingMinutes":4,"wordCount":354},{"title":"Command Pattern","description":"Command 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Command Pattern"],"draft":false,"date":"2023-10-10 / 14:45","content":"\n## 필요성\n\n개발하다보면, 특정 버튼을 누르면 이벤트가 발생하도록 처리하는 패턴을 구현해야 하는 경우가 생길 것이다.\n예로들어 만능 리모컨을 만든다고 가정해보자.\n\n버튼 1 - ON을 누르면 tv가 켜지고 OFF를 누르면 꺼지고,\n\n```java:TV.java\npublic class TV {\n  private boolean isOn;\n  private int channel;\n\n  public TV() {\n    this.isOn = false;\n    this.channel = 1;\n  }\n\n  public void on() {\n    this.isOn = true\n  }\n\n  public void off() {\n    this.isOn = false;\n  }\n\n  public void changeChannel(int channel) {\n    this.channel = channel;\n  }\n}\n```\n\n버튼 2는 전등, 3은 선풍기 등등...\n\n이런 경우에 보통의 경우 `if - else`로 처리하는 경우가 많을 것이다.\n\n```java:Example\nif (버튼 1 - ON) {\n  tv.on();\n} else if (버튼 2 - OFF) {\n  tv.off();\n}\n```\n\n하지만 이런 경우에는 새로운 기능을 추가하거나, 기존에 있는 기능을 수정하려면 그 유지보수가 매우 불편하다.\n\n따라서 이를 해결하기 위한 디자인 패턴을 소개한다.\n\n## Command Pattern\n\nCommand Pattern의 기본적인 아이디어는 모든 기능 요청들을 `하나의 명령어(Command)`로서 관리하여 은닉화 하는데에 있다.\n바로 코드를 보며 이해해보자.\n\n```java:Command.java\npublic interface Command {\n  public void execute();\n}\n```\n\n```java:TVOnCommand.java {1, 8-10}\npublic class TVOnCommand implements Command {\n  TV tv;\n\n  public TVOnCommand(TV tv) {\n    this.tv = tv;\n  }\n\n  public void execute() {\n    tv.on();\n  }\n}\n```\n\n모든 명령어는 무조건 `execute()`로 실행하고, 각 명령어의 실행 방법은 그 명령어가 어떤 장치를 조작하는지에 따라 다르게 구현한다.\n따라서 이렇게 구현한다면 TV를 켜든 끄든 전등을 제어하든 모든 명령은 `execute()`를 호출하면 되는 것이다.\n\n```java:RemoteController.java {2-3}\npublic class RemoteController {\n  Command[] onCommands;\n  Command[] offCommands;\n\n  public RemoteController() {\n    onCommands = new Command[7];\n    offCommands = new Command[7];\n\n    Command empty = new Command();\n    for (int i=0; i\u003conCommands.length; i++) {\n      onCommands[i] = empty;\n      offCommands[i] = empty;\n    }\n  }\n\n  public void setCommand(int slot, Command onCom, Command offCom) {\n    onCommands[slot] = onCom;\n    offCommands[slot] = offCom;\n  }\n\n  public void onBtnPushed(int slot) {\n    onCommands[slot].execute();\n  }\n\n  public void offBtnPushed(int slot) {\n    offCommands[slot].execute();\n  }\n}\n```\n\n그리고 만능 리모컨을 이렇게 구현한다면, 사용자 입장에서는 원하는 기능을 `Command interface`로 구현하고, 원하는 slot에 `setCommand()`를 이용해 넣어주기만 하면 된다.\n\n### 추가 기능\n\n명령어 인터페이스를 이용해 하나로 구현하면 다른 기능을 추가하고 싶을 때도 용이하다.\n예로 들어 undo 기능을 구현해보자.\n\n```diff-java:Command.java\n  public interface Command {\n    public void execute();\n+   public void undo();\n  }\n```\n\n그럼 각 명령어에서 수행할 undo 기능을 추가만 하면 된다.\n\n```diff-java:TVOnCommand.java\n  public class TVOnCommand implements Command {\n    TV tv;\n\n    public TVOnCommand(TV tv) {\n      this.tv = tv;\n    }\n\n    public void execute() {\n      tv.on();\n    }\n\n+   public void undo() {\n+     tv.off(); // on의 반대는 off\n+   }\n  }\n```\n\n그렇다면 컨드롤러의 구현은 이렇게만 수정되면 undo 기능을 쉽게 구현할 수 있게된다!\n\n```diff-java:RemoteController.java\n  public class RemoteController {\n    Command[] onCommands;\n    Command[] offCommands;\n+   Command undoCommand;\n\n    ...\n\n    public void onBtnPushed(int slot) {\n      onCommands[slot].execute();\n+     undoCommand = onCommands[slot];\n    }\n\n    public void offBtnPushed(int slot) {\n      offCommands[slot].execute();\n+     undoCommand = offCommands[slot];\n    }\n\n+   public void undoBtnPushed() {\n+     undoCommand.undo();\n+   }\n  }\n```\n\nundo 뿐만 아니라, 매크로 기능과 같은 서드파티 기능도 쉽게 구현할 수 있을 것이다.\n\n```java:MacroCommand.java\npublic class MacroCommand implements Command {\n  Command[] commands;\n\n  public MacroCommand(Command[] commands) {\n    this.commands = commands;\n  }\n\n  public void execute() {\n    for (int i=0; i\u003ccommands.length; i++) {\n      commands[i].execute();\n    }\n  }\n\n  public void undo() {\n    for (int i=commands.length-1; i\u003e=0 i--) {\n      commands[i].undo();\n    }\n  }\n}\n```\n\n### IRL\n\nIn Real Life에서는 Command Pattern이 어떻게 쓰이고 있을까?\n\n1. 명령어 queuing\n**Command queue**를 만들어 `enqueue`, `dequeue`를 구현하여, 각각의 명령어를 순차처리, 스레드에 할당하는 방식으로 사용하는 경우가 있다.\n\n2. logging\n**Command**에 `store`, `load` 따위의 메서드를 추가하여 명령어가 실행되면 disk에 로깅 및 불러올 수 있도록 기능을 추가하여 에러 및 데이터 분석을 용이하게 하는 경우도 있다.\n\n\n## 결론\n\n클라이언트 별로 다른 요청을 처리하는 경우나, 요청 queue, 로깅이 필요한 경우에는\n명령어, 요청을 `은닉화(encapsulates)`하는 Command Pattern을 활용해보자.","slug":"univ_design-pattern/mid_05","readingMinutes":6,"wordCount":583},{"title":"Singleton Pattern","description":"Singleton 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Singleton Pattern"],"draft":false,"date":"2023-10-08 / 21:31","content":"\n## 필요성\n\n시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용한다.\n\n## Singleton Pattern\n\n```java:Singleton.java {2, 4} showLineNumbers\n  public class Singleton {\n    private static Singleton _instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      if (_instance == null) {\n        _instance = new Singleton();\n      }\n      return _instance;\n    }\n  }\n```\n\n기존에 봐오던 클래스들과 많이 다르게 클래스 내부에 본인의 인스턴스를 저장하는 공간이 있으며,\n**생성자가 외부로 노출되지 않는다**.\n\n인스턴스 생성은 오직 `getInstance()` 메서드 호출을 통해서만 이루어지며,\n내부적으로 null값인 경우에만 인스턴스를 생성하기 때문에 `1개의 인스턴스만 생성`이 된다.\n\n### Multithreading\n\n하지만 멀티스레딩 환경에서는 인스턴스가 2개 이상 생성되는 경우가 발생할 수 있다.\n`Line 7`과 `Line 8` 사이에서 `Context switching`이 일어나는 경우가 그러하다.\n\n이런 경우를 막기 위해서 getInstance()는 `동기화 처리`를 해주는 편이 좋다.\n\n```java:Singleton.java {2}\npublic class Singleton {\n  private static Singleton _instance = new Singleton();\n  ...\n}\n```\n\n이렇게 하면 프로그램 실행시점에 인스턴스가 생성되어 반드시 1개의 인스턴스만 생성할 수 있다.\n하지만, 해당 클래스의 생성시점을 제어할 수 없기에 프로그램 성능이 저하되는 문제가 발생할 수 있다.\n\n```java:Singleton.java {6}\n  public class Singleton {\n    private static Singleton _instance;\n\n    private Singleton() {}\n\n    public static synchronized Singleton getInstance() {\n      if (_instance == null) {\n        _instance = new Singleton();\n      }\n      return _instance;\n    }\n  }\n```\n\njava처럼 동기화 키워드를 제공하는 경우 인스턴스를 생성하는 함수를 동기화 걸어주면 된다.\n하지만 이 경우에도 해당 함수가 매우 무거운 기능을 수행하는 경우에는 동기화 시간이 매우 길어져 성능 저하의 원인이 될 수 있다.\n\n\n```java:Singleton.java {6}\n  public class Singleton {\n    private volatile static Singleton _instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      if (_instance == null) {\n        synchronized (Singleton.class) {\n          if (_instance == null) {\n            _instance = new Singleton();\n          }\n        }\n      }\n      return _instance;\n    }\n  }\n```\n\n위의 코드는 인스턴스 생성 함수 내부에서 정확히 인스턴스를 생성하는 부분만 동기화되기 때문에\n성능상의 이슈도 없앨 수 있다.\n\n## 결론\n\n필요성과 같다.\n시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용하자.","slug":"univ_design-pattern/mid_04","readingMinutes":4,"wordCount":300},{"title":"Decorator Pattern","description":"Decorator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Decorator Pattern","OCP","Java I/O"],"draft":false,"date":"2023-10-08 / 14:49","content":"\n## 필요성\n\n키오스크 개발자라고 가정하고 음료를 정의할 인터페이스를 만들어보자.\n\n```java:Beverage.java\npublic abstract class Beverage {\n  private String description;\n\n  public Beverage(String des) {\n    this.description = des;\n  }\n\n  public String getDescription() {\n      return description;\n  }\n  public abstract double cost();\n}\n```\n\n그렇다면 음료들은 이 클래스를 상속받아서 구현하면 될 것이다.\n하지만 이 경우에 다음과 같은 문제점이 발생할 수 있다.\n\n아아, 아아 샷추가, 아아 우유추가 등 여러 `베리에이션 음료`에 대해 모두 **각각** 클래스로 구현해야 한다는 점이다.\n단순히 샷추가나 우유추가의 경우에는 가격만 좀 더 받으면 될터인데 이를 각각 따로 구현하는거는 코드의 중복 뿐만 아니라, 유지보수도 어렵게 만든다.\n\n### OCP\n\n그렇다면 Beverage에서 옵션도 관리하게 하면 되지 않을까?\n\n```diff-java:Beverage.java\n  public abstract class Beverage {\n    private String description;\n+   private boolean milk;\n+   private boolean soy;\n\n    public Beverage(String des) {\n      this.description = des;\n    }\n\n    public abstract String getDescription() {\n      return description;\n    }\n    public abstract double cost();\n\n+   setMilk();\n+   hasMilk();\n+   setSoy();\n+   hasSoy();\n  }\n```\n\n처음 생각해볼 수 있는 간단한 해결법이지만, 좋은 방법은 아니다.\n다른 옵션을 추가하거나 옵션에 따른 가격 변동을 수정하려는 경우에는 Beverage 클래스에 대한 전면적인 수정이 필요해지기 때문이다.\n\n`새로운 옵션`에 대해서는 **변수 추가 및 get, set을 추가**해야 하고,\n`가격 변동`의 경우에는 **cost 함수가 전면적으로 수정**되어야 한다.\n이 과정에 Beverage를 상속받은 `모든 클래스`에서 일어나야 한다.\n\n이런 경우를 방지하기 위해 `OCP` 방법론을 준수하여 코딩하는게 좋다.\n\nOCP는 Open-Closed Principle의 약어로, 확장엔 유연하게, 변경엔 엄격하게 디자인 해야함을 추구하는 원칙이다.\n\n## Decorator Pattern\n\n이를 해결하기 위해 `Decorator Pattern`을 사용할 수 있다.\n\n우선 Beverage는 다시 원상복구를 시키고, 옵션에 대한 클래스를 구현하자.\n\n```java:CondimentDecorator.java\npublic abstract class CondimentDecorator extends Beverage {\n  public abstract String getDescription();\n}\n```\n\n이제 음료는 Beverage를 상속받아 구현하고, 옵션은 CondimentDecorator를 상속받아 구현하면 된다.\n계속 예시를 살펴보며 이해하자.\n\n```java:Espresso.java\npublic class Espresso extends Beverage {\n  public Espresso() {\n    description = 'Espresso';\n  }\n\n  public double cost() {\n    return 0.89;\n  }\n}\n```\n\n```java:Milk.java\npublic class Milk extends CondimentDecorator {\n  Beverage beverage;\n\n  public Milk(Beverage beverage) {\n    this.beverage = beverage;\n  }\n\n  public String getDescription() {\n    return beverage.getDescription() + ', Milk';\n  }\n\n  public double cost() {\n    return beverage.cost() + 0.20;\n  }\n}\n```\n\n이런식으로 구현한다면 사용할 때는 Espresso를 Milk가 감싸는 방식으로 옵션을 추가할 수 있게된다.\n\n```java:Kiosk.java\npublic class Kiosk {\n  public static void main(String args[]) {\n    Beverage espressoWithMilk = new Milk(new Espresso());\n    System.out.println(espressoWithMilk.getDescription() + “ $” + espressoWithMilk.cost());\n    ...\n  }\n}\n```\n\n\u003e Espresso, Milk $1.09\n\n실제로 Java의 I/O를 사용하다보면 이런 코드를 많이 본 적이 있을 것이다.\n\n```java:FileIO.java\nInputStream in = new LineNumberInputStream(\n                    new BufferedInputStream(\n                       new FileInputStream('text.txt')));\n```\n\n이런 Stream도 모두 Decorator Pattern이 적용된 것이다.\n\n## 결론\n\nDecorator Pattern은 `새로운 기능이 추가`되거나, `적용 순서를 자유롭게` 해야하는 경우에 사용하는 것이 좋다.","slug":"univ_design-pattern/mid_03","readingMinutes":5,"wordCount":417},{"title":"Dart 언어 마스터","description":"Dart 언어에 대한 보다 심화된 내용을 정리해봤습니다.","icon":"","image":"","tags":["Dart","factory","get","set","stream","async*","yield","mixin","with"],"draft":false,"date":"2023-09-25 / 14:55","content":"\n## factory constructor\n\n`factory` 키워드를 사용하면 아래와 같은 기능을 구현할 수 있다고 공식문서에 나와 있습니다.\n\n1. 인스턴스를 `캐시에서 반환`하여 클래스의 인스턴스를 한 번만 생성할 수 있도록 합니다. (일종의 Singleton 패턴 구현법)\n2. 생성자에서 `서브 클래스`(상속 받은 클래스)의 인스턴스를 반환할 수 있습니다.\n\n둘 다 신기한 기능입니다. (다만 언제 사용하는게 적재적소인지는 잘 모르겠네요..)\n1번부터 알아봅시다.\n\n### caching\n\n```dart:.dart\nclass Singleton {\n  static final Singleton _instance = Singleton._internal();\n\n  Singleton._internal() {}\n\n  factory Singleton() {\n    return _instance;\n  }\n\n  void getHash() {\n    print(this.hashCode);\n  }\n}\n\nvoid main() {\n  Singleton s1 = new Singleton();\n  Singleton s2 = new Singleton();\n\n  s1.getHash(); // 302000605\n  s2.getHash(); // 302000605\n}\n```\n\n위와 같이 구현한다면, Singleton 클래스의 인스턴스는 `단 한개`만 생성되게 됩니다.\n클래스 로드 시점에 static으로 이미 인스턴스가 만들어지기 때문이죠.\n하지만 이런 사용용법은 의미가 없어보입니다.\n차라리 아래의 예시가 더 의미 있어보입니다.\n\n```dart:.dart\nclass SingletonLog {\n  final String value;\n\n  static final Map\u003cString, SingletonLog\u003e _cache = {};\n\n  SingletonLog._internal(this.value);\n\n  factory SingletonLog(String value) {\n    return _cache.putIfAbsent(value, () =\u003e SingletonLog._internal(value));\n  }\n\n  void getHash() {\n    print(this.hashCode);\n  }\n\n  String getValue() {\n    return value;\n  }\n\n  Map\u003cString, String\u003e getLogs() {\n    Map\u003cString, String\u003e result = {};\n    _cache.forEach((key, value) {\n      result[key] = value.value;\n    });\n    return result;\n  }\n}\n\nvoid main() {\n  SingletonLog s1 = new SingletonLog('log1');\n  SingletonLog s2 = new SingletonLog('log2');\n\n  s1.getHash();        // 888013580\n  s2.getHash();        // 870182876\n\n  print(s1.value);     // log1\n  print(s2.value);     // log2\n\n  print(s1.getLogs()); // {log1: log1, log2: log2}\n  print(s2.getLogs()); // {log1: log1, log2: log2}\n}\n```\n\n이렇게 하면 s1, s2가 같은 인스턴스를 반환받기 때문에, 어디에서 로그를 추가해도 모든 객체가 같은 로그기록을 보관할 수 있습니다.\n\n\u003ctip\u003e\n  그럼 이런 의문이 듭니다.\n  hashCode가 다르게 나오는데, 그럼 다른 객체 아닌가요?\n  \u003cbr /\u003e\n  실제로 s1 == s2의 값은 `false`입니다. 따라서 `다른 객체`가 맞습니다.\n  하지만 **약간 변형**이 이루어지긴 했으나, `싱글톤 패턴` 역시 맞습니다.\n  \u003cbr /\u003e\n  왜냐하면, 인스턴스의 생성을 **클래스 내부**에서 `_internal`로 생성하고, 생성자를 외부에서 호출하지 못합니다.\n  또한, static으로 선언된 `_cache` 내부에서 인스턴스를 보관하기 때문에 _cache를 통해서 **전역적으로 인스턴스를 공유**하게 됩니다.\n  \u003cbr /\u003e\n  그렇다고 항상 다른 객체를 반환하는 것은 아닙니다.\n  실제로, s2를 생성할 때, s1과 동일하게 `'log1'`을 주입시키면 s1, s2 동일한 hashCode를 갖게 됩니다.\n  왜냐하면, factory 생성자는 일단 캐시되어있는 인스턴스를 반환하기 때문에,\n  _cache 내부에 인스턴스를 저장하고 있고, s1, s2 모두 같은 데이터를 갖고 있기에 메모리주소 역시 같아집니다.\n\u003c/tip\u003e\n\n### return subclass constructor\n\n그럼 2번도 알아봐야겠죠?\n\n```dart:.dart\nclass Human {\n  final String name;\n\n  Human(this.name);\n\n  factory Human.create(String name, {required bool isMan}) {\n    if (isMan) {\n      return Male(name);\n    }\n    return Female(name);\n  }\n}\n\nclass Male extends Human {\n  Male(String name) : super(name);\n}\n\nclass Female extends Human {\n  Female(String name) : super(name);\n}\n\nvoid main() {\n  Human man = new Human.create('h1', isMan: true);\n  Human woman = new Human.create('h2', isMan: false);\n\n  print(man.name);   // h1\n  print(woman.name); // h2\n}\n```\n\n이 방식은 객체지향 프로그래밍의 다형성의 원리를 충족시키기에 좋은 문법입니다.\n\n신기한 점은 부모 클래스 생성자에서 자식 클래스의 생성자를 호출해 반환한다는 점입니다.\n이렇게하면 인스턴스 생성 시점에 조건을 달아 다른 인스턴스를 반환하는 것이 가능해집니다.\n_(상태나 이벤트를 클래스로 관리할 때 유용해 보이네요!)_\n\n### constructor body\n\n사실 공식문서에는 자세히 설명하진 않지만, factory 생성자의 가장 큰 이점은 `final variable`을 생성자에서 `initialize list`로 **초기화하지 않아도 된다는 점** 이라고 생각합니다.\n정확히 말하자면, 생성자를 내부에서 호출함으로서 생성자 호출 전, `전처리`를 할 수 있다는 점이 이점이라고 생각합니다.\n\n예시를 봐야겠죠?\n\n```dart:.dart {7-10}\nclass Human {\n  final String name;\n\n  Human(this.name);\n\n  // Human.withSir(String name) : this.name = 'Sir - ' + name;\n  factory Human.withSir(String name) {\n    String newName = 'Sir - ' + name;\n    return Human(newName);\n  }\n}\n\nvoid main() {\n  Human man = new Human.withSir('h1');\n\n  print(man.name);\n}\n```\n\n위 코드에서 주석처리 된 부분과 하이라이트 된 부분 모두 동일한 기능을 수행합니다.\n지금은 간단하게 문자열 앞에 `Sir - `을 붙이도록 했지만, 만약 배열을 직렬화 해야하는 상황이라면?\n한 줄로 처리하기 복잡한 기능은 분명 일반 생성자의 initialize list로 처리하는덴 한계가 있을 것입니다.\n\n\u003ctip\u003e\n  한 줄로 처리하기 복잡한 코드는 예로들어 `json serialize` 부분이 있겠죠?\n  \u003cbr /\u003e\n  그래서 우리가 무의식적으로 사용하던 factory가 사실은 인스턴스 생성을 편-안하게 생성하기 위해 사용했던 것이었습니다!\n\u003c/tip\u003e\n\n---\n\n## get, set\n\ngetter, setter 메서드를 이용해서 객체의 가상 멤버변수(`property`)를 읽고 쓰는게 가능해진다는 건 다른 객체지향 언어에도 있는 기능입니다.\ndart에선 이를 가능케 하는 키워드가 `get`, `set` 입니다.\n\n공식문서에 있는 코드를 분석해봅시다.\n\n```dart:.dart\nclass Rectangle {\n  double left, top, width, height;\n\n  Rectangle(this.left, this.top, this.width, this.height);\n\n  // right, bottom 이라는 두 개의 계산된 프로퍼티 정의.\n  double get right =\u003e left + width;\n  set right(double value) =\u003e left = value - width;\n  double get bottom =\u003e top + height;\n  set bottom(double value) =\u003e top = value - height;\n}\n\nvoid main() {\n  var rect = Rectangle(3, 4, 20, 15);\n\n  print(rect.right); // 23.0\n  print(rect.left);  // 3.0\n  rect.right = 20;\n  print(rect.right); // 20.0\n  print(rect.left);  // 0.0\n}\n```\n\n제 개인적인 생각에는 get은 가상의 멤버변수를 만들어서 이를 사용하게 해주고,\nset은 이 가상의 멤버변수를 위해 처리해야 하는 기능을 함수 내부에서 별도로 처리하게 해준다가 주된 사용법인거 같습니다.\n\n\u003cnotice\u003e\n  제가 `가상`의 멤버변수라고 표현한 이유는, get으로 정의된 변수는 그 자체가 특정 값을 저장할 수 없고, 별도로 정의된 멤버변수에 의존해야 하기 때문입니다.\n\u003c/notice\u003e\n\n### interface\n\n그렇다면 get, set을 언제 사용해야 잘 사용한걸까요?\n보통은 멤버변수를 `은닉화`하고 이를 `접근제어`를 할 때 사용하는 방식이 대부분일 것입니다.\n\n하지만, 개인적으로 `인터페이스`를 구현할 때 역시 get의 적절한 사용처라고 개인적으로 생각합니다.\n예를 들어봅시다.\n\n```dart:.dart {2}\nabstract class IColor {\n  String get color;\n}\n\nclass Car implements IColor {\n  final String name;\n  @override\n  final String color;\n\n  Car(this.name, this.color);\n}\n\nclass Boat implements IColor {\n  final String name;\n  @override\n  final String color;\n\n  Boat(this.name, this.color);\n}\n\nvoid main() {\n  Car car = Car('car1', 'red');\n  Boat boat = Boat('boat1', 'red');\n\n  print(car.color == boat.color); // true\n}\n```\n\n\u003ctip\u003e\n  dart에선 abstract class로 구현해도 될 정도로 interface의 의미가 약합니다.\n  최근에는 interface 키워드가 추가되었으나, implements 하는 것이 아닌 extends 해도 에러가 안 날정도로 중요하진 않은 거 같습니다.\n  abstract interface와 같이 키워드를 중복해서 쓰는 경우도 있으므로 자세한 내용은 [**`공식문서`**](https://dart.dev/language/class-modifiers#interface)를 참고해주세요.\n\u003c/tip\u003e\n\n두 클래스간 `필요에 따라` 공통속성을 갖고싶게 할 때 interface를 사용하곤 하는데요,\ndart는 `null-safety` 언어이기 떄문에, get 키워드가 없다면 **abstract class라 하더라도 멤버변수를 초기화** 해줘야만 합니다.\n그러면 코드가 아래처럼 복잡해지겠죠.\n\n```diff-dart:.dart {2}\n  abstract class IColor {\n    String color;\n\n+   IColor(this.color);\n  }\n\n  class Car implements IColor {\n    final String name;\n    @override\n    final String color;\n\n    Car(this.name, this.color);\n\n+   @override\n+   set color(String _color) {\n+     color = _color;\n+   }\n  }\n```\n\n## stream\n\n비동기의 4번타자, `future`는 완료되지 않은 연산을 나타냅니다.\n비동기 함수가 return을 해야만 future은 연산이 완료되었다는 것을 알려줍니다.\n\n그에 반면, `stream`은 **일련, iterable**한 비동기 이벤트입니다.\n따라서 iterable과 같이 동작하게 됩니다만, 그 과정이 비동기인 것이죠.\n\n즉, future은 요청시 다음에 올 이벤트를 받는 방식이라면,\nstream은 준비가 된 후 이벤트가 있음을 알려주는 방식입니다.\n\n### async* / yield\n\n`async*`는 async와 마찬가치로 이 함수가 비동기 함수라는 것임을 선언하는 키워드 입니다.\n차이점은 이 함수는 `Stream\u003cT\u003e`을 반환하기 때문에 일련의 비동기로 연산된 결과를 반환하게 됩니다.\n즉, **지속적으로 값을 반환**하기 위해 `yield` 키워드가 return을 대신하여 값을 반환합니다.\n_(return 키워드는 여기서 사용 불가합니다)_\n\n예시를 살펴봅시다.\n\n```dart:.dart\nFuture\u003cint\u003e sumStream(Stream\u003cint\u003e stream) async {\n  var sum = 0;\n  await for (final value in stream) {\n    print('get stream value $value');\n    sum += value;\n  }\n  return sum;\n}\n\nStream\u003cint\u003e countStream(int to) async* {\n  for (int i = 1; i \u003c= to; i++) {\n    await Future.delayed(Duration(milliseconds: 200));\n    print('stream $i ready');\n    yield i;\n  }\n}\n\nvoid main() async {\n  var stream = countStream(3);\n  var sum = await sumStream(stream);\n  print(sum);\n}\n```\n\n\u003e (0.2초 대기)\n\u003e stream 1 ready\n\u003e get stream value 1\n\u003e (0.2초 대기)\n\u003e stream 2 ready\n\u003e get stream value 2\n\u003e (0.2초 대기)\n\u003e stream 3 ready\n\u003e get stream value 3\n\u003e 6\n\nStream 역시 비동기로 처리되는 **일련**의 연산이라는 것을 알려주는 객체이기 때문에,\n실제 연산 결과를 받으려면 await을 사용해서 값이 전달받을 때 까지 대기해야 합니다.\n\n따라서, dart에서는 `await for` 키워드를 제공하여 iterable한 비동기 이벤트를 처리할 수 있도록 도와줍니다.\n\n\u003ctip\u003e\n  동기적은 `Iterable\u003cT\u003e` 객체를 반환하고 싶다면 `sync*` / `yield` 키워드를 사용하면 됩니다.\n\u003c/tip\u003e\n\n\u003ctip\u003e\n  stream은 파일읽기와 같이 한 번의 요청이 있으면 처음부터 끝까지 끊김없이 진행되어야 하는 `Single subscription streams`, \n  브라우저의 마우스 이벤트와 같이 Observer pattern을 사용하기에 언제든지 누구나 stream을 들을 수 있는 `Broadcast streams` 으로 나뉩니다.\n  \u003cbr /\u003e\n  뿐만 아니라, stream은 iterable한 성격을 갖는다 했었는데, 이런 stream을 제어할 수 있는 여러 메서드 또한 존재합니다.\n  따라서 자세한 내용은 [**`공식문서`**](https://dart-ko.dev/tutorials/language/streams#working-with-streams)를 참고하시는걸 추천 드립니다.\n\u003c/tip\u003e\n\n## mixin, with\n\n간단하게 말하면 class \u0026rarr; `mixin`, extends \u0026rarr; `with`와 같은 개념입니다.\n물론 이해를 돕기위해 위와같이 적었을 뿐, 완전히 다른 키워드이니 혼동하지 마시길 바랍니다.\n\n클래스를 상속할 때는 부모 클래스에서 미리 정의된 변수나 메서드를 자식 클래스에서 구현하지 않아도 바로 사용할 수 있습니다.\n하지만, 계층구조를 나타내기 위해 **반드시 한 개의 클래스를 상속**해야 한다는 단점이 있죠.\n\n여러개의 자료 구조를 공유하기 위해서는 인터페이스를 구현 하는 방법으로 사용해야 합니다.\n하지만, 인터페이스는 말 그대로 틀만 제공하고 **구현은 별도로 해야한다**는 단점이 있습니다.\n\n이 떄, extends와 implements의 **중간 포지션**에 위치한 키워드가 with이고, with은 mixin을 받을 수 있습니다.\n\n```dart:.dart\nmixin SwimBehabior {\n  void swim() {\n    print('swim');\n  }\n}\n\nmixin FlyBehiabior {\n  void fly() {\n    print('fly');\n  }\n}\n\nclass Duck {\n  final String name;\n\n  Duck(this.name);\n}\n\nclass RealDuck extends Duck with SwimBehabior, FlyBehiabior {\n  RealDuck(super.name);\n}\n\nclass RubberDuck extends Duck with SwimBehabior {\n  RubberDuck(super.name);\n}\n\nvoid main() {\n  RealDuck duck = RealDuck('duck');\n\n  duck.fly();\n  duck.swim();\n}\n```\n\n이런식으로 implements 처럼 여러 인터페이스를 사용할 수 있지만, extends 처럼 재정의할 필요 없이 사용할 수 있습니다.\n하지만, mixin을 사용할 때는 클래스 구성요소가 `매우 세분화` 되어있는게 좋습니다.\n이런저런 메서드를 잔뜩 만들어놓으면 상속했을 때 **필요없는 기능도 수행**할 수 있는 상황이 발생할 수 있기 때문입니다.\n\n이런 상황이 생길 가능성이 있는 코드는 mixin 보단 `Strategy pattern`으로 구현하는 것이 더 좋습니다.\n\n```dart:.dart {18, 22-24}\nabstract class SwimBehavior {\n  void swim();\n}\n\nabstract class FlyBehavior {\n  void fly();\n}\n\nclass CanSwim implements SwimBehavior {\n  @override\n  void swim() {\n    print('swim');\n  }\n}\n\nclass Duck {\n  final String name;\n  SwimBehavior swimBehavior;\n\n  Duck(this.name, this.swimBehavior);\n\n  void performSwim() {\n    swimBehavior.swim();\n  }\n}\n\nclass RealDuck extends Duck implements FlyBehavior {\n  RealDuck(String name) : super(name, CanSwim());\n\n  @override\n  void fly() {\n    print('fly');\n  }\n}\n\nclass RubberDuck extends Duck {\n  RubberDuck(String name) : super(name, CanSwim());\n}\n\nvoid main() {\n  RealDuck real = RealDuck('duck');\n  RubberDuck rubber = RubberDuck('duck');\n\n  real.performSwim();\n  real.fly();\n  rubber.performSwim();\n}\n```\n\n사실 mixin을 사용하지 않더라도 class의 `상속 depth를 깊게` 하는 방법도 있으니, 본인의 상황에 맞게 취사선택을 잘 하는 것이 좋은 개발습관이 될 것입니다.","slug":"flutter/005_dart_expert","readingMinutes":17,"wordCount":1610},{"title":"Dart 언어 심화","description":"Dart 언어에 대한 심화된 내용을 정리해봤습니다.","icon":"","image":"","tags":["Dart","Asynchronous","Isolate","Callback"],"draft":false,"date":"2023-09-15 / 11:24","content":"\n\u003cnotice\u003e\n  기초적인 지식이 필요하신 분들은 [**`Dart 언어 기초`**](https://wjlee611.github.io/blog/flutter/003_dart_basic) 포스트를 읽어보시길 권장드립니다.\n\u003c/notice\u003e\n\n## async / await\n\n`async`, `await` 키워드는 **비동기 프로그래밍**시 빠지지 않는 키워드입니다.\n여기서 `.then()` 메서드나 Dart 에서 `Future\u003cT\u003e` 도 포함해서 원리와 적절한 사용법까지 알아보고자 합니다.\n\n\u003ctip\u003e\n  `비동기 프로그래밍`\n  특정 코드가 완료되기 전, 다른 코드를 수행함으로서 코드의 실행 순서가 순차적(동기적)으로 실행되지 않는 프로그래밍 방식입니다.\n  보통 처리완료까지 시간이 많이 걸리는 네트워크 통신이나 파일 입출력 등에 많이 사용됩니다.\n\u003c/tip\u003e\n\n\u003cnotice\u003e\n  비동기 처리는 `단일 스레드(Dart의 경우 단일 Isolate) 환경`에서 이루어집니다.\n  따라서 비동기 처리를 한다고 해도, 비동기 함수가 `컴퓨팅 자원 사용량이 많다`면 해당 스레드(Isolate)는 `일시 정지`되는 현상이 발생할 수 있습니다.\n  \u003cbr /\u003e\n  이와 관련한 자세한 내용은 아래 [**`Isolate`**](https://wjlee611.github.io/blog/flutter/004_dart_advanced#isolate) 파트에서 다루겠습니다.\n\u003c/notice\u003e\n\n### Future\n\n`Future` 객체는 지금 당장은 처리되지 않았지만, 미래에 처리가 완료될 데이터를 알려주는 객체입니다.\n예를 들어봅시다.\n\n```dart:.dart\nFuture\u003cString\u003e futureStr() async {\n  print('do something');\n  return Future.delayed(Duration(seconds: 2), () =\u003e 'future string');\n}\n\nvoid main() {\n  print('start');\n  print(futureStr());\n}\n```\n\n위의 futureStr() 함수는 호출 후 2초뒤에 'future string'을 반환하는 함수입니다.\n실행결과는 어떻게 될까요?\n\n\u003e start\n\u003e do something\n\u003e Instance of 'Future\\\u003cString\\\u003e'\n\u003e (2초 후 종료)\n\n답은 `future 객체` 입니다.\n어찌보면 당연합니다. `main` 함수는 비동기 함수도 아닐 뿐더러 futureStr의 리턴값은 `Future\u003cString\u003e` 이라고 명시해두었으니 말이죠.\n\n![230917-211924](/posts/004_dart_advanced/230917-211924.png)\n\nfuture는 `Uncompleted`, `Completed` 상태를 갖습니다.\n비동기 함수 호출시에 future은 Uncompleted 상태를 갖습니다.\n따라서 `Instance of 'Future\u003cString\u003e'`와 같은 결과를 출력한 것이죠.\n하지만 함수가 성공적으로 종료되면 future은 비로소 Completed 상태를 갖습니다.\n따라서 `future string`과 같은 결과를 출력하게 될 것입니다.\n\n사용자 입장에서는 Future 객체는 중요하지 않습니다. 중요한 것은 Future 객체가 처리되고 나서 반환되는 데이터인거죠.\n따라서, Future 객체의 처리(비동기 함수)를 원활히 하기위해 `async`, `await` 키워드를 사용하는 것입니다.\n\n### async\n\nasync 키워드는 이 함수가 비동기 처리를 수행하는 함수임을 명시하는 키워드 입니다.\n다만 위의 예시에서 보듯, 반드시 `Future\u003cT\u003e` 객체 또는 `void`를 반환해야만 합니다.\n\n그렇다면, main 함수를 async 키워드를 붙여 실행한다면 제대로된 결과가 나올까요?\n\n```dart:.dart\nFuture\u003cString\u003e futureStr() async {\n  print('do something');\n  return Future.delayed(Duration(seconds: 2), () =\u003e 'future string');\n}\n\nvoid main() async {\n  print('start');\n  print(futureStr());\n}\n```\n\n\u003e start\n\u003e do something\n\u003e Instance of 'Future\\\u003cString\\\u003e'\n\u003e (2초 후 종료)\n\n그렇습니다. 함수를 비동기 처리하는 함수로 선언한다고 해서 해결되지는 않습니다.\n함수 내부에서 비동기 처리가 진행될 수 있다는 것을 암시할 뿐, `어디서` 비동기 처리를 해야하는 지는 명시하지 않았기 때문이죠.\n\n### await\n\nawait 키워드는 **해당 키워드가 명시된 비동기 처리**(futureStr)가 완료될 때 까지 **비동기 함수**(main)의 처리를 `멈추겠다`는 의미입니다.\n그렇기에 await 키워드는 반드시 async 키워드가 명시된 함수 내부에서만 사용할 수 있는 것입니다.\n\n그렇다면 futureStr의 함수 앞에 await를 명시하여 비동기 함수가 끝날 때 까지 대기시킨다면 어떨까요?\n\n```dart:.dart\nFuture\u003cString\u003e futureStr() async {\n  print('do something');\n  // return Future.delayed(Duration(seconds: 2), () =\u003e 'future string');\n  await Future.delayed(Duration(seconds: 2));\n  return 'future string';\n}\n\n\nvoid main() async {\n  print('start');\n  print(await futureStr());\n}\n```\n\n\u003e start\n\u003e do something\n\u003e (2초 대기)\n\u003e future string\n\u003e (즉시 종료)\n\n비로소 원하던 결과가 나왔습니다.\n\n---\n\n## Isolate\n\n`Isolate`는 Dart에서 스레드를 부르는 용어라고 생각하시면 됩니다.\n\n![230917-221122](/posts/004_dart_advanced/230917-221122.png)\n\nIsolate는 스레드와 마찬가지로 멀티 코어 CPU의 장점을 살리는 프로그래밍 기법으로 `별도의 이벤트 루프`를 갖는 실행 흐름을 만들어 `병렬적인 처리`를 가능케 합니다.\n하지만, 스레드와 용어에서의 차이점을 두는 이유가 있습니다.\n\n보통 **스레드**라 하면 `메모리 영역을 공유`한다고 배웠습니다. 하지만 그 때문에 `race-condition`이 발생하는 문제점을 고려하여 프로그래밍을 했어야 합니다.\n\n하지만, **Isolate**는 스레드와 다르게 `메모리 영역 또한 공유하지 않습니다`.(물론 코드 영역은 공유합니다) \n그렇기에 mutex, lock 등을 고려할 필요가 없는 편의성이 있습니다.\n\n하지만 왜 Isolate를 알아야 하고, 사용해야만 할까요?\n\n### Isolate vs Async\n\n아래의 영상을 확인해봅시다.\n\n\u003cYT id='HkBaS098BrE' /\u003e\n\n`Main isolate`부분은 json 데이터 파싱과 화면 빌드를 `하나의 isolate`에서 구동한 결과입니다.\n영상에서 보시는 바와 같듯 십몇만줄의 json 파싱은 단일 isolate 환경에서 구동하기에는 다소 무리가 있습니다.\n아무리 async로 실행 결과를 뒤로 미룬다 할지라도 실제 데이터 파싱하는 동작과 화면을 그리는 동작 모두 `동일한 isolate`에서 처리되기 때문에 `성능상 이슈`가 생길 수 밖에 없습니다.\n\n하지만 `Worker isolate`부분은 json 데이터 파싱을 `별도의 worker isolate`에서 구동한 결과입니다.\n차이는 명확합니다. 화면에 그리는 동작과 파싱 동작이 `별도의 isolate`에서 처리되기 때문에 화면을 그리는 부분에서 `랙이 걸리지 않습니다`.\n\n이렇듯 단일 isolate에서 동작이 버벅일 정도로 무거운 기능을 수행해야 한다면, 해당 기능은 별도의 isolate로 빼서 처리하는 것이 사용자에게 더 나은 경험을 제공하게 됩니다.\n\n해당 영상에서 구동하는 코드는 [**`Arkhive repo`**](https://github.com/wjlee611/arkhive/blob/main/lib/bloc/enemy/enemy_data/enemy_data_bloc.dart)에서 확인하실 수 있습니다.\n\n---\n\n## function\n\n### callback function\n\n콜백 함수는 함수의 인자로 넘겨주어 넘겨받은 함수 내부에서 실행 가능한 함수를 의미합니다.\n예시를 살펴봅시다.\n\n```dart:.dart\nvoid main() {\n  int value = 0;\n\n  print(valueModifire(value: value, modifire: add1)); // 1\n  print(valueModifire(value: value, modifire: sub1)); // -1\n}\n\nint add1(int value) =\u003e value + 1;\nint sub1(int value) =\u003e value - 1;\n\nint valueModifire({\n  required int value,\n  required Function(int) modifire,\n}) {\n  return modifire(value);\n}\n```\n\n위 코드에서는 `valueModifire`의 인자로서 `add1`, `sub1`을 전달했습니다.\n이 때, 이 두 함수를 `callback function`라고 부르고, 이 함수는 valueModifire 내부에서 `modifire`의 형태로 호출됩니다.\n\n보통은 이런식으로 `동일한 함수` 내부에서 `서로 다른 기능`을 수행해야 할 때 콜백 함수로서 전달하는 경우가 많습니다.\n\n```dart:.dart\nvoid main() async {\n  int value = 0;\n\n  print(await valueModifire(value: value, modifire: add1)); // await 1 second -\u003e 1\n  print(await valueModifire(value: value, modifire: sub1)); // await 1 second -\u003e -1\n}\n\nint add1(int value) =\u003e value + 1;\nint sub1(int value) =\u003e value - 1;\n\nFuture\u003cint\u003e valueModifire({\n  required int value,\n  required Function(int) modifire,\n}) async {\n  await Future.delayed(Duration(seconds: 1)); // something actions\n  return modifire(value);\n}\n```\n\n또는, `특정 함수의 동작이 끝난 후` 수행해야 할 기능이 있을 때 많이 사용되곤 합니다.","slug":"flutter/004_dart_advanced","readingMinutes":10,"wordCount":836},{"title":"Dart 언어 기초","description":"Dart 언어에 대한 기초지식을 정리해봤습니다.","icon":"","image":"","tags":["Dart"],"draft":false,"date":"2023-09-14 / 17:41","content":"\n\u003cwarning\u003e\n  제가 생각하기에 **너무 기초지식**이다 하는 부분은 과감하게 **제외**했습니다.\n  다만, 기초지식이다 하더라도 `개념적으로 매우 중요`하거나 `많이들 알려주지 않는 내용`은 포함하였습니다.\n\u003c/warning\u003e\n\n## variables\n\n변수 네이밍 방법은 다음과 같습니다.\n\n```dart:.dart\n  \u003c제어자\u003e \u003c타입\u003e \u003c변수이름\u003e = \u003c값\u003e;\n```\n\n타입은 int, String 과 같은 타입들이 오거나, `var` 와 같은 타입 추론 키워드도 사용할 수 있습니다.\n제어자에는 `final`, `const`, `late`, `static` 와 같은 키워드가 오게 됩니다.\n\n### var\n\ndart에선 var는 타입 추론 키워드로 사용되는 예약어입니다.\n따라서 `\u003c값\u003e`에 어떤 데이터가 오는지에 따라 변수의 타입이 결정됩니다.\n단, 값을 지정하지 않을 때는 `dynamic` 타입으로 자동 결정됩니다.\n\n\u003ctip\u003e\n  `dynamic?`\n  타입 안정성이 보장되지 않지만, 모든 타입의 데이터를 할당할 수 있도록 해줍니다.\n  보통 json 파일을 파싱할 때 임시로 데이터 형식을 지정할 때 많이 사용합니다.\n\u003c/tip\u003e\n\n### final vs const\n\n`final`과 `const` 둘 모두 데이터의 불변성을 보장하고 싶을 때 사용하는 키워드 라는 점에서는 공통점을 갖습니다.\n또한, 이 키워드를 사용한다면 타입을 굳이 지정하지 않아도 알아서 `var`로 타입을 지정하는 효과가 있습니다.\n하지만 둘 사이의 중요한 차이점이 있습니다.\n\n`final`은 런타임에 값이 지정됩니다.\n따라서 메모리상의 `heap 영역`에 데이터가 저장됩니다.\n그렇기에 생명주기는 스코프 내부로 한정되기 떄문에 flutter 에서 **build 메서드**가 호출될 때 이 부분은 `반복적`으로 메모리에 올라왔다 내려갔다를 반복하게 됩니다.\n\n`const`는 컴파일타임에 값이 지정됩니다.\n특이한 점인 const 키워드로 지정된 데이터는 메모리상에 별도로 적재되지 않고, `컴파일된 코드의 상수 풀(constant pool)`상에 저장됩니다.\n따라서 별도의 인스턴스가 생성되지 않고, 생명주기도 프로그램 수명과 동잃하기에 flutter 에서 **build 메서드**가 호출될 때 이 부분은 `다시 랜더링되지 않습니다`.\n\n### late\n\ndart는 **null-safety** 언어입니다.\n따라서 `\u003c타입\u003e?` 와 같이 `?`로 null값이 가능하다고 지정해 주지 않는한 변수 선언시(혹은 인스턴스 생성시) 반드시 값을 지정해야 합니다.\n하지만, `late`의 경우에는 인스턴스 생성 시점에 null값을 허용하지만, 이후에 `단 한번` 값을 할당할 수 있도록 해주는 키워드입니다.\n\n물론, null값이 임시 허용이 되는만큼 사용에 주의가 필요합니다.\n\n### static\n\n`static`은 클래스가 로드될 때 값이 지정됩니다.\n따라서 heap영역이 아닌 `클래스 자체 메모리 영역`에 저장됩니다.\n그렇기에 일반 메서드에선 static 변수에 접근할 수 있지만, static 메서드에선 일반 변수에 접근할 수 없습니다.\n하지만 그렇기에 클래스를 인스턴스화 하지 않아도 바로 접근이 가능합니다.\n\n---\n\n## function\n\ndart는 사실 js를 대체하기 위해 나온 언어라고 합니다.\n그래서일까요, dart의 모든 데이터 타입도 사실은 모두 `Object`입니다.\n\n뿐만 아니라, `변수에 함수를 할당`하거나, `익명 함수`, `람다 함수` 모두 사용 가능합니다.\n\n### named parameter\n\n보통 함수의 파라미터는 아래와 같이 작성하곤 합니다.\n\n```dart:.dart\n  void myFunction(int num) {\n    ...\n  }\n  ...\n  myFunction(1);\n```\n\n하지만 입력받고자 하는 파라미터가 많아진다면, 인자를 넘겨줄 때 어느 자리에 어느 데이터를 넘겨야 할지 알기가 어렵습니다.\n특히 flutter에서는 위젯을 만들 때 인자를 십수개씩 넘기는 경우가 많죠...\n\n그렇기에 `named parameter` 기능을 제공합니다. (마치 js에서 객체를 인자로 넘기 듯)\n\n```dart:.dart\n  void myFunction({required int myNum}) {\n    ...\n  }\n  ...\n  myFunction(myNum: 1);\n```\n\n이렇게 하면 함수 호출이나, 클래스 생성자 호출시 어느 인자에 어느 데이터를 넘겨야 하는지 명확해집니다.\n\n물론, 위 두 방식을 `혼합`하여 사용할 수도 있습니다.\n\n```dart:.dart\n  void myFunction(String str, {required int val}) {\n    ...\n  }\n  ...\n  myFunction(\"string\", myNum: 1);\n```\n\n---\n\n## class\n\n### constructor\n\n```dart:.dart\nclass Car {\n  final String color;\n  int wheels;\n  String? name;\n\n  Car({\n    required this.color,\n    required this.wheels,\n    this.name,\n  });\n}\n```\n\n기본적으로 생성자는 위와 같이 정의할 수 있습니다.\n`named parameter` 형식으로도 사용이 가능합니다. (대부분의 flutter 위젯은 위와 같이 정의합니다)\n\n### named constructor\n\n```dart:.dart\nCar {\n  final String color;\n  late int wheels;\n  String? name;\n\n  Car.fourWheels({required this.color, this.name}) {\n    this.wheels = 4;\n  }\n}\n```\n\n클래스를 생성할 때 특별한 기능을 붙인채로 인스턴스화 할 수 있도록 `named constructor`를 지원합니다.\n보통 초기상태를 위한 `.init`, 모델링을 위한 `.fromJson`와 같이 쓰이곤 합니다.\n(참고로 이 때 factory 키워드를 이용해서 싱글톤 패턴으로 많이 구현하는데 이는 다음에 소개하겠습니다)\n\n### initializer list\n\n위에 `wheels`을 별도로 초기화하기 위해 late 한정자를 사용했는데요, 보기가 안좋습니다.\n`final` 멤버변수는 생성자 body에서 값을 지정할 수 없기에 저런식으로 표현했는데요,\n`initializer list`를 이용하면 final 멤버변수도 생성자 호출시 별도로 처리할 수 있습니다.\n\n```dart:.dart\nclass Car {\n  final String color;\n  final int wheels;\n  String? name;\n\n  Car.prototype({required this.color}) : wheels = 4 {\n    this.name = 'proto';\n  }\n}\n```\n\n`:`를 붙여 `: wheels = 4`와 같이 사용할 수 있습니다.\n또한, 뒤에 body를 붙여 추가작업 또한 할 수 있습니다.\n\ninitializer **list**에서 알 수 있듯 `wheels = 4` 와 같은 initializer를 `,`를 이용해서 여려개 연달아 초기화할 수 있습니다.\n\n### redirecting constructor\n\n```dart:.dart\nclass Car {\n  final String color;\n  final int wheels;\n  String? name;\n\n  Car({\n    required this.color,\n    required this.wheels,\n    this.name,\n  });\n\n  Car.fourWheels({required String color, String? name})\n      : this(\n          color: color,\n          wheels: 4,\n          name: name,\n        );\n}\n```\n\n기존의 생성자를 `this`로 호출하여 named constructor를 구현한 방식입니다.\n다만, 이 경우에는 생성자의 body를 구현할 수 없습니다.\n","slug":"flutter/003_dart_basic","readingMinutes":9,"wordCount":703},{"title":"플러터 프로젝트 만들기","description":"플러터 프로젝트 생성 가이드 입니다.","icon":"","image":"","tags":["Flutter","Getting started"],"draft":false,"date":"2023-09-14 / 16:37","content":"\n## 시작 전 주의사항\n\n\u003cnotice\u003e\n  이 포스트에선 플러터 프로젝트를 생성하는 방법을 다뤄봅니다.\n  따라서 플러터 SDK 설치나, 관련 환경설정이 안되신 분은 [**`플러터 시작하기`**](https://wjlee611.github.io/blog/flutter/001_installation)를 꼭 읽어보시고 다시 와주시기 바랍니다.\n\u003c/notice\u003e\n\n\u003cnotice\u003e\n  본 블로그의 플러터 개발환경은 `VSCode`와 `터미널`로 고정됩니다.\n  따라서 다른 개발환경에 대한 정보는 없으므로 이 점 참고 부탁드립니다.\n\u003c/notice\u003e\n\n## 프로젝트 생성\n\n프로젝트 생성을 위해 우선 본인이 프로젝트를 관리할 폴더로 이동해주세요.\n제 경우에는 깃허브로 버전관리를 하는 프로젝트의 경우 `~/Documents/GitHub` 폴더에서 일괄적으로 관리하는 편입니다.\n\n```bash:Terminal\ncd ~/Documents/GitHub\n```\n\n이후에는 아래의 명령어로 플러터 프로젝트를 생성합니다.\n\n```bash:Terminal\nflutter create \u003cproj_name\u003e\n```\n\n이 때, 프로젝트를 생성할 때 알아두면 유용한 (거의 필수) 몇 가지 옵션을 소개드립니다.\n\n### --org\n\n이 옵션을 지정하면 프로젝트를 생성할 때 패키지명을 지정할 수 있습니다.\n\n```bash:Terminal\nflutter create \u003cproj_name\u003e --org \u003cpackage_name\u003e\n```\n\n\u003cnotice\u003e\n  \\\u003cpackage_name\\\u003e이 100% 동일하게 패키지 이름이 되는 것은 아닙니다.\n  옵션명에서 유추할 수 있듯 기관의 이름을 적는 것입니다.\n\n  따라서 진짜 패키지 이름은 `\u003cpackage_name\u003e.\u003cproj_name\u003e` 형식이 됩니다.\n\u003c/notice\u003e\n\n예로들어 아래와 같이 프로젝트를 생성했다고 가정해봅시다.\n\n![230914-164837](/posts/002_project_initalize/230914-164837.png)\n\n이 경우에는 프로젝트명 - `gdsc_study` / 패키지명 - `com.gmail.wjlee611` 입니다.\n따라서 프로젝트에서 실제로 적용되는 패키지명은 아래와 같아집니다.\n\n![230914-165226](/posts/002_project_initalize/230914-165226.png)\n\n\u003e Android - `com.gmail.wjlee611.gdsc_study`\n\u003e iOS - `com.gmail.wjlee611.gdscStudy`\n\n같은 명령어라도 다른 패키지명이 생성되니 나중에 앱을 배포할 때 반드시 패키지명을 확인하도록 합시다.\n\n### -i swift\n\n기본적으로 생성되는 iOS 코드는 `Objective-C` 입니다.\n하지만 이 옵션을 추가하면 `Swift`로 생성되게 됩니다.\n\n### -a kotlin\n\n기본적으로 생성되는 Android 코드는 `Java` 입니다.\n하지만 이 옵션을 추가하면 `Kotlin`으로 생성되게 됩니다.\n\n\n","slug":"flutter/002_project_initalize","readingMinutes":3,"wordCount":223},{"title":"플러터 시작하기","description":"플러터 설치 및 VSCode 세팅 가이드입니다.","icon":"","image":"","tags":["Flutter","VSCode","Package manager"],"draft":false,"date":"2023-09-13 / 21:12","content":"\n## 들어가며...\n\n이 포스트에선 플러터(Flutter) 개발을 시작할 때 세팅해야할 전 과정에 대해 설명합니다.\nFlutter SDK 설치부터 에뮬레이터 세팅, VSCode 세팅, 추가로 유용한 단축키에 대해서 알아봅니다.\n다만, 단축키는 운영체제, 에디터 환경, 설정에 따라 다를 수 있으니 이점 참고 바랍니다.\n\n\u003cnotice\u003e\n  **이미 설치를 완료하신 분들도 시간 내셔서 [**`VSCode 세팅`**](https://wjlee611.github.io/blog/flutter/001_installation#vscode-%EC%84%B8%ED%8C%85)부터 읽어보시는 것을 강력 추천드립니다.**\n\u003c/notice\u003e\n\n블로그 주인장은 M1 Mac 환경에서 세팅하였기에 리눅스 계열 세팅방법을 기준으로 다뤄봅니다만,\n윈도우 머신에서의 세팅도 다뤄볼 겁니다. (다만, 실제 테스트는 하지 않았기에 오류가 있을지도 모릅니다)\n\n참고로 아래의 모든 설치과정은 [**노마드코더**](https://nomadcoders.co/flutter-for-beginners)의 강좌를 정리한 자료입니다.\n\n- https://nomadcoders.co/flutter-for-beginners/lectures/4133\n- https://nomadcoders.co/flutter-for-beginners/lectures/4142\n\n---\n\n## Flutter SDK 설치\n\nFlutter SDK를 설치할 때 방법이 크게 두 가지로 나뉩니다.\n첫 번째는 Flutter 공식 사이트에서 제공하는 방식을 따라가는 방법\n두 번째는 패키지 매니저를 이용해서 설치하는 방법\n\n제 개인적인 생각에는 패키지 매니저를 이용하는 방법이 더 간단해 보입니다.\n첫 번째 방법을 따라하려면 환경 PATH도 설정해야 하기에 좀 무서워 보이기 때문이죠...\n~_(그리고 제가 이 방법밖에 안해보기도 했구요...)_~\n\n그래도 일단은 두 방법 모두 소개해 드리겠습니다.\n\n### 공식 사이트\n\n1. [**플러터 공식 페이지**](https://flutter.dev)로 접속합니다.\n\n2. `Get started`로 들어갑니다.\n   ![230913-211858](/posts/001_installation/230913-211858.png)\n\n3. 본인 운영체제에 맞는 Flutter SDK를 설치합니다.\n   ![230913-212121](/posts/001_installation/230913-212121.png)\n\n   이후에는 공식 사이트에서 제공하는 문서를 천천히 따라하시면 됩니다.\n\n---\n\n### 패키지 매니저 (MacOS)\n\n1. [**Homebrew**](https://brew.sh/)에 들어갑니다.\n   ![230913-214251](/posts/001_installation/230913-214251.png)\n\n\u003cnotice\u003e\n  _참고로 Homebrew는 MacOS에서 사용할 수 있는 **대부분의 개발자도구를 터미널로 설치할 수 있는 강력한 도구**입니다._\n  _Flutter가 아니더라도 **반드시** 설치하는게 정신건강에 이롭습니다._\n\u003c/notice\u003e\n\n2. `터미널`을 열어줍니다.\n\n3. 아래의 명령어를 입력하여 Homebrew를 설치합니다.\n   (공식 사이트에서 복사하는 것을 권장합니다)\n\n```bash:Terminal\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n4. 아래의 명령어로 Flutter SDK를 설치합니다.\n\n```bash:Terminal\nbrew install --cask flutter\n```\n\n---\n\n### 패키지 매니저 (Windows)\n\n1. [**Chocolatey - individual**](https://chocolatey.org/install#individual)에 들어갑니다.\n   ![230913-213419](/posts/001_installation/230913-213419.png)\n\n2. `PowerShell`을 관리자 권한으로 실행합니다.\n\n3. 아래의 명령어를 입력하여 Chocolatey를 설치합니다.\n\n```shell:PowerShell\nGet-ExecutionPolicy\n```\n\n만약 `Restricted` 라고 뜬다면 아래의 명령어 중 하나를 입력하면 됩니다.\n\n```shell:PowerShell\nSet-ExecutionPolicy AllSigned\n또는\nSet-ExecutionPolicy Bypass -Scope Process\n```\n\n그 이후에 아래의 긴- 명령어를 입력합니다.\n(공식 사이트에서 복사하는 것을 권장합니다)\n\n```shell:PowerShell\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n```\n\n`Chocolatey` 설치가 완료되었다면 `choco` 라는 명령어가 실행 가능할 겁니다.\n\n4. 아래의 명령어로 Flutter SDK를 설치합니다.\n\n```shell:PowerShell\nchoco install flutter\n```\n\n### 설치 확인 방법 (1)\n\n터미널 창에 `flutter` 를 입력해봅시다.\n`Command not found` 와 같은 에러를 제외하고 뭐라도 뜬다면 설치가 완료된 것입니다.\n\n---\n\n## 애뮬레이터 설치\n\n아래의 공식 문서를 통해 설치하는 것이 가장 바람직합니다.\n설명도 친절해서 왠만하면 설치하는데 문제가 없을겁니다. (아예 없진 않음...)\n관련 링크를 아래에 정리합니다.\n\n🫧[**MacOS - ios setup**](https://docs.flutter.dev/get-started/install/macos#ios-setup)\n🫧[**MacOS - android setup**](https://docs.flutter.dev/get-started/install/macos#android-setup)\n\n🫧[**Windows - android setup**](https://docs.flutter.dev/get-started/install/windows#android-setup)\n\n### 설치 확인 방법 (2)\n\n터미널 창에 `flutter doctor` 를 입력해봅시다.\n![230913-220216](/posts/001_installation/230913-220216.png)\n\nSDK, 애뮬레이터, 에디터까지 발생하는 문제사항을 한 눈에 파악할 수 있습니다.\n\n\u003ctip\u003e\n  참고로 최초 실행시 안드로이드 라이센스에 동의하라는 에러 혹은 경고가 나타날 수 있습니다. \n  그럴 땐 당황하지 마시고 아래의 명령어를 입력하면 됩니다.\n  (_설치할 때 꼼꼼히 읽어보면 이런 내용도 있다는 걸 확인할 수 있죠..._)\n\n  \u003cbr /\u003e\n\n  ```bash:Terminal\n  flutter doctor --android-licenses\n  ```\n\u003c/tip\u003e\n\n### Troubleshooting\n\n간혹가다 Xcode `command line tools`에서 문제가 발생하는 경우가 있습니다.\n명령어 라인 도구는 Xcode를 설치할 때 자동적으로 설치됩니다.\n\n하지만 제 경우에는 Xcode를 설치하기 전에 아래의 명령어로 미리 설치한 적이 있었습니다.\n\n```bash:Terminal\nxcode-select --install\n```\n\n명령어 라인 도구를 먼저 설치하고 Xcode를 설치하면 가끔 정상동작하지 않는 에러가 발생하는 거 같습니다.\n이런 경우에는 명령어 라인 도구를 제거하고 다시 설치하면 해결됩니다.\n\n---\n\n## VSCode 세팅\n\n사실 마켓플레이스에서 `Flutter`, `Dart` 확장을 설치하기만 하면 개발할 준비가 끝나긴 합니다.\n하지만, 개발 편의성과 코드 통일을 위해서 필요한, 혹은 유용한 `확장`과 `setting.json`을 공유할까 합니다.\n\n### setting.json\n\n아래와 같은 키값을 추가하면 개발에 있어 편의성이 증진됩니다.\n하지만, 설정을 건드릴 땐, 본인의 설정과 충돌이 생기는지 반드시 확인한 후에 추가하시는 것을 권장합니다.\n\n참고로, setting.json은 `명령 팔레트`를 열고 `settings.json`을 검색하면 바로 나옵니다.\n또 참고로, 명령 팔레트는 `Command(Window) + Shift + P` 명령어 조합으로 열 수 있습니다.\n\n```json:settings.json showLineNumbers\n{\n  ...\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll\": true\n  },\n  \"dart.previewFlutterUiGuides\": true,\n}\n```\n\n`Line 3-5`의 설정은 자동으로 필요한 모든 곳에 `const` 키워드를 삽입해주는 설정입니다.\nflutter에서 const를 사용하는 것은 매우 중요한데 그 이유에 대해서는 다음에 설명하도록 하겠습니다.\n일단은 가능하다면 반드시 const를 붙이는게 좋고, 이를 자동으로 붙여줄 수 있다는 것만 기억합니다.\n\n`Line 6`의 설정은 flutter 위젯을 트리 구조로 선으로 연결해주는 설정입니다.\n![230913-222546](/posts/001_installation/230913-222546.png)\n\nflutter은 위젯의 depth가 깊어지는 단점이 있는데 이를 어느정도 극복하게 해주는 유용한 설정입니다.\n\n### Error Lens\n\n![230913-223129](/posts/001_installation/230913-223129.png)\n\nError Lens는 코드 문제의 원인을 에디터상에 바로 띄워주는 확장입니다.\n실시간으로 무슨 에러가 있는지 한 눈에 확인할 수 있는게 개인적으로 매우 만족하면서 사용하고 있습니다.\n\n![230913-223528](/posts/001_installation/230913-223528.png)\n\n개인적으로 눈뽕(?) 방지를 위해 `line` 이 아닌, `message` 로 설정하는 것을 추천드립니다.\n\n![230913-224036](/posts/001_installation/230913-224036.png)\n\n또한, 분석 레벨에서 `info` 는 제거해주시는 것을 추천 드립니다.\n\nflutter의 경우 info가 중첩되서 뜨는 경우가 많기에 위 두 세팅을 바꾸지 않으면 아래와 같은 눈뽕(?)을 자주 겪게 될 지도 모릅니다...\n![230913-223954](/posts/001_installation/230913-223954.png)\n\n### Image preview\n\n![230913-224456](/posts/001_installation/230913-224456.png)\n\nImage preview는 로컬, 네트워크 이미지를 미리보기 형식으로 띄워주는 확장입니다.\nFE 개발 입장에서 이미지나 svg, icon을 사용할 일이 많은데, 이를 미리볼 수 있다는 것 만으로도 많은 시간을 절약할 수 있습니다.\n\n---\n\n## VSCode 단축키\n\n개발 시간을 줄여주는 유용한 단축키 및 snippets 를 소개합니다.\n\n### Code Action\n\n![230913-224956](/posts/001_installation/230913-224956.png)\n\nflutter 개발을 하다보면 중간에 위젯을 다른 위젯으로 감싸거나, 부모 위젯을 통째로 드러내야 하는 경우가 잦은데,\n이를 일일이 코드를 잘라내고 붙여넣기 하는건 매우 귀찮은 작업입니다.\n\n하지만 이 기능을 수행하는데 있어 Code Action은 매우 유용한 도구들을 제공합니다.\n\n기능을 수행하고자 하는 위젯의 좌측에 `💡(전구) 모양 아이콘`을 클릭하면 해당 위젯에서 수행할 수 있는 여러 기능들을 보여줍니다.\n\n또는 `Command(Window) + .` 단축키로 빠르게 Code Action에 접근할 수 있습니다.\n매우매우 자주쓰는 기능이니 본인 에디터 환경에 맞는 단축키를 외우도록 합시다.\n~_(사실 외울 필요도 없이 쓰다보면 손가락이 알아서 움직이게 된다는...)_~\n\n### Intellisense\n\n쉽게 말하면 `코드 추천 + 자동완성` 기능입니다.\n\n코드를 입력하다 보면 자동으로 코드를 추천해줄텐데, 실수로 이를 꺼버리는 일이 발생합니다.\n이 경우 코드를 지웠다가 다시 치는 것 보단, `Option(Alt) + Space`로 다시 활성화 시키는 것이 더 유용합니다.\n\n### st + (intellisense)\n\n![230913-230035](/posts/001_installation/230913-230035.png)\n\n플러터의 위젯의 대부분은 Stateful, Stateless 위젯을 상속 받습니다.\n그에 따라 여러 메서드를 override해서 사용해야만 하는데요,\n이 모든 코드를 일일이 입력하는 것도, 기억하는 것도 쉽지 않습니다.\n\n이 경우에는 `st`를 입력하고 intellisense 기능을 이용하면 VSCode가 알아서\nStateful, Stateless 위젯의 필수 부분을 알아서 완성해주고,\n클래스 이름과 관련한 부분 모두를 선택한 상태로 사용자의 입력을 기다리게 됩니다.\n\n따라서 사용자는 아래의 절차를 밟으면 간단하게 위젯 하나를 생성할 수 있게 됩니다.\n\n1. st + (intellisense)\n2. 원하는 부모위젯(Stateful, Stateless) 선택\n3. 원하는 클래스 이름 입력\n\n## 마무리\n\n지금까지 Flutter SDK 설치부터 VSCode 단축키까지 개발에 앞서 필요한 모든 준비단계를 알아봤습니다.\n추가로 필요한 설정이나 기능은 알아보시고 추가하여 사용하신다면, 개발이 조금이라도 더 즐거워지리라 생각됩니다.\n\n긴 글 읽어주셔서 감사드리고, 모두 알찬 `Flutt-er` 생활 되시길 바랍니다!\n","slug":"flutter/001_installation","readingMinutes":14,"wordCount":1023},{"title":"Observer Pattern","description":"Observer 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Observer Pattern","interface"],"draft":false,"date":"2023-09-11 / 10:33","content":"\n## Strategy Pattern\n\n[**저번 포스트**](https://wjlee611.github.io/blog/univ_design-pattern/mid_01)에서 배운 `Strategy 디자인 패턴`을 이용해서 한 가지 예를 살펴보자.\n\n```java:WeatherData.java {7} showLineNumbers\npublic class WeatherData {\n  public void measurementsChanged() {\n    float temp = getTemperature();\n    float humidity = getHumidity();\n    float pressure = getPressure();\n\n     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n    currentConditionsDisplay.update(temp, humidity, pressure);\n    statisticsDisplay.update(temp, humidity, pressure);\n    forecastDisplay.update(temp, humidity, pressure);\n  }\n}\n```\n\n이 코드는 `Display`장치들이 `WeatherData`에서 제공하는 데이터를 이용하려는 코드이다.\n\n예로 들어 `forecastDisplay`에서 날씨 정보를 출력하기 위해서는\n`WeatherData`에서 `forecastDisplay.update()` 메서드를 호출해야\n날씨 정보가 비로소 `forecastDisplay`로 전달되는 것이다.\n\n### 문제점\n\n여기서 문제가 발생한다.\n만약 새로운 장치 futureDisplay를 구현하려면 Strategy Pattern을 사용하는 코드는 아래와 같은 코드수정이 필요해진다.\n\n1. update() 전략을 갖고있는 인터페이스로 구현한 전략(Display) 클래스를 만든다.\n2. `Line 7`에 새로운 장치를 등록한다.\n\n지금 당장은 문제될게 없어 보이지만, 만약 당신이 WeatherData를 `라이브러리화 해서 배포`하는 입장일 경우를 고려해보자.\n`사용자`는 단지 새로운 Display를 추가하여 바로 날씨 정보를 받아오고 싶을 것이다.\n하지만, 위와 같은 코드라면 사용자는 라이브러리 파일을 뜯어서 WeatherData 클래스 내부에\n직접적으로 `새로운 Display를 의존성 주입`을 해줘야만 할 것이다.\n\n이 경우는 꽤나 치명적이다.\n생각해보면 우리가 사용하는 대부분의 라이브러리는 이런 과정을 겪지 않으니 말이다.\n\n따라서 이런 문제를 해결하기 위한 디자인 패턴이 필요하다.\n\n## Observer Pattern\n\nObserver Pattern의 정의는 다음과 같다.\n\n\u003e 객체들이 1:N의 관계를 갖을 때, 한 객체의 상태가 변하면 다른 모든 객체들에 업데이트 통지가 떨어지는 관계로,\n\u003e `객체(Subject)`와 `객체들(Observers)`간의 `종속성이 없는 관계`를 의미한다.\n\n코드로 살펴보며 이해해보자.\n\n### interface\n\n```java:IObserverPattern.java {1-5, 7-9}\npublic interface Subject {\n    public void registerObserver(Observer o);\n    public void removeObserver(Observer o);\n    public void notifyObservers();\n}\n\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\n\npublic interface DisplayElement {\n    public void display();\n}\n```\n\n위 코드는 Observer Pattern에서 사용하는 인터페이스이다.\n`1`의 입장인 클래스(Subject)는 `Subject 인터페이스`를 구현해야 하고,\n`N`의 입장인 클래스(Observers)는 `Observer 인터페이스`를 구현해야 한다.\n\n### Subject class\n\n```diff-java:WeatherData.java {24, 35}\n  public class WeatherData implements Subject {\n+   private ArrayList\u003cObserver\u003e observers;\n\n    public WeatherData() {\n      observers = new ArrayList\u003cObserver\u003e();\n    }\n\n+   @implements\n+   public void registerObserver(Observer o) {\n+     observers.add(o);\n+   }\n+\n+   @implements\n+   public void removeObserver(Observer o) {\n+     int i = observers.indexOf(o);\n+     if (i \u003c 0) return;\n+     observers.remove(i);\n+   }\n+\n+   @implements\n+   public void notifyObservers() {\n+     for (int i=0; i\u003cobservers.length; i++) {\n+       Observer o = observers.get(i);\n+       o.update(temp, humidity, pressure);\n+     }\n+   }\n\n    public void setMeasurements(float temp, float humidity, float pressure) {\n      this.temp = temp;\n      this.humidity = humidity;\n      this.pressure = pressure;\n      measurementsChanged();\n    }\n\n    // 더이상 WeatherData 클래스는 수정할 일이 없어진다.\n    public void measurementsChanged() {\n+     notifyObservers()\n-     float temp = getTemperature();\n-     float humidity = getHumidity();\n-     float pressure = getPressure();\n-\n-     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n-     currentConditionsDisplay.update(temp, humidity, pressure);\n-     statisticsDisplay.update(temp, humidity, pressure);\n-     forecastDisplay.update(temp, humidity, pressure);\n    }\n  }\n```\n\nSubject class의 역할은 Observer의 `구독과 해지`하는 역할을 담당하고,\n구독된 Observers에게 `본인의 변경사항을 알려`주는 역할을 한다.\n\n본인의 변경사항을 알려주기 위해 `Observer는 update 전략`을 포함하고 있어야 한다.\n\n이제 Subject 클래스는 `구독된 Observer를 배열로 관리`하고, `관리되고 있는 Observer를 대상`으로 `변경사항을 emit(update)`하기 때문에\n**더이상 Subject 클래스를 수정할 필요가 없어진다.**\n\n### Observer class\n\n```java:FutureDisplay.java {6-8}\npublic class FutureDisplay implements Observer, DisplayElement {\n  private Subject weatherData;\n\n  public FutureDisplay(Subject weatherData) {\n    this.weatherData = weatherData;\n    // Observer가 Subject를 구독한다.\n    // 비로소 Subject가 update를 쏴줄 수 있다.\n    weatherData .registerObserver(this);\n  }\n\n  public void update(float temp, float humidity, float pressure) {\n    this.temp = temp;\n    this.humidity = humidity;\n    this.pressure = pressure;\n    display();\n  }\n\n  @implements\n  public void display() {\n    // ...\n  }\n}\n```\n\nObserver는 생성시 자동으로 `Subject를 구독`하게 되고,\n구독했기에 Subject의 상태 변경시 자동으로 Observer를 업데이트 할 수 있다.\n_Subject의 observers 배열에 추가되어 관리됨_\n\n\u003e 여기서 눈여겨 봐야 할 점은 `Observer의 update` 전략 메서드는 `Subject`에서,\n\u003e `Subject의 register, remove` 전략 메서드는 `Observer`에서 호출된다는 점이다.\n\u003e 서로 `크로스`되어 메서드를 호출한다는 점을 주목하자.\n\n### main (사용자 입장)\n\n```diff-java:WeatherStation.java {5-6}\n  public class WeatherStation {\n    public static void main(String[] args) {\n      WeatherData weatherData = new WeatherData();\n\n      // another displays\n+     FutureDisplay futureDisplay = new FutureDisplay(weatherData);\n\n      weatherData.setMeasurements(80, 65, 30.4f);\n      weatherData.setMeasurements(82, 70, 29.2f);\n      weatherData.setMeasurements(78, 90, 29.3f);\n    }\n  }\n```\n\n사용자 입장에서는 새로운 Display객체 생성시 WeatherData를 의존성 주입만 해주면,\n그 뒤의 모든 과정은 Observer Pattern에 의해 자동으로 업데이트가 가능해진다.\n\n## 결론\n\n`의존성이 없어`야 하지만 `여러 클래스와 관계`를 가져야하고,\n동시에 `코드가 수정되는 일이 적어`야만 하는 클래스는\nObserver Pattern을 그 클리스와 관계를 갖는 여러 클래스에 적용하는 것이 좋다.\n","slug":"univ_design-pattern/mid_02","readingMinutes":7,"wordCount":693},{"title":"Strategy Pattern","description":"Strategy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Strategy Pattern","extends","implements"],"draft":false,"date":"2023-09-11 / 09:09","content":"\n## 상속\n\n### extends\n\n오리 시뮬레이터를 만든다고 가정해보자.\n그렇다면 일단 오리 객체를 만들어야 할 것이다.\n\n```java:Duck.java {5}\nclass Duck() {\n  quack() {};\n  swim() {};\n  fly() {};\n  display() {};\n  // other duck-like methods\n}\n```\n\n그리고 여러 종류의 오리는 이 `Duck` 클래스를 상속받아서 사용하면 될 것이다.\n\n```java:Ducks.java {2-3, 7-8}\nclass MallardDuck extends Duck {\n  @override\n  display() {};\n}\n\nclass RedheadDuck extends Duck {\n  @override\n  display() {};\n}\n```\n\n물론 생김새는 다르기에 일부 메서드는 `override`해서 사용해야 할 것이다.\n이 때 자식 클래스와 부모 클래스는 `is a` 관계를 갖는다고 말한다.\n_e.g. MallardDuck is a Duck_\n\n### implements (interface)\n\n이제 고무 오리를 만들어보자.\n\n```java:Ducks.java {4-7}\nclass RubberDuck extends Duck {\n  @override\n  display() {}\n  @override\n  quack() {}\n  @override\n  fly() {}\n}\n```\n\n고무 오리는 `꽥` 소리를 내지 않고 `삑`소리를 내기 때문에 `quack()` 메서드 역시 override 해야한다.\n또한, 날지도 않기에 `fly()` 메서드 역시 override 해야한다.\n\nDecoyDuck을 또 만든다면?\n이 역시 quack, fly 메서드를 override 해야한다.\n\n이렇게 모든 Duck들이 공유하지 않는 속성은 매번 override 해야하는 문제점이 있다.\n\n이 때, `interface`를 사용하면 이 문제를 해결할 수 있다.\n\n```diff-java:DucksWithInterfece.java {12, 18}\n  class Duck() {\n    swim() {};\n    display() {};\n  }\n+ interface Flyable() {\n+   fly();\n+ }\n+ interface Quackable() {\n+   quack();\n+ }\n\n  class MallardDuck extends Duck implements Flyable, Quackable {\n+   fly() {};\n+   quack() {};\n    @override\n    display() {};\n  }\n  class RubberDuck extends Duck implements Quackable {\n+   quack() {};\n    @override\n    display() {};\n  }\n```\n\n이렇게 변할 수 있는 부분은 interface로 띄어내면 쓸데없이 메서드를 override할 일이 줄어든다.\n이 때 구현 클래스와 인터페이스는 `has a` 관계를 갖는다고 한다.\n_e.g. RubberDuck has a Quackable_\n\n_참고:_\n_class, interfece의 차이는 사실 거의 없다._\n\n### interface 다형성\n\n하지만 위 방식 역시 문제가 존재한다.\nMallardDuck, RedheadDuck 두 오리 모두 같은 quack 메서드로 동작해야 하지만,\n이를 implements 하는 과정에서 두 메서드를 중복해서 구현해야 한다는 문제점이 발생한다.\n\n이를 해결하기 위해서는 인터페이스의 다형성의 원리를 이용하는게 좋다.\n\n```diff-java:DucksWithPolymorphism.java {18, 20-24}\n  interface QuackBehavior {\n    quack();\n  }\n+ class Quack implements QuackBehavior {\n    @override\n    quack() {'꽥'};\n  }\n+ class Squack implements QuackBehavior {\n    @override\n    quack() {'삑'};\n  }\n+ class MuteQuack implements QuackBehavior {\n    @override\n    quack() {};\n  }\n\n  class Duck {\n    QuackBehavior quackBehavior;\n\n    performQuack() {\n      // delegate to the behavior class\n      // 한 마디로 짬때리기...\n      quackBehavior.quack();\n    }\n    // ...\n  }\n\n  class MallardDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Quack 객체를 지정할 수 있다.\n+     quackBehavior = new Quack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(꽥)를 사용할 수 있음.\n    // ...\n  }\n  class RubberDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Squack 객체를 지정할 수 있다.\n+     quackBehavior = new Squack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(삑)를 사용할 수 있음.\n    // ...\n  }\n```\n\n이렇게 하면 필요한 부분에만 기능을 추가할 수 있고, 코드의 재사용성도 올라간다.\n뿐만 아니라 새로운 기능 (예로 들어 새로운 울음 소리)의 추가도 쉬워진다.\n\n## Strategy Pattern\n\n위에서 알아본 적절한 상속관계를 준수한 패턴을 `Strategy Pattern` 라고 한다.\n정확한 정의는 다음과 같다.\n\n\u003e 객체들이 할 수 있는 행위 각각에 대해 `전략 클래스 (Quack, Squack)`를 생성하고,\n\u003e `유사한 행위들을 캡슐화` 하는 `인터페이스 (QuackBehavior)`를 정의하여,\n\u003e 객체의 행위를 동적으로 바꾸고 싶은 경우 `직접 행위를 수정하지 않고 (performQuack())`\n\u003e 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.\n\n간단히 말해서 객체가 할 수 있는 행위들을 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것만으로 행위의 수정이 가능하도록 만든 패턴이다.\n\n## 결론\n\n`has a (구현)`관계가 `is a (상속)`관계보다 낫다.\n\n상속은 뭘 상속해야 하는지 일일이 파악해야 하는 귀찮음이 있기 때문이다.\n하지만, 구현은 필요한 기능만 가져다 쓰면 되기에 사용및 개발적 측면에서 좋고,\n새로운 기능은 인터페이스를 추가로 구현하면 끝이기에 유지보수 측면에서도 좋다.\n\n따라서 단순히 상속을 이용한 객체지향 프로그래밍 보단,\n전략 패턴을 적용한 코딩 습관을 기르도록 하자.\n","slug":"univ_design-pattern/mid_01","readingMinutes":6,"wordCount":594}]},"__N_SSG":true},"page":"/blog/posts","query":{},"buildId":"IJm44Ue2CpfgF7XV88rGl","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>