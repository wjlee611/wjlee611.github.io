<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>웅덩이</title><link rel="canonical" href="https://wjlee611.github.io/blog/posts"/><meta name="next-head-count" content="4"/><link rel="icon" href="/images/icon_circle.png"/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" rel="stylesheet"/><meta name="description" content="웅덩이"/><meta name="apple-mobile-web-app-title" content="웅덩이"/><meta name="application-name" content="웅덩이"/><meta name="theme-color" content="#009c39"/><meta name="google-site-verification" content="vhQ9DaDdUJcSBHKI_U6tAtE61zwz2i2pLQXyZ62GRLk"/><meta name="naver-site-verification" content="07764cc1a8eda55b4bdf78cf846d6811d042b9ee"/><link rel="preload" href="/_next/static/media/a37cf3809adb2c63-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/dd50543ba70be8e9-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/c372a630cbda84f2-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/553b0c3f635f266c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/553b0c3f635f266c.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-401a9806b070f31a.js" defer=""></script><script src="/_next/static/chunks/main-6b74302918225334.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b6a4b29518e66136.js" defer=""></script><script src="/_next/static/chunks/pages/blog/posts-c7ce4e4b0ccc937b.js" defer=""></script><script src="/_next/static/deatTRx3qrRnvuKFWMv7Z/_buildManifest.js" defer=""></script><script src="/_next/static/deatTRx3qrRnvuKFWMv7Z/_ssgManifest.js" defer=""></script></head><body class="text-primary transition-[background] bg-white dark:bg-[#1A1C23]"><script>
            const theme = localStorage.getItem("theme");
            const getUserTheme = () => {
             if(theme){
              return theme
             } 
             return window.matchMedia('(prefers-color-scheme: dark)').matches
             ? 'dark'
             : 'light'
          }
          document.body.dataset.theme = getUserTheme();
          </script><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="__className_e7b8b0 text-center transition-all "><header class="fixed top-0 left-0 right-0 mx-anuo w-screen h-12 md:h-16 flex justify-between items-center px-2 md:px-10 backdrop-blur bg-blue-200 bg-opacity-20 z-50"><div class="h-full flex items-center"><a class="h-full aspect-square flex justify-center items-center text-3xl select-none cursor-pointer" href="/">🫧</a><nav class="h-full hidden md:flex space-x-8 overflow-hidden ml-10"><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-black dark:text-white " href="/">Portfolio</a></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-blue-500 " href="/blog">Blog</a><div class="hidden md:flex w-full h-[2px] bg-blue-500 absolute bottom-0 left-0 blur-[2px]"></div></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-black dark:text-white " href="/arkhive">Arkhive</a></li></nav></div><div class="flex items-center h-full"><button aria-label="Toggle Dark Mode" type="button" class="flex h-9 w-9 items-center justify-center rounded-lg transition-all text-secondary hover:bg-secondary "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="h-6 w-6 text-yellow-400 drop-shadow-base"></svg></button><button class="flex md:hidden items-center justify-center w-16 h-full text-2xl text-black dark:text-white"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.5 11.5A.5.5 0 0 1 5 11h10a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 1 3h10a.5.5 0 0 1 0 1H1a.5.5 0 0 1-.5-.5z"></path></svg></button></div></header><main class="inline-block w-full relative pt-16 px-8 max-w-5xl 2xl:max-w-7xl" style="opacity:1;transform:none"><div class="flex flex-col mt-8 pb-16"><h3 class="mt-10 mb-5 text-xl bg-gradient-to-r from-blue-700 to-blue-400 bg-clip-text font-bold text-transparent">// 전체 포스트</h3><ul class="flex flex-col items-center space-y-3"><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/flavorizr"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">flavorizr</h4><span>빌드 환경을 분리를 위한 flutter_flavorizr의 거의 모든 것</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2024-03-02 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/lerp"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Lerp (애니메이션 선형 보간)</h4><span>애니메이션을 이용해서 선형 보간(Linear Interpolation)를 쉽게 구현해봅시다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2024-02-15 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/ticker"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Ticker</h4><span>Ticker와 TickerProvider mixin에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2024-02-02 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/generic_freezed"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Freezed에서 제네릭 사용하기</h4><span>API 응답 모델링에서 사용하면 좋은 Freezed 제네릭 테크닉에 대해 소개합니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2024-01-24 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/bloc_outof_context"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">BLoC, context 외부에서 관리하기</h4><span>BuildContext 없이 BLoC에 접근하고, listen 하는 방법을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2024-01-24 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/fcm_with_bloc"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">FCM, BLoC으로 관리하기</h4><span>FCM 응답을 BLoC을 이용해서 상태관리 하는 방법에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2024-01-21 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/memoir/240120_happy_career"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Happy Career (24) 회고</h4><span>참여자의 시선에서 GDGxGDSC의 24년도 Happy Career 행사 회고 및 얻은 점을 공유합니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2024-01-20 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/valuenotifier"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">ValueNotifier</h4><span>setState 없이 일부분만 리랜더링 할 수 있도록 해주는 ValueNotifier, ValueListenableBuilder 에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2024-01-17 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/final_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">AI</h4><span>게임에서의 AI, 그 중 pathfinding 방식에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-11 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/final_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Animation</h4><span>애니메이션이 처리되는 과정을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-11 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/final_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Rendering Pipeline</h4><span>랜더링 과정에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-09 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/final_05"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">자연어 처리</h4><span>자연어 처리의 과정에 대해 간략히 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-09 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/final_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">TensorFlow</h4><span>딥러닝 프레임워크 텐서플로우에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-09 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/final_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">딥러닝 &amp; CNN</h4><span>딥러닝 및 CNN 방식의 종류와 모델들을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-09 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/final_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">신경망</h4><span>인공지능 신경망의 구조와 원리에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-08 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/final_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">결정 트리 &amp; 단순 베이즈 분류기</h4><span>결정 트리의 형태, 학습 알고리즘, 회귀와 단순 베이즈 분류기에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-08 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/final_10"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Visitor Pattern</h4><span>Visitor 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-07 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/final_09"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Prototype Pattern</h4><span>Prototype 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-07 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/final_08"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Mediator Pattern</h4><span>Mediator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-07 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/final_07"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Chain of Responsibility</h4><span>Chain of Responsibility 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-07 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/final_06"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Builder Pattern</h4><span>Builder 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-07 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/final_05"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Bridge Pattern</h4><span>Bridge 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-07 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_mmds/final_05"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">PageRank</h4><span>인터넷 페이지의 중요도 순위를 매기는 방법을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-06 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_mmds/final_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Recommender System</h4><span>추천 시스템의 종류와 동작 방식에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-04 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_mmds/final_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Dimensionality Reduction &amp; SVD</h4><span>차원 축소 기법과 고윳값 분해에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-04 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_mmds/final_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Clustering</h4><span>여러 군집화 방법에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-03 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_mmds/final_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">LSH</h4><span>Locality-Sensitive Hashing과 응용에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-03 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/final_08"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Motion</h4><span>영상에서 움직임을 감지하는 방법에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-03 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/final_07"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Face Recognition</h4><span>얼굴을 인식하는 방법과 그에 사용되는 선형대수학을 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-03 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/final_06"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Object Recognition</h4><span>사물을 인식하는 방법을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-02 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/final_05"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Segmentation</h4><span>영상을 잘게 구역화(분할)하는 방법을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-02 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/final_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Image Transform and RANSAC</h4><span>영상을 변환하는 방법을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-12-02 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/final_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Feature Detection and Matching</h4><span>영상에서 특징점을 찾고 매칭하는 법을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-11-27 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/final_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Edge Detection</h4><span>영상에서 경계를 검출하는 방법을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-11-25 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/final_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Image Restoration</h4><span>훼손된 영상을 최대한 복원해보는 방식에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-11-25 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/final_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Factory Pattern</h4><span>Factory 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-11-19 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/final_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Proxy Pattern</h4><span>Proxy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-11-06 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/final_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">State Pattern</h4><span>State 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-11-06 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/final_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Composite Pattern</h4><span>Composite 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-11-06 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/mid_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Matrix and Transformations</h4><span>행렬에 대한 기본적인 내용과 이를 이용한 공간상에서의 변환에 대해 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-23 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/mid_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Vector</h4><span>벡터에 대한 기본적인 내용에 대해 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-23 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/mid_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Modeling</h4><span>모델을 저장하는 방법에 대해 알아봅나디.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-23 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_virtual-worlds/mid_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Unity Engine</h4><span>유니티 게임 엔진에 대한 기초적인 이론을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-23 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/mid_08"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">기계학습 - 비지도 &amp; 반지도학습</h4><span>비지도 &amp; 반지도학습에서 사용되는 개념에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-22 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/mid_07"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">기계학습 - 지도학습</h4><span>지도학습에서 사용되는 개념에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-22 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/mid_06"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">규칙 기반 시스템</h4><span>지식을 규칙의 형태로 표현하는 방법에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-22 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/mid_05"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">불확실한 지식 표현</h4><span>불확실한 지식을 표현하는 방법에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-22 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/mid_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">명제 논리 &amp; 술어 논리</h4><span>지식을 표현하는 방법 - 논리에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-22 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/mid_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">프레임 &amp; 의미망 &amp; 스크립트</h4><span>지식을 표현하는 방법 - 프레임, 의미망, 스크립트에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-22 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/mid_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">게임에서의 탐색 및 최적화</h4><span>게임 트리를 탐색하는 기법과 최적화에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-21 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_09"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Iterator Pattern</h4><span>Iterator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-21 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_08"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Template Method Pattern</h4><span>Template Method 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-21 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_07"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Facade Pattern</h4><span>Facade 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-21 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_mmds/mid_05"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Finding Similar Items</h4><span>유사도 높은 문서를 찾아내는 방법을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-20 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_mmds/mid_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Association Rules</h4><span>빅데이터에서 연관 규칙을 찾아내는 방법에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-20 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_mmds/mid_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Frequent Itemset</h4><span>빈발 항목 집합을 구하는 방법을 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-19 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_mmds/mid_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Spark 개념</h4><span>MapReduce 모델의 확장판, Spark에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-19 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_mmds/mid_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">분산 파일관리 시스템</h4><span>분산 파일관리 시스템에 관련한 기초 지식을 배웁니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-19 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/mid_06"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Filtering in the Frequency Domain</h4><span>주파수 도메인에서의 필터링에 대해 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-18 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/mid_05"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Filtering and Convolution</h4><span>Filtering 과 Convolution 의 동작방식과 차이를 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-17 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/mid_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Color Image</h4><span>색상과 관련된 용어와 변환을 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-16 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/mid_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Intensity Transformations</h4><span>이미지 밝기 변환에 대한 내용을 다뤄봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-16 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/mid_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Singal Processing Fundamentals</h4><span>신호 처리에 대한 기초적인 정보입니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-15 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_com-vision/mid_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Digital Image Fundamentals</h4><span>디지털 이미지에 대한 기초적인 정보입니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-15 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_06"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Adapter Pattern</h4><span>Adapter 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-11 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_05"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Command Pattern</h4><span>Command 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-10 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_04"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Singleton Pattern</h4><span>Singleton 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-08 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_03"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Decorator Pattern</h4><span>Decorator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-10-08 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/005_dart_expert"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Dart 언어 마스터</h4><span>Dart 언어에 대한 보다 심화된 내용을 정리해봤습니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-25 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/004_dart_advanced"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Dart 언어 심화</h4><span>Dart 언어에 대한 심화된 내용을 정리해봤습니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-15 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/003_dart_basic"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Dart 언어 기초</h4><span>Dart 언어에 대한 기초지식을 정리해봤습니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-14 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/002_project_initalize"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">플러터 프로젝트 만들기</h4><span>플러터 프로젝트 생성 가이드 입니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-14 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/flutter/001_installation"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">플러터 시작하기</h4><span>플러터 설치 및 VSCode 세팅 가이드입니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-13 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_ai/mid_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">상태공간 &amp; 탐색</h4><span>상태공간과 탐색의 의미와 예시를 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-12 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_02"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Observer Pattern</h4><span>Observer 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-11 </span></a><a class="w-full max-w-2xl flex flex-col border border-blue-300 rounded-md py-5 px-5 text-start shadow-md hover:bg-blue-100 hover:shadow-blue-200 dark:hover:bg-blue-950 dark:hover:shadow-blue-900 transition-colors relative" href="/blog/univ_design-pattern/mid_01"><h4 class="text-xl bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent">Strategy Pattern</h4><span>Strategy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="absolute bottom-0 -right-1 bg-gradient-to-r from-blue-600 to-blue-300 bg-clip-text font-bold text-transparent opacity-40 italic px-3">2023-09-11 </span></a></ul></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"flavorizr","description":"빌드 환경을 분리를 위한 flutter_flavorizr의 거의 모든 것","icon":"","image":"","tags":["flavor","flavorizr","Troubleshoots"],"draft":false,"date":"2024-03-02 / 22:45","content":"\n\u003ctip\u003e\n  이 포스트는 계속해서 업데이트 됩니다.\n  유용한 댓글이나 경험을 남겨주시면 해당 내용도 추가하겠습니다!\n\u003c/tip\u003e\n\n## Getting Started\n\n[flutter_flavorizr](https://pub.dev/packages/flutter_flavorizr)의 사용방법에 대해 설명합니다.\n\n### pubspec.yaml\n\n해당 파일에서 하단에 `flavorizr` 필드를 작성합니다.\n\n```yaml:pubspec.yaml {4, 18}\n  # Flavor settings\n  flavorizr:\n    flavors:\n      dev:\n        app:\n          name: \"DEV APP_NAME\"\n        android:\n          applicationId: \"dev.package.name.app_name\"\n          # icon: \"assets/app_icon.png\"\n          firebase:\n            config: \"android/firebase/dev/google-services.json\"\n        ios:\n          bundleId: \"dev.bundle.id.appName\"\n          # icon: \"assets/app_icon.png\"\n          firebase:\n            config: \"ios/firebase/dev/GoogleService-Info.plist\"\n\n      prod:\n        app:\n          name: \"APP_NAME\"\n        android:\n          applicationId: \"package.name.app_name\"\n          # icon: \"assets/app_icon.png\"\n          firebase:\n            config: \"android/firebase/prod/google-services.json\"\n        ios:\n          bundleId: \"dev.bundle.id.appName\"\n          # icon: \"assets/app_icon.png\"\n          firebase:\n            config: \"ios/firebase/prod/GoogleService-Info.plist\"\n```\n\n위와 같은 경우에는 `dev`, `prod` 두 개의 flavor 환경을 구축하는 경우입니다.\n\n다음은 아래에 추가로 필드를 기입하면 됩니다.\n공통사항은 app, AOS 전용사항은 android, iOS 전용사항은 ios 아래에 기입하면 됩니다.\n\n자세한 내용은 flavorizr의 공식 문서를 참고하시면 좋습니다.\n\n### CLI\n\npubspec.yaml 작성을 완료했다면, 아래의 명령어를 사용하면 자동 빌드됩니다.\n\n```bash:bash\n  dart run flutter_flavorizr\n```\n\n빌드가 완료되면 아래의 파일들이 자동 생성 및 자동 수정될 것 입니다.\n\n- main.dart\n- **main_prod.dart**\n  prod 빌드 환경에 맞는 초기 세팅을 진행하는 파일입니다.\n\n  ```dart:main_prod.dart {1, 9}\n    // Import from prod dependency\n    import 'package:flutter/material.dart';\n\n    import 'flavors.dart';\n\n    import 'main.dart' as runner;\n\n    Future\u003cvoid\u003e main() async {\n      F.appFlavor = Flavor.prod;\n\n      await runner.main();\n    }\n  ```\n\n- **main_dev.dart**\n  dev 빌드 환경에 맞는 초기 세팅을 진행하는 파일입니다.\n\n  ```dart:main_dev.dart {1, 9}\n    // Import from dev dependency\n    import 'package:flutter/material.dart';\n\n    import 'flavors.dart';\n\n    import 'main.dart' as runner;\n\n    Future\u003cvoid\u003e main() async {\n      F.appFlavor = Flavor.dev;\n\n      await runner.main();\n    }\n  ```\n\n- **flavors.dart**\n  flavor 관련 static field를 관리하는 클래스 파일입니다.\n\n  ```dart:flavors.dart\n    enum Flavor {\n      dev,\n      prod,\n    }\n\n    class F {\n      static Flavor? appFlavor;\n\n      static String get name =\u003e appFlavor?.name ?? '';\n\n      static String get title {\n        switch (appFlavor) {\n          case Flavor.dev:\n            return 'DEV APP_NAME';\n          case Flavor.prod:\n            return 'APP_NAME';\n          default:\n            return 'title';\n        }\n      }\n    }\n  ```\n\n- pages/my_home_page.dart\n\n\n### VSCode debug setting\n\n디버깅 시 아래의 명령어를 사용해서 실행할 수 있습니다.\n\n```bash:bash\n  flutter run --flavor prod -t lib/main_prod.dart\n  flutter run --flavor dev -t lib/main_dev.dart\n```\n\n하지만, VSCode의 디버깅 탭을 100% 활용하기 위해 추가 설정을 진행하면 좋습니다.\n\n우선, 프로젝트 폴더에서 `.vscode` 폴더를 생성, 내부에 아래의 파일을 추가합니다.\n\n```json:launch.json\n  {\n    \"configurations\": [\n      {\n        \"name\": \"dev\",\n        \"request\": \"launch\",\n        \"type\": \"dart\",\n        \"args\": [\"--flavor\", \"dev\"],\n        \"program\": \"lib/main_dev.dart\"\n      },\n      {\n        \"name\": \"prod\",\n        \"request\": \"launch\",\n        \"type\": \"dart\",\n        \"args\": [\"--flavor\", \"prod\"],\n        \"program\": \"lib/main_prod.dart\"\n      }\n    ]\n  }\n```\n\n이렇게 설정하면 명령어 없이 디버깅 탭에서 버튼을 통해 실행할 수 있습니다.\n\n## Tips \u0026 Addon(?)\n\nflavor를 사용할 때 추가로 구현하면 좋은 것들, 혹은 firebase와 같은 추가 설정이 필요한 부분에 대해 설명합니다.\n\n### Config\n\nflavor의 주된 사용 목적에는 prod, dev 에서의 API endpoint를 다르게 설정하는 등, 앱 내부에서 상수들을 별도로 관리하는데에 있을 것 입니다.\n따라서 이러한 처리를 자동으로 하도록 Config 객체를 만들어 관리하는 방법에 대해 소개하겠습니다.\n\n우선 코드 전문부터 보겠습니다.\n\n```dart:config.dart {5, 8, 29}\n  import 'package:child_goods_store_flutter/constants/networks.dart';\n  import 'package:child_goods_store_flutter/flavors.dart';\n\n  class Configs {\n    // Add configs here\n    final String baseUrl;\n\n    // Initialize configs here\n    Config._dev() : baseUrl = Networks.devBaseUrl;\n\n    Config._prod() : baseUrl = Networks.baseUrl;\n\n    factory Config(Flavor? flavor) {\n      switch (flavor) {\n        case Flavor.dev:\n          _instance = Config._dev();\n          break;\n        case Flavor.prod:\n          _instance = Config._prod();\n          break;\n        default:\n          _instance = Config._dev();\n          break;\n      }\n      return instance;\n    }\n\n    static Config? _instance;\n    static Config get instance =\u003e _instance ?? Config(F.appFlavor ?? Flavor.dev);\n  }\n```\n\n위 코드는 일단 Configs 싱글톤 객체를 생성하는 파일입니다.\n그 과정에서 기본적으로 F(lavor) 클래스의 appFlavor static 필드를 생성자에 주입 받습니다.\n\n즉, `Configs.instance` 를 호출하는 것 만으로토 현재 실행 환경의 flavor가 적용된 Configs 싱글톤 객체를 반환받을 수 있습니다.\n\n여기에 추가로 본인이 원하는 필드(e.g. baseUrl)를 추가하고, 각 생성자에서 각 환경에 맞게 초기화 해주시면 됩니다.\n\n그럼 앞으로 `Configs.instance.baseUrl`를 사용하는 것 만으로도 빌드 환경에 따라 다른 값이 알아서 적용되게 됩니다.\n\n### Firebase\n\nfirebase의 `google-services.json`이나, `GoogleService-Info.plist`를 빌드 환경에 맞게 알아서 처리하는 방법도 알아봅시다.\n\n\u003ctip\u003e\n  firebase 프로젝트 및 service 파일을 빌드 환경에 맞게 분리하면 좋은게,\n  가끔 Test 라며 푸쉬 알림이 실 사용자에게 전송되는 일을 예방할 수 있기 때문입니다.\n\u003c/tip\u003e\n\n우선 firebase 프로젝트를 생성합니다.\n자세한 생성 방법 및 flutterfire CLI 설치 방법은 생략합니다.\n\n다음은 프로젝트 폴더에서 아래의 CLI 명령어를 실행하여 firebase 프로젝트에 flutter 앱을 추가해줍니다.\n\n```bash:bash\n  flutterfire config \\      \n  --project=firebase_project_name \\\n  --ios-bundle-id=bundle.id.appName \\\n  --android-package-name=package.name.app_name\n```\n\n위 명령어는 firebase_project_name firebase 프로젝트에 prod 빌드 환경의 앱을 추가하는 명령어 입니다.\n\n1. 만약 **같은** firebase 프로젝트에 dev 빌드 환경의 앱을 추가하려면 아래의 명령어를 입력하면 됩니다.\n\n    ```bash:bash {3-4}\n      flutterfire config \\      \n      --project=firebase_project_name \\\n      --ios-bundle-id=dev.bundle.id.appName \\\n      --android-package-name=dev.package.name.app_name\n    ```\n\n    \u003cnotice\u003e\n      2번째 부터 `ios/firebase_app_id_file.json` 파일이 중복된다는 경고가 나오는데,\n      이는 개발환경에 무관하게 동일한 파일이기 때문에 override 해도 상관 없습니다.\n    \u003c/notice\u003e\n\n2. 만약 **다른** firebase 프로젝트에 dev 빌드 환경의 앱을 추가하려면 아래의 명령어를 입력하면 됩니다.\n\n    ```bash:bash {2}\n      flutterfire config \\      \n      --project=dev_firebase_project_name \\\n      --ios-bundle-id=dev.bundle.id.appName \\\n      --android-package-name=dev.package.name.app_name\n    ```\n\n성공적으로 추가 되었다면, 자동으로 생성되는 `google-services.json`이나, `GoogleService-Info.plist`는 일단 제거해줍니다.\n\n여기까지 성공했다면 firebase 프로젝트에 4개의 앱이 추가되었을 것입니다.\n(AOS prod, dev / iOS prod, dev)\n\n![240302-233903](/posts/flavorizr/240302-233903.png)\n\n이제 `google-services.json`, `GoogleService-Info.plist` 파일을 다운로드 받아 `pubspec.yaml` 파일에 적힌 경로에 각각 다운로드 합니다.\n\n```yaml:pubspec.yaml {11, 16, 25, 30}\n  # Flavor settings\n  flavorizr:\n    flavors:\n      dev:\n        app:\n          name: \"DEV APP_NAME\"\n        android:\n          applicationId: \"dev.package.name.app_name\"\n          # icon: \"assets/app_icon.png\"\n          firebase:\n            config: \"android/firebase/dev/google-services.json\"\n        ios:\n          bundleId: \"dev.bundle.id.appName\"\n          # icon: \"assets/app_icon.png\"\n          firebase:\n            config: \"ios/firebase/dev/GoogleService-Info.plist\"\n\n      prod:\n        app:\n          name: \"APP_NAME\"\n        android:\n          applicationId: \"package.name.app_name\"\n          # icon: \"assets/app_icon.png\"\n          firebase:\n            config: \"android/firebase/prod/google-services.json\"\n        ios:\n          bundleId: \"dev.bundle.id.appName\"\n          # icon: \"assets/app_icon.png\"\n          firebase:\n            config: \"ios/firebase/prod/GoogleService-Info.plist\"\n```\n\n해당 경로는 본인 프로젝트의 파일 관리 정책에 맞게 알아서 설정해주시면 됩니다.\n\n그리고 다시 아래의 명령어를 실행하면 알아서 firebase 환경 설정이 완료됩니다.\n\n```bash:bash\n  dart run flutter_flavorizr\n```\n\n\u003cnotice\u003e\n  반드시 관련 파일은 .gitignore에 추가하여 보안에 유의합시다.\n\n  ```md:.gitignore\n    # Secret - Common\n    lib/configs/firebase_options.dart\n    lib/configs/firebase_options_dev.dart\n    # Secret - Android\n    android/firebase\n    android/app/src/prod/google-services.json\n    android/app/src/dev/google-services.json\n    # Secret - iOS\n    ios/firebase\n    ios/firebase_app_id_file.json\n    ios/Runner/prod/GoogleService-Info.plist\n    ios/Runner/dev/GoogleService-Info.plist\n    # Secret - iOS auto generated\n    ios/Runner/GoogleService-Info.plist\n  ```\n\u003c/notice\u003e\n\n마지막으로 `main_prod.dart`, `main_dev.dart`에 초기화 설정을 해주면 끝입니다.\n\n```dart:main_prod.dart {1, 2}\n  // Import from prod dependency\n  import 'package:child_goods_store_flutter/configs/firebase_options.dart';\n  import 'package:firebase_core/firebase_core.dart';\n  import 'package:flutter/material.dart';\n\n  import 'flavors.dart';\n\n  import 'main.dart' as runner;\n\n  Future\u003cvoid\u003e main() async {\n    F.appFlavor = Flavor.prod;\n\n    WidgetsFlutterBinding.ensureInitialized();\n\n    await Firebase.initializeApp(\n      options: DefaultFirebaseOptions.currentPlatform,\n    );\n\n    await runner.main();\n  }\n```\n\n```dart:main_dev.dart {1, 2}\n  // Import from dev dependency\n  import 'package:child_goods_store_flutter/configs/firebase_options_dev.dart';\n  import 'package:firebase_core/firebase_core.dart';\n  import 'package:flutter/material.dart';\n\n  import 'flavors.dart';\n\n  import 'main.dart' as runner;\n\n  Future\u003cvoid\u003e main() async {\n    F.appFlavor = Flavor.dev;\n\n    WidgetsFlutterBinding.ensureInitialized();\n\n    await Firebase.initializeApp(\n      options: DefaultFirebaseOptions.currentPlatform,\n    );\n\n    await runner.main();\n  }\n```\n\n(자세히 보면 firebase_options.dart 파일의 import 경로가 다릅니다)\n\n## TroubleShoots\n\n글쓴이가 실제로 해보며 겪은 문제와 그에 대한 해결법에 대해 정리해봤습니다.\n\n### Unable to load contents of file list\n\n글쓴이는 아래와 같은 에러를 본 적이 있습니다.\n\n\u003e Error (Xcode): Unable to load contents of file list: '/Target Support Files/Pods-Runner/Pods-Runner-frameworks-Debug-dev-input-files.xcfilelist'\n\u003e\n\u003e Error (Xcode): Unable to load contents of file list: '/Target Support Files/Pods-Runner/Pods-Runner-frameworks-Debug-dev-output-files.xcfilelist'\n\n해당 에러는 특정 파일이 존재하지 않을 때 발생하는 에러로, flavorizr 생성 CLI 명렁어를 실행했음에도 생성되지 않는 경우가 종종 있었습니다.\n그럴 경우에는 아래의 스탭을 천천히 밟아가면 대부분 해결될 것입니다.\n\n1. ios \u0026rarr; Xcode로 열기 \u0026rarr; 상단 상태바에서 Product \u0026rarr; Clean Build Folder\n\n    ![240302-235526](/posts/flavorizr/240302-235526.png)\n\n2. 아래 명령어로 pod 업데이트, depencency 초기화 및 재설치\n\n    ```bash:bash\n      cd ios/\n      sudo gem update cocoapods --pre\n      pod update\n      pod repo update\n      pod deintegrate\n      pod install\n    ```\n\n3. flavorizr 명령어 재실행\n\n    ```bash:bash\n      dart run flutter_flavorizr\n    ```\n\n4. ios \u0026rarr; Xcode로 열기 \u0026rarr; Runner(PROJECT) \u0026rarr; Info \u0026rarr; Configurations 의 파일이 잘 설정되어있는지 확인\n\n    ![240303-000448](/posts/flavorizr/240303-000448.png)\n\n5. 아래의 파일의 include가 아래와 같이 작성되어있는지 확인\n\n    ```c:ios/Flutter/Debug.xcconfig\n      #include? \"Pods/Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig\"\n      #include \"Generated.xcconfig\"\n    ```\n\n    ```c:ios/Flutter/Release.xcconfig\n      #include? \"Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig\"\n      #include \"Generated.xcconfig\"\n    ```\n\n### FirebaseCommandException\n\n글쓴이는 아래와 같은 에러를 본 적이 있습니다.\n\n\u003e FirebaseCommandException: An error occured on the Firebase CLI when attempting to run a command.\n\u003e COMMAND: firebase apps:create ios child_goods_store_flutter (ios) --bundle-id=dev.io.github.u3C1S.child_goods_store_flutter --json --project=child-goods-store \n\u003e ERROR: Failed to create iOS app for project child-goods-store. See firebase-debug.log for more info.\n\n이 경우에는 iOS bundleId가 snake_case로 작성되어서 발생한 문제였습니다.\n\n**반드시, iOS bundleId는 camelCase로 작성**하도록 합시다.","slug":"flutter/flavorizr","readingMinutes":11,"wordCount":1202},{"title":"Lerp (애니메이션 선형 보간)","description":"애니메이션을 이용해서 선형 보간(Linear Interpolation)를 쉽게 구현해봅시다.","icon":"","image":"","tags":["Animation","AnimationController"],"draft":false,"date":"2024-02-15 / 21:04","content":"\n\u003cnotice\u003e\n  Flutter Color의 `lerp()` 와 연결되는 내용은 **아닙니다**.\n  (이론적인 부분은 일맥상통 하지만, 정확히는 애니메이션에 대한 포스트 입니다)\n\u003c/notice\u003e\n\n우선 시작하기에 앞서 [**`gyro_provider`**](https://pub.dev/packages/gyro_provider) 플러그인을 소개합니다~\n저의 첫 라이브러리이자, pub.dev 데뷔 작품(?)입니다 ㅎㅎ\n\n![gyro_provider_demo](/posts/lerp/gyro_provider_demo.gif)\n\n모바일 기기의 자이로스코프 센서를 이용해서 위젯을 변형시키거나, 센서 값을 제공하는 라이브러리 입니다.\n이번 포스트는 이 플러그인을 개발하며 배웠던 내용을 소개 하겠습니다.\n\n## 문제 인지\n\nFlutter Animation은 AnimationController가 지정한 시간(Duration)동안 동작합니다.\n\n```dart:.dart\n_animationController = AnimationController(\n  vsync: this,\n  duration: Duration(seconds: 1),\n)\n```\n\n그리고 Animation은 AnimationController에 의해 변화되는 값을 보관하고 있죠.\n\n```dart:.dart\n_xAnimation = Tween\u003cdouble\u003e(\n  begin: 0,\n  end: _xTarget,\n).animate(_animationController);\n```\n\n예로 들어 AnimationController의 값이 **0**에서 **1**로 _1초 동안_ 변할 동안 _xAnimation의 값은 **0**에서 **_xTarget**까지 _1초 동안_ 변화하는 것이죠.\n즉, AnimationController에 의해 Animation의 값이 **선형 보간**되는 것입니다.\n\n만약 _xTarget의 값이 도중에 변한다면 어떻게 될까요?\n\n### 문제 발생\n\n여기서 문제가 발생합니다.\n\n애니메이션은 새로운 _xTarget 값을 향해 바뀌는 것이 아닌, 바뀌기 전의 _xTarget값을 향해 선형 보간될 것입니다.\n\n---\n\n## Lerp\n\n바뀐 후의 _xTarget값을 향하여 선형 보간을 하기 위해서는 AnimatedContainer를 리셋시키고 Animation을 재정의 해야 합니다.\n\n```dart:.dart\n_animationController.reset();\n\n_xAnimation = Tween\u003cdouble\u003e(\n  begin: 0,\n  end: _xTarget, // new value\n).animate(_animationController);\n\n_animationController.forward();\n```\n\n하지만 이런식으로 코드를 짠다면 문제가 발생하겠죠.\n시작점(begin)이 0으로 초기화 되기 때문입니다.\n\n따라서 begin의 값은 AnimationController를 초기화 하기 직전의 Animation의 값을 가지고 있어야 할 것 입니다.\n\n```dart:.dart\nvar currX = _animation.value;\n\n_animationController.reset();\n\n_xAnimation = Tween\u003cdouble\u003e(\n  begin: currX,\n  end: _xTarget, // new value\n).animate(_animationController);\n\n_animationController.forward();\n```\n\n위와 같이 코드를 수정한다면, _xTarget가 변경되었을 때, 위 코드를 실행하면 \n진행되던 애니메이션이 이어서 부드럽게 새로운 애니메이션이 되어 새로운 _xTarget를 향하여 진행할 것입니다.\n\n### 장점\n\nAnimatedContainer의 Duration보다 짧은 시간안에 _xTarget 값이 변하더라도 애니메이션을 부드럽게 진행시킬 수 있습니다.\n\n즉, _xTarget이 변할 때마다 새로운 선형 보간을 적용할 수 있게 되는 것입니다.\n\n### 단점\n\nAnimatedContainer의 Duration이 길수록 _'뭔가 늦게 반응한다'_ 라는 느낌을 받으실 수 있습니다.\n\n그렇다고 Duration을 _xTarget이 변화하는 주기보다 짧게 설정할 경우에는 애니메이션 중간마다 끊기는 느낌을 받을 수 있습니다.\n\n---\n\n## 코드 리뷰\n\n그럼 선형 보간과 관련한 [**`gyro_provider`**](https://pub.dev/packages/gyro_provider)의 코드를 리뷰해보며 이해를 굳혀봅시다.\n\n### forward\n\n우선 애니메이션이 진행 중입니다.\n\n```dart:gyro_provider.dart {30}\n  @override\n  void initState() {\n    super.initState();\n    ...\n    // Initialize animation\n    _animationController = AnimationController(\n      vsync: this,\n      duration: widget.animationDuration,\n    )\n      ..addListener(_animationListener)\n      ..addStatusListener(_animationStatusListener);\n\n    _linearCurve = CurvedAnimation(\n      parent: _animationController,\n      curve: Curves.linear,\n    );\n    _easeCurve = CurvedAnimation(\n      parent: _animationController,\n      curve: Curves.easeOut,\n    );\n\n    _xAnimation = Tween\u003cdouble\u003e(\n      begin: 0,\n      end: _xTarget,\n    ).animate(_linearCurve);\n    _yAnimation = Tween\u003cdouble\u003e(\n      begin: 0,\n      end: _yTarget,\n    ).animate(_linearCurve);\n    _animationController.forward();\n  }\n```\n\n0에서 _xTarget 으로 이동 중이겠죠.\n\n### change target\n\n그러다 _xTarget의 값이 변화합니다.\n\n```dart:gyro_provider.dart {12}\n  void _gyroListener() {\n    var value = _gyroscopeController.value;\n    _gyroData.value = value;\n    widget.gyroscope?.call(value);\n\n    if (value.x.abs() \u003c 0.1 \u0026\u0026 value.y.abs() \u003c 0.1 \u0026\u0026 !widget.centerLock) {\n      ...\n    }\n    // Change the target rotation angle by the amount the sensor value changes\n    // and animate toward that value.\n    else {\n      _xTarget += value.x;\n      _yTarget += value.y;\n    }\n    // The animation only changes when the widget is not being moved to the center.\n    if (!_onCenter) {\n      _animation(curve: _linearCurve);\n    }\n  }\n```\n\n하지만, 현재 AnimatedContainer가 변형시키는 Animation의 _xTarget 값은 변화하지 않았습니다.\n\n### reset\n\n따라서 애니메이션을 중지시키고 재설정을 합니다.\n하지만, 중지 시키기 전에 현재까지 변화한 Animation의 값을 보관합니다.\n\n```dart:gyro_provider.dart {4, 6}\n  void _animation({required CurvedAnimation curve}) {\n    if (!mounted) return;\n\n    var xCurr = _xAnimation.value;\n    var yCurr = _yAnimation.value;\n    _animationController.reset();\n    _xAnimation = Tween\u003cdouble\u003e(\n      begin: xCurr,\n      end: _xTarget,\n    ).animate(curve);\n    _yAnimation = Tween\u003cdouble\u003e(\n      begin: yCurr,\n      end: _yTarget,\n    ).animate(curve);\n    _animationController.forward();\n  }\n```\n\n### (re)forward\n\n그리고 다시 애니메이션을 동작 시킵니다.\n\n```dart:gyro_provider.dart {8, 15}\n  void _animation({required CurvedAnimation curve}) {\n    if (!mounted) return;\n\n    var xCurr = _xAnimation.value;\n    var yCurr = _yAnimation.value;\n    _animationController.reset();\n    _xAnimation = Tween\u003cdouble\u003e(\n      begin: xCurr,\n      end: _xTarget,\n    ).animate(curve);\n    _yAnimation = Tween\u003cdouble\u003e(\n      begin: yCurr,\n      end: _yTarget,\n    ).animate(curve);\n    _animationController.forward();\n  }\n```\n\n---\n\n## 마무리\n\n코드 전문은 오픈소스로 공개된 [**`gyro_provider`**](https://pub.dev/packages/gyro_provider) 레포에서 확인하실 수 있습니다.\n\nFlutter Animation에 대해 잘 모르는 상태로 플러그인 개발 프로젝트를 시작했는데,\n무작정 시도하긴 했지만, 배워가는 점도 많았던거 같습니다. \n(적어도 AnimationController, Animation은 나름 자유자재로 사용할 수 있게 되었다는 거?)\n\n사실 네이티브 코드에서 센서의 인터벌(interval)을 매우 빠르게 설정하면(초당 60 이상) 애니메이션을 구현할 필요도 없을 것입니다.\n\n하지만, 초당 60번의 통신은 성능 저하의 원인이 될 수 있다는 생각이 들었고,\n기기 사양이 안좋은 경우에는 초당 60회의 통신이 불가능할 수도 있을지도 몰랐기에 이런 방식으로 구현했습니다.\n(초당 10~15회 통신, 기기 주사율에 맞도록 사이의 값은 애니메이션을 이용해 lerp(선형 보간))\n~_이 부분을 문제 인지에 적는게 나았을지도.._~\n\n사실 신경 쓸 필요도 없을지도 모르지만, 이런 고민 덕분에 새로운 시도를 할 수 있게 되어 오히려 좋았던 거 같습니다.","slug":"flutter/lerp","readingMinutes":8,"wordCount":689},{"title":"Ticker","description":"Ticker와 TickerProvider mixin에 대해 알아봅니다.","icon":"","image":"","tags":["Ticker","TickerProvider","Controller"],"draft":false,"date":"2024-02-02 / 15:14","content":"\nFlutter로 개발하다보면 TabController, AnimationController와 같은 Controller에 `vsync: this` 를 반드시 종속성 주입해야 하는 경우가 있습니다.\n이럴 때 마다 TickerProviderStateMixin 을 상속받아 사용해서 this를 사용할 수 있게 되는데, 이게 항상 궁금했었죠...\n\n그러다, Flutter 애니메이션을 공부하다 그 이유를 알게되었고, 그 내용을 정리해보고자 합니다.\n\n## Ticker\n\n우선 Ticker에 대해 알아야 합니다.\n\nTicker는 매 프레임마다 함수를 호출하는 역할을 수행하는데, 아래의 코드를 살펴봅시다.\n\n```dart:stateful_widget.dart {7}\nlate final Ticker _ticker;\n\n@override\nvoid initState() {\n  super.initState();\n  _ticker = Ticker(\n    (elapsed) =\u003e print(elapsed);\n  );\n  _ticker.start();\n}\n\n@override\nvoid dispose() {\n  _ticker.dispose();\n  super.dispose();\n}\n```\n\n이렇게 하면, 이 위젯이 위젯트리에 올라가서 상태가 컨텍스트에 등록되는 순간부터 매 프레임마다 elapsed가 찍히게 됩니다. (대략 60fps)\n만약, `_ticker.dispose()` 를 호출하지 않는다면, 위젯트리에서 내려가도 Ticker가 계속 함수를 매 프레임마다 호출하게 될 겁니다.\n\n정리하자면, 매 프레임마다 함수를 호출하게 해주는 클래스가 Ticker 입니다.\n하지만, 왜 Ticker를 사용하는 걸까요?\n\n바로 **부드러운 화면 모션** 때문입니다.\n매 프레임마다 함수를 실행한다는 것은, 매 프레임마다 화면을 업데이트 시킬 수도 있다는 뜻입니다.\n자원을 많이 잡아먹긴 하겠지만, 최적화만 잘 한다면, 부드러운 애니메이션을 보여줄 수 있겠죠!\n\n### TickerProvider\n\n이제, Ticker가 뭔지, 왜 사용하는지를 알았습니다.\n하지만, 강력한 기능을 가진 만큼, 취급에 주의해야 하겠죠...\n생성하고, 함수를 등록하고, 반드시 dispose 해야하는...\n\n이런 과정을 개발자에게 맡겼다간 반드시 실수가 발생할 것입니다.\n따라서 Ticker의 사용을 은닉화 하기위해 우선 Ticker을 생성하는 인터페이스(정확히는 abstract class)가 제공되는데, 이게 바로 TickerProvider 입니다.\n\n```dart:ticker.dart\nabstract class TickerProvider {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const TickerProvider();\n\n  /// Creates a ticker with the given callback.\n  ///\n  /// The kind of ticker provided depends on the kind of ticker provider.\n  @factory\n  Ticker createTicker(TickerCallback onTick);\n}\n\n```\n\n이 클래스를 상속받은 클래스는 반드시 createTicker 구현해서 사용해야 하며, 이름에서 알 수 있듯 이 함수는 Ticker를 반환하게 됩니다.\n\n예로 들어, TickerProvider의 구현체 중 하나인 SingleTickerProviderStateMixin의 내부를 살펴보겠습니다.\n\n```dart:ticker_provider.dart {5}\nmixin SingleTickerProviderStateMixin\u003cT extends StatefulWidget\u003e on State\u003cT\u003e implements TickerProvider {\n  Ticker? _ticker;\n\n  @override\n  Ticker createTicker(TickerCallback onTick) {\n    _ticker = Ticker(onTick, debugLabel: kDebugMode ? 'created by ${describeIdentity(this)}' : null);\n    _updateTickerModeNotifier();\n    _updateTicker(); // Sets _ticker.mute correctly.\n    return _ticker!;\n  }\n\n  @override\n  void dispose() {\n    _tickerModeNotifier?.removeListener(_updateTicker);\n    _tickerModeNotifier = null;\n    super.dispose();\n  }\n}\n```\n\n간단하게만 보면 해당 mixin에서 Ticker 생성과 삭제에 필요한 모든 기능을 수행한다고 볼 수 있습니다.\n\n\u003ctip\u003e\n  필요한 모든 기능 중, 가장 중요한 기능은 `자원 관리` 라고 생각됩니다.\n  실제로 설명의 최상단에도 언급되어 있습니다.\n  \u003e Provides a single [Ticker] that is configured to only tick while the current tree is enabled, as defined by [TickerMode].\n\n  즉, 사용을 강제하는 주된 이유는 위젯이 위젯 트리에 등록된 상태에서만 Ticker를 제공함으로서 자원을 효율적으로 실수 없이 관리하기 위함이라고 생각됩니다.\n\u003c/tip\u003e\n\n### Controller\n\n생성했으면 이를 사용해야겠죠?\n이 때, vsync 가 사용됩니다.\n\n```dart:animation_controller.dart {12, 15}\nclass AnimationController extends Animation\u003cdouble\u003e\n  with AnimationEagerListenerMixin, AnimationLocalListenersMixin, AnimationLocalStatusListenersMixin {\n\n  AnimationController({\n    double? value,\n    this.duration,\n    this.reverseDuration,\n    this.debugLabel,\n    this.lowerBound = 0.0,\n    this.upperBound = 1.0,\n    this.animationBehavior = AnimationBehavior.normal,\n    required  TickerProvider vsync,\n  }) : assert(upperBound \u003e= lowerBound),\n       _direction = _AnimationDirection.forward {\n    _ticker = vsync.createTicker(_tick);\n    _internalSetValue(value ?? lowerBound);\n  }\n}\n```\n\nvsync는 TickerProvider를 인자로 받게 되는데, TickerProviderStateMixin을 상속받은 클래스(위젯)에서 `vsync: this` 를 다형성의 원리에 의해 종속성 주입하면 해당 클래스(위젯)의 createTicker 함수를 호출할 수 있게 되는 것입니다.\n\n즉, Controller는 부드러운 애니메이션을 위해 Ticker를 사용해야 하는데, 개발자에게 이를 맡겼다간 실수가 발생할 수도 있고, 기타 여러 이유 때문에 TickerProvider 로부터 ticker를 받도록 구현되었고, 그 과정에서 vsync로 종속성을 주입받게 되었다고 정리해볼 수 있겠습니다.\n\n---\n\n## Animation 엿보기\n\n정리하는 차원에서 `_animationController.forward()` 의 과정을 추적해봅시다.\n\n```dart:animation_controller.dart\nTickerFuture forward({ double? from }) {\n  _direction = _AnimationDirection.forward;\n  if (from != null) {\n    value = from;\n  }\n  return _animateToInternal(upperBound);\n}\n```\n\n애니메이션의 방향(_direction)을 설정하고 `_animateToInternal` 함수를 실행합니다.\n\n```dart:animation_controller.dart\nTickerFuture _animateToInternal(double target, { Duration? duration, Curve curve = Curves.linear }) {\n  double scale = 1.0;\n  if (SemanticsBinding.instance.disableAnimations) {\n    switch (animationBehavior) {\n      case AnimationBehavior.normal:\n        scale = 0.05;\n      case AnimationBehavior.preserve:\n        break;\n    }\n  }\n  Duration? simulationDuration = duration;\n  if (simulationDuration == null) {\n    final double range = upperBound - lowerBound;\n    final double remainingFraction = range.isFinite ? (target - _value).abs() / range : 1.0;\n    final Duration directionDuration =\n      (_direction == _AnimationDirection.reverse \u0026\u0026 reverseDuration != null)\n      ? reverseDuration!\n      : this.duration!;\n    simulationDuration = directionDuration * remainingFraction;\n  } else if (target == value) {\n    simulationDuration = Duration.zero;\n  }\n  stop();\n  if (simulationDuration == Duration.zero) {\n    if (value != target) {\n      _value = clampDouble(target, lowerBound, upperBound);\n      notifyListeners();\n    }\n    _status = (_direction == _AnimationDirection.forward) ?\n      AnimationStatus.completed :\n      AnimationStatus.dismissed;\n    _checkStatusChanged();\n    return TickerFuture.complete();\n  }\n  return _startSimulation(_InterpolationSimulation(_value, target, simulationDuration, curve, scale));\n}\n```\n\n`_startSimulation` 실행에 필요한 값들을 연산하고, 기존에 실행 중이던 애니메이션을 stop 하는 것으로 보입니다.\n이 후, `_startSimulation` 함수를 실행합니다.\n\n```dart:animation_controller.dart {5}\nTickerFuture _startSimulation(Simulation simulation) {\n  _simulation = simulation;\n  _lastElapsedDuration = Duration.zero;\n  _value = clampDouble(simulation.x(0.0), lowerBound, upperBound);\n  final TickerFuture result = _ticker!.start();\n  _status = (_direction == _AnimationDirection.forward) ?\n    AnimationStatus.forward :\n    AnimationStatus.reverse;\n  _checkStatusChanged();\n  return result;\n}\n```\n\n초기 값을 설정하고 _ticker를 시작하는 모습입니다.\n참고로 위 코드를 보면 아시겠지만, _ticker는 `_tick` 함수를 매 프레임마다 호출하게 됩니다.\n따라서 `_tick` 함수도 살펴봅시다.\n\n```dart:animation_controller.dart\nvoid _tick(Duration elapsed) {\n  _lastElapsedDuration = elapsed;\n  final double elapsedInSeconds = elapsed.inMicroseconds.toDouble() / Duration.microsecondsPerSecond;\n  _value = clampDouble(_simulation!.x(elapsedInSeconds), lowerBound, upperBound);\n  if (_simulation!.isDone(elapsedInSeconds)) {\n    _status = (_direction == _AnimationDirection.forward) ?\n      AnimationStatus.completed :\n      AnimationStatus.dismissed;\n    stop(canceled: false);\n  }\n  notifyListeners();\n  _checkStatusChanged();\n}\n```\n\n매 프레임마다 _value값이 업데이트 되고, notifyListeners를 통해 화면을 업데이트 하는 모양새입니다.","slug":"flutter/ticker","readingMinutes":8,"wordCount":828},{"title":"Freezed에서 제네릭 사용하기","description":"API 응답 모델링에서 사용하면 좋은 Freezed 제네릭 테크닉에 대해 소개합니다.","icon":"","image":"","tags":["Freezed","Generic"],"draft":false,"date":"2024-01-24 / 22:20","content":"\n기존 JsonSerializable로 아래와 같은 응답을 모델링 하였습니다.\n\n```json:json\n{\n  'code': 1000,\n  'message': '성공',\n  'data': { ... }\n}\n```\n\n이런 식으로, code, message(선택) 가 반드시 포함된 응답이 오는 상황이어서\ncode, message를 갖고있는 ResModel,\n그리고 ResModel을 상속받아 만든 DataModel 이런식으로 구현하였습니다.\n\n하지만, JsonSerializable로 구현했던 모델들을 Freezed로 마이그레이션 하는 과정에서 문제가 발생했습니다.\n바로, Freezed는 상속이 불가능하다는 점..!\n\n그래서 해결책을 몰색하던 중 ResModel에 제네릭 타입의 data 멤버를 추가하면 어떤가 하는 조언을 받았습니다.\n\n좋은 해결책인거 같기도 하고, 마침 Freezed에 대해 딥하게 알아보고 공부할 겸 이 해결책을 적용해보기로 하였습니다.\n\n## 구현\n\n### DataModel\n\n우선 Data에 해당하는 객체를 모델링 하였습니다.\n\n```dart:diary_model.dart\npart 'diary_model.freezed.dart';\npart 'diary_model.g.dart';\n\n@freezed\nclass DiaryModel with _$DiaryModel {\n  factory DiaryModel({\n    @JsonKey(name: 'diaryid') int? id,\n    @JsonKey(name: 'dcontent') String? content,\n    @JsonKey(name: 'dtime') DateTime? time,\n    @JsonKey(name: 'dtag') EEmotion? emotion,\n    @JsonKey(name: 'userid') int? userId,\n    @JsonKey(\n      name: 'openable',\n      fromJson: openableFromJson,\n      toJson: openableToJson,\n    )\n    bool? isOpen,\n  }) = _DiaryModel;\n\n  factory DiaryModel.fromJson(Map\u003cString, dynamic\u003e json) =\u003e\n      _$DiaryModelFromJson(json);\n}\n```\n\n`@JsonKey` 어노테이션을 통해 API에서 전달하는 key와 모델링의 변수명을 변환했습니다.\n또한, openable key의 value가 0 or 1 로 표현하는 bool 형식이라\n0 \u0026rarr; false, 1 \u0026rarr; true 로 변환하는 함수(openableFromJson/ToJson)를 적용하였습니다.\n\n### ResModel\n\n그 다음 공통 응답 모델을 맡을 ResModel을 제네릭으로 모델링합니다.\n\n```dart:res_model.dart\npart 'res_model.freezed.dart';\npart 'res_model.g.dart';\n\n@Freezed(genericArgumentFactories: true)\nclass ResModel\u003cT\u003e with _$ResModel\u003cT\u003e {\n  factory ResModel({\n    required int code,\n    String? message,\n    T? data,\n  }) = _ResModel;\n\n  factory ResModel.fromJson(\n    Map\u003cString, dynamic\u003e json,\n    T Function(dynamic json) fromJsonT,\n  ) =\u003e\n      _$ResModelFromJson\u003cT\u003e(json, fromJsonT);\n}\n```\n\n여기서 눈여겨 봐야 할 점은 fromJson의 인자로 fromJsonT 함수를 전달한다는 것입니다.\n\n보통은 fromJson에 json 만 인자로 넘기는데, 제네릭을 포함하는 경우 문제가 발생합니다.\n바로 제네릭에 해당하는 객체의 직렬화, 역직렬화 로직을 프로그램은 모른다는 것이죠.\n\n따라서 해당 로직을 대신 수행할 fromJsonT 함수를 인자로 추가로 받는 것입니다.\n(toJsonT는 freezed에 의해 자동 생성되며, 마찬가지로 toJsonT를 인자로 받습니다.)\n\n이를 build_runner가 알도록 하기 위해 **@freezed** 어노테이션 대신 **@Freezed** 를 사용하며,\n`genericArgumentFactories`을 true로 설정합니다.\n\n### fromJson / toJson\n\n이제 실제로 사용도 해봐야겠죠?\n\n```dart:diray_repository.dart\nvar resModel = ResModel\u003cDiaryModel\u003e.fromJson(\n  res.data,\n  (json) =\u003e DiaryModel.fromJson(json),\n);\n```\n\n첫 번째 인자로 API의 응답으로 온 json 이 들어갑니다.\n두 번째 인자로는 제네릭 타입의 역직렬화를 수행하는 함수가 들어가는데, 제네릭이 DiaryModel 이므로, DiaryModel.fromJson를 넣어주면 됩니다.\n(참고로 파라미터로 전달되는 json 인자에는 data의 value가 전달됩니다.)\n\ntoJson도 살펴봅시다.\n\n```dart:diray_repository.dart\nvar reqJson = resModel.toJson(\n  (model) =\u003e DiaryModel.fromJson(model),\n);\n```\n\n인자로는 제네릭 타입의 직렬화를 수행하는 함수가 들어가는데, 제네릭이 DiaryModel 이므로, DiaryModel.toJson를 넣어주면 됩니다.\n(참고로 파라미터로 전달되는 model 인자에는 diaryModel의 인스턴스가 전달됩니다.)\n\n### 결과물\n\ndata가 없는 경우, 또는 필요 없는 경우에는 아래와 같이 fromJson을 사용할 수 있습니다.\n\n```dart:auth_interceptor.dart\nvar res = ResModel.fromJson(response.data, (json) =\u003e null);\nif (res.code == 2000) {\n  AuthBlocSingleton.bloc.add(AuthSignoutEvent());\n}\n...\n```\n\n또한, data가 있는 경우, 또는 필요한 경우에는 아래와 같이 fromJson을 사용할 수 있습니다.\n\n```dart:diray_repository.dart\nDio dio = Dio();\ndio.interceptors.add(AuthInterceptor());\nvar res = await dio.get(\n  '/diary',\n  queryParameters: {\n    'emotion': emotion.key,\n  },\n  data: {\n    'page': page,\n  },\n);\n\nvar resModel = ResModel\u003cDiaryModel\u003e.fromJson(\n  res.data,\n  (json) =\u003e DiaryModel.fromJson(json),\n);\n```\n\n코드의 재사용성을 최대로 하고, 로직간의 의존성을 최소화 하도록 구현해본 유익한 시간이었습니다 ㅎㅎ.","slug":"flutter/generic_freezed","readingMinutes":5,"wordCount":469},{"title":"BLoC, context 외부에서 관리하기","description":"BuildContext 없이 BLoC에 접근하고, listen 하는 방법을 알아봅니다.","icon":"","image":"","tags":["BLoC","Singleton Pattern"],"draft":false,"date":"2024-01-24 / 19:15","content":"\n보통 Bloc은 BlocProvider로 context(위젯트리)에서 관리하고, `context.read\u003cBloc\u003e()` 형태로 읽어오죠?\n하지만, 이 경우 문제가, context 밖에서는 Bloc에 접근할 방법이 없다는 것입니다.\n\n제 경우에는, dio interceptor에서 Bloc에 접근하고 싶은 상황이었죠..\n\n이런 상황, 혹은 앱 실행시간동안 계속 필요한 Bloc의 경우 Singleton Pattern을 이용하여 관리하는 유용한 방법에 대해 설명하려 합니다.\n\n## BlocBuilder\n\n우선 BlocBuilder, Listern의 bloc 파라미터를 먼저 살펴봅시다.\n보통은 bloc 파라미터를 null값으로 놔두고 사용합니다.\n\n하지만, 아래의 bloc 소스 코드를 살펴보겠습니다.\n\n```dart:bloc_builder.dart {9}\nclass _BlocBuilderBaseState\u003cB extends StateStreamable\u003cS\u003e, S\u003e\n    extends State\u003cBlocBuilderBase\u003cB, S\u003e\u003e {\n  late B _bloc;\n  late S _state;\n\n  @override\n  void initState() {\n    super.initState();\n    _bloc = widget.bloc ?? context.read\u003cB\u003e();\n    _state = _bloc.state;\n  }\n  ...\n}\n```\n\n보이는 바와 같이, bloc이 null값이면 context에서, notnull이면 bloc 에서 bloc을 가져오는 방식으로 작동합니다.\n\n즉, context에서 bloc에 접근할 수 없는 경우에는 bloc 파라미터에 bloc을 직접 주입시키면 되는 것입니다.\n이를 응용해서 코드 어디에서나 Singleton Pattern을 통해서 bloc에 접근하는 방법을 사용해 볼 수 있겠습니다.\n\n## 구현\n\n### Singleton\n\n우선, context 외부에서 관리할 Bloc의 인스턴스를 보관할 Singleton 객체를 하나 만들어줍니다.\n\n```dart\nclass AuthBlocSingleton {\n  AuthBlocSingleton._constructor();\n  static final AuthBlocSingleton _signleton = AuthBlocSingleton._constructor();\n  static AuthBlocSingleton get instance =\u003e _signleton;\n\n  static late final AuthBloc _bloc;\n  static AuthBloc get bloc =\u003e _bloc;\n\n  static initializer({required AuthenticationRepository repository}) {\n    _bloc = AuthBloc(authenticationRepository: repository);\n  }\n}\n```\n\n이렇게하면, AuthBlocSingleton.bloc 으로 코드 전역에서 접근할 수 있습니다.\n(물론 사용하기 전에 initializer 메서드를 호출해야만 합니다)\n\n### Initialized\n\n그리고, bloc에 종속성을 주입해야 하는 경우, 사용하기 전에 주입하도록 합시다.\n\n```dart:app_routes.dart\n\nclass _AppRoutesState extends State\u003cAppRoutes\u003e {\n  late GoRouter _routerConfig;\n\n  @override\n  void initState() {\n    super.initState();\n\n    // Initialize AuthBloc\n    AuthBlocSingleton.initializer(\n      repository: context.read\u003cAuthenticationRepository\u003e(),\n    );\n    ...\n  }\n  ...\n}\n```\n\n제 경우에는 repository를 context에 주입하여 사용하고 있기 때문에, context에 접근 가능한 최상위 위젯에서 bloc에 주입시켜 초기화를 진행하였습니다.\n\n### 결과물\n\n이제 BlocBuilder, Listener는 아래와 같이 코드 한 줄만 추가하면 됩니다.\n\n```dart {2}\nBlocBuilder\u003cAuthBloc, AuthState\u003e(\n  bloc: AuthBlocSingleton.bloc,\n  builder: (context, state) {\n  ...\n```\n\n이렇게 하면, BlocProvider로 Bloc을 생성하지 않고도 Bloc을 사용할 수 있습니다.\n아래와 같은 장점도 챙길 수 있죠!\n1. 위젯트리가 가벼워진다.\n2. 싱글톤으로 코드 어디서나 Bloc에 접근할 수 있다. (state, add() 모두 가능)\n\n따라서 dio의 interceptor 클래스에서 아래와 같은 코드로 가능해집니다.\n\n```dart:auth_interceptor.dart {17}\nclass AuthInterceptor extends Interceptor {\n  ...\n  @override\n  void onResponse(\n    Response response,\n    ResponseInterceptorHandler handler,\n  ) async {\n    // Logging\n    debugPrint(\n      '[RES] [${response.requestOptions.method}] ${response.requestOptions.uri}',\n    );\n\n    // Error handling\n    var res = ResModel.fromJson(response.data, (json) =\u003e null);\n    if (res.code != 1000) {\n      if (res.code == 2000) {\n        AuthBlocSingleton.bloc.add(AuthSignoutEvent());\n      }\n      handler.reject(\n        DioException.connectionError(\n          requestOptions: response.requestOptions,\n          reason: res.message ?? Strings.unknownFail,\n          error: res,\n        ),\n      );\n      return;\n    }\n\n    handler.next(response);\n  }\n  ...\n}\n```\n\napi 응답 중 jwt관련 인증 문제가 발생하는 경우, 자동으로 로그아웃 하는 로직도 이런식으로 구현할 수 있습니다.","slug":"flutter/bloc_outof_context","readingMinutes":5,"wordCount":412},{"title":"FCM, BLoC으로 관리하기","description":"FCM 응답을 BLoC을 이용해서 상태관리 하는 방법에 대해 알아봅니다.","icon":"","image":"","tags":["Firebase Cloud Message","FCM","BLoC","Cubit"],"draft":false,"date":"2024-01-21 / 22:41","content":"\nFCM을 구현하는데 있어, FCM 세팅이나 수신하는 방법에 대한 글은 많이 봤는데,\n이를 상태관리와 엮어서 소개하는 글은 못봤던거 같습니다.\n\n제 경우에는 코드 스타일을 통일하는 것을 좋아하기 때문에, FCM 역시 상태관리를 이용해서 관리하고 싶었습니다.\n\n또한, 저는 Bloc을 애용하기 때문에, 이번에는 FCM이 수신되면 Bloc을 통해 해당 상태를 관리하는 방법에 대해 알아보려 합니다.\n(정확히는 Cubit을 사용할 예정입니다)\n\n\u003cnotice\u003e\n  해당 방식은 부족한 제 지식으로 자체 구현한 방법이기 때문에 다소 어설프게 보일 수 있음을 알려 드립니다.\n\u003c/notice\u003e\n\n## FirebaseMessaging\n\n우선 FCM을 사용하기 앞서, FirebaseMessaging 객체를 조금만 살펴봅시다.\n\n앱의 상태(fore/background, terminate)에 따라 FCM 수신 방법이 달라지는데, 각 상태에 따른 수신 방법은 아래와 같습니다.\n\n- **foreground**\n\n    앱이 화면위에서 실행중인 경우에 해당하며, 수신 방법은 다음과 같습니다.\n\n    ```dart:.dart\n      FirebaseMessaging.onMessage.listen(listenFCM);\n\n      void listenFCM(RemoteMessage? message) { ... }\n    ```\n\n- **background**\n\n    앱이 죽지는 않았지만 화면위에 없는 경우. \n    즉, 태스크매니져 상에만 존재하는 백그라운드 상태에 해당하며, 수신 방법은 다음과 같습니다.\n\n    ```dart:.dart\n      FirebaseMessaging.onMessageOpenedApp.listen(listenFCM);\n\n      void listenFCM(RemoteMessage? message) { ... }\n    ```\n\n- **terminate**\n\n    앱이 완전히 종료된 상태에 해당하며, 수신 방법은 다음과 같습니다.\n\n    ```dart:.dart\n      FirebaseMessaging.onBackgroundMessage(onBackgroundMessage);\n      ...\n      Future\u003cvoid\u003e onBackgroundMessage(RemoteMessage message) async { ... }\n    ```\n\n    \u003cnotice\u003e\n      fore/background 와 다르게, terminate의 이벤트핸들러는 static 형식, 또는 전역으로 관리되는 비동기 함수여야 합니다.\n    \u003c/notice\u003e\n\n\u003ctip\u003e\n  fore/background의 경우에는 onBlah getter를 이용해서 stream을 반환하고, stream의 listen을 이용해서 stream을 구독합니다.\n  즉, 인스턴스가 존재하는한, 스트림 형식으로 지속해서 FCM과 같은 이벤트를 수신할 수 있습니다.\n  \u003cbr /\u003e\n  반면에 terminate의 경우에는 앱이 죽은 상태에서의 FCM 수신을 담당하기 때문에, stream 형식으로 지속적으로 수신할 필요가 없습니다.\n\u003c/tip\u003e\n\n---\n\n## 구현\n\n### State\n\nCubit에서 관리할 상태 클래스를 우선 정의합니다.\n\n```dart:fcm_cubit.dart\nclass FCMState extends Equatable {\n  final FCMEvent state;\n  final String? body;\n  final FCMDataModel? data;\n\n  const FCMState({\n    this.state = FCMEvent.none,\n    this.body,\n    this.data,\n  });\n\n  factory FCMState.fromBgMessage(RemoteMessage? message) {\n    if (message != null) {\n      if (message.notification != null) {\n        return FCMState(\n          state: FCMEvent.message,\n          body: message.notification!.body,\n          data: FCMDataModel.fromJson(message.data),\n        );\n      }\n    }\n    return const FCMState();\n  }\n\n  @override\n  List\u003cObject?\u003e get props =\u003e [\n        state,\n        body,\n        data,\n      ];\n}\n```\n\n`FCMEvent`는 자체 정의한 해당 fcm의 타입을 관리하는 enum 타입입니다. (option)\n\n`body`는 앱의 푸쉬 알림에서 보여지는 문자열을 보관하는 멤버 변수입니다.\n\n\u003ctip\u003e\n  기본 firebase_messaging 에서 FCM이 수신되었을 때, 푸쉬알림은 background, terminate 상태에서만 표시되고, foreground 상태에서는 푸쉬알림이 발생하지 않습니다 (FCM 자체는 수신됨).\n  \u003cbr /\u003e\n  따라서, body에 데이터를 보관하고, 상태가 변화했을 때 Snackbar 와 같은 방식으로 사용자에게 알려줄 수 있습니다.\n\u003c/tip\u003e\n\n`FCMDataModel`은 FCM의 data 객체의 정보를 저장하는 자체 모델입니다.\n이 모델은 int `code`, String `data`을 갖고있습니다.\n`code`는 일종의 응답코드로, code에 따라 FCM이 수신되었을 때의 앱의 동작이 달라지게 됩니다.\n`data`는 직렬화된 객체의 json 문자열으로, code에 따라 파싱 방법이 달라지며, 필요한 정보를 보관합니다.\n\n모든 FCM 이벤트 핸들러는 `RemoteMessage` 객체를 파라미터로 넘겨받기 때문에, 해당 객체를 이용한 생성자를 구현하여 상태를 업데이트 합니다.\n\n### Cubit\n\n다음으로 위에서 언급했던 fore/background는 Cubit 생성자에서 스트림을 구독받도록 구현합니다.\n\n```dart:fcm_cubit.dart\nclass FCMCubit extends Cubit\u003cFCMState\u003e {\n  final String _fcmToken;\n\n  FCMCubit(\n    this._fcmToken,\n    RemoteMessage? bgMessage,\n  ) : super(FCMState.fromBgMessage(bgMessage)) {\n    // fcm listening\n    // at foground\n    FirebaseMessaging.onMessage.listen(listenFCM);\n    // at background\n    FirebaseMessaging.onMessageOpenedApp.listen(listenFCM);\n  }\n\n  // token getter\n  String get token =\u003e _fcmToken;\n  \n  void listenFCM(RemoteMessage? message) {\n    if (message != null) {\n      emit(FCMState(\n        state: FCMEvent.message,\n        body: message.notification?.body,\n        data: FCMDataModel.fromJson(message.data),\n      ));\n    }\n    emit(const FCMState());\n  }\n}\n```\n\n이렇게 하면 fore/background 에서 FCM이 수신될 때 마다 listenFCM 리스너가 실행이 되고,\n해당 리스너 안에서 emit을 2회 호출하게 됩니다.\n\n첫 번째 emit에서는 위에서 정의한, RemoteMessage의 데이터를 활용해 초기화된 FCMState 상태로 업데이트 되고,\n두 번째 emit에서는 init 상태의 FCMState 상태로 되돌립니다.\n\n두 번째 emit이 필요한 이유는, 동일한 FCM이 2번 연속 수신되는 일도 존재할 수 있기 때문에 상태를 초기화 시켜 2번 모두 정상적으로 수신시켜 주기 위함입니다.\n\n### main\n\n이제 main에서 FCM Token과 권한 요청, terminate의 동작을 정의하도록 합니다.\n\n```dart:main.dart\nRemoteMessage? bgMessage;\n\nvoid main() async {\n  // flutter ensure initialized\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // request FCM permission\n  FirebaseMessaging.instance.requestPermission(\n    badge: true,\n    alert: true,\n    sound: true,\n  );\n\n  // listening fcm from background\n  FirebaseMessaging.onBackgroundMessage(_onBackgroundMessage);\n\n  // get fcm token\n  String? fcmToken = await FirebaseMessaging.instance.getToken();\n  debugPrint('FCM Token: $fcmToken');\n\n  runApp(MyApp(\n    fcmToken: fcmToken ?? '',\n    bgMessage: bgMessage,\n  ));\n}\n\nFuture\u003cvoid\u003e _onBackgroundMessage(RemoteMessage message) async {\n  bgMessage = message;\n}\n```\n\n제가 구현했을 때는, terminate 에서의 FCM 수신은 앱의 최초 화면을 제어하는 용도로만 사용했었습니다.\n\n따라서, bgMessage에 임시 보관하여 runApp으로 넘겨주었습니다.\n이후에 별도 처리를 통해 go_router의 initialRoute를 설정하였습니다.\n\n### BlocProvider\n\n이제 FCMCubit을 BuildContext에 등록을 시킵시다.\n\n```dart:main.dart\nclass MyApp extends StatelessWidget {\n  final String fcmToken;\n  final RemoteMessage? bgMessage;\n\n  const MyApp({\n    super.key,\n    required this.fcmToken,\n    this.bgMessage,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return MultiRepositoryProvider(\n      providers: [ ... ],\n      child: MultiBlocProvider(\n        providers: [\n          BlocProvider(\n            create: (context) =\u003e FCMCubit(\n              fcmToken,\n              bgMessage,\n            ),\n            lazy: false,\n          ),\n          ...\n        ],\n        child: const App(),\n      ),\n    );\n  }\n}\n```\n\n이렇게 하면 Bloc을 통해 FCM의 상태를 관리할 준비가 모두 끝납니다.\n\n### 결과물\n\n```dart:.dart {1}\nBlocListener\u003cFCMCubit, FCMState\u003e(\n  listener: (context, state) {\n    if (state.data?.code == \"10000\") {\n      // action for res code 10000\n    }\n    if (state.data?.code == '10001') {\n      // action for res code 10001\n    }\n    if (state.data?.code == '10002') {\n      // action for res code 10002\n    }\n  },\n  ...\n),\n```\nFCM이 수신될 경우, `BlocListener\u003cFCMCubit, FCMState\u003e`를 통해 FCM에 의한 state에 접근할 수 있고,\n\n```dart:.dart {6}\nBlocProvider(\n  create: (context) =\u003e SignalStateBloc(\n    homeSignalBoxRepository: context.read\u003cHomeSignalBoxRepository\u003e(),\n    myIdx: context.read\u003cUserCubit\u003e().state.user!.userIdx!,\n    jwt: context.read\u003cUserCubit\u003e().state.user!.jwt!,\n    fcmToken: context.read\u003cFCMCubit\u003e().token,\n  ),\n),\n```\n\n서버에서 FCM Token이 필요한 경우 `FCMCubit.token`을 통해 해당 클라이언트의 FCM Token을 조회할 수 있습니다.\n\nBloc으로 FCM까지 관리 완료!","slug":"flutter/fcm_with_bloc","readingMinutes":9,"wordCount":819},{"title":"Happy Career (24) 회고","description":"참여자의 시선에서 GDGxGDSC의 24년도 Happy Career 행사 회고 및 얻은 점을 공유합니다.","icon":"","image":"","tags":["Happy Career","GDG Campus Korea","GDSC"],"draft":false,"date":"2024-01-20 / 19:47","content":"\n## 계기\n\n대학교 4학년을 준비하는 겨울 방학 시즌, 슬슬 취업에 대한 압박감이 다가오기 시작했습니다...\n사실 전부터 막연하게 취업에 대한 생각이 있었지만, 이제 슬슬 구체화해야 해야겠다는 생각이 들더군요..ㅎ\n\n그때였습니다.\nGDSC KW에서 코어로 활동하던 중, 리드님이 Happy Career 행사가 열린다는 소식을 공유해 주셨습니다.\n\n![240120-195500](/posts/240120_happy_career/240120-195500.png)\n\n사람 만나는게 익숙치 않았지만, 저도 변하기 위해서 용기를 내어 이번 행사에 참여하기로 결정했습니다!\n\n---\n\n## 과정\n\n### 사전준비?\n\n![240120-195846](/posts/240120_happy_career/240120-195846.png)\n\n저 답지 않게, 커피챗을 너무나 하고싶은 나머지, GDG Campus Korea 오픈채팅방에 들어가서 이런저런 질문도 해보고, 구글 스타트업 캠퍼스로 출발했습니다.\n\n### 도착\n\n기대 반, 떨림 반 떄문인지 20분 일찍 도착하여, 체크인을 하고 자리에서 대기하였습니다.\n\nDevfest 기념품도 받을 수 있었습니다. ㅎㅎ\n\n### 연사님의 연사\n\n두 분의 연사님께서 커리어를 쌓으며 느꼈던 점과, 그 방향 등을 공유해 주셨습니다.\n\n그 중 기억에 남는 내용을 Q\u0026A 형식으로 적어볼까 합니다.\n\n\u003e **성장하는 방법?**\n\u003e\n\u003e 우선 본인의 욕망을 들여다봐야 합니다.\n\u003e 본인이 뭘 좋아하고, 잘하고, 재능이 뭔지를 우선 파악하는 것이 중요합니다.\n\u003e 이후 목표와 방향성을 수립하여 해당 성향의 회사를 선택하는 것이 좋습니다.\n\u003e 이 때, 목표가 있다면 반드시 어딘가에 기록하여, 본인이 정말 성취했는지 파악하는 것도 중요합니다.\n\n\u003e **좋은 습관을 형성하는 방법?**\n\u003e\n\u003e 하루 10분, 스몰 스탭을 잡는것이 좋습니다.\n\u003e 하루 10분 해외 기사 읽기, 영어 공부 등 본인만의 브랜드를 개척하는 것입니다.\n\u003e 이 과정에서 \"목표 설정\" \u0026rarr; \"환경 설정\" \u0026rarr; \"실천 및 테스트\" 과정을 반복하여 피드백을 통해 개선 및 내것으로 만들면 됩니다.\n\n\u003e **신입의 고충 및 어필방법**\n\u003e\n\u003e 신입은 당연스럽게도 경력이 부족합니다.\n\u003e 따라서 기술적인 부분도 좋지만, 기본기나, 사이트 프로젝트를 진행하며 고민의 흔적과 기술 선택 이유 등에 대해 어필하는게 좋습니다.\n\u003e 반대로, 이력서에 내용이 많다면?\n\u003e 이건 이대로 해당 내용으로 공격을 많이 받을 수 있습니다. 따라서 중요하거나 잘 아는 것만, 꼬리 질문까지 대비하여 작성하는 것이 바람직 합니다.\n\n\u003e **신입 vs 2년차**\n\u003e\n\u003e 개인마다 다르겠지만, 면접관의 입장에서는 둘 다 비슷하게 보일 확률이 높습니다.\n\u003e 하지만, 신입의 경우에는 사이드 프로젝트와 협업 경험을 살려 어필하는게 좋고,\n\u003e 2년차 주니어의 경우에는 신입과 동일하지만, 회사에서 무엇을 했는지, 회고, 느낀점 등을 추가로 기술하는게 좋습니다.\n\n\u003e **입사 제의 받는 법?**\n\u003e\n\u003e 본인의 경력과 PR이 잘 되어있어야겠죠..\n\u003e 보통 그 어필을 Linkedin 과 같은 플렛폼에 잘 기술해두면 연락이 올 수도 있습니다.\n\n\u003e **같이 일하고 싶은 개발자는?**\n\u003e\n\u003e YES맨이면 좋지만, 불가능한 부분은 왜 안되는지 잘 짚어줄 수 있는 사람이 좋습니다.\n\u003e 한마디로, 긍정적이고 대화가 잘 통하는 사람이 좋습니다.\n\n\n### Coffee Chat\n\n사실 이 세션을 위해 여기까지 온거라 볼 수 있겠죠..\n하지만, 생각보다 신청자가 많아 처음에는 신청에 실패했습니다 ㅜㅜ.\n\n그래서 아쉽지만, 맨토님께 네트워킹 세션 시간에라도 간단한 질문 한 두개 정도 받아주실 수 있는지 여쭤봤습니다.\n그러자, OK라는 답변과 함께, 커피챗 세션이 추가로 열릴 수 있다는 답변을 받을 수 있었습니다.\n\n그래서 수강신청에서 과목을 줍는다는 마음으로 신청폼을 계속해서 새로고침 해봤습니다...\n\n그러자 26일이 추가로 열린것이 아니겠습니까? (당일은 20일 이었습니다)\n그래서 혹시나 하는 마음에 일단 개인정보는 기록해놓고 대기하고 있었습니다.\n\n이후 운영진 분들이 다시 신청할 수 있다고 말씀해주셔서 냉큼 제출하여 운이 좋게도 커피챗 기회를 얻을 수 있었습니다.\n\n맨토님과, 저를 포함한 4명의 참가자 분들이 1시간동안 지속되는 커피챗에 참가하였고,\n신기하게도 맨토님께서 아까 질문 드릴 때의 제 얼굴을 기억하고 계셨던게 인상 깊었습니다 ㅎㅎ.\n\n커피챗 내용 중 기억에 남는 내용을 Q\u0026A 형식으로 정리해봅니다.\n\n\u003e **개발자에게 좋은 회사란?**\n\u003e\n\u003e 개발자에게 맡기는(권한을 위임하는) 문화를 가진 회사가 좋은 문화를 가진 회사라 생각합니다.\n\u003e 그 지표로, `데브렐` 부서나, 커뮤니케이션을 집중적으로 담당하시는 팀장님이 별도로 계신 회사가 그런 기업 문화를 가진 회사로 판단할 수 있습니다.\n\n\u003e **플러터 개발자는 신입으로 잘 안뽑는다?**\n\u003e\n\u003e 잘 안뽑는다기 보단, 플러터가 크로스플랫폼을 타게팅으로 나온만큼, 여러 분야에 대해 전문적인 지식이 필요해서 그렇게 평가하는거 같습니다.\n\u003e 하지만, 신입 수준에서 어느정도 전문 지식을 갖추고, 성장 가능성을 보여준다면, 면접에서 떨어질 일은 적으니 너무 걱정하지 않아도 될 거 같습니다.\n\u003e 오히려, 해외에서는 플러터로 거의 전환된 상태이기 때문에 전망도 나쁘지 않습니다.\n\u003e 물론, 딥한 영역은 플러터가 해결할 수 없기 때문에, 안드로이드와 같은 네이티브 영역또한 사라질 일이 없을 거 같습니다.\n\n\u003e **신입 개발자의 자세?**\n\u003e\n\u003e 우선을 알고리즘과, 자료구조와 같은 기본 지식이 탄탄해야 합니다.\n\u003e 나아가 대학 활동이나 플젝을 수행함에 있어서, 해당 활동(플젝)을 본인이 수행할 수 있음(역량)을 증명할 수 있어야 합니다.\n\u003e 양보다는 질이 중요하며, 높은 성장률을 기대하는 경우가 많습니다.\n\n\u003e **나의 객관적인 위치를 파악하는 법?**\n\u003e\n\u003e 커뮤니티에서 포트폴리오를 평가해주시는 분들이 있습니다.\n\u003e 그 분들에게 이력서를 피드백 받으면 객관적인 평가가 가능할 것입니다.\n\n\u003e **커뮤니티에 잘 녹아드는 방법?**\n\u003e\n\u003e 우선은 여기저기 여러 커뮤니티 세션에 참여하는 것 부터 시작해야 합니다.\n\u003e 이후, 본인 성향의 커뮤니티를 남기고 추려가면서 활동하다보면 녹아들 수 있을 겁니다.\n\n\u003e **기업 입장에서 자소서에 강점으로 쓰면 좋은 것?**\n\u003e\n\u003e 터무니 없지 않은 강점을 작성하되, 본인의 강점을 뒷받침 해주는 기업에 지원하는 것이 중요합니다.\n\u003e 신입의 경우, 강점 자체는 이 사람이 논리적인 사람인지 파악하는 용도로서 쓰이며, 열정과 끈기를 중요시하게 봅니다.\n\n### 네트워킹\n\n이후에는 네트워킹 세션이 진행되었습니다.\n간단한 게임으로 코인을 벌어 가장 많은 코인을 모으는 팀이 우승하는 방식이었습니다.\n\n조건에 해당하는 사람을 찾아오는 문제도 있었는데, 앱 출시해본 사람이나, 프로젝트 경험, 웹 개발 등등 상당한 부분에서 _'저요!!'_ 하면서 뛰쳐나갔던 기억이 납니다 ㅋㅋ.\n\n하지만, 2위와 코인 1개 차이로 아쉽게 입상하지 못했네요 ㅜㅜ.\n\n---\n\n## 회고\n\n이번 행사를 참여하고 나서, 취업에 대한 **막연한 두려움의 원인을 알아**낼 수 있었습니다.\n바로 정보의 부재 때문이었던거 같습니다.\n\n신입 개발자의 자세나, 역량에 대한 기대를 현직자의 시선에서 들어보니, 어떤 방향으로 노력하는게 좋은지 방향이 명확해지며, 불안감도 어느정도 해소되었던거 같습니다.\n\n뿐만 아니라, 모의 면접을 관전하며 (근거는 충분치 않지만) **자신감**도 어느정도 얻을 수 있었습니다.\n\n저는 프론트엔드(Web)을 공부하다가 플러터로 갈아탄 케이스인데, 절반 정도의 프론트엔드 면접 질문에 대한 답이 떠올랐습니다.\n물론, 완벽하게 답변할 수는 없었겠지만, 제가 지금까지 학습한 내용들이 헛되지 않았음을 재확인 할 수 있었던 거 같습니다.\n만약, 플러터에 대한 질문이 들어온다면, 제 생각으로 프론트엔드 파트에서 답변했던 것 이상으로 잘 답변할 수 있을거 같았기에, 자신감도 어느정도 가질 수 있었습니다.\n\n두려워 말고, 내가 할 수 있는 최선의 활동을 하고, 기초를 단단히 다진다면, 플러터 분야의 신입 개발자라도 기회는 반드시 올 것이라는 희망을 가질 수 있는 값진 시간이었습니다.\n\n마지막으로 이런 행사를 마련해주신 GDG Campus Korea, GDSC 커뮤니티 및 연사님, 멘토님과 정보를 제공해주신 GDSC KW 1기 리드님께 감사드립니다.","slug":"memoir/240120_happy_career","readingMinutes":14,"wordCount":933},{"title":"ValueNotifier","description":"setState 없이 일부분만 리랜더링 할 수 있도록 해주는 ValueNotifier, ValueListenableBuilder 에 대해 알아봅니다.","icon":"","image":"","tags":["ValueNotifier","ValueListenableBuilder"],"draft":false,"date":"2024-01-17 / 15:08","content":"\n저는 게임이나, 깃허브(깃허브 서비스 그 자체)에서 영감을 많이 얻는 편입니다.\n그 중에 깃허브 앱에서 꼭 따라해보고 싶은 UI가 있었습니다.\n\n![github_app](/posts/valuenotifier/github_app.gif)\n\n바로 AppBar가 스크롤함에 따라 움직이는 애니메이션이죠!\n\n그래서 구글링 해보니까 ScrollController와 `ValueNotifier` 만 있으면 쉽게 구현이 가능했기에 오늘은 이 방법에 대해 적어보려 합니다.\n\n## ValueNotifier\n\n[공식문서](https://api.flutter.dev/flutter/foundation/ValueNotifier-class.html) 의 내용을 요약하면 다음과 같습니다.\n\n\u003e ChangeNotifier를 상속 받았으며, 단일 value를 갖고 있습니다.\n\u003e oldValue와 newValue를 == 연산자를 통해 비교하며,\n\u003e 그 값이 다를 경우 listener 에게 notify 하게 됩니다. (notifyListeners를 호출하는 방식)\n\n따라서 ValueNotifier는 일종의 observer pattern으로 구현되어 있기 떄문에 stateful widget의 상태주기에 의해 제어되지 않을 수 있습니다.\n\n\n\n### ValueListenableBuilder\n\n이 위젯은 필수로 valueListenable 인자를 받게 되어있습니다.\n이 인자로는 반드시 Listenable 을 상속받은 `ValueListenable` 객체를 넘겨주어야 합니다.\n\n이 때, ValueNotifier는 **ValueListenable의 구현체**이기 때문에 ValueNotifier를 인자로 넘겨주면 이 빌더 위젯이 ValueNotifier 상태가 변화하면 알아서 이 부분만 재랜더링 하게 되는 것입니다.\n\n```dart:value_listenable_builder.dart\n@override\nvoid didUpdateWidget(ValueListenableBuilder\u003cT\u003e oldWidget) {\n  super.didUpdateWidget(oldWidget);\n  if (oldWidget.valueListenable != widget.valueListenable) {\n    oldWidget.valueListenable.removeListener(_valueChanged);\n    value = widget.valueListenable.value;\n    widget.valueListenable.addListener(_valueChanged);\n  }\n}\n\nvoid _valueChanged() {\n  setState(() { value = widget.valueListenable.value; });\n}\n```\n\n실제로 위젯을 까(?)보면 valueListenable이 변경될 때 마다 stateful 위젯이 재랜더링 됨을 볼 수 있었네요!\n\n---\n\n## 구현\n\n이제 이론적인 내용은 다뤄봤으니 실제로 구현을 해봅시다.\n\n### 컨트롤러\n\n```dart:myinfo_screen.dart {4, 5}\nclass _MyinfoScreenState extends State\u003cMyinfoScreen\u003e {\n  static const double _expandedHeight = 250;\n  static const double _appbarHeight = Sizes.size52;\n  late ScrollController _scrollController;\n  final ValueNotifier\u003cdouble\u003e _titleBottomPadding = ValueNotifier(0);\n\n  @override\n  void initState() {\n    super.initState();\n    _scrollController = ScrollController();\n    _scrollController.addListener(_scrollListener);\n  }\n```\n\n우선 ScrollController와 ValueNotifier를 생성 및 초기화 해줍니다.\ndispose도 잊지 마세요!\n\n### 위젯\n\n```dart:myinfo_screen.dart {6, 19}\noverride\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: ValueListenableBuilder(\n          valueListenable: _titleBottomPadding,\n          builder: (context, value, child) =\u003e AnimatedContainer(\n            duration: const Duration(milliseconds: 1),\n            margin: EdgeInsets.only(\n              bottom: value * 2,\n              top: _appbarHeight,\n            ),\n            child: child,\n          ),\n          child: ... \n        ),\n      ),\n      body: CustomScrollView(\n        controller: _scrollController,\n      ...\n```\n\n그리고, 스크롤이 되는 위젯에는 ScrollController 객체를 넣어주고,\n스크롤에 따라 애니메이션 되어야 할 부분은 ValueListenableBuilder 위젯으로 구현합니다.\n이 떄, valueListenable의 인자로 ValueNotifier 객체를 넣어줍니다.\n\n\u003ctip\u003e\n  여기서 ValueListenableBuilder의 builder 함수의 파라미터로 넘어오는 value로\n  ValueNotifier에 보관되어있는 value의 값에 접근할 수 있습니다.\n\u003c/tip\u003e\n\n### 이벤트 리스너\n\n```dart:myinfo_screen.dart\nvoid _scrollListener() {\n  const ratio = 0.3;\n  if (_expandedHeight - _appbarHeight * ratio \u003e _scrollController.offset) {\n    _titleBottomPadding.value = 0;\n  }\n  if (_expandedHeight - _appbarHeight * ratio \u003c= _scrollController.offset \u0026\u0026\n      _expandedHeight + _appbarHeight * (1 - ratio) \u003e=\n          _scrollController.offset) {\n    _titleBottomPadding.value =\n        _scrollController.offset - _expandedHeight + _appbarHeight * ratio;\n  }\n  if (_expandedHeight + _appbarHeight * (1 - ratio) \u003c\n      _scrollController.offset) {\n    _titleBottomPadding.value = _appbarHeight;\n  }\n}\n```\n\n마지막으로 ScrollController의 listener 함수를 구현하면 깃허브 앱 AppBar 구현 완료!\n\n### 결과물\n\n![my_app](/posts/valuenotifier/my_app.gif)\n\n라이브러리 안쓰고 직접 구현하고, 코드 분석해보는...\n조금은 성장하는 맛이 있는 시간이었습니다 ㅎㅎ","slug":"flutter/valuenotifier","readingMinutes":4,"wordCount":425},{"title":"AI","description":"게임에서의 AI, 그 중 pathfinding 방식에 대해 알아봅니다.","icon":"","image":"","tags":["Pathfinding","Greedy","BSF","A*","Planning"],"draft":false,"date":"2023-12-11 / 20:48","content":"\n## Basic Pathfinding\n\n경로 찾기 알고리즘을 평가하는 요소는 다음과 같습니다.\n\n- 해가 존재하는 문제에 대해 해를 구할 수 있는가? (Complete)\n- 최적해를 보장할 수 있는가? (Optimal)\n- 시간, 공간 복잡도가 복잡한가? (Time, Space)\n\n여러 알고리즘을 알아보며 평가해봅시다.\n\n### Greedy\n\n당장의 이득이 큰 선택을 이어가는 방식입니다.\n예로 들어 현재 위치에서 목적지 까지의 거리가 최소화되는 방향으로 이동하는 방식이 그리디 정책입니다.\n\n하지만, 최적해를 보장하지 못한다는 문제가 있습니다.\n\n### BFS\n\n그리디 방식보다는 Graph를 탐색하는 기법을 활용하는 것이 최적해를 찾을 수 있습니다.\n그 중 Breadth First Search 방식은 최적해를 보장할 수 있습니다.\n\n하지만, BFS는 모든 경로를 기록해야 하기 때문에 공간 복잡도가 높으며 시간 복잡도 또한 높게 측정됩니다.\n\n\u003ctip\u003e\n  **vs. DFS**\n  Depth First Search 방식은 일반적으로 BFS보다 시간, 공간 복잡도 측면에서 효율적입니다.\n  하지만, 이 역시 Greedy만큼 심각하지는 않지만, 역시 최적해를 보장할 수 없습니다.\n  또한, graph에 cycle이 존재하는 경우에는 해를 구하지 못하는 경우도 생깁니다.\n\n  | Algorithm | Complete | Optimal | Time | Space |\n  |---|---|---|---|---|\n  | BFS | Y | Y | $O(min(N, B^L))$ | $O(min(N,B^L))$ |\n  | DFS | Y | N | $O(B^{L_{MAX}})$ | $O(L_{MAX})$ |\n\u003c/tip\u003e\n\n\u003ctip\u003e\n  **vs. Greedy**\n  그리디와 BFS는 사실 비슷합니다.\n  ![231211-215115](/posts/final_03/231211-215115.png)\n\u003c/tip\u003e\n\n### A*\n\n위에서 BFS와 Greedy 방식이 비슷하다 했었는데, 다른 부분은 priority queue를 사용하는 것이 차이입니다.\n\n그렇다면, BFS에서 먼저 pop되는 노드의 기준은 무엇일까요?\n처음부터 현재까지의 탐색 거리 중 가장 짧은 거리를 **g**라고 했을 때, g가 가장 작은 노드가 선택되게 됩니다.\n\nGreedy에서 먼저 pop되는 노드의 기준은 무엇일까요?\n현재 지점부터 목표 거리까지 거리가 최소가 될 거 같은 휴리스틱한 거리를 **h**라고 했을 때, h가 가장 작은 노드가 선택되게 됩니다.\n\nA*는 BFS와 Greedy의 장점만을 모은 알고리즘으로, **f = g + h** 라 했을 때, f가 가장 작은 노드를 선택하여 경로를 탐색합니다.\n즉, 빠르게 탐색하면서도 최적해를 보장할 수 있게 됩니다.\n하지만, 메모리를 너무 많이 사용한다는 단점도 있습니다.\n\n의사 코드는 아래와 같습니다.\n\n```java:A*\nINIT priority-queue Q\nINSERT start node N to Q\nwhile (Q is not empty) {\n  REMOVE best N from Q that has lowest f(N)\n  if (N is goal) break\n  for (next node N' in Succ(N)) {\n    if (N' is visited first ||\n        previously expanded with f(N') \u003e f(N) ||\n        currently in Q with f(N') \u003e f(N)\n        ) {\n      INSERT N' into Q or UPDATE N' within Q\n    }\n  } \n}\n```\n\n즉, 특이하게도 A* 목표 노드를 발견해도 종료하지 않습니다.\nGoal state가 priority-queue에서 pop되었을 때만 종료하게 됩니다.\n\n---\n\n## Modified Pathfinding\n\n지금까지는 정적인 장애물만 피해갔지만, 이런 경우에는 어떡해야 할까요?\n\n- 동적인 장애물이 있을 경우\n- 이동 경로를 부드럽게 움직이게 하고 싶을 경우\n\n![231211-221920](/posts/final_03/231211-221920.png)\n\n이동 경로를 부드럽게 하고싶은 경우에는 선형 보간을 사용하는 방식으로 해결할 수 있습니다.\n\n동적인 장애물이 있는 경우에는 장애물이 움직인다고 A* 알고리즘을 다시 돌리는 행위는 너무 비효율적입니다.\n따라서 A*에 약간의 Greedy 함이 추가되면 좋을 거 같습니다... 만, 어떻게 해야할까요?\n\n### Inadmissible\n\nA*가 최적해를 구할 수 있는 조건은 휴리스탁한 길이 h가 실제 길이보다 같거나 짧아야한다는 admissible이 지켜졌기 때문입니다.\n그렇다면 h가 inadmissible 하다면?\n\n기존 휴리스틱 h에 $\\alpha$를 곱하여 inadmissible 하게 만들어봅시다.\n\n$$\nh'(n) = \\alpha \\cdot h(n)\n$$\n\n휴리스틱한 거리가 실제 거리보다 길어질만큼 $\\alpha$를 곱하여 inadmissible하게 만들었습니다.\n하지만, 효율성을 챙길 수 있습니다.\n왜냐하면, f가 동일하다고 했을 때, $\\alpha$를 곱한다면 f'의 값은 원래의 h가 작았던 경로가 더 작게 나올 것입니다.\n\n즉, $\\alpha$값을 높임으로서 효율적인 탐색을 지향하지만, 그리디의 특성을 일부 챙길 수 있게 되었습니다.\n(물론 이 과정에서 최적해는 구하지 못할 수 있습니다)\n\n### Hierarchical Planning\n\n처음부터 전체적으로 세부적인 경로를 구하는 것이 아닌, 초기에는 듬성듬성한 탐색 경로를 설정하고, 나중에 세부적인 탐색 경로를 2차적으로 설정하는 방법입니다.\n\n![231211-221544](/posts/final_03/231211-221544.png)\n\n위에 소개된 두 방법은 일반적으로 비용이 저렴하며, 실제 필요한 영역만 탐색하기 때문에 효율적이고, 동적인 환경에 더 적응성이 강하다는 장점이 있습니다.\n하지만, 최적해를 보장하지 못한다는 단점이 있습니다.\n\n### Dynamic Planning\n\n전체 경로를 planning 하는 것이 아니라, 일부 경로만 planning하고, planning 한 경로의 끝에 다다를 때 쯤, 다음 경로를 planning 하는 방식입니다.\n\n동적인 환경에 대한 적응성이 더욱 뛰어납니다.\n하지만, 극단적인 경우에 한 스탭만 planning 하는 경우에는 그리디 방식과 동일해집니다.\n\n---\n\n## Reactive Planning\n\n위에서 언급한 Dynamic Planning의 극단적인 경우입니다.\n즉, 최적성을 보장하지는 않지만, 빠르고, 자연스러운 움직임을 추구해야 하는 경우 사용하는 알고리즘 입니다.\n\n### Potential Field Planning\n\n잠재적인 힘의 공간을 이용한 planning 방식입니다.\n경로 탐색 공간을 두 가지 힘에 의해 좌우되는 공간으로 변형해봅시다.\n\nF는 장애물에서 멀어지려는 힘을 가하는 공간이고, G는 목표지점으로 향하는 힘을 가하는 공간이라고 가정해봅시다.\n이 떄, F+G인 공간에서 물리 시뮬레이션을 한다면?\n매 순간마다 위치와 속도를 얻을 수 있고, 그 방향으로 움직인다면 자연스러운 선택을 유도할 수 있습니다.\n\n![231211-222259](/posts/final_03/231211-222259.png)\n\n하지만 문제가 많습니다.\n\n- 파라미터가 너무 많음\n  힘, 가파르기, 속도, 질량 등 물리 시뮬레이션을 위한 파라미터가 너무 많이 필요합니다.\n\n- 목표의 충돌\n\n    ![231211-222520](/posts/final_03/231211-222520.png)\n\n    장애물을 피하려는 목표와 부드럽게 움직이려는 목표의 충돌로 부자연스러운 움직임을 보일 수 있습니다.\n\n- 국소 최적해\n\n    ![231211-222543](/posts/final_03/231211-222543.png)\n\n    목적지로 이동하지 못하고 갇힐 수도 있습니다.\n\n### Flocking Models\n\n경로를 파악해야 하는 객체, 즉 이동하는 객체가 집단일 경우에는 어떨까요?\n집단 내부에서 규칙을 정해서 따르도록 하는 힘의 함수를 만드는 것이 도움이 됩니다.\n\n![231211-222714](/posts/final_03/231211-222714.png)\n\n- Separation\n  일종의 personal space 개념으로 남들과 약간의 거리를 두고 싶은 정도의 힘 입니다.\n- Alignment\n  남들과 같은 방향으로 같이 가려는 힘 입니다.\n- Cohesion\n  집단에 속하려고 서로 응집하려는 힘 입니다.\n- Avoidance\n  장애물을 회피하려는 방향으로 가려는 힘 입니다.\n\n이런 4가지 힘의 행동 규칙에 가중치를 부여하여 집단의 이동을 결정하면 간단한 규칙들의 합으로 군중의 복잡한 움직임을 모방할 수 있습니다.\n가중치를 부여하는 방식에 따라 우선순위가 낮은 규칙은 적용되지 않을 수도 있고, 모든 규칙이 고루 영향을 미치도록 할 수도 있습니다.\n\n정리하자면, 복잡한 군중 행동을 단순하게 표현할 수 있고, 여러 행동양식을 만들어 낼 수 있다는 장점이 있지만,\n가중치 조절이 쉽지 않으며, 앞서 봤던 Potential Field의 영향도 받을 수 있다는 단점이 있습니다.","slug":"univ_virtual-worlds/final_03","readingMinutes":11,"wordCount":874},{"title":"Animation","description":"애니메이션이 처리되는 과정을 알아봅니다.","icon":"","image":"","tags":["Kinematics","Quaternion","Rotation Matrix","Splines","Lagrange Polynomial","Bezier Curve"],"draft":false,"date":"2023-12-11 / 17:53","content":"\n## Kinematics\n\n관절(Joints)와 뼈대(Links)의 트리구조의 계층적 모델로 표현 가능하며, 힘에 대한건 고려하지 않고, 관절의 각도만 고려하게 됩니다.\n\n연산 순서에 따라 Forward, Inverse Kinematics로 구분되는데, 어떤식으로 다른지 알아봅시다.\n\n- Forward\n\n    ![231211-180201](/posts/final_02/231211-180201.gif)\n\n    local coordinate 관점\n\n- Inverse\n\n    ![231211-180202](/posts/final_02/231211-180202.gif)\n\n    global coordinate 관점\n\n사실상 동일합니다.\n\n3차원의 경우 회전은 각 축을 중심으로 하는 3개의 회전으로 분리(Eular angles)하여 계산합니다.\n\n![231211-180643](/posts/final_02/231211-180643.png)\n\n각 관절과 뼈대는 트리구조로 표현된다고 했었는데, 각 관절의 회전과 뼈대의 길이를 DFS 방식으로 탐색하며 계산한다면 원하는 부분의 움직임을 계산할 수 있습니다.\n\n---\n\n## Rotation\n\n![231211-180857](/posts/final_02/231211-180857.png)\n\n지금까지 3차원에서의 회전은 Eular angles를 연산하여 계산했었습니다.\n하지만, 이 방식에는 치명적인 단점이 존재합니다.\n\n- 연산 순서에 따라 결과가 달라진다.\n- Gimbal lock 현상이 발생한다.\n\n\u003ctip\u003e\n  `Gimbal lock`\n  \u003cbr /\u003e\n  가장 안쪽에 있는 축(Gimbal)과 가장 밖에있는 축이 평행하게 되어버리면 회전의 자유도의 손실이 발생하는 현상.\n  [예시 영상](https://youtu.be/zc8b2Jo7mno?si=c-oq07BEsga7V98i\u0026t=58)\n\u003c/tip\u003e\n\n따라서 이를 해결할 두 가지 3차원 회전방법을 알아보겠습니다.\n\n### Quaternion\n\n4개의 파라미터로 4차원 공간의 구의 좌표(4원수)를 사용합니다.\n\n$$\nq = (w, x, y, z) \\\\\n{}\\\\\nw^2 + x^2 + y^2 + z^2 = 1\n$$\n\n쿼터니언은 복소수의 확장판으로 엄밀한 정의는 다음과 같습니다.\n\n$$\nw + ix + jy + kz = (w,x,y,z) = (w,v) \\\\\n{}\\\\\ni^2 = j^2 = k^2 = ijk = -1\n$$\n\n![231211-183507](/posts/final_02/231211-183507.png)\n\n즉, 교환법칙이 성립되지 않으며, 허수부의 연산을 표로 그려보면 다음과 같습니다.\n\n| x | 1 | i | j | k |\n|---|---|---|---|---|\n| **1** | 1 | i | j | k |\n| **i** | i | -1 | k | -j |\n| **j** | j | -k | -1 | i |\n| **k** | k | j | -i | -1 |\n\n이제 쿼터니언의 여러 연산을 알아봅시다.\n\n- Add, Sub\n  ![231211-184240](/posts/final_02/231211-184240.png)\n\n- Mul\n  ![231211-184321](/posts/final_02/231211-184321.png)\n\n- Conjugate (켤레 복소수)\n  ![231211-184501](/posts/final_02/231211-184501.png)\n\n- Norm (크기)\n  ![231211-184516](/posts/final_02/231211-184516.png)\n\n- Mul Identity (곱셈 항등원)\n  ![231211-184538](/posts/final_02/231211-184538.png)\n\n- Mul Inverse (곱셈 항등원의 역)\n  ![231211-184559](/posts/final_02/231211-184559.png)\n\n근데 쿼터니언이 왜 회전과 관련이 있는걸까요?\n다음을 보며 이해해봅시다.\n\n![231211-185645](/posts/final_02/231211-185645.png)\n\n오일러 공식에 의한 회전은 가장 아름다운 수식으로 알려진 만큼 유명해서 익숙할 겁니다.\n\n![231211-185900](/posts/final_02/231211-185900.png)\n\n실제로 전에 다뤄본대로 변환 행렬의 원소가 실수부와 허수부의 변환된 좌표로 나오게 됩니다.\n\n![231211-190100](/posts/final_02/231211-190100.png)\n\n위 개념을 확장하면 쿼터니언을 사용하면 3차원의 회전을 다룰 수 있다는 사실을 알 수 있습니다.\n\n![231211-190242](/posts/final_02/231211-190242.png)\n\n즉, 회전하고자 하는 좌표를 순허수 쿼터니언으로 변환하고,\n특정 축(**유닛 벡터**)을 기준으로 회전각을 곱해주면 회전된 좌표가 순허수 쿼터니언의 형태로 나오게 됩니다.\n\n### Rotation Matrix\n\n9개의 파라미터로 3차원 회전을 달성하는 3by3 행렬입니다.\n\n$$\nR = \\begin{bmatrix}\nu_1 \u0026 v_1 \u0026 w_1 \\\\\nu_2 \u0026 v_2 \u0026 w_2 \\\\\nu_3 \u0026 v_3 \u0026 w_3 \\\\\n\\end{bmatrix} = \\begin{bmatrix}\nu \u0026 v \u0026 w \\\\\n\\end{bmatrix}\n$$\n\n여기서 u, v, w는 단위벡터이고, det(R) = 1 인 회전 행렬입니다.\n\n파라미터가 9개나 되는데 굳이 rotation matrix를 사용하는 이유는 무엇일까요?\n쿼터니언은 부호가 반대가 되는 경우가 있기 때문입니다.\n\n$$\nR_q(p) = R_{-q}(p)\n$$\n\n즉, 하나의 회전을 2개의 방법으로 표현할 수 있기 때문입니다.\n반면에 rotation matrix는 하나의 회전이 유니크한 matrix 하나로 정의되기에 사용합니다.\n\n물론, 쿼터니언-회전행렬간 변환 연산도 있습니다.\n\n---\n\n## Splines\n\n애니메이션의 움직임을 부드럽게 하려면 어떻게 해야할까요?\n수학적인 함수를 사용해서 시간 분할(간격)에 관계없이 애니메이션(위치)를 얻거나, 아주 잘게 쪼갠 미리 계산된 값(위치)를 사용하는 방법이 있을 것입니다.\n\n다항식으로 이루어진 curve를 polynomial curve 라고 하는데 단순히 다항식을 사용하면 문제가 있습니다.\n특정 점(위치)를 지나는 다항식을 계산하기가 어렵고, 차수가 높아질수록 불가능에 가까워집니다.\n\n따라서 다음과 같은 방식을 사용해볼 수 있겠습니다.\n\n### Lagrange Polynomial\n\n라그랑주 다항식은 아래와 같이 생겼습니다.\n\n$$\nx(t) = L_0(t)x_0 + L_1(t)x_1 + ... + L_n(t)x_n \\\\\n{}\\\\\nL_k(t_i) = \\left\\{\\begin{matrix}\n1 \\; if \\; k=i \\\\\n0 \\; if \\; k \\neq i\n\\end{matrix}\\right.\n$$\n\n![231211-201931](/posts/final_02/231211-201931.png)\n\n즉, $x(t_0) = x_0$, $x(t_1) = x_1$ 과 같이 값이 나오기 때문에 원하는 함수 모양을 잡기 쉽습니다.\n그러나, 차수가 높아질수록 L이 출렁이는, 일명 Oscillation 현상이 발생하기 때문에 keyframe particle motion에 적용하기에는 부적절합니다.\n\n### Spline Interpolation\n\n그렇다면 아래와 같이 해결해볼 수 있을 거 같습니다.\n\n![231211-202159](/posts/final_02/231211-202159.png)\n\n여기서 3차를 사용하는 이유는 2차는 평면상의 곡선만 표현할 수 있기에 공간의 움직임을 표현하기에는 부적절하고, 4차는 Oscillation 현상이 발생하기 때문에 부적절하기 때문입니다.\n하지만 이 역시 문제가 있습니다.\n\n우선 연걸지점이 미분 불가능할 수 있기에 움직임이 부자연스러울 수 있습니다.\n또한, 일반적인 다항함수의 기저($t^3$ ~ $t^0$)로는 직관적으로 다항식이 어떤 모양인지 알 수 없습니다.\n\n### Bezier Curve\n\n우선 기저만 봤을 때 함수의 모양을 직관적으로 확인할 수 있도록 Bernstein 기저 함수를 사용할 수 있겠습니다.\n\n$$\nB_i^n = (_nC_i)(1-t)^{n-i}t^i\n$$\n\nBernstein 기저 함수의 특징은 아래와 같습니다.\n\n![231211-203158](/posts/final_02/231211-203158.png)\n\n이 기저를 이용한 3차 다항식은 아래와 같습니다.\n\n$$\np(t) = B_0^3(t)b_0 + B_1^3(t)b_1 + B_2^3(t)b_2 + B_3^3(t)b_3 \\\\\n{}\\\\\n= (1-t)^3b_0 + 3t(1-t)^2b_1 + 3t^2(1-t)b_2 + t^3b_3\n$$\n\n여기서 b의 값을 알면 함수의 모양을 예측할 수 있는데, 함수 p가 Bezier curve 입니다.\n\n![231211-203320](/posts/final_02/231211-203320.png)\n\n이 때의 $b_i$를 control point라고 부릅니다.\n\n베지어 곡선의 특징은 다음과 같습니다.\n\n- **End point interpolation**\n\n    항상 $p(0) = b_0$, $p(1) = b_3$ 입니다.\n    즉, 시점과 종점을 바로 알 수 있습니다.\n\n- **Convex hull**\n\n    항상 control points가 만드는 가장 작은 다각형(볼록한 모양) 내부에 베지어 곡선이 위치합니다.\n\n    ![231211-203617](/posts/final_02/231211-203617.png)\n\n    이 특성은 곡선이 교차되는 지점을 구할 때, 계산 범위를 한정지어 효과적으로 계산할 수 있도록 도와줍니다.\n\n- **Affine inveriance**\n\n    동일한 control points는 반드시 1개의 베지어 곡선만 생성합니다.\n    즉, control points를 transform 하는 경우에는 동일한 transform이 베지어 곡선에 적용되는 효과를 갖습니다.\n\n- **Tangent vectors**\n\n    시점, 종점의 탄젠트 벡터는 각 시/종점과 인접한 control point의 차이의 3배로 표현됩니다.\n\n    ![231211-203942](/posts/final_02/231211-203942.png)\n\n    여기서 Spline Interpolation의 또 다른 문제였던 연결지점이 부자연스러울 경우를 예방할 수 있겠죠?\n\n    ![231211-204538](/posts/final_02/231211-204538.png)\n\n    끝 점의 탄젠트 벡터의 방향을 일치하도록 설정하면 됩니다.\n    다르게 표현하면, 각 곡선 조각의 끝에 탄젠트 벡터가 있다면, 이를 이용해서 조각에 해당하는 베지어 커브를 그릴 수 있습니다.\n\n- **Subdivision**\n\n    베지어 곡선위의 임의의 점으로 곡선을 분할하면 분할된 곡선 역시 베지어 곡선이 됩니다.\n\n- **De Casteljau's algorithm**\n\n    시점 $t_k=u$ 일 때의 위치는 u:1-u로 내분하는 방식으로 구할 수 있습니다.\n\n    ![231211-204228](/posts/final_02/231211-204228.png)","slug":"univ_virtual-worlds/final_02","readingMinutes":11,"wordCount":896},{"title":"Rendering Pipeline","description":"랜더링 과정에 대해 알아봅니다.","icon":"","image":"","tags":["Geometry processing","Projection","Lighting","Shading","Reflection","Polygon","Rasterization","Antialiasing","Texture"],"draft":false,"date":"2023-12-09 / 23:30","content":"\n![231210-002735](/posts/final_01/231210-002735.png)\n\n랜더링은 3D 세상의 정보를 2D의 영상으로 변환하는 과정을 의미합니다.\n그 변환 과정을 세밀하게 알아봅시다.\n\n## Geometry processing\n\n공간상의 좌표를 모니터의 좌표로 변환하기 위해서 좌표를 변환하는 과정이 필요한데, 그 순서와 변환법을 알아보겠습니다.\n\n### Viewing-transform\n\n![231209-233923](/posts/final_01/231209-233923.png)\n\n공간상의 좌표를 View plane 상에서 바라보는 곳의 좌표로 우선 변환합니다.\n\n![231209-234611](/posts/final_01/231209-234611.png)\n\n여기서 P는 카메라의 위치, N은 바라본 위치상의 평면(View plane)의 normal vector 입니다.\n이 때, 사각 뿔 도형의 $P_{ref}$ 지점을 바라본다고 한다면, 법선 벡터 N은 $P_0 - P_{ref}$로 구할 수 있습니다.\n\n여기서 View plane의 법선 벡터를 구했다고 View plane을 확정할 수는 없습니다.\n왜냐하면 N을 축으로 회전이 가능하기 때문이죠.\n따라서 View-up vector V를 정의합니다.\n\n![231209-234059](/posts/final_01/231209-234059.png)\n\n위에서 N, V를 구했다면, view space의 세 축을 정의할 수 있습니다.\n\n$$\nn = \\frac{N}{||N||} \\\\\n{}\\\\\nu = \\frac{V \\times n}{||V||} \\\\\n{}\\\\\nv = n \\times u\n$$\n\n이제 view space의 축의 벡터를 구했으니, world space의 물체를 view space로 좌표 변환이 가능합니다.\n2차원을 예시로 들어보겠습니다.\n\n![231209-235335](/posts/final_01/231209-235335.png)\n\n2차원의 물제의 좌표를 우선 homogeneous coordinate로 표현합니다.\n\n![231209-235404](/posts/final_01/231209-235404.png)\n\n그리고 view coordinate를 word coordinate의 원점으로 이동시킵니다.\n\n![231209-235416](/posts/final_01/231209-235416.png)\n\n그리고 view coordinate를 rotation 하여 축을 일치시킵니다.\n\n위 과정은 하나의 행렬로 표현 가능합니다.\n\n$$\nB' = \\begin{bmatrix}\nu_x \u0026 u_y \u0026 0 \\\\\nv_x \u0026 v_y \u0026 0 \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{bmatrix} \\cdot \\begin{bmatrix}\n1 \u0026 0 \u0026 -x_o \\\\\n0 \u0026 1 \u0026 -y_o \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{bmatrix} \\cdot B\n$$\n\n여기서 회전 방향이 시계방향이기 때문에 회전 백터가 Row 벡터로 이루어짐을 알아둡시다.\n\n### Projection\n\n좌표를 이동했다면, 3차원 물체를 2차원 View plane에 투영(projection)해야 합니다.\n투영하는 방법에는 소실점이 있는 Perspective projection과 소실점이 없는(무한한 거리에 있는) Orthographic projection 2가지 방법이 있습니다.\n\n- **Perspective projection**\n\n    ![231210-000508](/posts/final_01/231210-000508.png)\n\n    이 투영법은 닮음의 성질을 이용해서 투영합니다.\n    즉, 아래와 같이 좌표가 view space에서 view plane으로 변환됩니다.\n\n    $$\n    (x,y,z) \\Rightarrow (-d\\frac{x}{z}, -d\\frac{y}{z})\n    $$\n\n    하지만, 이는 선형 변환이 아니므로, 계산의 효율을 위해 homogeneous coordinate로 변환하여 선형 변환으로 만들어줍시다.\n\n    $$\n    \\begin{bmatrix}\n    1 \u0026 0 \u0026 0 \u0026 0 \\\\\n    0 \u0026 1 \u0026 0 \u0026 0 \\\\\n    0 \u0026 0 \u0026 -1/d \u0026 0\n    \\end{bmatrix} \n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    1\n    \\end{bmatrix} = \n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    -z/d\n    \\end{bmatrix}\n    $$\n\n    여기서 결과로 나온 벡터의 모든 원소를 $-z/d$로 나눠주면 $(-d\\frac{x}{z}, -d\\frac{y}{z})$를 얻을 수 있습니다.\n    (homogeneous coordinate의 사용 안하는 좌표를 1로 바꿔주는 연산과 동일합니다)\n\n    컴퓨팅 능력을 끌어올리기 위해 정사각행렬로 변환하면 식을 아래와 같이 표현할 수도 있습니다.\n\n    $$\n    \\begin{bmatrix}\n    1 \u0026 0 \u0026 0 \u0026 0 \\\\\n    0 \u0026 1 \u0026 0 \u0026 0 \\\\\n    0 \u0026 0 \u0026 1 \u0026 0 \\\\\n    0 \u0026 0 \u0026 -1/d \u0026 0\n    \\end{bmatrix} \n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    1\n    \\end{bmatrix} = \n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    -z/d\n    \\end{bmatrix} \\Rightarrow (-d\\frac{x}{z}, -d\\frac{y}{z})\n    $$\n\n- **Orthographic projection**\n\n    ![231210-001519](/posts/final_01/231210-001519.png)\n\n    이 방식은 그저 z축의 정보을 사용하지 않으면 알아서 투영될 것입니다.\n\n    $$\n    \\begin{bmatrix}\n    1 \u0026 0 \u0026 0 \u0026 0 \\\\\n    0 \u0026 1 \u0026 0 \u0026 0 \\\\\n    0 \u0026 0 \u0026 0 \u0026 1 \\\\\n    \\end{bmatrix} \n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    1\n    \\end{bmatrix} = \n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    1\n    \\end{bmatrix} \\Rightarrow (x, y)\n    $$\n\n### Clipping \u0026 Normalize\n\n\u003ctip\u003e\n  `View Frustum`\n  \u003cbr /\u003e\n  ![231210-001840](/posts/final_01/231210-001840.png)\n  공간상에서 화면에 실질적으로 보여지는 영역을 의미하며, 절두체 형식으로 공간이 잘리게 됩니다.\n  최소로 카메라에 인식되는 평면을 near clipping plane, 최대는 far clipping plane 이라고 합니다.\n\u003c/tip\u003e\n\n![231210-002108](/posts/final_01/231210-002108.png)\n\n화면에서 보이지 않는 영역은 랜더링하지 않기 위해 clipping 하는 과정이 필요합니다.\n\n![231210-002343](/posts/final_01/231210-002343.png)\n\n하지만, 절두체는 계산하기가 힘들기 때문에 near clipping plane을 확장시켜 정사각형으로 만들어준 뒤 clipping 과정이 들어가게 됩니다.\n\n이후에는 모니터의 해상도에 맞게 변환을 편리하게 하기 위해 좌표를 [-1, 1] 사이로 normalize 하는 과정이 추가됩니다.\n\n아래는 위의 모든 과정을 요약한 Geometry processing 과정입니다.\n\n![231210-002534](/posts/final_01/231210-002534.png)\n\n---\n\n## Lighting and shading\n\n이 단계 역시 **Geometry processing 단계에서 수행**되지만, 분량이 많으므로 별도로 다뤄보겠습니다.\n\n빛을 인식한다는 것은 광원으로부터 나온 빛이 물체와 부딪혀 흡수되지 않은 반사된 빛을 눈이 감지하는 과정을 의미합니다.\n하지만 빛의 진행과 반사를 모두 추적하는 것은 연산량이 매우 많이 필요하기 때문에 이를 단순화 하기 위해 광원의 종류와 반사의 종류를 나누어 연산합니다.\n\n### Light sources\n\n광원의 종류에 따라 광원을 수식으로 표현해보겠습니다.\n\n\u003cnotice\u003e\n  색상을 표현하기 위해 RGB값을 모두 연산해야 하지만, 수식으로 나타낼 때는 벡터 I로 한 번에 표현합니다.\n  $$\n  I = \\begin{bmatrix}\n  I_R \\\\\n  I_G \\\\\n  I_B \\\\\n  \\end{bmatrix} \n  $$\n\u003c/notice\u003e\n\n- **Point lights**\n\n    ![231210-003440](/posts/final_01/231210-003440.png)\n    \n    점광원으로 일반 적인 광원입니다.\n    빛의 강도는 거리의 제곱에 반비례하며, 수식적으로는 아래와 같이 표현됩니다.\n\n    $$\n    I(p, p_0) = \\frac{1}{|p-p_0|^2}I(p_0)\n    $$\n\n    하지만, 이렇게 처리하는 경우 실제로 거리에 따른 표현이 잘 되지는 않습니다.\n    따라서 제곱항만 넣는 것이 아닌, 다항식으로 처리됩니다.\n\n    $$\n    I(p, p_0) = \\frac{1}{k_c + k_ld + k_qd^2}I(p_0)\n    $$\n\n- **Distant lights**\n\n    ![231211-162941](/posts/final_01/231211-162941.png)\n\n    방향성 광원(무한히 멀리있는 광원)으로, 점광원과 차이점은 위치를 고려하지 않는다는 점입니다.\n    점광원은 위치에 따라 입사각이 달라졌다면, 방향성 광원은 방향에 따라서만 입사각이 달라지게 됩니다.\n    위 식에서 $p_0$ = [x y z 1]$^T$ 였다면, 방향성 광원에서는 $p_0$ = [x y z 0]$^T$ 입니다.\n\n- **Spotlights**\n\n    ![231211-163031](/posts/final_01/231211-163031.png)\n\n    점광원 + 원뿔로, 점광원과 비슷하지만, 원뿔 영역에 해당하는 부분에만 빛이 비춰집니다.\n    수식적으로 아래와 같습니다.\n\n    $$\n    I = cos^e \\phi = (s\\cdot I_s)^e\n    $$\n\n    여기서 $\\phi$는 0과 $\\theta$ 사이의 값이고, e값이 커질수록 중심부가 강하게 스포트라이트 됩니다.\n\n    ![231211-164403](/posts/final_01/231211-164403.png)\n\n- **Ambient lights**\n\n    배경 광원으로 공간 전체에 은은하게 퍼져있는 빛입니다.\n    즉, Intensity만 전체적으로 더해주면 됩니다.\n\n### Interaction with Materials\n\n빛과 상호작용하는 물질에 따라 흡수, 투과, 반사되는 정도가 달라지는데 여기선 반사에 대해서만 다뤄보도록 합니다.\n(반사를 해야 물체가 눈에 보이겠죠?)\n\n반사는 Phong reflection model로 표현되는데 이는 정반사(Specular) + 난반사(Diffuse) + 배경 의 3요소로 표현됩니다.\n하나하나 알아봅시다.\n\n- **Ambient reflection**\n\n    배경 반사는 물리적 실체가 있는 구성요소는 아니고, 랜더링시 전체적으로 퍼진 빛을 시뮬레이션하기 위해 계산하며 아래와 같습니다.\n\n    $$\n    I_a = k_aL_a\n    $$\n\n    여기서 $k_a$는 반사 계수로 0과 1 사이의 값을 가지며, 1이면 배경 빛을 모두 반사합니다.\n\n- **Diffuse reflection**\n\n    난반사는 빛의 입사각과 관계 없이 모든 방향으로 반사한다고 가정하기 때문에 입사하는 빛의 양만 알면 반사량을 계산할 수 있습니다.\n\n    $$\n    I_d = k_d(N\\cdot L)L_d\n    $$\n\n    여기서 N은 표면의 수직 단위벡터, L은 빛 소스($L_d$) 로의 방향 단위벡터 입니다.\n    즉, 사이각을 계산하는 항이 추가된 것입니다. (**Position dependent**)\n\n- **Specular reflection**\n\n    정반사는 입사각과 동일한 반사각으로 빛을 반사합니다.\n    즉, 관찰자가 어디있는지에 따라 반사된 빛의 밝기가 다르게 느껴지게 됩니다. (**View, Position dependent**)\n\n    $$\n    I_s = k_s(cos\\alpha)^nL_s = k_s(V\\cdot R)^nL_s\n    $$\n\n    여기서 R은 반사되는 방향 단위벡터, V는 view 방향 단위벡터 입니다.\n    또한 $\\alpha$는 R, V 사이의 각도입니다.\n\n    ![231211-170153](/posts/final_01/231211-170153.png)\n\n    또한 n은 일종의 상수인데, 거울의 경우에는 n이 거의 무한한 값이고, 금속은 100~500 사이 정도로 표현됩니다.\n\n### Polygonal Shading\n\n![231211-170419](/posts/final_01/231211-170419.png)\n\n지금까지 위 그림과 같이 빛을 반사까지 했습니다.\n그렇다면 이제 폴리곤 덩어리에 색칠을 해야 하는데, 그 방식도 여럿 존재합니다.\n각 방식과 장단점을 알아봅시다.\n\n- **Flat shading**\n\n    ![231211-170816](/posts/final_01/231211-170816.png)\n\n    면 단위로 색칠하는 방식으로 특정 면의 법선 벡터 n을 구하면 해당 면을 하나의 색상으로 칠하는 방식입니다.\n    계산량은 가장 적지만, 다른 면과 매끄럽게 연결되지 않는다는 단점이 있습니다.\n\n- **Gouraud shading**\n\n    vertex 단위로 색칠하는 방식으로 면의 꼭짓점의 법선 벡터들을 구하고, 꼭짓점들의 색상을 칠합니다.\n    면의 내부는 꼭짓점의 색상을 선형 보간하는 방식으로 계산합니다.\n\n    이 때, 꼭짓점은 점이기 때문에 법선 벡터를 바로 구할 수는 없습니다.\n\n    ![231211-171148](/posts/final_01/231211-171148.png)\n\n    따라서 개발자가 임의로 지정해주거나, 주변 면의 법선 벡터의 평균을 사용해서 구하는 방식을 사용합니다.\n\n    계산량은 보통이지만, 면과 면이 부드럽게 연결됩니다.\n    하지만, vertex의 보간으로 계산하기 때문에 면 중앙에만 하이라이트로 비춰지는 빛을 표현할 수는 없습니다.\n\n- **Phone shading**\n\n    픽셀 단위로 색칠하는 방법으로 꼭짓점의 법선 벡터를 구하는 것 까지는 동일합니다.\n    하지만, 색칠을 할 때는 픽셀별로 법선 벡터를 선형 보간하는 방식으로 구한 후, 픽셀의 법선 벡터를 이용해서 색상을 칠합니다.\n\n    따라서 계산량은 가장 많지만, 가장 사실적으로 빛을 묘사할 수 있습니다.\n\n    ![231211-171436](/posts/final_01/231211-171436.png)\n\n    물론, 반사되는 빛 표현만 사실적으로 하는 것이지, 실루엣까지 부드럽게 할 수는 없습니다.\n    실루엣을 부드럽게 하려면 vertex 개수 자체를 늘리는 방법을 사용해야 합니다.\n\n---\n\n## Rasterization\n\n모든 객체는 아래의 세가지의 조합으로 표현할 수 있습니다.\n\n- Points\n- Line segments\n- Triangles\n\n예로 들어 곡선은 짧은 직선을 어려개로 근사할 수 있고, 폴리곤 덩어리와 곡면 역시 여러 삼각형으로 근사할 수 있습니다.\n\n하지만, 위 세 요소를 수학적으로 기술했다고 해도, 화면에 띄우는 과정에서 Aliasing 현상이 나타나게 됩니다.\n\n선을 기준으로 여러 근사 알고리즘과 Aliasing 현상을 알아보도록 합시다.\n\n- **Point Sampling**\n\n    ![231211-172416](/posts/final_01/231211-172416.png)\n\n    각 픽셀의 중심부가 직선 범위 내부이면 1, 아니면 0으로 처리합니다.\n    연산량이 가장 적이만 문제가 많습니다.\n\n- **Bresenhan Line**\n\n    ![231211-172343](/posts/final_01/231211-172343.png)\n\n    인접한 픽셀이 둘 다 켜지는 방식을 방지하는 알고리즘으로, row, column 별로 1개만 1이 되도록 강제합니다.\n\n- **Box Filtering - Antialiasing**\n\n    ![231211-172713](/posts/final_01/231211-172713.png)\n\n    각 픽셀이 직선에 얼마나 포함되는지에 대한 정보를 바탕으로 \\[0, 1\\] 사이로 찰하게 합니다.\n    Antialiasing이 아닌 방식에 비해서는 느리지만, 그래도 빠른 편이며, 나름 정확하게 표현할 수 있습니다.\n\n- **Weighted Filtering - Antialiasing**\n\n    ![231211-172915](/posts/final_01/231211-172915.png)\n\n    가우시안 필터링 기법을 사용하여 가중치를 부여(중심부의 weight가 큼)한 평균을 계산하여 칠합니다.\n    가장 느리지만, 가장 묘사가 잘 됩니다.\n\n### Hidden Surface Elimination\n\n시각에 따라 보이지 않는 폴리곤 덩어리를 랜더링하면 성능이 떨어질 것입니다.\n따라서 보이지 않는 부분은 랜더링 대상에서 제외시키는 방법들을 알아봅시다.\n\n- **Back-face Culling**\n\n    ![231211-173323](/posts/final_01/231211-173323.png)\n\n    간단하게 설명하면 뒤를 바라보는 면은 랜더링 대상에서 제외시키는 방법입니다.\n    view 방향 단위벡터(v)와 면의 법선 단위벡터(n)를 이용해서 $n \\cdot v$로 계산하여 양수라면 랜더링, 음수면 제외하는 방식으로 동작합니다.\n\n    주의할 점은 법선 벡터를 계산할 때, 꼭짓점의 좌표를 이용해서 $(p_1-p_0) \\times (p_2-p_0)$ 와 같이 계산해야 하는데, 시계방향, 반시계방향으로 죄표를 넣으면 법선 벡터의 방향이 달라지게 됨을 주의합시다.\n\n- **Depth Buffer (Z-Buffer)**\n\n    ![231211-173721](/posts/final_01/231211-173721.png)\n\n    진짜 무식한 방법이지만, Back-face culling보다 성능 좋은 방법입니다.\n\n    1. 우선, Z-buffer를 무한대로, Frame buffer를 배경색으로 초기화 합니다.\n\n        $$\n        Z(x,y) = \\infty \\\\\n        C(x,y) = c_0\n        $$\n\n    2. depth가 작아지면, 즉 더욱 view plane에 가깝다면 (**z(x, y) \\\u003c Z(x, y)**) Z, Frame buffer를 업데이트 합니다.\n\n        $$\n        Z(x,y) = z(x,y) \\\\\n        C(x,y) = c(x,y)\n        $$\n    \n    심지어 속도도 빠릅니다.\n    하지만, 메모리를 많이 쓴다는 단점은 있습니다.\n\n    ![231211-174248](/posts/final_01/231211-174248.png)\n\n    하지만 오늘날은 메모리 용량도 많기 때문에 Z-Buffer 방식을 사용합니다.\n\n---\n\n## Texture mapping\n\n간단하게 텍스쳐를 폴리건 표면에 붙이는 방법만 알아봅시다.\n\n1. 폴리건에 붙이고자 하는 텍스쳐 이미지를 \\[0, 1\\]로 normalize 합니다.\n2. world coordinate(폴리건)과 texture coordinate(텍스쳐)의 대응관계를 찾습니다.\n3. 대응관계에 따라 normalize된 텍스쳐의 좌표를 변환하여 폴리건 위에 씌웁니다.\n\n일부 수학적 3차원 도형의 경우 2개의 좌표로도 표현이 가능한데, 이를 텍스쳐 좌표에서 활용하면 됩니다.\n\n이 과정에서 샘플링이 누적되며 오류가 중첩되어 Aliasing 현상이 발생할 수 있습니다.\n\n또한, 텍스쳐를 이용해서 세부 음영 묘사를 할 수 있는 트릭을 사용할 수 있습니다.\n즉, 폴리건은 간단히 만들고, 세부 음영 묘사는 텍스쳐로 수행하여 성능을 높이는 최적화 방법입니다.\n\n![231211-174923](/posts/final_01/231211-174923.png)\n\n하지만, 가장자리 실루엣은 세부적으로 묘사가 안됩니다.\n(vertex를 늘리는 방법 외엔...)\n\n마지막으로, 배경을 텍스쳐로 입혀서 반사를 구현하는 최적화 방식 또한 있습니다.","slug":"univ_virtual-worlds/final_01","readingMinutes":20,"wordCount":1619},{"title":"자연어 처리","description":"자연어 처리의 과정에 대해 간략히 알아봅니다.","icon":"","image":"","tags":[],"draft":false,"date":"2023-12-09 / 22:25","content":"\n## 분석 단계\n\n![231209-224151](/posts/final_05/231209-224151.png)\n\n### 형태소 분석\n\n입력된 문자열을 분석하여 형태소 단위로 분석합니다.\n형태소 분석은 다음과 같은 목적 활용될 수 있습니다.\n\n- 맞춤법, 철자 교정\n- 단어의 품사 분석\n- 단어의 의미 추정\n- 검색엔진 색인 구성\n\n형태소를 분석하고 나서는 품사를 태깅합니다.\n태깅을 할 때는 문장의 구성 원리 등을 이용한 규칙 기반 태깅 방법과, 기계학습 기반 태깅이나, 통계적 기계학습 알고리즘을 사용할 수 있습니다.\n\n이후에는 개체명을 인식합니다.\n정보를 검색하거나, 질의응답에서 중요한 역할을 하는 고유명사와 같은 개체명을 인식하는 겁니다.\n인명, 지명, 시간, 날짜, 화폐 등이 이에 해당합니다.\n개체명을 인식할 때는 사전을 사용하거나, 규칙을 만들거나, 기계학습 기반의 분류기를 사용합니다.\n\n### 구문 분석\n\n구문에 따라 주어진 문장에서 단어들의 역할을 파악하여 문장을 계층적인 트리 구조로 변환하는 작업입니다.\n이 역시 규칙 기반 구문 분석방법과 기계학습 기반 구문 분석방법이 있습니다.\n\n하지만, 구문 분석시에는 아래와 같은 문제점이 있을 수 있습니다.\n\n- 구조적 중의성\n  하나의 문장이 다수의 구조로 해석될 수 있음.\n- 어휘적 중의성\n  하나의 단어가 여러 품사로 사용될 때, 다수의 구조로 해석될 수 있음.\n\n규칙 기반 구분 분석에서는 파싱 방식을 자주 사용하는데, 파싱 방식에는 아래와 같은 방식이 있습니다.\n\n- 확장 전이망 기반 파싱\n- 차트 파싱 (CKY 파싱 알고리즘)\n\n기계학습 기반 구문 분석에서는 아래와 같은 모델이 사용됩니다.\n\n- SVM\n- 조건부 랜덤 필드(CRF) 모델\n- 딥러닝 신경망\n\n### 의미 분석\n\n형태소, 구분 분석 결과를 해석하여 문장이 가진 의미를 파악합니다.\n이를 위해 담화가 이루어지는 상황에 대한 world model과 상식에 대한 지식이 필요합니다.\n\n이를 위해 단어를 수치화 해야 하는데, ont-hot vector 또는 Word2Vec(word embedding)을 사용합니다.\n두 방식 모두 단어를 좌표상에 하나의 위치벡터로 수치화 합니다.\n\n- one-hot vector\n  단어 위치에만 1, 나머지는 0으로 설정된 벡터입니다.\n  학습에는 편리하지만, 이 방식은 단어간의 유사도를 계산하기가 어렵습니다.\n\n- Word2Vec\n  단어의 의미를 충분히 잘 나타내도록 단어를 공간상의 실수 벡터로 표현합니다.\n  유사한 의미의 단어는 좌표공간 상에서 근처에 위치하게 되기 때문에 유사도를 판단할 때 유용합니다.\n\n이렇게 단어를 벡터화(수치화) 하고나면, 단어를 유의미하게 배치하기 위한 모델을 구성해야 합니다.\none-hot vector로 수치화된 단어는 아래와 같은 모델에서 사용됩니다.\n\n- CBOW\n\n    ![231209-230325](/posts/final_05/231209-230325.png)\n    Continuous Bag-of-Words 모델은 V차원의 one-hot 벡터로 표현된 단어를 N차원의 실수 벡터로 바꾸는 역할을 수행합니다.\n    입력에 주변 단어들이 주어질 때, 출력에서 해당 단어가 나타날 확률이 높아지도록 학습합니다.\n    e.g. 빈칸 채우기\n\n- Skip-gram\n\n    ![231209-230425](/posts/final_05/231209-230425.png)\n    CBOW 모델과 대칭적인 구조를 갖습니다.\n    입력에 학습 대상이 되는 단어가 주어질 때, 출력에서 해당 단어의 주위 단어들이 나타날 확률이 높아지도록 학습합니다.\n    e.g. 문장 생성\n\nWord2Vec로 수치화된 단어는 아래와 같은 분야에서 사용됩니다.\n\n- 유의어, 어근 비교, 시제 등 한 정보 추출 또는 분석\n- 품사 태깅, 의미 분석, 관계 추출, 단위 의미 식별 등\n- 기계 번역, 영상 주석달기 등","slug":"univ_ai/final_05","readingMinutes":6,"wordCount":401},{"title":"TensorFlow","description":"딥러닝 프레임워크 텐서플로우에 대해 알아봅니다.","icon":"","image":"","tags":["Tensor"],"draft":false,"date":"2023-12-09 / 18:17","content":"\n## Tensor\n\n텐서플로우에서 사용하는 기본 자료형으로 다차원 배열이다.\n텐서는 rank, shape, type의 세가지 속성을 갖는다.\n\n- rank\n\n    ![231209-201955](/posts/final_04/231209-201955.png)\n    텐서의 차원수로 rank k는 k차원 배열이다.\n\n- shape\n\n    ![231209-202047](/posts/final_04/231209-202047.png)\n    텐서의 구조로, 각 축에 텐서의 원소 개수를 알려준다.\n\n- type\n  텐서의 구성원소의 자료형을 알려준다.\n\n\u003ctip\u003e\n  `축(axis)`\n  \u003cbr /\u003e\n  대괄호의 가장 바깥부터 0, 1, 2 축이 된다.\n\u003c/tip\u003e\n\n## Flow\n\n텐서를 데이터 플로우 그래프를 이용하여 계산 과정과 모델을 표현하게 된다.\n\n- Op(eration)\n  하나 이상의 텐서를 받아 계산을 수행하고 결과를 하나 이상의 텐서로 변환\n\n- Session\n  그래프를 실행하기 위한 객체(세션)\n\n- Variables\n\n    그래프 실행 시 파라미터를 저장하고 갱신하기 위해 사용\n    ```python:.py\n    W = tf.Variable(tf.randon_normal([4, 1]), name=\"weight\")\n    b = tf.Variable(tf.randon_normal([1]), name=\"bias\")\n    ```\n\n- Placeholder\n\n    데이터 플로우 그래프 실행 시 데이터(텐서)를 전달하기 위해 사용\n    ```python:.py\n    x = tf.placeholder(tf.float32)\n    y = tf.placeholder(tf.float32)\n    z = tf.multiply(x, y)\n    sess.run(z, feed_dict=[x: 3, y: 4])\n    ```\n\n---\n\n## 텐서 변환 연산\n\n### reshape\n\n텐서의 원소를 새로운 shape에 맞게 배치합니다.\n\n\u003e a = [[[1,2,3,4], [5,6,7,8]], [[9,10,11,12], [13, 14, 15, 16]], [[17,18,19,20], [21,22,23,24]]]\n\u003e tf.shape(a) \u0026rarr; [3, 2, 4]\n\u003e tf.reshpae(a, [3, 8])\n\u003e \u0026rarr; [[1,2,3,4,5,6,7,8], [9,10,11,12,13,14,15,16], [17,18,19,20,21,22,23,24]]\n\n### squeeze\n\n텐서에서 크기가 1인 축을 제거합니다.\n\n\u003e a = [**[**[1,2]**]**, **[**[3,4]**]**, **[**[5,6]**]**]\n\u003e tf.shape(a) \u0026rarr; [3, 1, 2]\n\u003e tf.squeeze(a)\n\u003e \u0026rarr; [[1,2], [3,4], [5,6]]\n\n### expand_dims\n\n지정한 축 위치에 차원을 하나 추가합니다.\n\n\u003e tf.expands_dims([[1,2,3], [4,5,6]], 0)\n\u003e \u0026rarr; **[**[[1,2,3], [4,5,6]]**]**\n\u003e tf.expands_dims([[1,2,3], [4,5,6]], 1)\n\u003e \u0026rarr; [**[**[1,2,3]**]**, **[**[4,5,6]**]**]\n\n### slice\n\n텐서에서 일부분을 선택합니다.\n**slice(텐서, [축i 시작위치], [축i의 추출길이])**\n\n\u003e a = [[1,2,3,4,5,6,7], [8,9,10,11,12,13,14], [15,16,17,18,19,20,21]]\n\u003e tf.slice(a, [0,2], [2,3])\n\u003e \u0026rarr; [[3,4,5], [10,11,12]]\n\n### split\n\n지정된 축을 분할개수로 분리합니다.\n**spilt(텐서, 분할개수, 축)**\n\n\u003e a = [[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]]\n\u003e tf.split(a, 2, 0)\n\u003e \u0026rarr; [[[1,2,3,4], [5,6,7,8]], [[9,10,11,12], [13,14,15,16]]]\n\u003e tf.split(a, 2, 1)\n\u003e \u0026rarr; [[[1,2], [5,6], [9,10], [13,14]], [[3,4], [7,8], [11,12], [15,16]]]\n\n### concat\n\n지정된 축 방향으로 두 텐서를 이어 붙힙니다.\n\n\u003e a = [[1,2], [3,4]]\n\u003e b = [[5,6], [7,8]]\n\u003e tf.concat([a, b], 0)\n\u003e \u0026rarr; [[1,2], [3,4], [5,6], [7,8]]\n\u003e tf.concat([a, b], 1)\n\u003e \u0026rarr; [[1,2,5,6], [3,4,7,8]]\n\n### reverse\n\n지정된 축을 기준으로 원소를 역순으로 배열합니다.\n\n\u003e a = [[1,2,3], [4,5,6]]\n\u003e tf.reverse(a, [0])\n\u003e \u0026rarr; [[4,5,6], [1,2,3]]\n\u003e tf.reverse(a, [1])\n\u003e \u0026rarr; [[3,2,1], [6,5,4]]\n\u003e tf.reverse(a, [0, 1])\n\u003e \u0026rarr; [[6,5,4], [3,2,1]]\n\n### transpose\n\n지정된 축의 순서로 텐서를 transpose 합니다.\n**transpose(텐서, perm=[축])**\n(perm을 지정 안하면 [0, 1] 로 간주함)\n\n\u003e a = [[1,2,3], [4,5,6]]\n\u003e tf.transpose(a)\n\u003e \u0026rarr; [[1,4], [2,5], [3,6]]\n\u003e b = [[[1,2,3], [4,5,6]], [[7,8,9], [10,11,12]]]\n\u003e tf.transpose(b, [0,2,1])\n\u003e \u0026rarr; [[[1,4], [2,5], [3,6]], [[7,10], [8,11], [9,12]]]\n\n### gather\n\n지정된 index의 원소들로 이루어진 텐서를 생성합니다.\n**gather(텐서, [index])**\n\n\u003e tf.gather([1,3,5,7,9,0,2,4,6,8], [2,5,2,5])\n\u003e \u0026rarr; [5,0,5,0]\n\u003e tf.gather([[1,2,3,4,5,6], [7,8,9,10,11,12]], [0,1])\n\u003e \u0026rarr; [[1,2,3,4,5,6], [7,8,9,10,11,12]]\n\u003e tf.gather([[1,2,3,4,5,6], [7,8,9,10,11,12]], [[0,0], [1,1]])\n\u003e \u0026rarr; [[[1,2,3,4,5,6], [1,2,3,4,5,6]], [[7,8,9,10,11,12], [7,8,9,10,11,12]]]\n\n### ont_hot\n\n정수값을 one-hot 벡터로 변환합니다.\n\n\u003e tf.ont_hot([0,1,2], depth=3)\n\u003e [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]\n\u003e tf.ont_hot([0,1,2], depth=4)\n\u003e [[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0], [0.0, 0.0, 1.0, 0.0]]\n\n---\n\n## 기타\n\n### 텐서 축약 연산\n\n![231209-222217](/posts/final_04/231209-222217.png)\n\n### 텐서 행렬 연산\n\n![231209-222315](/posts/final_04/231209-222315.png)\n\n","slug":"univ_ai/final_04","readingMinutes":4,"wordCount":492},{"title":"딥러닝 \u0026 CNN","description":"딥러닝 및 CNN 방식의 종류와 모델들을 알아봅니다.","icon":"","image":"","tags":["Deep Learning","Convolutional Neural Network","CNN Models"],"draft":false,"date":"2023-12-09 / 16:42","content":"\n## 딥러닝\n\n일반적인 다수의 퍼셉트론을 이용해서 은닉층을 여럿 두었던 기존 신경망과 거의 유사하지만, 그 은닉층의 개수가 엄청 많은 신경망을 딥러닝 신경망이라고 합니다.\n\n원시 신경망은 은닉층의 개수가 적었기에, 사람이 직접 특징을 추출해서 만든 특징 벡터를 이용해 학습을 시켰던 것에 반해,\n딥러닝 신경망은 데이터 그 자체를 입력으로 주고, 특징 추출과 학습을 함께 수행할 수 있습니다.\n즉, 스스로 데이터로부터 유의미한 특징을 추출하고 학습하기 때문에 성능이 우수합니다.\n\n### 기울기 소멸 문제\n\n단, 딥러닝시 문제가 있습니다.\n컴퓨팅 파워가 많이 필요하단 것은 둘 째 치고, 학습하는 과정에서 역전파를 할 때, 역전파 하는 과정에서 전파될수록 기울기(gradient)가 점점 줄어들다가 소멸하는 문제가 있습니다.\n\n기울기 소멸 문제가 발생하는 이유는 sigmoid, typertangent와 같은 활성함수를 사용하기 때문에 발생하는 것인데, 이런 활성함수의 특징이 있습니다.\n바로, 0에서 멀어질수록 도함수(기울기)의 값이 0에 가까워진다는 점입니다.\n\n따라서 아무리 멀어져도 기울기가 0으로 수렴하지 않도록 ReLU 함수나 ReLU 파생 함수를 사용하곤 합니다.\n\n![231209-165142](/posts/final_03/231209-165142.png)\n\n### 가중치 초기화 문제\n\n신경망을 학습하는 과정에서 경사하강법을 사용한다고 했었는데, 경사하강법의 문제가 있습니다.\n바로 국소 최적해에 빠질 수 있다는 것입니다.\ngradient의 반대 방향으로 이동하는 과정에서 더이상 움직이지 않는 지점까지 내려왔는데, 알고보니 그 지점보다 더 낮은 지점이 존재하는 것이죠.\n\n즉, 학습에 있어, 초기에 가중치를 어떻게 초기화하느냐에 따라 학습 방향이 변하게 될 수 있다는 뜻입니다.\n\n보통은 초기값으로 0에 가까운 무작위 값을 넣곤하는데, 균등 분포, Xavier 초기화, He 초기화 방법 등이 있습니다.\n\n### 과적합 문제\n\n학습을 너무 완벽하게 시켜도 문제입니다.\n\n![231209-170008](/posts/final_03/231209-170008.png)\n\n해당 모델은 학습 데이터를 완벽하게 분류할 수 있을 뿐, 테스트데이터에 대해서는 좋지 못한 성능을 보일 수 있기 때문입니다.\n\n따라서 여러 과적합 완화 기법이 있습니다.\n\n- 규제화 기법\n\n    오차함수에 error 뿐 만 아니라 모델 복잡도도 평가요소로 사용하는 방법입니다.\n\n    **오차함수 = 오차 항 + $\\alpha$ 모델 복잡도 항**\n\n    모델 복잡도는 가중치(weight)를 이용하여 정의할 수 있으며 아래와 같이 사용할 수 있습니다.\n\n    - L1-norm: $\\sum_{i=1}^{n}|w_i|$\n    - L2-norm: $\\sum_{i=1}^{n}w_i^2$\n\n- 드롭아웃 기법\n\n    일정 확률로 노드들을 무작위로 선택해 선택된 노드 앞뒤로 연결된 가중치 연결선은 없는 것으로 간주하고 학습하는 기법입니다.\n\n    ![231209-170524](/posts/final_03/231209-170524.png)\n\n    미니배치(mini-batch)나 학습주기(epoch)마다 드롭아웃할 노드를 선택하는데, 모든 노드는 한 번 이상은 특정 주기에 속해 학습되어야 합니다.\n\n    \u003ctip\u003e\n      `미니배치(mini-batch)`\n      \u003cbr /\u003e\n      전체 학습 데이터를 일정 크기의 데이터로 나누어 놓은 것으로, 학습 데이터가 큰 경우에 사용하는 것이 좋습니다.\n      단, 그레디언트를 계산할 때는 매 데이터마나 역전파해서 업데이트 하는 것이 아닌, 일정 수 이상의 데이터가 들어올 때 마다 평균을 계산해서 한 번에 업데이트 해야합니다.\n      \u003cbr /\u003e\n      미니배치의 장점은 데이터에 포함된 오류에 대해 둔감하게 학습할 수 있기에 과적함 문제 완화에 도움이 됩니다.\n    \u003c/tip\u003e\n  \n- 배치 정규화\n\n    신경망의 각 층에서 미니배치의 각 데이터의 가중치 연산 결과의 분포를 정규화 하는 것으로, 간단하게 말하면 출력을 \\[-1, 1\\] 범위로 스케일링 하는 것입니다.\n\n    이게 도움이 되는 이유는 내부 공변량 이동 문제를 완화할 수 있기 때문인데요, 간단하게 설명하면 학습에 따라 가중치가 변하면 같은 학습 데이터에 대해 출력이 변하는 문제입니다.\n\n    하지만, 배치 정규화를 통해 출력을 정규화하면 같은 학습 데이터에 대해 시차가 있더라도 비슷한 출력을 내보낼 수 있게 되어 학습 효율이 올라갑니다.\n\n    ![231209-171350](/posts/final_03/231209-171350.png)\n\n    연산 결과를 활성화 함수에 통과시키기 전에 배치 정규화 블록을 삽입하여 구현합니다.\n\n---\n\n## 컨볼루전 신경망 (CNN)\n\nConvolution이란, 신경망에 컨볼루전을 처리하는 층이 추가된 딥러닝 신경망으로, 해당 컨볼루턴 층에서는 색상, 밝기, 에지 등등 특정 영역에 대한 특징을 추출하는 역할을 진행합니다.\n(컴퓨터 비전의 그 컨볼루전임)\n\n![231209-171707](/posts/final_03/231209-171707.png)\n\n이런 컨볼루전은 여러개 두어 각 영역 특징들을 추출하고, 해당 특징을 이용해 딥러닝 신경망의 새로운 입력으로 사용해 의미있는 정보로 변환되게 됩니다.\n\n### 컨볼루전\n\n![231209-171759](/posts/final_03/231209-171759.png)\n\n컴퓨터 비전과 비슷하게 일정 영역의 값에 가중치를 적용하여 하나의 값을 얻는 과정입니다.\n단, 여기에 threshold에 해당하는 bias 도 더해진다는 차이점이 있습니다.\n\n$$\ny_{11} = w_{11}x_{11} + w_{12}x_{12} + ... + w_{33}x_{33} + w_0 (bias)\n$$\n\n\n![231209-172107](/posts/final_03/231209-172107.png)\n\n컨볼루전시 padding과 stride 요소에 따라 연산이 조금 달라지게 되는데요,\n피연산 배열을 확장하는 것을 padding, 커널의 이동거리를 stride라고 합니다.\n\n### 특징지도\n\n컨볼루전 필터의 적용 결과로 만들어지는 2차원 행렬(N차원 배열)을 feature map 이라고 합니다.\n단순히 컨볼루전의 연산 결과라고 생각해도 됩니다.\n\n![231209-172428](/posts/final_03/231209-172428.png)\n\nk개의 커널을 컨볼루전하면 k개의 2차원 특징지도가 만들어집니다.\n커널은 RGB, 모서리, 경계선, 주파수 등등 필요한 정보를 추출할 수 있는 커널을 사용할 수 있습니다.\n\n### 풀링\n\n일정 크기의 블록을 통합하여 하나의 대푯값으로 대체하는 연산을 pooling 이라고 합니다.\n특징지도의 크기를 축소함으로서 다음 단계에서 사용할 메모리 크기와 연산량을 감소하는데 사용되며,\n특정 영역내의 특징을 결합하거나, 위치변화에 둔감한 특정을 선택하는 효과를 얻을 수 있습니다.\n\n풀링 방식의 종류에 대해 알아봅시다.\n\n- 최댓값 풀링\n\n    ![231209-172746](/posts/final_03/231209-172746.png)\n\n    지정된 블록 내의 원소 중에서 최대값을 대푯값으로 선택하는 풀링입니다.\n\n- 평균값 풀링\n\n    ![231209-172815](/posts/final_03/231209-172815.png)\n\n    지정된 블록 내의 원소의 평균값을 대푯값으로 선택하는 풀링입니다.\n\n- 확률적 풀링\n\n    ![231209-172848](/posts/final_03/231209-172848.png)\n\n    지정된 블록 내의 원소의 값의 크기에 비례하는 확률로 선택하는 풀링힙니다.\n    **학습시에는 확률적으로 학습**하기에 랜덤성이 부여되는 장점이 있고,\n    **추론시에는 확률에 가중치를 둔 평균**으로 구하는 방식으로 동작합니다.\n\n### CNN 구조\n\n특징을 추출하는 컨볼루전 부분과 추출된 특징을 사용하여 분류, 회귀하는 다층 퍼셉트론 부분으로 구분됩니다.\n\n컨볼루전 부분은 보통 아래의 층드로 구성된 블록들을 여럿 반복하여 배치합니다.\n\n- Conv: 컨볼루전 연산\n- ReLU: 활성화 함수\n- Pool: 풀링\n\nReLU, Pool은 둘 다 쓰거나 둘 중 하나만 사용할 수도 있습니다.\n\n다층 퍼셉트론 부분은 전 방향 연결되어있기에 FC(Fully Connected) 로 표현하며, 마지막 층은 출력을 정규화하기 위해 SM(SoftMax) 층을 둡니다.\n\n이에 대한 예시는 다음과 같습니다.\n\n![231209-173733](/posts/final_03/231209-173733.png)\n![231209-173744](/posts/final_03/231209-173744.png)\n\nPool을 제외하고는 가중치 연산이 필요합니다.\n노드는 Conv에서 많은 경향이 있고, 가중치는 FC에서 많은 경향이 있습니다.\n\n### CNN 학습\n\nCNN의 학습 방법은 여러 방법이 있지만, 제가 수식을 이해못한 관계로(...) 종류와 특징만 기술하도록 하겠습니다.\n\n- 경사 하강법\n  그레디언트의 반대방향으로 학습률($\\eta$) 만큼의 보폭으로 이동하는 방식입니다.\n\n- 모멘텀을 고려한 경사 하강법\n\n    ![231209-174536](/posts/final_03/231209-174536.png)\n\n    이전 그레디언트의 누적값을 반영하여 이동하는 방식입니다.\n\n- NAG\n\n    ![231209-174626](/posts/final_03/231209-174626.png)\n\n    직전 모멘텀으로 이동한 위치에서의 그레디언트로 이동하는 방식입니다.\n  \n- AdaGrad\n  가중치별로 별도의 학습률($\\eta$)을 적용하는 방식입니다.\n  예로 들어 x축보다 y축의 움직임이 크다면, y축에는 낮은 학습률을 적용하는 방식입니다.\n\n- AdaDelta\n  AdaGrad의 변형으로 과거 그레디언트의 영향을 점점 줄이는 방식입니다.\n\n- RMSprop\n\n- ADAM (best?)\n\n---\n\n## CNN 모델 종류\n\n전부 깊이 다뤄보지는 않고, ILSVRC 대회에서 좋은 성적을 거둔 모델 중 새로운 방식을 적용한 사례에 대해서만 알아봅시다.\n\n### LeNet\n\n![231209-175915](/posts/final_03/231209-175915.png)\n\n- 대회에서 최초로 컨볼루전을 사용\n\n### AlexNet\n\n![231209-175924](/posts/final_03/231209-175924.png)\n\n- 대회에서 최초로 ReLU 함수를 사용\n- FC층에 드롭아웃 기법 적용\n- 최댓값 풀링 사용\n\n### VGGNet\n\n![231209-175939](/posts/final_03/231209-175939.png)\n\n- 모든 컨볼루전 층에서 3by3 필터를 사용\n\n\u003ctip\u003e\n  3by3을 2번 적용하면 5by5를 적용한 효과를 낼 수 있고, 3번 적용하면 7by7을 적용한 효과를 낼 수 있습니다.\n  여기서 작은 필터를 여러번 사용하는게 큰 필터 한 번을 사용하는 것 보다 좋은 효과를 얻을 수 있었는데요,\n  그 이유는 가중치 개수가 적어지는 효과도 있고, 컨볼루전만 하면 선형 변환이라 중간에 ReLU 같은 비선형 변환을 사용해야 하는데, ReLU를 많이 사용할수록 복잡한 결정 경계를 표현할 수 있게되기 때문입니다.\n\u003c/tip\u003e\n\n### GoogleNet\n\n![231209-175950](/posts/final_03/231209-175950.png)\n\n- 인셉션 모듈 사용\n- 1by1 컨볼루전 사용\n- FC층 단 1개 사용\n- 보조 분류기 사용해 기울기 소멸 문제 완화\n\n\u003ctip\u003e\n  `인셉션 모듈`\n  \u003cbr /\u003e\n  ![231209-180142](/posts/final_03/231209-180142.png)\n  특징을 동시에 추출할 수 있습니다.\n\u003c/tip\u003e\n\n\u003ctip\u003e\n  `1by1 컨볼루전`\n  \u003cbr /\u003e\n  ![231209-180225](/posts/final_03/231209-180225.png)\n  특징지도를 압축할 수 있습니다.\n\u003c/tip\u003e\n\n### ResNet\n\n![231209-180954](/posts/final_03/231209-180954.png)\n\n- 잔차 모듈 사용\n\n\u003ctip\u003e\n  `잔차 모듈`\n  \u003cbr /\u003e\n  ![231209-180447](/posts/final_03/231209-180447.png)\n  입력값을 그대로 넘기는 과정이 추가된 모듈로 이를 이용하면 기울기 소멸 문제를 완화할 수 있습니다.\n  뿐만 아니라, 작은 변화에도 민감하며, 다양한 경로를 통해 복합적인 특징을 추출할 수도 있습니다.\n  \u003cbr /\u003e\n  ![231209-180724](/posts/final_03/231209-180724.png)\n  즉, 여러 층이 연결된 효과를 볼 수 있습니다.\n  때문에, 필요한 출력이 얻어지면 컨볼루전 층을 건너뛸 수도 있습니다.\n\u003c/tip\u003e\n\n### DenseNet\n\n![231209-180943](/posts/final_03/231209-180943.png)\n\n앞 층에서 올 수 있는 지름길 연결구성 방식이기에 연산 방식이 ResNet과 좀 다릅니다.\n\n- ResNet: Conv-배치정규화-ReLU\n- DenseNet: 배치정규화-ReLU-Conv\n\n따라서 이전 단계의 동일한 특징 정보가 진차모듈을 통해 각 단계에 전달되기 때문에 새로운 특징을 만드는데 소극적이었던 ResNet과 달리\n새로운 특징이 추출될 가능성이 높아졌습니다.\n\n![231209-181230](/posts/final_03/231209-181230.png)\n\n또한, 전이층을 두어 층이 과도하게 늘어나는 현상을 예방하고 학습 효율을 높였습니다.\n\n### DPN\n\nResNet + DenseNet 으로, DenseNet의 단점인 특징이 중복해서 추출될 수 있는 문제를 마이크로 블록을 사용하여 극복한 모델입니다.","slug":"univ_ai/final_03","readingMinutes":17,"wordCount":1180},{"title":"신경망","description":"인공지능 신경망의 구조와 원리에 대해 알아봅니다.","icon":"","image":"","tags":["Neural Network","Perceptron"],"draft":false,"date":"2023-12-08 / 23:53","content":"\n## 퍼셉트론\n\n![231209-160856](/posts/final_02/231209-160856.png)\n\n인간의 신경세포를 모방한 신경망 모델에서 하나의 신경세포에 해당하는 뉴런 유닛입니다.\n다른 퍼셉트론의 출력들을 입력으로 받아 하나의 출력을 생성하게 되는데요, 입력들의 합이 threshold를 넘으면 1, 아니면 0을 출력하게 됩니다.\n\n$$\ny = \\left\\{\\begin{matrix}\n0 \\; otherwise \\\\\n1 \\; \\sum_{i=1}^{d}w_ix_i \u003e threshold\n\\end{matrix}\\right.\n$$\n\n이 때, $\\sum_{i=1}^{d}w_ix_i \u003e threshold$ 부분을 아래와 같이 수정해봅시다.\n\n$$\n\\sum_{i=1}^{d}w_ix_i - threshold\u003e 0\n$$\n\nthreshold를 마찬가지로 하나의 입력으로 생각할 수도 있을 것입니다.\n즉, 가중치(w)가 1이고, 값(x)이 bias 라고 생각하면 아래와 같이 식이 정리됩니다.\n\n$$\ns = \\sum_{i=1}^{d}w_ix_i + b = \\sum_{i=0}^{d}w_ix_i\n$$\n\n이제 s의 값이 0보다 작으면 0을 출력하고, 0보다 크면 1을 출력하면 퍼셉트론 완성입니다.\n\n퍼셉트론을 이용해서 OR 회로를 만들어봅시다.\n\n![231209-161940](/posts/final_02/231209-161940.png)\n\n그럼 AND 회로는 만들 수 있을까요?\nbias(1)에 연결된 weight에 -0.5가 아닌 -1.5와 같은 값을 넣으면 만들 수 있습니다.\n\n그렇다면 XOR 회로는 만들 수 있을까요?\n위와 같이 퍼셉트론 1개만으로는 구현이 불가능합니다.\n하나의 퍼셉트론은 선형 분리가능 문제만 해결할 수 있기 때문입니다.\n\nXOR와 같은 선형 분리불가 문제는 2개 이상의 퍼셉트론으로 해결할 수 있습니다.\n\n### 다층 퍼셉트론\n\n여러 개의 퍼셉트론을 층 구조로 구성한 신경망 모델을 의미하며, 이를 이용하면 단일 퍼셉트론의 한계였던 선형 분리불가 문제도 해결할 수 있습니다.\n\n다층 퍼셉트론을 이용해서 XOR 회로를 만들어봅시다.\n\n![231209-162649](/posts/final_02/231209-162649.png)\n\n### 학습\n\n다층 퍼셉트론을 학습을 시킨다는 것은 입력-출력 학습데이터에 대해 출력값과 오파의 차이가 최소가 되도록 가중치(weight)를 조정하는 것을 의미합니다.\n\n이를 위해 역전파 알고리즘을 사용하는데, 역전파 알고리즘은 미분을 사용합니다.\n따라서 수식화된 퍼셉트론이 미분 가능해야 하는데, threshold(bias)보다 크다/작다로 1/0이 나뉘는 step 함수를 사용하는 경우에는 미분이 불가능합니다.\n\n![231209-162951](/posts/final_02/231209-162951.png)\n\n그렇기에 미분이 가능한 sigmoid 함수나 다른 함수를 사용하여 출력값을 결정합니다.\n\nXOR와 같은 간단한 회로는 학습이 필요없이 바로 weight를 결정할 수 있지만, 사물 인식과 같이 상상할 수 없는 회로의 경우에는 퍼셉트론 층들을 많이 두고, 학습하는 방식으로 회로를 구성하게 됩니다.\n\n![231209-163157](/posts/final_02/231209-163157.png)\n\nn개의 은닉층을 둔 n+1층 퍼셉트론을 구성하면 복잡한 회로도 만들 수 있습니다.\n단, weight을 계산하는 것은 사실상 불가능하기 때문에 학습이라는 이름의 노가다(?)를 통해 weight이 오류가 적어지는 방향으로 조정하는 것입니다.\n\n학습 데이터의 입력은 $x_i$들의 벡터로 주어지고, 출력은 $y_i$의 벡터로 주어지는데, $y_i$ 중 하나만 1이고 나머지는 0인 ont-hot 벡터로 주어지는게 일반적입니다.\n\n오류를 줄이는 방향으로 학습하기 위한 방식으로 최대경사법 또는 경사하강법이라는 태크닉이 사용됩니다.\n원리만 설명하면, 각 스탭에서의 x, y 편미분을 구합니다(gradient).\n그리고, gradient의 반대 방향으로 weight를 수정하면 에러가 작아지는 방식입니다.\n\n### 기타\n\n최종 출력시 모든 속성값에 대한 확률을 0~1로 표현하기 위해 마지막 층으로 소프트맥스 층을 두기도 합니다.\n`소프트맥스 층`은 최종 출력을 분류 확률로 변환하는 층으로 모든 퍼셉트론 출력의 합이 1이 됩니다.\n\n가중치를 사용하는 대신, 퍼셉트론이 기존 벡터와 입력 벡터의 유사도를 측정하는 방식인 `RBF망` 이라는 방식도 있습니다.","slug":"univ_ai/final_02","readingMinutes":6,"wordCount":395},{"title":"결정 트리 \u0026 단순 베이즈 분류기","description":"결정 트리의 형태, 학습 알고리즘, 회귀와 단순 베이즈 분류기에 대해 알아봅니다.","icon":"","image":"","tags":["Decision Tree","Information Gain","Information Gain Ratio","Gini Gain","Regression","Naive Bayesian Classifier"],"draft":false,"date":"2023-12-08 / 21:32","content":"\n## 결정 트리\n\n의사결정 지식을 트리의 형태로 표현한 것으로, 구성요소는 다음과 같습니다.\n\n| 구성요소 | 역할 |\n|---|---|\n| 내부노드 | 비교 속성 |\n| 간선(edge) | 속성 값 |\n| 단말노드 | 부류(class), 대표 값 |\n\n이런 결정 트리를 학습하는 알고리즘의 종류에 대해 알아보도록 하겠습니다.\n\n### 정보 이득(IG)\n\n데이터로부터 결정 트리를 생성하는 알고리즘으로, 모든 데이터를 포함한 하나의 노드로 구성된 트리에서 시작하여, 반복적인 노드 분할 과정을 거치며 서브 트리를 만들어갑니다.\n\n트리는 간단하게 표현될수록(depth가 낮을수록) 좋은데, 이를 달성하기 위해서는 **분류력이 높은$^*$** 속성을 상위 노드에 배치하는 것이 좋습니다.\n($^*$분류력이 높다: 분류된 결과들이 비슷한 부류일수록 분류력이 높음)\n\n이 때, 분할 속성을 결정할 때, 분류력이 높음을 수치화할 수 있을까요?\n이 척도로 엔트로피 개념이 사용됩니다.\n\n엔트로피는 비동질(불순도) 정도의 척도로, 클수록 비동질적이라는 뜻입니다.\n즉, 엔트로피가 작을수록 동질성이 크다는 의미인데, 정보량 측정 목적의 척도로 사용됩니다.\n\n정보량(I) 및 정보 이득(IG)은 아래와 같이 수식화 할 수 있으며, 정보 이득이 클수록 엔트로피의 차이가 크다는 뜻이고, 이는 우수한 분할 속성으로 분할되었다는 의미입니다.\n\n$$\nI = -\\sum_{c}p(c)log_2p(c) \\\\\nI_{res} = -\\sum_{v}p(v) \\sum_{c}p(c|v)log_2p(c|v) \\\\\nIG = I - I_{res}(A)\n$$\n\n여기서 **p는 부류별 확률**이고, 위 수식을 해석하면 다음과 같습니다.\n부모 엔트로피가 $I$이고, 자식 트리의 엔트로피 가중 평균이 $I_{res}$일 때, 그 차이가 커야 부모 노드(속성)을 잘 선택해서 분류했다는 뜻입니다.\n\n예를 들어 이해해봅시다.\n\n![231208-220043](/posts/final_01/231208-220043.png)\n\n이런 데이터를 분류한다고 가정해봅시다.\n이 때의 I는 아래와 같이 계산할 수 있습니다.\n\n$$\nI = - \\frac{5}{14}log_2\\frac{5}{14} - \\frac{9}{14}log_2\\frac{9}{14} = 0.940\n$$\n\n- Case 1: Pattern으로 분류\n\n    ![231208-220649](/posts/final_01/231208-220649.png)\n\n    Pattern이 수평, 대각선, 수직인지에 따라 분류할 경우 $I_{res}$를 계산해봅시다.\n\n    $$\n    I_{horizontal} = - \\frac{2}{5}log_2\\frac{2}{5} - \\frac{3}{5}log_2\\frac{3}{5} = 0.971 \\\\\n    {}\\\\\n    I_{digonal} = - \\frac{0}{4}log_2\\frac{0}{4} - \\frac{4}{4}log_2\\frac{4}{4} = 0 \\\\\n    {}\\\\\n    I_{vertical} = - \\frac{3}{5}log_2\\frac{3}{5} - \\frac{2}{5}log_2\\frac{2}{5} = 0.971 \\\\\n    {}\\\\\n    I_{res}(Pattern) = \\frac{5}{14} \\cdot 0.971 + \\frac{4}{14} \\cdot 0 + \\frac{5}{14} \\cdot 0.971 = 0.694\n    $$\n\n    즉, 분류 기준이 Pattern인 경우 IG = 0.246이 나옵니다.\n\n- Case 2: Outline으로 분류\n\n    ![231208-221128](/posts/final_01/231208-221128.png)\n\n    Outline이 점선, 실선인지에 따라 분류할 경우 $I_{res}$를 계산해봅시다.\n\n    $$\n    I_{dashed} = - \\frac{4}{7}log_2\\frac{4}{7} - \\frac{3}{7}log_2\\frac{3}{7} = 0.985 \\\\\n    {}\\\\\n    I_{solid} = - \\frac{1}{7}log_2\\frac{1}{7} - \\frac{6}{7}log_2\\frac{6}{7} = 0.592 \\\\\n    {}\\\\\n    I_{res}(Outline) = \\frac{7}{14} \\cdot 0.985 + \\frac{7}{14} \\cdot 0.592 = 0.789\n    $$\n\n    즉, 분류 기준이 Outline인 경우 IG = 0.151이 나옵니다.\n\n- Case 3: Dot으로 분류\n\n    ![231208-221413](/posts/final_01/231208-221413.png)\n\n    Dot이 있는지, 없는지에 따라 분류할 경우 $I_{res}$를 계산해봅시다.\n\n    $$\n    I_{no} = - \\frac{2}{8}log_2\\frac{2}{8} - \\frac{6}{8}log_2\\frac{6}{8} = 0.811 \\\\\n    {}\\\\\n    I_{yes} = - \\frac{3}{6}log_2\\frac{3}{6} - \\frac{3}{6}log_2\\frac{3}{6} = 1 \\\\\n    {}\\\\\n    I_{res}(Dot) = \\frac{8}{14} \\cdot 0.811 + \\frac{6}{14} \\cdot 1 = 0.892\n    $$\n\n    즉, 분류 기준이 Dot인 경우 IG = 0.048이 나옵니다.\n\n즉, 이 경우에는 첫번째 분류 기준으로 Pattern을 선택하는 것이 합리적입니다.\n다음 분류기준을 선택할 때도 이와 동일한 방법으로 진행하면 되지만, 다음 분류기준을 Pattern으로 선택하는 것은 의미가 없기에 선택하지 않도록 주의합니다.\n\n![231208-221914](/posts/final_01/231208-221914.png)\n\n하지만, 정보 이득(IG) 척도의 단점 역시 존재합니다.\n분류기준을 선택함에 있어 **속성값이 많은 것을 선호**한다는 것입니다.\n\n예로 들어 학번같은 경우, 학번은 유니크하기 때문에 분류시 학번별로 노드가 만들어지고, 그에 따라 엔트로피가 아주 낮게 측정되어 학번이 분류기준으로 선택될 것입니다.\n하지만, 학번으로 분류하는 것은 의미가 없죠.\n\n뿐만 아니라, **학습 데이터 셋에 없던 속성값의 경우 분류가 불가능**하다는 단점 또한 존재합니다.\n\n### 정보 이득 비(IG Ratio)\n\n속성값이 많은 것을 선호하는 문제를 해결하기 위한 개선된 알고리즘으로, 속성값이 많은 속성에 대한 불이익을 주는 방향으로 동작합니다.\n\n$$\nGainRatio(A) = \\frac{IG(A)}{I(A)} = \\frac{I - I_{res}(A)}{I(A)} \\\\\n{}\\\\\nI(A) = - \\sum_{v}p(v)log_2p(v)\n$$\n\n여기서 I(A)는 고유 엔트로피로, 속성 A의 속성값을 부류로 간주하여 계산한 엔트로피를 의미합니다.\n즉, 속성값이 많아질수록 엔트로피가 커지게 되므로, 학번을 분류기준으로 삼았을 때의 오류를 해결할 수 있습니다.\n\n앞의 `Case - Pattern`을 예로 들어봅시다.\n\n\n![231208-220649](/posts/final_01/231208-220649.png)\n\n$$\nI_{res}(Pattern) = \\frac{5}{14} \\cdot 0.971 + \\frac{4}{14} \\cdot 0 + \\frac{5}{14} \\cdot 0.971 = 0.694 \\\\\n{}\\\\\nI(Pattern) = - \\frac{5}{14}log_2\\frac{5}{14} - \\frac{4}{14}log_2\\frac{4}{14} - \\frac{5}{14}log_2\\frac{5}{14} = 1.58 \\\\\n{}\\\\\nGainRatio(Pattern) = \\frac{IG(Pattern)}{I(Pattern)} = \\frac{0.940 - 0.694}{1.58} = 0.156\n$$\n\n같은 방식으로 다른 분류기준에 대해 계산하면 다음과 같은 결과가 나옵니다.\n\n| 분류속성 | 속성의 개수 | IG | IG Ratio |\n|---|---|---|---|\n| Pattern | 3 | 0.247 | 0.156 |\n| Outline | 2 | 0.152 | 0.152 |\n| Dot | 2 | 0.048 | 0.049 |\n\n### 지니 이득(Gini Gain)\n\n다른 분류 알고리즘으로 지니 지수를 사용하는 방법도 있습니다.\n\n$$\nGini = \\sum_{i \\neq j}p(i)p(j)\n$$\n\n지니 지수는 위와 같이 수식화하며, 순도가 높을수록 낮은값이 나오게 됩니다.\n이를 이용한 지니 지수 이득은 아래와 같습니다.\n\n$$\nGini(A) = \\sum_{v}p(v) \\sum_{i \\neq j}p(i|v)p(j|v) \\\\\n{}\\\\\nGiniGain(A) = Gini - Gini(A)\n$$\n\n부모의 지니 지수에서 분류된 자식 트리의 지니 지수의 가중평균을 뺌으로서 구할 수 있습니다.\n마찬가지로 앞의 `Case - Pattern`을 예로 들어봅시다.\n\n![231208-220649](/posts/final_01/231208-220649.png)\n\n$$\nGini = \\frac{5}{14} \\times \\frac{9}{14} = 0.230 \\\\\n{}\\\\\nGini(Pattern) = \\frac{5}{14} \\times (\\frac{2}{5} \\times \\frac{3}{5}) + \\frac{4}{14} \\times (\\frac{0}{4} \\times \\frac{4}{4}) + \\frac{5}{14} \\times (\\frac{3}{5} \\times \\frac{2}{5}) = 0.171 \\\\\n{}\\\\\nGiniGain(Pattern) = 0.230 - 0.171 = 0.058\n$$\n\n같은 방식으로 다른 분류기준에 대해 계산하면 다음과 같은 결과가 나옵니다.\n\n| 분류속성 | IG | IG Ratio | Gini Gain\n|---|---|---|---|\n| Pattern | 0.247 | 0.156 | 0.058 |\n| Outline | 0.152 | 0.152 | 0.046 |\n| Dot | 0.048 | 0.049 | 0.015 |\n\n### 회귀(Regression)\n\n단말노드가 부류(class)가 아닌 수치(대표)값에 해당하는 경우 사용할 수 있는 분류법입니다.\n\n표준편차 축소 SDR를 최대로 하는 속성을 선택하는게 졸으며, SDR은 아래와 같은 수식으로 표현 가능합니다.\n\n$$\nSDR(A) = SD - SD(A) \\\\\n{}\\\\\nSD = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} (x_i-m)^2} \\\\\n{}\\\\\nSD(A) = \\sum_{v}p(v) \\sqrt{\\frac{1}{N_v} \\sum_{i=1}^{N_v} (x_i-m_v)^2}\n$$\n\n---\n\n## 단순 베이즈 분류기\n\n결정 트리의 학습 알고리즘과 다르게 부류(class) 결정 지식을 조건부 확률로서 결정하는 분류기 입니다.\n\n\u003ctip\u003e\n  조건부 확률\n  $$\n  P(c|x_1, x_2, ..., x_n)\n  $$\n  \u003cbr /\u003e\n  베이즈 정리\n  $$\n  P(c|x_1, x_2, ..., x_n) = \\frac{P(x_1, x_2, ..., x_n|c)P(c)}{P(x_1, x_2, ..., x_n)} \\\\\n  {}\\\\\n  사후확률 = \\frac{가능도 \\times 사전확률}{증거}\n  $$\n\u003c/tip\u003e\n\n단순 베이즈 분류기는 베이즈 정리를 이용해서 분류를 하는데, 단순의 정의는 다음과 같습니다.\n\n\u003e 가능도가 조건부 독립이라고 가정\n\n즉, 베이즈 정리를 다음과 같이 정의합니다.\n\n$$\nP(c|x_1, x_2, ..., x_n) = \\frac{P(x_1|c)P(x_2|c)...p(x_n|c)P(c)}{P(x_1, x_2, ..., x_n)}\n$$\n\n예를 들어 이해해봅시다.\n\n![231208-220043](/posts/final_01/231208-220043.png)\n\n여기서 수직이며, 점선이고, 점이 없을 때 삼각형일 확률을 구해봅시다.\n\n$$\nP(삼각형|수직,점선,무) \\\\\n{}\\\\\n= \\frac{P(수직|삼각형)P(점선|삼각형)P(무|삼각형)P(삼각형)}{P(수직,점선,무)} \\\\\n{}\\\\\n= \\frac{3/5 \\cdot 4/5 \\cdot 2/5 \\cdot 5/14}{2/14} = 0.48\n$$","slug":"univ_ai/final_01","readingMinutes":11,"wordCount":977},{"title":"Visitor Pattern","description":"Visitor 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Visitor Pattern"],"draft":false,"date":"2023-12-07 / 21:03","content":"\n## 필요성\n\nComposite pattern을 사용하면서 동적으로 어떤 기능을 추가해야 하는 경우가 있다.\n\n이 경우 컴포넌트가 visitor의 접근 수락(accept) 하여 기능을 수행하는 패턴을 Visitor Pattern 라고 한다.\n\n## Visitor Pattern\n\n예시를 위해 java코드로 html 파일을 작성하는 코드를 구현한다고 가정해보자.\n\n```java:VisitorPattern.java\npublic interface Element {\n  public void accept(Visitor visitor);\n}\n\npublic interface Visitor {\n  public void visit(HtmlElement element);\n  public void visit(HtmlParentElement parentElement);\n}\n```\n\n우선 모든 `방문 대상의 클래스`를 하나의 Element 인터페이스로 묶기 위해 인터페이스를 만든다.\n또한, 방문하여 `수정을 가할 클래스`는 Visitor 인터페이스로 묶기게 되는데, 해당 클래스의 visit 메서드는 모든 방문 대상의 구현 클래스를 방문할 수 있어야 한다.\n\n```java:HtmlTag.java\npublic abstract class HtmlTag implements Element {\n  public String getTagName() {\n    throw new UnsupportedOperationException();\n  }\n  public void setTagBody(String tagBody) {\n    throw new UnsupportedOperationException();\n  }\n  // ...\n}\n```\n\n`구현할 방문 대상의 클래스`는 모두 HtmlTag를 상속받게 되는데, 이 부분은 Composite pattern과 동일하다.\n\n```java:HtmlElement.java\npublic class HtmlElement extends HtmlTag {\n  private String tagName;\n  private String startTag;\n  private String tagBody;\n\n  public HtmlElement(String tagName) {\n    this.tagName = tagName;\n    this.tagName = '';\n  }\n\n  @override\n  public String getTagName() {\n    return tagName;\n  }\n  ...\n  @override\n  public void accept(Visitor visitor) {\n    visitor.visit(this);\n  }\n}\n```\n\n```java:HtmlParentElement.java\npublic class HtmlParentElement extends HtmlTag {\n  private String tagName;\n  private String startTag;\n  private List\u003cHtmlTag\u003e childrenTag;\n\n  public HtmlParentElement(String tagName) {\n    this.tagName = tagName;\n    this.childrenTag = new ArrayList\u003cHtmlTag\u003e();\n  }\n\n  @override\n  public String getTagName() {\n    return tagName;\n  }\n  ...\n  @override\n  public void accept(Visitor visitor) {\n    visitor.visit(this);\n  }\n}\n```\n\n`방문 대상의 구현 클래스`를 HtmlTag(Element)를 상속받아 만들어준다.\n이 역시 인터페이스를 HtmlTag로 통일하기 위함이므로 Composite pattern과 동일하다.\n\n```java:ClassNameVisitor.java\npublic class ClassNameVisitor implements Visitor {\n  @override\n  public void visit(HtmlElement element) {\n    element.setStartTag(element.getStartTag().replace(\"\u003e\", \" class='children'\"))\n  }\n\n  @override\n  public void visit(HtmlParentElement element) {\n    element.setStartTag(element.getStartTag().replace(\"\u003e\", \" class='parent'\"))\n  }\n} \n```\n\n```java:StyleVisitor.java\npublic class StyleVisitor implements Visitor {\n  @override\n  public void visit(HtmlElement element) {\n    element.setStartTag(element.getStartTag().replace(\"\u003e\", \" style='width: 46px;'\"))\n  }\n\n  @override\n  public void visit(HtmlParentElement element) {\n    element.setStartTag(element.getStartTag().replace(\"\u003e\", \" style='width: 58px;'\"))\n  }\n} \n```\n\n그리고 `수정을 가할 클래스`를 Visitor를 상속받아 만들어준다.\n\n```java:.java {12-17}\npsvm() {\n  HtmlTag parentTag = new HtmlParentElement(\"\u003cdiv\u003e\");\n  HtmlTag cTag1 = new HtmlElement(\"\u003cp\u003e\");\n  HtmlTag cTag2 = new HtmlElement(\"\u003cp\u003e\");\n\n  parentTag.addChildTag(cTag1);\n  parentTag.addChildTag(cTag2);\n\n  Visitor className = new ClassNameVisitor();\n  VIsitor style = new StyleVisitor();\n\n  parentTag.accept(className);\n  parentTag.accept(style);\n  cTag1.accept(className);\n  cTag1.accept(style);\n  cTag2.accept(className);\n  cTag2.accept(style);\n}\n```\n\n그럼 위와 같은 방식으로 HtmlTag를 수정할 수 있다.\n\n이렇게 하면, Composite들은 accept 메서드만 제공할 뿐, 실제 기능의 추가와 변경은 visitor가 수행하게 된다.\n즉, 동적으로 기능을 확장할 수 있고, 기능을 visitor로 분리하여 코드를 관리할 수도 있다.","slug":"univ_design-pattern/final_10","readingMinutes":4,"wordCount":389},{"title":"Prototype Pattern","description":"Prototype 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Prototype Pattern"],"draft":false,"date":"2023-12-07 / 20:40","content":"\n## 필요성\n\n객체를 만들 때, 상당히 자주 만들어야 하는 객체의 생성방법이 귀찮거나, 오래 걸리는 경우에는 객체를 deep copy 하여 만드는 것이 효율적이다.\njava의 경우에는 clone() 메서드를 이용해서 객체를 deep copy할 수 있다.\n\n하나의 객체(Prototype)을 하드코딩하여 생성하고, 이후의 객체는 이 객체를 복사(일부 수정)하는 방식으로 생성하는 패턴을 prototype pattern 이라고 한다.\n\n## Prototype Pattern\n\n```java:Prototype.java\npublic interface Prototype extends Cloneable {\n  public AccessControl clone() throws CloneNotSupportedException;\n}\n```\n\njava에서는 객체를 clone할 때는 Cloneable marker interface를 상속받는 것이 좋다.\n따라서 이 인터페이스를 상속받아 prototype 인터페이스를 만든다.\n(AccessControl은 clone 메서드로 생성할 클래스로, 아래에서 구현예정)\n\n\u003ctip\u003e\n  clone() 메서드는 최상위 클래스 Object 클래스로부터 상속받을 수 있다.\n\u003c/tip\u003e\n\n```java:AccessControl.java\npublic class AccessControl implements Prototype {\n  private final String controlLevel;\n  private String access;\n\n  public AccessControl(String controlLevel, String access) {\n    this.controlLevel = controlLevel;\n    this.access = access;\n  }\n\n  @override\n  public AccessControl clone() {\n    try {\n      return (AccessControl) super.clone();\n    } catch (CloneNotSupportedException e) {\n      e.printStackTrace();\n    }\n    return null;\n  }\n  // getter...\n}\n```\n\n그리고 prototype pattern으로 생성할 클래스는 Prototype 인터페이스를 구현하여 만든다.\n\n```java:AccessControlProvider.java {13}\npublic class AccessControlProvider {\n  private static Map\u003cString, AccessControl\u003e new HashMap\u003cString, AccessControl\u003e();\n  static {\n    map.put(\"USER\", new AccessControl(\"USER\", \"DO_WORK\"));\n    map.put(\"ADMIN\", new AccessControl(\"ADMIN\", \"ADD/REMOVE_USER\"));\n    map.put(\"MANAGER\", new AccessControl(\"MANAGER\", \"GENERATE/READ_REPORTS\"));\n  }\n\n  public static AccessControl getAccessControlObject(String controlLevel) {\n    AccessControl ac = null;\n    ac = map.get(controlLevel);\n    if (ac != null) {\n      return ac.clone();\n    }\n    return null;\n  }\n}\n```\n\n그리고 필요에 따라 객체를 복사하여 사용한다.\n\n\u003ctip\u003e\n  왜 ac가 아닌 ac.clone 을 return 하냐면, 그냥 ac를 return할 경우, 모든 객체가 하나의 ac를 포인팅하게 된다.\n  즉, shallow copy가 일어나게 된다.\n  \u003cbr /\u003e\n  참고롤 객체를 clone 하더라도, 객체의 멤버 변수로 객체를 갖고있다면, 해당 멤버 객체까지 clone되지는 않는다는 점 주의하자.\n  (A가 멤버 객체 B를 갖고있을 경우, A' = A.clone()을 한다면, A'는 B'를 포인팅하는 것이 아닌, B를 포인팅하게 된다는 것.)\n\u003c/tip\u003e","slug":"univ_design-pattern/final_09","readingMinutes":3,"wordCount":283},{"title":"Mediator Pattern","description":"Mediator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Mediator Pattern"],"draft":false,"date":"2023-12-07 / 18:57","content":"\n## 필요성\n\n여러 군데에 있는 컴포넌트가 서로 의존성을 갖고있다면, 유지보수하기 어려울 것이다.\n그렇다고 해서 도저히 그 의존성을 줄일 방법이 존재하지 않는다면?\n\nMediator pattern은 모든 컴포넌트가 mediator와 1:1 관계를 갖도록 만들어서 모든 클래스가 종속성있게 복잡하게 구현해야 할 것을 mediator만 의존성을 갖도록 하여 mediator만 복잡하게 구현하도록 하는 방식이다.\n(facade pattern과 유사)\n\n## Mediator Pattern\n\n```java:MachineMediator.java\npublic interface MachineMediator {\n  public void start();\n  public void wash();\n  public void open();\n  public void closed();\n  public void on();\n  public void off();\n}\n```\n\n우선 여러 컴포넌트가 수행하는 역할의 집약체인 기계가 수행해야 할 기능들을 mediator 인터페이스로 묶어줍니다.\n\n```java:Colleague.java \npublic class Colleague {\n  public void setMediator(MachineMediator mediator);\n}\n```\n\n그리고, 여러 컴포넌트가 mediator와 종속성을 갖도록 하기 위해 colleague 인터페이스를 만들어줍니다.\n\n```java:Button.java\npublic class Button implements Colleague {\n  private MachineMediator mediator;\n\n  @override\n  public void setMediator(MachineMediator mediator) {\n    this.mediator = mediator;\n  }\n\n  public void press() {\n    mediator.start();\n  }\n}\n```\n\n```java:Machine.java\npublic class Machine implements Colleague {\n  private MachineMediator mediator; \n\n  @Override\n  public void setMediator(MachineMediator mediator) {\n    this.mediator = mediator;   \n  }\n\n  public void start() { \n    mediator.open();\n  }\n  public void wash() { \n    mediator.wash();\n  }\n}\n```\n\n그리고 각 컴포넌트에서 각각 기계가 수행해야 할 기능을 mediator 인터페이스와 연결해줍니다.\n\n```java:CottonMediator.java\npublic class CottonMediator implements MachineMediator {\n  private final Machine machine;\n  private final Heater heater;\n  ...\n  public CottonMediator(Machine machine, Heater heater, ...) {\n    this.machine = machine;\n    this.heater = heater;\n    ...\n  }\n\n  @override\n  public void start() {\n    machine.start();\n  }\n\n  @override\n  public void wach() {\n    motor.startMotor();\n    motor.rotateDrum(700);\n    soilRemoval.low();\n  }\n  // override other methods\n}\n```\n\n그리고 마지막으로 하나의 기계에 모든 컴포넌트를 의존성 주입시키면 된다.\n\n그렇다면 코드 실행 부분에서 모든 컴포넌트에 대해 `setMediator()`로 mediator를 등록시켜주고,\n위 예시의 경우에는 `button.press()` 만 실행시키면 관련된 모든 코드가 연쇄적으로 실행된다.\n\nCottonMediator 만 본다면 facade pattern과 똑같다.\nmediator pattern이 facade와 다른점은 컴포넌트가 setMediator 메서드를 제공하는 하나의 인터페이스로 묶여있다는 점이다.\n\nfacade는 facade에서만 컴포넌트를 호출할 수 있었다면,\nmediator는 mediator, 컴포넌트에서 서로를 호출할 수 있다.","slug":"univ_design-pattern/final_08","readingMinutes":3,"wordCount":300},{"title":"Chain of Responsibility","description":"Chain of Responsibility 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Chain of Responsibility Pattern"],"draft":false,"date":"2023-12-07 / 18:33","content":"\n## 필요성\n\n에러를 핸들링하는 로직을 구현해야 하는 경우, 연쇄적인 try-catch문을 쓰면 코드가 길어질 뿐더러 유지 보수도 어려워진다.\n에러 뿐만 아니라 특정 요청만을 처리해야 하는 핸들러를 달아줄 때, if-else를 사용하면 위와 동일한 문제가 생길 뿐더러, 런타임에서 처리 순서를 변경할 수도 없어진다.\n\n위의 모든 문제를 해결하는 방법이 Chain of Responsibility Pattern 이다.\n\n## Chain of Responsibility\n\n파일의 포멧과 상관없는 파일을 읽는 로직을 개발해보자.\n\n```java:File.java\npublic class File {\n  private final String fileName;\n  private final String fileType;\n  private final String filePath;\n\n  public File(String fileName, String fileType, String filePath) {\n    this.fileName = fileName;\n    this.fileType = fileType;\n    this.filePath = filePath;\n  }\n  // getter...\n}\n```\n\n우선 모든 파일을 하나의 인터페이스로 다루기 위해 File 상위 클래스를 만든다.\n\n```java:Handler.java\npublic interface Handler {\n  public void setHandler(Handler handler);\n  public void process(File file);\n  public String getHandlerName();\n}\n```\n\n그리고, 핸들링을 연쇄적으로 하기 위해 하나의 인터페이스로 묶어줘야 한다.\n따라서 핸들러 인터페이스를 만들어준다.\n\n```java:TextFileHandler.java {16-19}\npublic class TextFileHandler implements Handler {\n  private Handler handler;\n  private String handlerName;\n\n  public TextFileHandler(String handlerName) {\n    this.handlerName = handlerName;\n  }\n\n  @override\n  public void setHandler(Handler handler) {\n    this.handler = handler;\n  }\n\n  @override\n  public void process(File file) {\n    if (file.getFileName().equals(\"text\")) {\n      // process\n    } else if (handler != null) {\n      handler .process(file);\n    } else {\n      throw Exception(\"Not supported file format\");\n    }\n  }\n}\n```\n\n그리고 인터페이스 규격에 맞게 각 파일 포멧에 해당하는 핸들러를 구현한다.\n만약, 포멧이 맞다면, 이 핸들러에서 파일이 처리될 것이고,\n포멧이 맞지 않다면, setHandler로 등록된 다음 핸들러에게 파일의 처리를 인가할 것이다.\n\n```java:ReadFile.java {10-12}\npublic class ReadFile {\n  public static void main(String[] args) {\n    File file = new File(\"asd.mp4\", \"mp4\", \"~\");\n\n    Handler textHandler = new TextHandler(\"Text Handler\");\n    Handler excelHandler = new ExcelHandler(\"Excel Handler\");\n    Handler audioHandler = new AudioHandler(\"Audio Handler\");\n    Handler videoHandler = new VideoHandler(\"Video Handler\");\n\n    textHandler.setHandler(excelHandler);\n    excelHandler.setHandler(audioHandler);\n    audioHandler.setHandler(videoHandler);\n\n    textHandler.process(file);\n  }\n}\n```\n\n필요에 따라 런타임에 처리 순서를 바꿔줄 수도 있다.","slug":"univ_design-pattern/final_07","readingMinutes":3,"wordCount":294},{"title":"Builder Pattern","description":"Builder 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Builder Pattern"],"draft":false,"date":"2023-12-07 / 17:57","content":"\n## 필요성\n\n인스턴스를 생성함에 있어, 주입해야할 인자의 개수가 너무 많을 경우 그 순서를 외우는 것은 쉽지 않다.\n또한, 클래스가 has-a관계로 depth가 깊은 경우에도 이를 인스턴스로 초기화 하는과정은 매우 복잡할 것이다.\n\n예를 들어 회원정보를 받는 클래스를 만들어보자.\n\n```java:Form.java\npublic class Form {\n  private String firstName;\n  private String lastName;\n  private String userName;\n  private String email;\n  private String password;\n  private String address;\n  private Date dayOfBirth;\n  // etc...\n\n  public Form(String firstName, String lastName, ...) {\n    //...\n  }\n}\n```\n\n하지만, 위에처럼 인스턴스의 생성을 복잡하게 하지 않도록 하는 방법이 있다.\n인스턴스의 생성(초기화)를 유연하고, 보기 편하게 하기 위해 Builder Pattern을 사용한다.\n\n## Builder Pattern\n\n```diff-java:Form.java {18, 28-36, 40-42}\n  public class Form {\n    private String firstName;\n    private String lastName;\n    private String userName;\n    private String email;\n    private String password;\n    private String address;\n    private Date dayOfBirth;\n    // etc...\n\n+   private Form(FormBuilder builder) {\n-   public Form(String firstName, String lastName, ...) {\n      this.firstName = builder.firstName;\n      this.lastName = builder.lastName;\n      //...\n    }\n\n    public static class FormBuilder {\n      private String firstName;\n      private String lastName;\n      // etc...\n\n      public FormBuilder(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n      }\n\n      public FormBuilder userName(String userName) {\n        this.userName = userName;\n        return this;\n      }\n\n      public FormBuilder email(String email) {\n        this.email = email;\n        return this;\n      }\n\n      // etc...\n\n      public Form build() {\n        return new Form(this);\n      }\n    }\n  }\n```\n\nbuilder 클래스를 외부에도 만들 수 있지만, 여기선 이렇게도 할 수 있다는 것을 보여주기 위해 클래스 내부에 넣었다.\n\n특이한 점은 Form 클래스의 생성자가 private 라는 점이다.\n즉, 일반적인 방법으로 Form 클래스를 인스턴스화 할 수 없다.\n반드시 FormBuilder 클래스를 이용해서 인스턴스화 해야한다.\n\n```java:LoginForm.java\npublic class LoginForm {\n  public static void main(String[] args) {\n    FormBuilder builder = new Form.FormBuilder(\"Woong\", \"dev\");\n    builder = builder.email(\"wjlee611@gmail.com\").password(\"asdasd\").userName(\"dev.Woong\");\n    Form myForm = builder.build();\n  }\n}\n```\n\nFormBuilder의 생성자에 인자를 집어넣으면 필수로 기입해야 하는 항목을 지정할 수 있고,\nemail, password, userName과 같은 요소는 순서와 시점에 상관없이 입력을 받을 수 있다.\n또한, 인스턴스는 반드시 FormBuilder의 build 메서드를 이용해서만 만들 수 있다.\n\nBuilder pattern을 사용하면 마치 클래스의 Iterator를 만들듯이 Builder를 만들어서 생성과정을 은닉할 수 있다.","slug":"univ_design-pattern/final_06","readingMinutes":3,"wordCount":325},{"title":"Bridge Pattern","description":"Bridge 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Bridge Pattern"],"draft":false,"date":"2023-12-07 / 11:17","content":"\n## 필요성\n\n자동차를 만든다고 가정해보자.\n자동차에는 셀 수 없는 여러 부품들이 종합적으로 들어가서 만들어질텐데, 만약 그 부품이 모두 종속적으로 연결되어 있다면?\n부품 교체는 물론이고, 개발하는 것도 여러 사람이 분산해서 개발하지 못할 것이다.\n\n각 부분을 독립적으로 개발하고, 확장을 유연하게 하기 위해 Bridge pattern을 사용한다.\n\n## Bridge Pattern\n\n```java:Product.java\npublic interface Product {\n  public String productName();\n  public void produce();\n}\n```\n\n유연한 확장을 위해 인터페이스를 정의한다.\n자동차의 부품에 해당하는 부분이다.\n\n```java:CentralLocking.java\npublic class CentralLocking implements Product {\n  private final String productName;\n\n  public CentralLocking(String productName) {\n    this.productName = productName;\n  }\n  // override methods\n}\n```\n```java:GearLocking.java\npublic class GearLocking implements Product {\n  private final String productName;\n\n  public GearLocking(String productName) {\n    this.productName = productName;\n  }\n  // override methods\n}\n```\n\n그리고, 여러 사람이 인터페이스에 맞게 부품을 개발한다.\n\n```java:Car.java {2}\npublic abstract class Car {\n  private final Product product;\n  private final String carType;\n\n  public Car(Product product, String carType) {\n    this.product = product;\n    this.carType = carType;\n  }\n\n  public abstract void assemble();\n  public abstract void produceProduct();\n}\n```\n\n그리고 자동차의 뼈대를 만들어준다.\n\n이 때, product를 인터페이스로 만들었기에 유연한 확장과, Car과 독립적으로 product를 개발할 수 있게되는데, 이것이 Bridge pattern 이다.\n\n```java:Motoren.java {8}\npublic class Motoren extends Car {\n  public Motoren(Product product, Strint carType) {\n    super(product, carType);\n  }\n\n  @override\n  public void produceProduct() {\n    product .produce();\n    // ...\n  }\n}\n```\n\n그럼 자동차를 조립하는 입장에서는 produce의 내부 구조는 알 필요없이 인터페이스만을 가지고 독립적으로 개발할 수 있게 된다.","slug":"univ_design-pattern/final_05","readingMinutes":3,"wordCount":228},{"title":"PageRank","description":"인터넷 페이지의 중요도 순위를 매기는 방법을 알아봅니다.","icon":"","image":"","tags":["PageRank","Surfer model","Google formulation"],"draft":false,"date":"2023-12-06 / 22:54","content":"\n검색 엔진을 개발할 때, 인터넷의 웹 페이지들을 사용자에게 제공함에 있어, 중요한 페이지를 우선적으로 노출시켜 주는 것이 중요합니다.\n이 때, 어떤 페이지가 중요한지를 어떻게 알 수 있을까요?\n\n## PageRank\n\nPageRank가 높으면 중요한 페이지로 인식을 하게 됩니다.\n이제, 페이지에 PageRank를 매기는 방법을 알아봅시다.\n\n![231206-230644](/posts/final_05/231206-230644.png)\n\n우선 인터넷은 방향 그래프의 형태로 표현 가능합니다.\n여기서 중요한 페이지는 무엇일까요?\n\n중요한 페이지는 아래와 같은 특징이 있습니다.\n\n- 중요한(믿을만한) 정보는 중요한 정보를 **서로** 가리키는 경향이 있음\n- 특정 query에 대한 링크를 많이 갖고 있는 페이지는 해당 query의 중요한 응답 페이지임\n\n이를 in-link로 정리하면 다음과 같아집니다.\n\n- 중요한 페이지는 in-link가 많음\n- 같은 in-link 개수라도, 중요한 페이지로부터 오는 in-link가 많을수록 중요한 페이지임\n\n\u003ctip\u003e\n  `in-link / out-link`\n  \u003cbr /\u003e\n  ![231206-231125](/posts/final_05/231206-231125.png)\n\u003c/tip\u003e\n\n### Surfer model\n\n그렇다면 in-link의 개수와 세기를 이용해서 페이지의 중요도를 파악해야 하는데, 어떤 방식으로 파악하는 것이 좋을까요?\n그에 대한 하나의 해답으로 surfer model이 있습니다.\n\n동작 방식은 다음과 같습니다.\n\n1. 랜덤한 페이지들에 surfer를 배치\n2. 한 스탭마다 페이지의 out-link로 surfer 들을 이동\n3. 2번 반복\n4. surfer들이 페이지들에 특정한 분포로 수렴하도록 이동함\n\n여기서 중요한 점은 초기에 surfer를 어떻게 배치하더라도 결국은 특정한 분포로 페이지들에 분포하게 된다는 것입니다.\n(마치 자연계의 생물 개체수가 일정 비율로 유지되듯...)\n\n그렇다면 2번에서 surfer를 어떻게 이동시키는 걸까요?\n위의 예시를 이용해서 알아봅시다.\n\n![231206-230644](/posts/final_05/231206-230644.png)\n\n$r_i$를 페이지 i의 rank라고 하고 페이지 y, a, m의 rank를 계산하면 아래와 같습니다.\n\n$$\nr_y = r_y/2 + r_a/2 \\\\\nr_a = r_y/2 + r_m \\\\\nr_m = r_a/2\n$$\n\n**각 페이지로 in-link되는 페이지의 1/out-degree 의 합**으로서 표현되며, 수식화하면 아래와 같습니다.\n\n$$\nr_j = \\sum_{i \\to j} \\frac{r_i}{d_i}\n$$\n\n그렇다면 PageRank는 위에서 나온 3개의 식을 연립하여 계산하면 됩니다... 만,\n해가 무수히 많이 나오는 문제가 있습니다.\n따라서 $\\sum{r_i} = 1$ 이라는 제약 조건을 달아서 계산하면 됩니다. (1말고 다른것도 가능하지만, 1이 쉬워서..)\n\n하지만, 이 경우 시간복잡도가 $O(n^3)$이 나오기 때문에 현실세계에선 사용하기 어렵습니다.\n따라서 행렬로 계산하는 것이 좋습니다.\n\n$$\n1 \\begin{bmatrix}\nr_y \\\\\nr_a \\\\\nr_m\n\\end{bmatrix} = \\begin{bmatrix}\n\\frac{1}{2} \u0026 \\frac{1}{2} \u0026 0\\\\\n\\frac{1}{2} \u0026 0 \u0026 1 \\\\\n0 \u0026 \\frac{1}{2} \u0026 0\n\\end{bmatrix} \\begin{bmatrix}\nr_y \\\\\nr_a \\\\\nr_m\n\\end{bmatrix}\n$$\n\n$$\nr = M \\cdot r\n$$\n\n여기서 1은 $\\sum{r_i} = 1$ 에서 나온 제약 조건입니다.\n\n즉, 이렇게 하면 앞에서 글로만 적었던 Surfer model의 동작방식을 알고리즘화 할 수 있습니다.\n\n1. Set r = \\[1/N, 1/N, 1/N\\]\n2. r' = Mr\n3. r = r'\n4. Goto 2\n\n참고삼아 방향성이 없은 graph 모델의 경우 PageRank는 아래와 같은 수식으로 구할 수 있습니다.\n\n$$\nr_v = \\frac{d_v}{2m}\n$$\n\n여기서 $d_v$는 **노드 v에 연결된 edge의 수**를 의미하고, m은 **전체 edge의 수**를 의미합니다.\n\n\u003cnotice\u003e\n  Degree(in-link)가 높다고 PageRank가 항상 더 높은 것은 아닙니다.\n  \u003cbr /\u003e\n  ![231206-233606](/posts/final_05/231206-233606.png)\n  \u003cbr /\u003e\n  위 경우에는 3의 PageRank가 더 높을거 같지만, 1이 더 높게 측정됩니다.\n\u003c/notice\u003e\n\n### Google formulation\n\n기존 surfer model에는 치명적인 문제가 있습니다.\n바로 Dead-end, Spider-trap 문제입니다.\n\n![231206-233818](/posts/final_05/231206-233818.png)\n\n이 경우 페이지 m이 spider-trap입니다.\n다른 페이지로의 out-link가 없고 특정 circle에 같히기 떄문이죠.\n이련 경우에는 PageRank 계산시 $r_m = 1$ 이 되어버리고, 나머지는 0이되는 문제가 발생합니다.\n\n![231206-233954](/posts/final_05/231206-233954.png)\n\n이 경우 페이지 m이 dead-end입니다.\nout-link가 아예 존재하지 않아 surfer가 이동하지 못하고 소멸하기 때문이죠.\n이런 경우에는 PageRank 계산시 모두 0이되는 문제가 발생합니다.\n\n이런 현실세계의 문제를 해결하기 위해 Google에서 개선한 알고리즘이 바로 이것입니다.\n\n- spider-trap을 예방하기 위해 일정 확률(대충 0.1~0.2)로 링크로 연결된 페이지가 아닌 아예 생뚱맞은 페이지로 surfer를 점프\n- dead-end의 경우(out-link가 없는 경우) surfer를 생뚱맞은 페이지로 점프\n\n이를 반영한 PageRank 수식은 다음과 같습니다.\n\n$$\nr_j = \\sum_{i \\to j} \\beta \\frac{r_i}{d_i} + (1-\\beta)\\frac{1}{N}\n$$\n\n앞에 $\\frac{r_i}{d_i}$ 부분은 위와 동일합니다.\n다만, $\\beta$의 확률로만 적용됩니다. (대략 0.8~0.9)\n\n나머지 0.1~0.2의 확률로는 N개의 페이지 중 하나로 이동하는 방식을 적용한 것입니다!\n\n그럼 여기서 의문점이 듭니다.\n\n\u003e spider-trap은 해결한거 같은데 dead-end는요?\n\nspider-trap인지 아닌지는 판단할 수 있는 방법이 없기 때문에 위와 같이 확률에 의존하여 해결하였지만,\ndead-end인지 아닌지는 판단할 수 있는 방법이 존재합니다. (단순히 out-link의 개수가 0이면 dead-end)\n따라서 dead-end의 경우에는 그냥 surfer를 다른곳으로 점프시키면 됩니다.\n\n위 식을 행렬식으로 변환해볼까요?\n\n$$\n\\begin{bmatrix}\nr_y \\\\\nr_a \\\\\nr_m\n\\end{bmatrix} = (0.8 \\begin{bmatrix}\n\\frac{1}{2} \u0026 \\frac{1}{2} \u0026 0\\\\\n\\frac{1}{2} \u0026 0 \u0026 1 \\\\\n0 \u0026 \\frac{1}{2} \u0026 0\n\\end{bmatrix} + 0.2 \\begin{bmatrix}\n\\frac{1}{3} \u0026 \\frac{1}{3} \u0026 \\frac{1}{3} \\\\\n\\frac{1}{3} \u0026 \\frac{1}{3} \u0026 \\frac{1}{3} \\\\\n\\frac{1}{3} \u0026 \\frac{1}{3} \u0026 \\frac{1}{3}\n\\end{bmatrix})\\begin{bmatrix}\nr_y \\\\\nr_a \\\\\nr_m\n\\end{bmatrix}\n$$","slug":"univ_mmds/final_05","readingMinutes":8,"wordCount":669},{"title":"Recommender System","description":"추천 시스템의 종류와 동작 방식에 대해 알아봅니다.","icon":"","image":"","tags":["Recommender System","Content-based","TF-IDF","Collaborative Filtering"],"draft":false,"date":"2023-12-04 / 15:23","content":"\n사람이 손수 작성한 추천목록, 플레이리스트 등 기존의 추천엔 한계가 있습니다.\n따라서 개인화된 추천 시스템을 만들어야 하는데, 이를 개발할 때 여러 문제점들이 있습니다.\n\n- 훈련 데이터를 얻기 힘듦\n- 입력 안된 데이터를 채우기 힘듦 (평가 안된 항목 예측이 힘듦)\n- 추천 방식의 성능을 평가할 방식을 찾기 힘듦\n\n그렇기에 이러한 요소를 염두해두고 아래의 소개되는 추천 시스템을 비교하며 알아보도록 합시다.\n\n## Content-based\n\n기본적인 아이디어는 추천 대상을 여러가지 키워드의 벡터로 표현하고, 유저의 추천 대상에 대한 평점을 기반으로 벡터의 값을 계산해 비슷한 아이템을 추천하는 것입니다.\n\n따라서, 우선 영화라고 한다면 감독, 배우, 장르 등등의 키워드로서 영화를 표현해야 하는데요, 특징을 추출하는데는 TF-IDF 휴리스틱 알고리즘이 사용됩니다.\n\n### TF-IDF\n\nIF-IDF score는 아래와 같은 수식으로 계산합니다.\n\n$w_{ij} = TF_{ij} \\times IDF_i$\n_j: 문서, i: 단어_\n\n여기서 TF는 i-단어가 j-문서에 얼마나 많이 등장하는지에 대한 척도로, 아래와 같이 계산됩니다.\n\n$$\nTF_{ij} = \\frac{f_{ij}}{max_k f_{kj}}\n$$\n\n**i-단어의 등장횟수**를 **한 문서에 대해 가장 많이 등장하는 단어의 등장횟수**로 나눠줌으로서 문서의 길이에 비해 많이 나오는 정도(normalize)를 캐치합니다.\n\n하지만, 모든 문서에 대해 빈번하게 등장하는 단어의 경우에는 키워드로서 부적절 할 것입니다.\n따라서 이런 단어들에 대한 페널티를 부과하기 위해 IDF 항이 존재하며, 식은 아래와 같습니다.\n\n$$\nIDF_i = log \\frac{N}{n_i}\n$$\n\n**전체 문서의 개수**를 **i-단어가 나온 문서의 수**로 나눠줍니다.\n즉, 단어가 특이하게 많이 등장할수록 큰 점수를 부여하는 방식입니다.\n\n### User Profiles\n\nTF-IDF를 이용해서 item을 프로파일링 했으니, 이제 user를 프로파일링 해보겠습니다.\n\n예로 들어 아래와 같이 프로파일링된 item들이 있다고 가정해보겠습니다.\nTF-IDF에서 선택된 키워드는 1, 아닌 키워드는 0으로 표기됩니다.\n\n|  | keywordA | keywordB | keywordC | keywordD | keywordE |\n|---|---|---|---|---|---|\n| itemA | 1 | 1 | 0 | 0 | 0 |\n| itemB | 1 | 0 | 1 | 0 | 0 |\n| itemC | 0 | 0 | 0 | 1 | 1 |\n\n그리고 user들이 이런 item에 평점을 매겼다고 가정해보겠습니다.\n\n|  | itemA | itemB | itemC | average |\n|---|---|---|---|---|\n| user1 | 5(1) | 3(-1) | 0 | 4 |\n| user2 | 3(0) | 1(-2) | 2(-1) | 3 |\n| user3 | 3(0) | 0 | 3(0) | 3 |\n| rate(diff) ||||\n\nuser 프로파일링은 item profile에 대한 평점을 이용한 가중평균을 사용합니다.\n\n| user1 | keywordA | keywordB | keywordC | keywordD | keywordE |\n|---|---|---|---|---|---|\n| itemA | 5 | 5 | 0 | 0 | 0 |\n| itemB | 4 | 0 | 4 | 0 | 0 |\n| itemC | 0 | 0 | 0 | 0 | 0 |\n| average | 3 | 5/3 | 4/3 | 0 | 0 |\n\n하지만, 이렇게되면 유저가 평가하지 않은 항목에 대해서는 반드시 부정적인 평가가 이루어지게 되는 문제가 있습니다.\n따라서, **유저의 평점에서 평점의 평균 뺀 값 (diff)** 을 사용해서 가중평균을 구하는 것이 좋습니다.\n\n| user1 | keywordA | keywordB | keywordC | keywordD | keywordE |\n|---|---|---|---|---|---|\n| itemA | 1 | 1 | 0 | 0 | 0 |\n| itemB | -1 | 0 | -1 | 0 | 0 |\n| itemC | 0 | 0 | 0 | 0 | 0 |\n| average | 0 | 1/3 | -1/3 | 0 | 0 |\n\n같은 방식으로 user를 모두 프로파일링 하면 다음과 같은 profile을 얻을 수 있습니다.\n\n|  | keywordA | keywordB | keywordC | keywordD | keywordE |\n|---|---|---|---|---|---|\n| user1 | 0 | 1/3 | -1/3 | 0 | 0 |\n| user2 | -2/3 | 0 | -2/3 | -1/3 | -1/3 |\n| user3 | 0 | 0 | 0 | 0 | 0 |\n\n\u003ctip\u003e\n  user profile를 이용해서 비슷한 사용자를 찾을 때는 cosine 유사도, L1-norm 유사도의 방법을 사용하곤 합니다.\n  cosine 유사도(방향)는 취향 유사도를 판단할 때 쓰이고, L1-norm(차원별 거리)는 구매력 유사도를 판단할 때 사용하면 좋습니다.\n\u003c/tip\u003e\n\n\u003ctip\u003e\n  user profile를 이용해서 비슷한 item을 찾을 때는 [`LSH`](https://wjlee611.github.io/blog/univ_mmds/final_01)를 사용하면 됩니다.\n\u003c/tip\u003e\n\n### Pros \u0026 Cons\n\n장점\n- 다른 유저가 없어도 item을 추천할 수 있다(cold start 문제가 없다)\n  (물론, user profiling은 cold start 문제가 있다)\n- 독특한 취향의 사람에게도 추천할 수 있다\n- 새로운 item이나, 독특한 item의 경우에도 잘 동작한다\n- 추천에 대한 설명도 제공할 수 있다\n\n단점\n- 분야에 따라 추출해야 하는 keyword를 찾아야 한다\n- 새로운 user에 대한 추천은 어렵다\n- 너무 사용자 전용 추천이 되어버린다\n  (관심 밖은 추천이 아예 안되고, 다른 사람의 취향(트렌드)를 따르지 않음)\n\n---\n\n## Collaborative Filtering\n\n위에서는 item을 프로파일링 했다면, Collaborative Filtering 방식은 그런 프로파일을 작성하지 않습니다.\n이 방식은 단순히 utility matrix(위에 user의 item에 대한 평점 matrix)를 사용합니다.\n\n### User-User C.F.\n\n나와 비슷한 유저를 추천해주는 시스템을 만들기 위해 User-User Collaborative Filtering을 사용합니다.\n빠르게 LSH로 찾을 수도 있겠지만, 정밀한 추천을 위해 예시와 함께 다른 추천방법을 알아봅시다.\n\n우선, 유저 A~D의 item에 대한 평점정보가 아래와 같이 있다고 가정해봅시다.\n\n|  | item1 | item2 | item3 | item4 | item5 | item6 | item7 | avg |\n|---|---|---|---|---|---|---|---|---|\n| A | 4 |  |  | 5 | 1 |  |  | 10/3 |\n| B | 5 | 5 | 4 |  |  |  |  | 14/3 |\n| C |  |  |  | 2 | 4 | 5 |  | 11/3 |\n| D |  | 3 |  |  |  |  | 3 | 3 |\n\n만약 Jaccard 유사도를 기준으로 측정한다면 어떻게 될까요?\nA-B 유사도는 1/5, A-C 유사도는 1/2가 나올 것입니다.\nJaccard 유사도는 영화의 평점을 반영하지 못하기 때문에 여기서 사용하는 것은 부적절해 보입니다.\n\n이번엔 Cosine 유사도를 기준으로 측정해봅시다.\nA-B 유사도는 0.380, A-C 유사도는 0.322가 나올 것입니다.\nB가 C보다 A와 비슷하다는 점은 잘 캐치하는 것을 볼 수 있습니다.\n하지만, C가 A와 비슷한게 아니라 취향이 다르다는 점은 캐치하지 못합니다.\n\nNegative도 캐치할 수 있도록 피어슨 상관계수를 기준으로 측정해봅시다.\n\u003ctip\u003e\n  피어슨 상관계수는 평점을 평점의 평균으로 뺀 값을을 코사인 유사도를 측정한 것입니다.\n  피어슨 상관계수를 사용하면 좋은게, 부정적인 정도도 나타낼 수 있을 뿐만 아니라,\n  사용자가 평가하지 않은 항목은 0으로 출력한다는 점에서 좋습니다.\n\u003c/tip\u003e\nA-B 유사도는 0.092, A-C 유사도는 -0.559가 나올 것입니다.\n이제는 얼마나 다른지도 \\[-1, 1\\] 범위로 잘 측정할 수 있습니다.\n\n이렇게 나온 필터를 이용해서 유저에게 영화를 추천할 수 있습니다.\n위에서 나온 가중평균을 이용하면 되는데요, 여기서는 소개하지 않겠습니다.\n왜냐하면, Item-Item 필터로 추천하는 것이 성능이 더 좋기 때문입니다.\n(user의 취향은 여러개가 동시에 존재할 수 있지만, item은 일정하고 간단하기 때문)\n\n### Item-Item C.F.\n\n이제 Item-Item Collaborative Filtering 을 이용해서 item의 평점을 예측하고, 그 평점을 바탕으로 user에게 추천을 주도록 해봅시다.\n\n위의 예시를 그대로 사용하겠습니다.\n여기서 item2을 userA에게 추천할만한지 판단하기 위해 userA의 item2에 대한 평점을 예측해보겠습니다. \n\n|  | item1 | item2 | item3 | item4 | item5 | item6 | item7 |\n|---|---|---|---|---|---|---|---|\n| A | 4(2/3) | **\\[!\\]** |  | 5(5/3) | 1(-7/3) |  |  |\n| B | 5(1/3) | 5(1/3) | 4(-2/3) |  |  |  |  |\n| C |  |  |  | 2(-5/3) | 4(1/3) | 5(4/3) |  |\n| D |  | 3(0) |  |  |  |  | 3(0) |\n| $Sim_{item2}$ | 0.45 | 1.00 | -1.00 | 0 | 0 | 0 | 0 |\n\n여기서 $Sim_{item2}$는 item2에 대한 각 item의 피어슨 상관계수를 구한 것입니다.\n이제 item2의 가중평균을 아래와 같은 계산식으로 구해줍니다.\n\n$$\n\\frac{0.45*4 + 0*5 + 0*1}{0.45 + 0 + 0} = 4\n$$\n\n즉, item2에 대한 userA의 평점을 4로 예측하였고, 이는 userA 평균평점 이상이기에 추천할만한 item이라 판단할 수 있겠습니다.\n\n\u003cnotice\u003e\n  지금은 가중 평균 계산시 모든 item을 다 사용했지만,\n  일반적으로는 Sim(유사도)이 높은 k개의 item만을 가지고 평점을 예측합니다.\n\u003c/notice\u003e\n\n**장단점**은 Content-based와 정 반대입니다.\n\n추가로, 유사한 k개를 찾을 때, 그 k를 구하는 것이 어렵다는 단점도 있습니다.\n그럴때는 그냥 LSH, 클러스터링, 차원축소 등을 사용하는 것도 하나의 방법입니다.\n추천 알고리즘의 정답은 없으니까요!\n\n\u003ctip\u003e\n  추천 시스템을 개발할 때는 일반적으로 복잡한 알고리즘을 쓰는 것 보다,\n  단순한 알고리즘을 쓰되, 데이터를 많이 집어넣는게 좋습니다.\n\u003c/tip\u003e\n\n---\n\n## Evaluating Prediction\n\n마지막으로 추천 시스템을 평가하는 방법을 알아봅시다.\n대표적으로 아래의 평가 방법이 있습니다.\n\n- RMSE\n  오차의 제곱근(큰 오차에 대한 페널티 부여)의 평균을 이용합니다.\n  $\\sqrt{\\frac{1}{N} \\sum_{xi}(r_{xi}-r_{xi}^*)^2}$\n- MAE\n  오차의 절댓값의 평균을 이용합니다.\n  $\\frac{1}{N} \\sum_{xi}|r_{xi}-r_{xi}^*|$\n\n예시로 알아봅시다.\n\n| | | MAE | RMSE |\n|---|---|---|---|\n| 실제 평점 | 2 2 2 | - | - | \n| 예측 A | 3 3 3 | 1 | 1 |\n| 예측 B | 2 2 5 | 1 | $\\sqrt{3}$ |\n\n물론 이 측정 방법의 한계도 존재합니다.\n바로, 아래의 상황을 반영하지 못하는 것이죠..\n\n- 추천 다양성\n  e.g. 어떤 영화를 많이 봤는데, 이와 다른 장르는 추천하지 않는 현상\n- 추천 문맥\n  e.g. 여행 당시에 사놓은 여행 서적의 기록을 갖고, 평상시에도 여행 서적을 추천하는 현상\n- 추천의 순서\n  e.g. 시리즈물은 순서별로 추천해야 하는데 그렇지 않은 현상","slug":"univ_mmds/final_04","readingMinutes":15,"wordCount":1350},{"title":"Dimensionality Reduction \u0026 SVD","description":"차원 축소 기법과 고윳값 분해에 대해 알아봅니다.","icon":"","image":"","tags":["Dimensionality Reduction","SVD","concept"],"draft":false,"date":"2023-12-04 / 13:15","content":"\n## Dimensionality Reduction\n\n차원 축소 방법에 대해 알아보기 전에, 왜 차원축소를 하는걸까요?\n다음과 같은 이유들이 있다고 생각합니다.\n\n- [**차원의 저주**](https://wjlee611.github.io/blog/univ_mmds/final_02#curse-of-dimensionality) 해결\n- 데이터 용량 절약\n- 잠재된 관점(축)의 발견\n\n그렇다면 차원 축소는 어떤 원리를 이용해서 하게 되는 걸까요?\n아래의 예시를 봐봅시다.\n\n![231204-135530](/posts/final_03/231204-135530.png)\n\n좌측은 2차원 데이터인데 하나의 직선 위에 데이터들이 많이 밀집된 형태를 보입니다.\n우측은 3차원 데이터인데 하나의 평면 위에 데이터들이 많이 밀집된 형태를 보입니다.\n\n만약, 직선이나 평면에 데이터들을 적절하게 투영(projection)할 수 있다면?\n데이터를 표현하기 위해 2, 3개의 파라미터를 사용해야 했던 것에 반해, 1, 2개의 파라미터 만으로 데이터를 표현할 수 있을 것입니다.\n\n그렇지만, 무턱대고 투영하는 것은 좋지 않습니다.\n최대한 데이터의 손실이 적도록 투영하는게 옳은 방법이겠죠?\n\n데이터의 손실이 적도록 차원을 축소하기 위해서는 새로운(낮은) 차원의 축을 잘 선택해야 합니다.\n축을 잘 선택하는 방법은 아래와 같은 순서로 진행하면 왠만하면 차원 축소할 때 데이터의 손실이 적을 것입니다.\n\n1. 데이터의 분산이 가장 큰 방향의 축을 선택\n2. 1에서 선택한 축의 수직인 방향의 축을 선택\n3. 1, 2에서 선택한 축의 수직인 방향의 축을 선택... (반복)\n\n### Rank\n\n축을 선택하는 방법은 대강 알 거 같습니다.\n그러면 얼마나 축을 뽑는게 좋은걸까요?\n\n답은 행렬의 rank 에 해당하는 만큼 축을 뽑으면 됩니다.\n\n\u003ctip\u003e\n  `Rank`\n  \u003cbr /\u003e\n  rank는 선형 독립적인 행의 개수를 의미합니다.\n\u003c/tip\u003e\n\n예시와 함께 알아봅시다.\n\n$$\nA = \\begin{bmatrix}\n1 \u0026 2 \u0026 1 \\\\\n-2 \u0026 -3 \u0026 1 \\\\\n3 \u0026 5 \u0026 0 \\\\\n\\end{bmatrix}\n$$\n\nrank(A) = 2 입니다.\n왜냐하면 3행은 **1행 - 2행** 으로 표현되기 때문에 3행은 선형 종속적인 행이기 때문입니다.\n\n즉, 기존 basis \\[1 0 0\\], \\[0 1 0\\], \\[0 0 1\\] 의 3축에서 \\[1 2 1\\], \\[-2 -3 1\\] 의 2축으로 차원을 축소할 수 있습니다.\n그렇다면 A는 아래와 같이 변형되겠죠?\n\n$$\nA_{with\\_new\\_basis} = \\begin{bmatrix}\n1 \u0026 0 \\\\\n0 \u0026 1 \\\\\n1 \u0026 -1 \\\\\n\\end{bmatrix}\n$$\n\n---\n\n## SVD\n\n3차원은.. 좀만 노력하면 분해할 수 있지만, 30차원이 넘어간다면?\n아마 특정 공식에 의존하여 분해하는 것이 좋을 것입니다.\n차원을 직접적으로 축소하는 방법은 아니지만, 하나의 행렬을 의미가 담긴 3개의 행렬로 분해하는 방법이 바로 SVD, 고윳값 분해 입니다.\n\n![231204-142024](/posts/final_03/231204-142024.png)\n\n행렬 A는 $U \\sum V^T$로 데이터 손실 없이 분해됩니다.\n다만 차원을 줄이기 위해 r을 보다 작은 값으로 분해하여 약간의 데이터 손실과 함께 차원을 축소하는 것이죠.\n\n아무튼, SVD는 위의 $U \\sum V^T$ 형태의 3개의 행렬로 분해하는데, 각각 행렬마다 중요한 특징이 있습니다.\n그 특징을 아래의 예시와 함께 살펴보겠습니다.\n\n![231204-143118](/posts/final_03/231204-143118.png)\n\n우선 **$A$** 부터 살펴보겠습니다.\n예시로 든 행렬은 유저가 평가한 영화 평점에 대한 행렬입니다.\n예로 들어, 4행의 유저는 SciFi한 영화에는 5점을 남겼지만, Romance 영화는 관심도 없다는 의미겠네요.\n\n다음은 **$\\sum$** 을 살펴보겠습니다.\n$\\sum$은 대각 행렬로, 원소가 좌상단부터 우하단으로 반드시 내림차순 정렬되어 있습니다.\n그렇기 때문에 SVD시 $U \\sum V^T$가 유일하게 결정됩니다.\n\n여기서 $\\sum$은 `concept`의 세기에 대한 정보를 담고 있습니다.\n| Value | Concept |\n|---|---|\n| 12.4 | Sci-fi |\n| 9.5 | Romance |\n| 1.3 | Romance-Alien |\n\n즉 데이터들이 Sci-fi, Romance 한 concept에 대해 분산이 크지만,\nRomance-Alien 과 같은 잡스러운(?) concept에 대한 분산은 낮음을 알 수 있습니다.\n(차후에 이를 이용해 차원 축소를 하게 됩니다)\n\n다음은 **$U$** 를 살펴보겠습니다.\n이 행렬은 유저에 대한 concept 정보를 담고 있습니다. (별로 안중요함)\n\n마지막으로 **$V^T$** 를 살펴보겠습니다.\n이 행렬은 영화에 대한 concept 정보를 담고 있습니다. (별로 안중요함)\n\n### D.R. with SVD\n\n이제 고윳값 분해 방식과 의미를 알았으니 차원을 실제로 축소해봅시다.\n\n바로 위에서 다음과 같이 언급했었습니다.\n\n\u003e 즉 데이터들이 Sci-fi, Romance 한 concept에 대해 분산이 크지만,\n\u003e Romance-Alien 과 같은 잡스러운(?) concept에 대한 분산은 낮음을 알 수 있습니다.\n\n분산이 크다는 것은 해당 축으로 투영시켰을 때, 데이터 손실이 적다는 것을 의미한다고 했었습니다.\n즉, $\\sum$의 값이 작은 부분을 제거한다면?\n영향력이 적은 차원을 제거하는 꼴이 되어버려서 차원 축소를 달성할 수 있습니다!\n\n![231204-144815](/posts/final_03/231204-144815.png)\n\n이렇게 SVD로 분해된 세 행렬을 계산하면 다음과 같이 복원할 수 있습니다.\n\n![231204-144924](/posts/final_03/231204-144924.png)\n\n상당히 유사하지만, 데이터 손실 때문에 완벽하게 복원되지는 않았습니다.\n즉, 데이터의 손실이 발생할 수 있는 점을 염두하여 차원을 축소해야 합니다.\n\n그렇다면 차원축소는 얼마나 하는것이 좋을까요?\n\n정해진 답은 없지만, 일반적으로 SVD된 $\\sum$ 행렬의 에너지(대각선 제곱의 합)의 90% 이상 남기는 것이 좋다고 알려져 있습니다.\n예로 들어서 차원 축소 전의 $\\sum$ 에너지는 아래와 같습니다.\n\n$$\n12.4^2 + 9.5^2 + 1.3^2 = 245.7\n$$\n\nRomance-Alien concept를 제거한다면 에너지는 아래와 같이 감소합니다.\n\n$$\n12.4^2 + 9.5^2 = 244.01\n$$\n\n즉, Romance-Alien concept 차원을 제거하여 축소한다고 해도 원본의 99%에 해당하는 에너지가 해당되기에 차원을 축소해도 데이터 손실이 거의 없습니다.\n하지만, 여기에서 Romance concept까지 제거한다면?\n\n$$\n12.4^2 = 153.76\n$$\n\n62.6%의 에너지밖에 남지 않습니다.\n즉, 차원을 많이 줄일수는 있지만, 복원했을 때 유의미한 데이터를 얻을 수는 없을 것입니다.\n\n---\n\n## Application\n\n이제 실제 예시와 함께 분석하는 방법을 알아봅시다.\n\n![231204-144815](/posts/final_03/231204-144815.png)\n\n위와 같이 관리되고 있는 추천 시스템 데이터에서 \"Matrix\" 와 같은 SciFi concept의 영화를 좋아하는 유저를 찾고싶다고 해봅시다.\n\n![231204-150645](/posts/final_03/231204-150645.png)\n\n그럴 때는 유저 벡터를 concept-space에 투영해서 그 방향(경향)을 비교하는게 좋습니다.\n그리고 그 투영을 구하는 방법은 $q \\cdot V_{concept}$ 이죠.\n\n예로 들어 아래와 같은 유저 p, q의 영화 성향이 같은지 다른지를 판단해봅시다.\n\n$$\np = \\begin{bmatrix}\n5 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \n\\end{bmatrix}\n$$\n$$\nq = \\begin{bmatrix}\n0 \u0026 4 \u0026 5 \u0026 0 \u0026 0 \n\\end{bmatrix}\n$$\n\nJaccard 유사도, LSH와 같은 방식을 사용한다면, 두 사람은 전혀 다른 취향을 가진 사람이라고 판단할 것입니다.\n하지만, $q \\cdot V$을 이용하여 concept 벡터를 만들어 비교해본다면 어떨까요?\n\n$$\np_{concept} = \\begin{bmatrix}\n5 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \n\\end{bmatrix} \\begin{bmatrix}\n0.56 \u0026 0.12 \\\\\n0.59 \u0026 -0.02 \\\\\n0.56 \u0026 0.12 \\\\\n0.09 \u0026 -0.69 \\\\\n0.09 \u0026 -0.69\n\\end{bmatrix} = \\begin{bmatrix}\n2.8 \u0026 0.6\n\\end{bmatrix}\n$$\n$$\nq_{concept} = \\begin{bmatrix}\n0 \u0026 4 \u0026 5 \u0026 0 \u0026 0 \n\\end{bmatrix} \\begin{bmatrix}\n0.56 \u0026 0.12 \\\\\n0.59 \u0026 -0.02 \\\\\n0.56 \u0026 0.12 \\\\\n0.09 \u0026 -0.69 \\\\\n0.09 \u0026 -0.69\n\\end{bmatrix} = \\begin{bmatrix}\n5.2 \u0026 0.4\n\\end{bmatrix}\n$$\n\np, q 유저의 성향이 비슷하다고 판단되었습니다.\n심지어 SVD 이후 차원까지 축소했는데도 말이죠!\n\n이렇듯 취향을 판단하면서, 데이터를 압축해야 할 경우에는 SVD가 유리하게 작동합니다.\n또한, 차원을 낮추면서 근사하는 방식에는 SVD가 최적해를 도출한다고 증명이 되었습니다.\n\n하지만, 압축한 데이터에 대해서는 해석할 수 없으며, 원래 행렬의 대부분의 값이 0으로 채워진 경우에는 SVD를 하면 오히려 원소의 개수가 늘어난다는 단점도 있습니다.\n","slug":"univ_mmds/final_03","readingMinutes":12,"wordCount":958},{"title":"Clustering","description":"여러 군집화 방법에 대해 알아봅니다.","icon":"","image":"","tags":["Curse of Dimensionality","Hierachical Clustering","Point-assignment Clustering","K-means","L1-norm","L2-norm","Edit distance"],"draft":false,"date":"2023-12-03 / 21:28","content":"\n## Clustering\n\n군집화란 여러개의 점(데이터)들의 집합이 주어졌을 때, 거리에 따라 점들을 그룹으로 묶는 행위를 의미합니다.\n점들을 그룹으로 묶을 때는 유사도(거리)를 기준으로 cluster를 생성하게 되는데요, 사용되는 거리의 단위에는 아래와 같은 것들이 있습니다.\n\n- **Euclidean**\n  - $L_2$ norm\n    일반적인 두 점 사이의 거리 ($\\sqrt{(x_a - x_b)^2 + (y_a - y_b)^2}$)\n\n  - $L_1$ norm (Manhattan distance)\n    차원별로 두 점 사이의 거리 ($|x_a - x_b| + |y_a - y_b|$)\n\n  즉, L1, L2 norm이 같은 경우는 같은 차원 축 위에 존재하는 경우밖에 없습니다. (L1의 값이 L2보다 같거나 더 큽니다)\n\n  \u003ctip\u003e\n    L2는 차원간 거리의 차이가 클 수록 페널티를 부여하는 효과가 있습니다.\n    \u003cbr /\u003e\n    예로 들어, 점 x로 부터의 거리가 각 축별로 다음과 같다고 가정해봅시다.\n    A = 2,3,4\n    B = 1,3,5\n    \u003cbr /\u003e\n    이 때 L1는 거리가 9로 같지만, L2는 B가 더 멀다고 판단합니다.\n    (3축의 거리차가 더 크기에 더 큰 페널티 부여)\n  \u003c/tip\u003e\n\n\n- **Cosine** (for vector)\n  $cos(x,y) = \\frac{x \\cdot y}{||x|| \\cdot ||y||}$\n  방향성이 얼마나 비슷한지를 거리로 사용합니다.\n  내적 식과 동일합니다.\n\n- **Jaccard** (for sets)\n  e.g. Jaccard 유사도가 1이다 \u0026rarr; 두 원소가 완전 일치한다 \u0026rarr; 거리는 0이다\n\n- **Edit distance** (for strings)\n  문자열 x가 문자열 y로 변환되기 위한 과정의 횟수를 거리로 사용합니다.\n  여기서 LCS 라는 개념이 등장하는데, LCS는 끊겨도 상관없는 올바른 순서로 존재하는 공통 문자 쌍의 개수를 의미합니다.\n  e.g. x = a**bcde**, y = **bcd**uv**e** \u0026rarr; LCS(x, y) = **bcde**\n  |x| - |y| - 2|LCS(x, y)| = 5 + 6 - 2*4 = 3 \u0026rarr; **distance = 3**\n\n  \u003ctip\u003e\n    x = ab, y = ba의 경우에는 LCS가 a or b 로 2개 생길 수도 있습니다.\n    이 경우의 x, y의 edit distance는 아무튼 2로 동일하긴 합니다.\n  \u003c/tip\u003e\n\n단, 클러스터링을 하더라도, 특정 클러스터가 어떤 그룹인지는 알 수 없습니다.\n사람이 직접 라벨링을 하거나, 데이터의 분포로 추측하는 수 밖에 없습니다.\n\n### Curse of Dimensionality\n\n그럼 단순하게 거리계산을 이용한 클러스터링? 쉬워 보입니다.\n하지만 현실은 차원의 저주 때문에 클러스터링이 제대로 이뤄지지 않습니다.\n\n차원의 저주란 고차원에서 보면 매우 달라보이는 두 데이터가 비슷하게 분류되는 문제를 의미합니다.\n예시와 함께 알아봅시다.\n\n구간 \\[0, 1\\] 사이에 1만개의 서로 다른 점이 있다고 가정해봅시다.\n0.1%, 즉 10개의 이웃한 점을 추출한다고 했을 때 각 차원별로 축의 몇%에 해당하는 범위의 점들이 포함될까요?\n\n1차원에서는 일직선 위의 0.1%, 즉, 축위의 0\\~0.001 사이의 점들이 비슷한 정도 0.1%에 해당하는 점들입니다.\n2차원에서는 평면위의 0.1%, 즉, 각 축위의 0\\~0.032 사이의 점들이 비슷한 정도 0.1%에 해당하는 점들입니다. (0.032${^2} \\approx$ 0.001)\nn차원에서는 n차원의 0.1%, 즉, 각 축위의 0\\~0.001$^{1/n}$ 사이의 점들이 비슷한 정도 0.1%에 해당하는 점들입니다. ((0.001$^{1/n}$)${^n}$ = 0.001)\n\n즉, 차원이 높아질수록 각 축에서는 더 넓은 범위에서 비슷하다고 판단하게 됩니다.\n10차원(n=10)의 경우에는 (0, 0, ... , 0)과 (0.5, 0.5, ..., 0.5)도 상위 0.1%로 비슷하다고 판단해 버립니다.\n\n### Clustrting Strategies\n\n클러스터링 전략은 크게 2가지로 나뉩니다.\n\n1. 계층적 클러스터링\n    1. bottom up\n        각 점이 클러스터 1개를 생성사고, 가까운(비슷한) 클러스터끼리 병합하여 커지는 방식\n    2. top down\n        하나의 단일 클러스터로 시작하여 클러스터를 분리해나가는 방식\n\n    ![231203-230112](/posts/final_02/231203-230112.png)\n\n    중심 포인트가 구분되지 않는다면 hierachical 방식이 더 좋습니다.\n\n2. 점 할당 클러스터링\n\n    하나의 점을 향하는 점들끼리 클러스터링 하는 방식 (e.g. k-means)\n\n    ![231203-230031](/posts/final_02/231203-230031.png)\n\n    중심 포인트가 구분된다면 point-assignment 방식이 더 좋습니다.\n\n또한, 데이터가 유클리드 공간에 표현할 수 있는 경우에는 거리를 L1, L2 norm과 같은 유클리드 거리로 계산하지만,\n유클리드 공간에 표현 불가능한 경우에는 거리를 Cosine, Jaccard, Edit-distance 등으로 거리를 계산합니다.\n\n---\n\n## Hierachical Clustering\n\n계층적 클러스터링 중에서 bottom-up 방식의 클러스터링에 대해 알아보겠습니다.\n이 경우에는 클러스터링을 할 때, 다음과 같은 의문점을 해결해야 합니다.\n\n1. 클러스터를 어떤식으로 표현하는가?\n2. 가까운(비슷한) 클러스터의 기준이 무엇인가?\n3. 합치는 과정을 언제 멈추는게 좋은가?\n\n이 경우에는 유클리드 공간과 비 유클리드 공간에서 정의되는 경우를 나누어서 살펴보겠습니다.\n\n### In Euclidean\n\n**1에 대한 해결방법**으로 centroid 개념을 도입하면 됩니다.\nCentroid란, 클러스터 내부 점들의 평균값으로 가상의 점을 생성하여 그 가상의 점을 centroid라고 합니다.\n\n**2에 대한 해결방법**으로, 유클리드 공간의 경우 centroid간 거리가 가장 짧은 클러스터가 가장 가까운 클러스터가 됩니다.\n즉, centroid가 가장 짧은 두 클러스터를 병합하면 됩니다.\n\n**3에 대한 해결방법**으로, 아래와 같은 경우에 병합을 중단하는게 좋습니다.\n- 클러스터의 직경이 너무 커질 경우\n- 클러스터의 밀도가 너무 작을 경우\n- 클러스터의 직경이나 밀도의 변화가 급작스럽게 변할 경우\n\n중단에 대한 평가법은 비 유클리드 공간에서도 동일하게 사용되기 때문에 비 유클리드 공간에서는 굳이 2번 언급하지 않겠습니다.\n\n### In Non-Euclidean\n\n비 유클리드 공간에서는 centroid를 정의할 수 없습니다.\n따라서 이를 대신할 방법이 2가지 정도가 존재합니다.\n\n- A - clusteroid\n- B - 클러스터 내부의 모든 점으로 표현\n\n따라서 여기서 또 케이스를 나누어 살펴봅시다.\n\n**1-A에 대한 해결방법**으로 clusteroid 개념을 도입합니다.\n가상의 점인 centroid와 다르게 clusteroid는 실제로 존재하는 포인트 중 하나를 대표값으로 설정하는 방법입니다.\n따라서 점들 중에서 어떤 점을 clusteroid로서 선택할지에 대한 여러 방법론이 존재합니다.\n\n![231204-123642](/posts/final_02/231204-123642.png)\n\n클러스터의 내부 점들이 아래와 같이 형성되었다고 가정해봅시다. (2, 3번은 outlier)\n\n1. inf-norm\n\n    다른 점들까지의 거리의 최댓값이 가장 작은 점을 선택하는 방법입니다.\n    이 경우에는 2의 점이 clusteroid로 선택이 될 것입니다.\n\n2. L1-norm\n\n    다른 점들까지의 평균 거리가 가장 짧은 점을 선택하는 방법입니다.\n    이 경우에는 1에 있는 점들 중 하나가 clusteroid로 선택이 될 것입니다.\n\n3. L2-norm\n\n    다른 점들까지의 거리 제곱의 평균이 가장 짧은 점을 선택하는 방법입니다.\n    이 경우도 2번과 유사하게 동작합니다.\n    하지만, 먼 거리일수록 패털티를 크게 부여한다는 점에서 다르게 사용될 수 있습니다.\n\n**2-A에 대한 해결방법**으로, 유클리드 공간에서의 2번 해결법과 동일합니다.\n다만, centroid가 아닌 clusteroid를 사용한다는 차이점만이 존재합니다.\n\n\n**1-B에 대한 해결방법**으로 별도의 대표값을 지정하는 것이 아닌, 클러스터 내부의 점들 그 자체를 평가 요소로 사용합니다.\n그렇다면 이 경우에는 거리를 측정하는 방법을 찾는게 가장 중요한 요소가 되겠죠?\n\n**2-B에 대한 해결방법**으로 아래와 같은 방법을 생각해볼 수 있겠습니다.\n\n- 클러스터 사이의 거리가 가장 짧은 점 2개를 기준으로 거리 측정\n- 클러스터 사이의 거리가 가장 긴 점 2개를 기준으로 거리 측정\n  \u0026rarr; 이 경우에는 클러스터를 병합했을 때의 생성되는 클러스터의 직경을 의미하며 작을 수록 좋습니다.\n- 모든 점들의 페어에 대한 거리의 평균으로 측정\n  \u0026rarr; 이 경우에는 클러스터간 점들의 평균 거리를 의미하며 역시 작을 수록 좋습니다.\n- 직경이나 평균 거리를 구한 뒤에 그 안에 들어있는 점들의 개수(밀도)를 측정\n  \u0026rarr; 이 경우에는 위 방식들과 다르게 새로운 클러스터를 마지한다고 가정하고 진행합니다. 밀도가 높을수록 좋습니다.\n\n이렇게 방법이 많은데 그럼 무슨 클러스터링 방법을 써야 할까요?\n답은, 알 수 없습니다.\n데이터의 케이스가 굉장히 다양하기 때문이죠..\n\n![231204-125101](/posts/final_02/231204-125101.png)\n\n이런 경우에는 centroid 방식으로는 잘 동작합니다. (색칠된 영역으로 클러스터가 병합됩니다)\n하지만, `클러스터 사이의 거리가 가장 짧은 점 2개를 기준으로 거리 측정`하는 방식으로는 잘 동작하지 않을 것입니다. (A, C 클러스터가 병합해버림)\n\n![231204-125304](/posts/final_02/231204-125304.png)\n\n이런 경우에는 반대로 centroid 방식으로는 잘 동작하지 않을 것입니다.\n\n여기서 알 수 있듯, 계층적 구조는 클러스터링에서 최적해를 보장하지 않는다는 것을 알 수 있습니다.\n\n---\n\n## K-means (Point-assignment) Clustering\n\nK-means 알고리즘은 point-assignment clustering 방식의 대표적인 알고리즘 입니다.\nk개의 클러스터를 찾는 알고리즘인데, 위의 계층적 클러스터링 방식과 마찬가지로 최적해를 보장하지는 않습니다.\n\n알고리즘의 동작 방식은 다음과 같습니다.\n\n1. 일단은 랜덤하게 k개의 중심을 정한다.\n2. 각 점들은 가장 가까운 중심으로 연결한다. (임시 클러스터 생성)\n3. 연결, 즉, 임시 클러스터가 생성되면 임시 클러스터의 점들의 실제 중심으로 중심을 이동시킨다.\n  여담으로, 여기서 말하는 중심은 `In Non-Euclidean - 1-A에 대한 해결방법 - L2-norm`과 비슷하게 거리의 제곱이 최소화 되는 곳을 중심으로 합니다.\n4. 2, 3 과정을 반복하며 클러스터의 centroid가 안정(수렴)되면 종료합니다.\n\n단, k-means 방식은 결과 또한 보장받을 수가 없는게, 초기값의 영향을 많이 받기 때문에 무한루프에 빠질 가능성이 있기 때문입니다.\n아래의 예시가 그러한 경우입니다.\n\n![231204-130321](/posts/final_02/231204-130321.png)\n\n따라서 이런 경우를 방지하기 위해 실제 점을 초기값으로 잡거나, k-means++ 방식을 사용합니다.\n\n\u003ctip\u003e\n  `K-means++`\n  \u003cbr /\u003e\n  랜덤 중심을 정할 때, 이미 선택된 랜점 중심을 고려해서 고르자는 아이디어에서 출발하는 개선 알고리즘 입니다.\n  이미 선택된 랜덤 중심으로부터 거리가 멀 수록 선택 확률을 높이는 방식으로 동작합니다.\n\u003c/tip\u003e\n\n### vs. Hierachical\n\n계층적 클러스터링과 비교했을 때, K-means의 장점은 거리 비교 횟수가 적다는 것입니다.\n계층적 클러스터링 방식은 점들마다 다른 점들의 개수 만큼의 비교 횟수가 필요합니다.\n하지만, k-means 방식은 점들마다 centroid의 개수 만큼의 비교 횟수만이 필요하기에 빠르게 군집화를 달성할 수 있습니다.\n\n### Getting the k right\n\n그렇다면 k 개수는 어느정도로 설정하는 것이 좋을까요?\n\n![231204-131006](/posts/final_02/231204-131006.png)\n\ncentroid 까지의 거리가 유의미한 수준으로 줄어드는 정도에서 멈추는 것이 좋습니다.\n즉, 거리가 줄어들긴 해도 유의미한 수준으로 줄어들지 않는다면 그 시점의 k의 개수를 선택하는 것입니다.\n\n![231204-131019](/posts/final_02/231204-131019.png)\n![231204-131033](/posts/final_02/231204-131033.png)\n![231204-131046](/posts/final_02/231204-131046.png)","slug":"univ_mmds/final_02","readingMinutes":17,"wordCount":1233},{"title":"LSH","description":"Locality-Sensitive Hashing과 응용에 대해 알아봅니다.","icon":"","image":"","tags":["LSH"],"draft":false,"date":"2023-12-03 / 15:48","content":"\n## LSH\n\nLSH는 비슷한 객체를 찾는 방식 중 하나로, 일반 해싱과 비슷하게 동작하지만, 큰 차이가 있습니다.\n\n일반 해싱은 데이터가 조금만 달라져도 아웃풋이 완전히 달라지는 반면,\nLSH는 해싱을 부분적으로 진행하기 때문에 조금만 달라지면 아웃풋도 조금만 달라지게 됩니다.\n\n예시를 통해 알아봅시다.\n\n![231203-203340](/posts/final_01/231203-203340.png)\n\nLSH는 해싱을 진행할 때, 전체 데이터를 해싱하는 것이 아닌, 전체 데이터를 b등분한 b개의 bands를 각각 해싱합니다.\n해싱된 band는 그 아웃풋에 해당하는 bucket에 담기게 됩니다.\n\n만약 두 문서가 비슷하다면 어떨까요?\n비슷한 두 문서는 높은 확률로 시그니처가 동일한 band를 갖고 있을 것입니다.\n즉, 비슷한 분서는 같은 bucket에 담기는 band를 공유하고 있을 것입니다.\n\n물론, 다른 입력에 대해 같은 아웃풋이 해싱에는 존재할 수 있습니다.\n따라서 가능한 많은 bucket를 확보하여 분류하는 것이 좋습니다.\n또는 각 band 별로 다른 해시 테이블을 사용하여 다른 버킷에 할당될 수 있도록 하는 것도 방법입니다.\n\n그런데 LSH가 얼마나 효율적인지도 알아봐야겠죠?\n\n10만개의 문서가 각각 길이 100의 시그니처를 갖고있다고 가정해봅시다.\n80% 비슷한 문서, 즉 시그니처가 80개 이상 일치하는 비슷한 pair를 찾고싶다면, 일반적인 방법으로는 아래와 같은 연산 횟수가 필요합니다.\n\n$$\n100000 + ... + 2 + 1 = 100001 * 50000 \\approx 5B\n$$\n\n즉 10만개의 문서을 일일이 비교하려면 약 50억 번의 비교 연산이 필요합니다.\n\n하지만, LSH로 우선 비교 대상을 줄인다면?\nLSH로 10만 번의 연산이 필요하고, 비교 대상이 100개로 줄어든다면 아래와 같은 연산 횟수가 필요합니다.\n\n$$\n100000 + 100 + ... + 2 + 1 = 100000 + 5050 = 105050\n$$\n\nLSH를 사용하는 것 만으로 연산 횟수가 기하급수적으로 줄어든 것을 확인할 수 있었습니다.\n하지만, 앞서 언급했 듯, 다른 band도 같은 bucket에 들어갈 확률이 있습니다.\n\n그렇기에 LSH는 false negative가 발생할 확률도 있기 때문에, 같은 bucket에 들어간 candidate pair에 대해 실제로도 비슷한지 전 시그니처를 검사하는 과정을 거쳐 유사도를 판단하는 게 좋습니다.\n(LSH는 전처리 과정일 뿐!)\n\n### Confidence\n\n그렇다면, LSH의 신뢰도는 얼마나 될까요?\n\n5int/band 단위로 길이 100의 시그니처를 20개의 bands로 분할하고, LSH를 적용한다고 가정해봅시다.\n\n문서 $C_1$, $C_2$가 80% 확률로 비슷할 때, 한 band가 같은 버킷에 들어갈 확률은 다음과 같습니다.\n\n$$\n(0.8)^5 \\approx 0.328\n$$\n\n그렇다면, 20개의 모든 밴드가 다른 버킷의 들어갈 확률은 다음과 같아집니다.\n\n$$\n(1-0.328)^20 \\approx 0.00035\n$$\n\n즉, 문서 $C_1$, $C_2$가 80% 확률로 비슷하다면 약 99.99965%의 확률로 최소한 하나의 bucket에 두 band가 들어갈 것입니다.\n\n40% 확률로 비슷한 경우는 어떨까요?\n\n$$\n(0.4)^5 \\approx 0.01 \\\\\n(1-0.01)^20 \\approx 0.82\n$$\n\n즉, 40% 확률로 비슷하다면 약 18%의 확률로 최소한 하나의 bucket에 두 band가 들어갈 것입니다.\n\n40%만 비슷해도 비슷하다고 판단해야 하는 시스템의 경우 88%의 케이스가 False positive가 되어버립니다.\n그럼에도 불구하고 50억번 비교하는 것 보다는 나을 것입니다.\n\n### Analysis\n\n위의 경우 80% 유사도를 검사할 때는 신뢰도가 매우 높았지만, 40%을 검사할 때는 신뢰도가 상당히 낮았습니다.\n신뢰도는 b(bands)와 r(ints/band)의 값에 영향을 받는데, 각각의 파라미터가 어느정도일 때 유사도에 따른 신뢰도는 어떻게 나오는 걸까요?\n\n![231203-210605](/posts/final_01/231203-210605.png)\n\n우선 band가 1개일 때의 신뢰도 입니다.\nband가 1개라는 것은 그냥 데이터 전체를 해싱하는 것과 같습니다.\n\n![231203-210859](/posts/final_01/231203-210859.png)\n\n다음은 band가 b개이고, r ints/band 일 때의 일치율 s에 따른 신뢰도 입니다.\n$$\n1 - (1-s^r)^b\n$$\n$(1/b)^{1/r}$ 지점에서 신뢰도가 급격하게 증가하는 모습을 볼 수 있습니다.\nb=20, r=5일 때 약 55% 일치율 지점에서 급격하게 증가합니다.","slug":"univ_mmds/final_01","readingMinutes":7,"wordCount":474},{"title":"Motion","description":"영상에서 움직임을 감지하는 방법에 대해 알아봅니다.","icon":"","image":"","tags":["Background Subtraction"],"draft":false,"date":"2023-12-03 / 15:25","content":"\n어떤 사물이 움직이는 사물이라고 정의할 수 있을까?\n움직임은 우선 시간이라는 차원이 있기에 존재하는 개념이다.\n그렇기에 2차원 영상 기준, 움직이는 영상은 2차원 데이터 + 시간으로 이루어진다.\n\n즉, 시간이 경과했을 때, 특정 픽셀의 변화가 없다면? 해당 픽셀에 해당하는 객체는 움직이는 사물이 아닌 배경이라고 판단하면 되고,\n시간이 경과했을 때 픽셀의 변화가 있다면, 해당 픽셀에 해당하는 객체는 움직이는 사물이라고 판단할 수 있을 것이다.\n\n## Background Subtraction\n\n원본 영상에서 배경을 빼는 방식으로 움직이는 사물만을 추출할 수 있다.\n즉, 원본 영상에서 배경을 추출하는 영역이 가장 중요한 부분인데, 이 배경을 추출하는 방법을 알아보자.\n\n![231203-153249](/posts/final_08/231203-153249.png)\n\n우선 배경(Background)은 시간에 따른 영상 스택에서 픽셀의 변화가 없거나 매우 천천히 변하는 영역일 것이다.\n물론 현실에서는 시간변화에 따른 일조량, 그림자 차이 등등 여러 요소가 있기 때문에 배경을 추출하는 방식에는 정해진 방식이 없다.\n그렇기에 지금껏 배운 컴퓨터 비전 지식을 총동원해야 한다.\n\n아무튼 배경을 추출했다면, 원본에서 배경을 뺄 수 있을텐데, 그럼 결과물로 어떤 영상이 나올까?\n움직이는 객체(foreground object)와 약간의 노이즈만이 나올 것이다.\n이렇게 나온 영상에 대해 절댓값을 취하고(음수가 나올 수 있기 때문) thresholding을 하면 foreground object 만 얻을 수 있을 것이다.\n\n$$\n|I(x,y,t) - B(x,y,t)| \u003e Th\n$$\n\n이제 특정 시각에서 배경을 추출하는 여러 아이디어를 알아보자.\n\n### Frame Differencing\n\n![231203-154303](/posts/final_08/231203-154303.png)\n\n단순히 이전 프레임의 영상을 배경으로 삼는 것이다.\n\n$$\nB(x,y,t) = I(x,y,t-1)\n$$\n\n단순해 보이지만, 생각보다 잘 동작한다.\n\n만약 사물의 움직임이 threshold에 걸리지 않을만큼 느려서 인식이 잘 안되는 경우에는 이전 프레임 말고, 10 프레임 이전과 같은 영상을 사용하는 방식을 취할 수도 있다.\n\n### Mean Filter\n\n![231203-154321](/posts/final_08/231203-154321.png)\n\n이전 프레임들의 평균값을 배경으로 사용하는 것이다.\n\n$$\nB(x,y,t) = \\frac{1}{n} \\sum_{i=0}^{n-1}I(x,y,t-i)\n$$\n\n### Median Filter\n\n![231203-154402](/posts/final_08/231203-154402.png)\n\n이전 프레임들의 중앙값을 배경으로 사용하는 것이다.\n\n$$\nB(x,y,t) = median\\{I(x,y,t-i)\\}\n$$","slug":"univ_com-vision/final_08","readingMinutes":4,"wordCount":258},{"title":"Face Recognition","description":"얼굴을 인식하는 방법과 그에 사용되는 선형대수학을 다뤄봅니다.","icon":"","image":"","tags":["SVD","PCA"],"draft":false,"date":"2023-12-03 / 14:07","content":"\n## SVD\n\nSingular Value Decomposition은 행렬을 여러 행렬로 분해하는 방법이다.\n보통 아래와 같은 기호로 표현한다.\n\n$A = U$ $\\sum$ $V^T$\n\n행렬 A는 세 행렬로 분해되는데, 각 행렬이 어떤 특성을 갖는지 알아보자.\n\n![231203-141325](/posts/final_07/231203-141325.png)\n\n우선 SVD된 행렬에서 $U$, $V^T$는 normalize 되어있다.\n그리고, $\\sum$는 대각 행렬인데, 원소가 내림차순으로 정렬되어 있다.\n\n여기서 대각행렬이 내림차순으로 정렬된다는 특징이 매우 중요한데, 왜 중요한지 아래의 예시를 보며 알아보자.\n\n$$\n\\begin{bmatrix}\n1 \u0026 2 \u0026 3 \\\\\n4 \u0026 5 \u0026 6\n\\end{bmatrix} = \\\\\n\\begin{bmatrix}\n-0.39 \u0026 -0.92 \\\\\n-0.92 \u0026 0.39\n\\end{bmatrix} \\times \\begin{bmatrix}\n9.51 \u0026 0 \u0026 0 \\\\\n0 \u0026 0.77 \u0026 0\n\\end{bmatrix} \\times \\begin{bmatrix}\n-0.42 \u0026 -0.57 \u0026 -0.70 \\\\\n0.81 \u0026 0.11 \u0026 -0.58 \\\\\n0.41 \u0026 -0.82 \u0026 0.41\n\\end{bmatrix}\n$$\n\n여기서 $U$와 $\\sum$을 먼저 계산하자.\n\n$$\n\\begin{bmatrix}\n-3.68 \u0026 -0.71 \u0026 0 \\\\\n-8.8 \u0026 0.30 \u0026 0\n\\end{bmatrix} \\times \\begin{bmatrix}\n-0.42 \u0026 -0.57 \u0026 -0.70 \\\\\n0.81 \u0026 0.11 \u0026 -0.58 \\\\\n0.41 \u0026 -0.82 \u0026 0.41\n\\end{bmatrix}\n$$\n\n$\\sum$이 내림차순 정렬되어 있었기 때문에 $U \\sum$의 1열의 값이 크고, 2열은 값이 작은 것을 확인할 수 있다.\n\n이 때, 위 두 행렬 $U \\sum$ 와 $V^T$ 의 i열 i행의 원소만을 가지고 $A_{pi}$ 를 만들어보자.\n\n$$\n\\begin{bmatrix}\n{\\color{Red} -3.68} \u0026 -0.71 \u0026 0 \\\\\n{\\color{Orange} -8.8} \u0026 0.30 \u0026 0\n\\end{bmatrix} \\times \\begin{bmatrix}\n{\\color{Red} -0.42} \u0026 {\\color{Orange} -0.57} \u0026 {\\color{Orange} -0.70} \\\\\n0.81 \u0026 0.11 \u0026 -0.58 \\\\\n0.41 \u0026 -0.82 \u0026 0.41\n\\end{bmatrix} \\\\\n= {\\color{Orange} \\begin{bmatrix}\n{\\color{Red} 1.6} \u0026 2.1 \u0026 2.6 \\\\\n3.8 \u0026 5.0 \u0026 6.2\n\\end{bmatrix}} = A_{p1}\n$$\n\n$$\n\\begin{bmatrix}\n-3.68 \u0026 {\\color{Orange} -0.71} \u0026 0 \\\\\n-8.8 \u0026 {\\color{Orange} 0.30} \u0026 0\n\\end{bmatrix} \\times \\begin{bmatrix}\n-0.42 \u0026 -0.57 \u0026 -0.70 \\\\\n{\\color{Orange} 0.81} \u0026 {\\color{Orange} 0.11} \u0026 {\\color{Orange} -0.58} \\\\\n0.41 \u0026 -0.82 \u0026 0.41\n\\end{bmatrix} \\\\\n= {\\color{Orange} \\begin{bmatrix}\n-0.6 \u0026 -0.1 \u0026 0.4 \\\\\n0.2 \u0026 0 \u0026 -0.2\n\\end{bmatrix}} = A_{p2}\n$$\n\n즉, $\\sum$의 크기 비율에 맞게 $A$를 $A_{p1}$, $A_{p2}$로 분해할 수 있다.\n\n근데 이걸 왜 했느냐?\nA를 6픽셀의 영상이라고 했을 때, A를 2개의 영상으로 분해한 꼴이다.\n이 때, 에너지 레벨이 큰 영상부터 작은 영상 순서대로 분해한 것인데, **에너지 레벨이 크다**는 것은 **가장 두드러지는 특징**을 의미한다.\n즉, 사람 얼굴을 예로 들면, 위의 partial 영상부터 타원모양, 눈코입 위치, 피부 질감과 같이 큰 특징 순으로 얼굴영상을 분해한 것이다.\n\n위 예시는 2개의 특징으로밖에 분리를 못하였지만, 아래의 예시를 살펴보자.\n\n![231203-143845](/posts/final_07/231203-143845.png)\n\n특징을 300개를 추출했는데, 그 중 상위 10개의 특징들로만 영상을 재구성하였다.\n단, 3%만의 특징으로만 영상을 복원했는데, 상당히 원본을 닮을 수 있는 이유는 아래에서 알아보자.\n\n---\n\n## PCA\n\nPrincipal Component Analysis는 주성분 분석이라고 하는데, 이를 이용하면 고차원 데이터를 저차원 데이터로 차원 축소를 시킬 수 있다.\n그런데 그 과정에서 데이터의 손실이 최소화 되도록 하는데, 어떤식으로 최소화 하는지 알아보자.\n\n![231203-145410](/posts/final_07/231203-145410.png)\n\n키, 몸무게로 표현된 2차원 데이터가 있다.\n이 데이터를 1차원으로 잘 낮춰보기 위해 PCA를 사용하자.\n\n![231203-145633](/posts/final_07/231203-145633.png)\n\n특정 직선에 수선의 발을 내렸을 때, 평균으로부터 수선의 발 까지의 길이의 제곱의 합이 최대가 되도록 하는 최적의 직선을 찾는다.\n\n![231203-145832](/posts/final_07/231203-145832.png)\n\n그리고, 그 최적의 직선에 수직인 다른 직선을 긋는다.\n\n![231203-150105](/posts/final_07/231203-150105.png)\n\n각 PC축이 전체 데이터를 얼마나 잘 표현하고 있는지 분석하기 위해 회전한다.\n여기서 이 회전은 SVD의 $U$ 행렬변환에 해당한다.\n\n![231203-150324](/posts/final_07/231203-150324.png)\n\n그리고 각 축이 데이터를 얼마나 잘 표현하는지에 대한 척도로 평균과 수선의 발까지의 거리의 제곱의 합으로 분석한다.\n여기서 분석 결과가 SVD의 $\\sum$ 행렬에 해당한다.\n\n만약 PC1이 PC2 보다 압도적으로 전체 데이터를 잘 표현한다면?\n\n![231203-150637](/posts/final_07/231203-150637.png)\n\nPC1 만으로도 전체 데이터를 표현해도 크게 상관 없을 것이다.\n따라서 PC2를 사용하지 않음으로써 차원을 낮출 수 있다.\n\n![231203-144044](/posts/final_07/231203-144044.png)\n\n대부분의 주요 특징은 높은 에너지 레벨을 보이고, 사소하고 디테일한 특징은 낮은 에너지 레벨을 보이기 때문에,\nSVD에서 상위 몇개의 특징만으로 원본 영상을 비슷하게 재현할 수 있는 것이다.\n\n---\n\n## Face Recognition\n\n이제 기본 배경 지식을 어느정도 알았으니, 얼굴 인식하는 방식에 대해 알아보자.\n\n![231203-150956](/posts/final_07/231203-150956.png)\n\n100x100 pixel의 얼굴 영상은 1만 차원의 하나의 포인트로 대응된다.\n\n![231203-151306](/posts/final_07/231203-151306.png)\n\n즉, 1만개의 특징 중, 얼굴을 표현하는 상위의 특징들로 차원을 축소한다면?\n얼굴인 영상만을 인식할 수 있을 것이다.\n\n따라서 PCA를 이용해서 얼굴의 가장 큰 특징벡터(sub-space)를 찾는 방식으로 얼굴 인식을 할 수 있으며,\nsub-space는 학습 데이터를 학습을 시켜 얼굴의 eigenvector 들을 구하는 방식으로 진행된다.\n\n![231203-151850](/posts/final_07/231203-151850.png)\n\n얼굴의 특징을 나타내는 eigenvector를 구했다면, 이를 이용해서 여러 얼굴을 만들수도 있다.\n\n![231203-151927](/posts/final_07/231203-151927.png)\n\n이러한 여러 얼굴은 아래의 공식으로 표현할 수 있다.\n\n$$\nx_i \\approx \\mu + a_1 \\phi _1 + a_2 \\phi _2 + ... + a_k \\phi _k\n$$\n\n여기서 중요한 점은 특징을 1만개를 사용하여 얼굴을 만든 것이 아니라, k개 만을 가지고 만들었다는 점이다.\n즉, 1만 차원의 얼굴 영상을 단 k차원으로 줄여서 파악할 수 있다.","slug":"univ_com-vision/final_07","readingMinutes":8,"wordCount":715},{"title":"Object Recognition","description":"사물을 인식하는 방법을 알아봅니다.","icon":"","image":"","tags":["Classifier","K-Nearest Neighbor","Bag of Features","Spatial Pyramids"],"draft":false,"date":"2023-12-02 / 16:09","content":"\n## Classifiers\n\n시각, 크기, 밝기 등등의 요소 때문에 사물인식이 어려워진다.\n현실적으로는 사물의 특징을 뽑고, 그 특징을 이용해서 분류기를 학습시키는 ML 방식으로 이를 해결한다.\n그렇기에 이번엔 어떤 종류의 분류기를 사용하면 어떤 식으로 사물을 구분할 수 있는지에 대한 내용을 중점적으로 다뤄보자.\n\n### K-Nearest Neighbor\n\n![231203-133822](/posts/final_06/231203-133822.png)\n\n일반 Nearest Neighbor 방식은 학습된 분류기에 새로운 Test example이 들어오면, 가장 유클리드 거리상으로 가까운 점의 분류로 분류하는 방식이다.\n하지만, 이 방식은 outlier에 대해 취약하기 때문에 k개의 가까운 점들을 찾고, 가장 많은 분류로 분류하는 방식이 K-Nearest Neighbor 방식이다.\n\n한마디로 비슷한 데이터와 같은 부류로 분류가 되는 것인데, 이 때문에 실제로 잘 분류가 되지 않기도 한다.\n\n| Pros | Cons |\n|---|---|\n| 구현이 간단함 | 차이(거리) 함수를 잘 설계해야 함 |\n| 비선형적인 경계에서도 잘 동작함 | 테스트 시간이 오래 걸림 |\n| 분류(클래스)가 늘어나도 잘 동작함 ||\n| 파라미터가 늘어나도 잘 동작함 ||\n\n### Linear\n\n![231203-134242](/posts/final_06/231203-134242.png)\n\n학습에 사용된 데이터를 가장 잘 분류할 수 있는 선형 함수를 예측하는 방법으로, 입력데이터가 들어왔을 때, 학습된 선형 함수에 의해 분류가 이루어진다.\n\n![231203-134446](/posts/final_06/231203-134446.png)\n\n하나의 선형 함수는 해당 선형 함수가 분류하는 데이터에 대한 일치도를 점수로 표현하게 되는데,\n그렇기에 여러 사물을 분류하기 위해서는 사물의 종류만큼의 선형 함수를 학습을 시켜야 한다.\n\n각각의 선형 함수는 다른 함수의 계산 결과에는 영향을 주지 않지만, 학습되는 과정에서는 영향을 주게 된다.\n\n| Pros | Cons |\n|---|---|\n| 파라미터의 차원이 낮기에 간단한 방식으로 표현됨 | 선형 함수는 2개의 클래스로만 분류 가능 (비선형은 여러개 가능) |\n| 테스트가 빠름 | 데이터가 선형적으로 분류가 안될 수 있음 |\n\n---\n\n## Bag of Features\n\nClassifiers와 마찬가지로 특징점을 사용한다.\n\n![231203-135123](/posts/final_06/231203-135123.png)\n\n하지만, 이 방식은 특징점들의 분포를 분석하여 객체를 파악한다는 특징에서 위 방식과 다르게 동작한다.\n\nBag of Features는 아래와 같은 단계로 객체를 분류한다.\n\n1. 영상의 특징 추출\n\n    영상의 특징을 추출하는 방법은 [**`Feature Detection`**](https://wjlee611.github.io/blog/univ_com-vision/final_03#sift-descriptor) 에서 설명한 방식대로 추출한다.\n    여기선 영상의 특징을 128개로 추출했다고 가정하자.\n\n2. 특징을 이용한 학습\n\n    이제 특징을 이용해서 학습을 진행시켜야 하는데, 학습은 아래와 같은 단계를 거치게 된다.\n\n    ![231203-135732](/posts/final_06/231203-135732.png)\n\n    비슷한 특징점들은 비슷한 descriptor를 갖고있다.\n    그렇기에 128차원 공간에서 비슷한 위치에 위치하게 될 것이다.\n\n    특징점들의 위치를 모두 저장하고, 이를 클러스터링하여 클러스터의 중앙값을 대푯값으로 지정하면 학습이 완료된다.\n    (K-means clustering 방법을 사용하면 된다.)\n\n    ![231203-140110](/posts/final_06/231203-140110.png)\n\n3. 영상 분류\n\n    이제 새로 들어온 영상에 대해 특징점을 추출하고, 이를 학습된 분류기에 넣으면 특징들에 대한 분포 히스토그램이 나오게 된다.\n\n    ![231203-140319](/posts/final_06/231203-140319.png)\n\n    물론, 어떤 히스토그램 분포가 어떤 객체인지 분류하기 위해서는 그 분포 경향 역시 학습을 통한 분류기를 만들어야 한다.\n\n하지만, Bag of Features 방식에는 큰 문제점이 하나 있는게, 영상을 분해한 특징들로만 객체를 파악하기 때문에, 위치와 무관하게 영상을 분류하게 된다.\n만약, 위치도 파악하여 영상을 분류해야 한다면, Spatial Pyramids 방식을 사용하면 된다.\n간단하게 말해서 영상을 쪼개서 분할된 영상에 대해 각각 Bag of Features 방식을 적용하는 방법이다.","slug":"univ_com-vision/final_06","readingMinutes":6,"wordCount":418},{"title":"Segmentation","description":"영상을 잘게 구역화(분할)하는 방법을 알아봅니다.","icon":"","image":"","tags":["Segmentation","Thresholding","Otsu's Method","K-means Clustering","Mean Shift Clustering"],"draft":false,"date":"2023-12-02 / 13:09","content":"\n## Thresholding\n\n에너지 레벨을 thresholding 하는 방식으로 segmentation하는 기법입니다.\n영역별로 threshold를 다르게 적용하는 방식도 있지만, 이번엔 전체적으로 같은 threshold 기준을 적용하는 방법을 알아볼 예정입니다.\n\n![231202-151956](/posts/final_05/231202-151956.png)\n\n영상의 에너지레벨들을 을 잘 분할할 수 있는 에너지레벨을 기준으로 threshold를 하면 segmentation이 가능합니다.\n그 방법은 아래와 같은 순서로 진행됩니다.\n\n1. 임의로 분할할 에너지레벨 T를 잡음.\n2. T를 기준으로 두 영역을 나눔 (between-class variance 관점).\n3. 각 영역의 평균을 계산함.\n4. 평균의 가운데 값으로 T를 이동.\n5. 2~4의 과정을 반복해 T가 특정 위치로 수렴하게 함.\n\n위 방식을 거치면 단순한 영상에 대한 경우에는 segmentation이 가능합니다.\n\n하지만, 약간의 노이즈가 끼거나 그림자가 지는 경우에는 정확하게 segmentation할 수 없을 뿐더러,\n단순한 영상이라 하더라도, 초기에 T를 잘 못 설정하면 동작하지 않는다는 한계가 있습니다.\n\n이를 해결하기 위한 몇 가지 방법들을 소개합니다.\n\n### Otsu's Method\n\nbetween-class variance 관점에서는 가장 최적해를 도출해주는 방식으로 알려져있으며, 수식은 다음과 같습니다.\n\n$$\n\\sigma _B^2 = P_1(m_1-m_G)^2 + P_2(m_2-m_G)^2\n$$\n\n$m_G$는 영상 전체의 평균이고, $m_i$는 threshold에 대한 class i에 대한 평균입니다 (위의 3번에 해당).\n$P_i$는 threshold에 대한 class i의 확률로서, 위 식은 에러를 계산할 때 크기를 반영해서 계산한다는 의미입니다.\n\n![231202-153042](/posts/final_05/231202-153042.png)\n\n즉, 영상에서 threshold할 때 큰 객체 뿐만 아니라, 작은 객체역시 threshold 가능합니다.\n\n### Smoothing\n\n노이즈가 있는 영상에 대한 thresholding을 해야할 때 적용해볼 수 있는 방법입니다.\n\n![231202-153204](/posts/final_05/231202-153204.png)\n\nsmoothing을 적용하면 threshold가 가능한 수준으로 히스토그램이 변할 수 있습니다.\n하지만, 디테일은 약간 뭉게진다는 한계는 있습니다.\n\n### Edge\n\n노이즈도 있고, 매우 작은 영역을 검출해야 하는 경우에는 위의 두 방식 역시 제대로 동작하지 않을 수 있습니다.\n그럴 때 시도할 수 있는 방법으로 edge를 이용해서 시도하는 방법입니다.\n\n![231202-153519](/posts/final_05/231202-153519.png)\n\n노이즈가 있는 영상에 대해 gradient를 구하고, threshold(99.7%)를 하여 우상단의 영상을 얻습니다.\n이후 원본과 곱연산을 하여 좌하단의 영상을 구하고, 해당 영상에 대해 threshold를 하면 segmentation이 가능합니다.\n\n\u003ctip\u003e\n  지금부터 알아보는 내용에는 정형화된 방식이 없습니다.\n  상황에 맞는 방식을 사용하는 것이 좋습니다.\n  \u003cbr /\u003e\n  예로 들어, 노이즈가 많다? \u0026rarr; smoothing을 해볼까?\n  세밀한 특징을 찾아야 한다? \u0026rarr; edge를 구해볼까? 하는 식으로 말이죠.\n\u003c/tip\u003e\n\n---\n\n## K-means clustering\n\nK-means 군집화 방법은 빅데이터, 인공지능 자료에서도 언급한 바가 있으니, 이론적인 내용은 생략하고, 바로 영상에 적용하는 방법에 대해 알아보겠습니다.\n\n1. 영상을 feature space로 변형한다.\n2. feature space 상에서 k-means clustering을 수행한다.\n3. 군집화 결과를 본래 영상공간으로 변형한다.\n\n즉, feature space를 어떻게 설계하느냐에 따라 segmentation 되는 방식이 달라지게 됩니다.\n우선 간단한 예시로 intensity(에너지 레벨)를 feature space로 사용해 봅시다.\n\n![231202-154403](/posts/final_05/231202-154403.png)\n\n만약, feature space를 RGB값으로 사용한다면? 위와 다른 결과가 나올 것입니다.\n\n하지만, 색상, 에너지레벨만을 이용하는 feature space를 사용하는 경우 문제가 있습니다.\n바로, 물리적인 공간이 떨어진 곳도 같은 cluster(segmentation)으로 분류가 된다는 점입니다.\n\n이를 해결하려먼 feature space를 만들 때 intensity + position(x, y)도 함께 묶어 만들어주면, 위치가 크게 떨어져 있으면 다른 cluster로 묶이게 만들 수 있습니다.\n\n![231202-154837](/posts/final_05/231202-154837.png)\n\n그럼에도 불구하고, 위 방식 만으로는 위의 영상을 segmentation 할 수는 없을 것입니다. (사람이 하라해도 힘들 듯...)\n\n이를 개선하기 위해 질감(texture)을 사용하여 feature space를 구성하는 방식을 사용해볼 수 있을 것입니다.\n\n\u003ctip\u003e\n  `질감(texture)?`\n  \u003cbr /\u003e\n  일종의 패턴으로, 특정 모양의 필터는 특정 모양의 패턴에만 반응하는 것을 이용합니다.\n  즉, 필터에 대한 반응성의 정도를 질감이라고 생각하면 될 거 같습니다.\n\u003c/tip\u003e\n\n![231202-155131](/posts/final_05/231202-155131.png)\n\n예로 들어 위의 24종의 필터에 대한 반응도를 이용해 feature space를 만든다면, feature space는 24차원으로 구성될 것이며, 비슷한 질감인 부분은 비슷한 feature space 영역에 위치하게 되고,\n결국, 비슷한 질감은 같은 cluseter로 군집화 될 것입니다.\n\nk-means 방식은 간단하며, 빠르게 계산할 수 있고, feature space를 잘만 설계한다면 아주 잘 동작한 알고리즘처럼 보이지만, k-means 방법 역시 한계가 존재합니다.\n\n- k를 얼마로 설정해야 하는지 모른다.\n- 초기값에 민감함.\n- outlier에 민감함.\n\n    ![231202-155927](/posts/final_05/231202-155927.png)\n\n- 클러스터를 원형으로만 생성할 수 있음.\n\n    ![231202-155938](/posts/final_05/231202-155938.png)\n\n- 평균을 계산할 수 있다는 전제가 필요함.\n\n\n---\n\n## Mean shift clustering\n\n이 방식은 Mean shift algorithm을 이용하여 clustering 하는 방법으로, mean shift algorithm은 feature space에서 밀집도가 높은 부분을 찾는 알고리즘 입니다.\n\n![231202-160412](/posts/final_05/231202-160412.png)\n\n1. 초기점을 하나 랜덤으로 설정하고, 탐색 윈도우 W의 크기를 적절히 세팅한다.\n2. W의 무게중심을 계산한다.\n3. W를 무게중심으로 이동시킨다.\n4. W가 움직이지 않을 때까지 반복한다.\n\n![231202-160348](/posts/final_05/231202-160348.png)\n\n간단하게 이해해보자면, 각 feature space의 점들이 밀집도가 높아지는 방향으로 흘러가고, 한 점에서 모이는 점들은 같은 cluster로 분류됩니다.\n이러한 특성 때문에 k-means의 한계를 극복할 수 있습니다.\n\n![231202-160450](/posts/final_05/231202-160450.png)\n\n정리하면, k-means는 거리 중심으로 segmentation 했는 반변,\nmean shift는 무게 중심이 어디로 이동하지는지를 중심으로 segmentation 을 수행합니다.\n\nmean shift 방식은 아래와 같은 장점이 있습니다.\n\n- 일반적으로 여러 분야에서 사용 가능.\n- 모델*이 필요없다. 즉, 어떠한 형태도 잘 클러스터링이 된다.\n    *모델: 얼굴을 잘 감지하는 모델, 타원을 잘 감지하는 모델 등등...\n- 파라미터가 1개(W 크기)밖에 없기에 단순하며, 그 1개 마저도 정하기 쉽다.\n- outlier에 대해서도 잘 동작한다.\n\n물론 W 크기에 종속적으로 동작한다는 단점이 있습니다.","slug":"univ_com-vision/final_05","readingMinutes":10,"wordCount":703},{"title":"Image Transform and RANSAC","description":"영상을 변환하는 방법을 알아봅니다.","icon":"","image":"","tags":["Image Transform","RANSAC"],"draft":false,"date":"2023-12-02 / 12:21","content":"\n영상을 변환하는 방법은 [**`가상세계 - Matrix and Transformations`**](https://wjlee611.github.io/blog/univ_virtual-worlds/mid_04#2d-linear-transformations)에서 소개했었습니다.\n이제 영상이 주어졌을 때 어떻게 위 변환식을 도출하는지에 대한 과정을 살펴보겠습니다.\n\n## Transformation Fitting\n\n![231202-122618](/posts/final_04/231202-122618.png)\n\n영상이 위와 같이 변환된다고 가정해봅시다.\n이 때 위의 식에서 하나의 특징점은 아래와 같은 식을 통해 변환된다고 할 수 있습니다.\n\n$$\n\\begin{bmatrix}\nx_i' \\\\\ny_i'\n\\end{bmatrix} = \\begin{bmatrix}\nm_1 \u0026 m_2 \\\\\nm_3 \u0026 m_4\n\\end{bmatrix} \\begin{bmatrix}\nx_i \\\\\ny_i\n\\end{bmatrix} + \\begin{bmatrix}\nt_1 \\\\\nt_2\n\\end{bmatrix}\n$$\n\n식은 2개, 모르는 미지수는 6개.\n즉, 3개의 점에 대한 변환식을 구하면 6개의 미지수($m_i$, $t_1$, $t_2$)를 모두 구할 수 있습니다.\n\n여기서 위 식을 아래와 같이 변환할 수 있는데요,\n\n$$\n\\begin{bmatrix}\n\u0026 \u0026 ... \\\\\nx_i \u0026 y_i \u0026 0 \u0026 0 \u0026 1 \u0026 0 \\\\\n0 \u0026 0 \u0026 x_i \u0026 y_i \u0026 0 \u0026 1 \\\\\n\u0026 \u0026 ...\n\\end{bmatrix} \n\\begin{bmatrix}\nm_1 \\\\\nm_2 \\\\\nm_3 \\\\\nm_4 \\\\\nt_1 \\\\\nt_2\n\\end{bmatrix} = \\begin{bmatrix}\n... \\\\\nx_i' \\\\\ny_i' \\\\\n...\n\\end{bmatrix}\n$$\n\n특징점 변환식 하나 당 `...` 부분에 식이 들어갑니다.\n위 식을 $MP = X$ 라고 합시다.\n그렇다면, 특징점이 5개라면 식이 10개가 만들어져 $M$은 10by6 행렬이 만들어지는 것이죠.\n\n참고로, 최소 3개가 필요한 것이고, 더 많은 특징점을 사용한다면 $P$에 대한 오차를 선형대수학을 이용하여 줄일 수 있습니다.\n\n이제 양변에 $M^{-1}$를 취해준다면, $P = M^{-1}X$를 사용하여 미지수 6개를 얻을 수 있습니다.\n\n---\n\n## RANSAC\n\n위의 선형대수학 방식을 이용하여 특징점이 변환되는 pair를 선으로 연결하여 시각화 하면 아래와 같은 모습을 보입니다.\n\n![231202-124547](/posts/final_04/231202-124547.png)\n\n대부분은 맞지만, 몇몇 outlier가 있습니다.\n이런 outlier 때문에 선형 변환 P에 오차가 생기기 마련인데요, RANSAC은 이런 outlier를 빼고 예측할 수 있는 방법을 제공합니다.\n\nRANSAC은 아래의 방식을 통해 outlier의 영항을 제거하고, inlier로만 예측하도록 도와줍니다.\n\n1. 랜덤으로 특징점을 선택한다.\n    운이 좋다면 피팅이 잘 될 것이고, 운이 좋지 않다면 잘 안될 것이다.\n\n    참고로, 좋은 피팅의 경우에는 랜덤 선택되지 않은 특징점에 대해서도 에러가 작을 것이고, outlier에 대해서만 에러가 클 것이다.\n\n    ![231202-125407](/posts/final_04/231202-125407.png)\n\n2. 렌담으로 선택된 특징점을 이용해서 Transformation을 구한다.\n\n    ![231202-125425](/posts/final_04/231202-125425.png)\n\n3. 구한 Transform(P)에 대해서 에러를 계산하여 inlier를 찾아본다.\n\n    ![231202-125458](/posts/final_04/231202-125458.png)\n\n4. inlier의 개수가 충분히 크다면 그 inlier를 이용해서 더 정밀한 Transformation을 구한다.\n\n    ![231202-125538](/posts/final_04/231202-125538.png)\n\n5. 1~3 과정을 반복하며 가장 큰 inlier를 찾도록 개수를 추적한다.\n\n    ![231202-125553](/posts/final_04/231202-125553.png)\n\n    ![231202-125604](/posts/final_04/231202-125604.png)\n\n    ![231202-125613](/posts/final_04/231202-125613.png)\n\n단, 이런 알고리즘의 특성 덕분에 대부분의 데이터가 inlier로 존재하고, 일부 데이터만이 outlier로 존재하는 경우에만 잘 동작합니다.\n\n### calculate trial counts\n그렇다면 유효한 fitting을 하기위해 얼마나 많은 비교 연산(시도)을 해야할까?\n\np를 inlier의 비율이라 하고, s를 시도횟수라고 하자.\n\n이 때, 특징점 k개를 모두 inlier에서만 선택할 확률은 $p^k$이다.\n즉, 특징점에 outlier가 포함되는 확률은 $1 - p^k$이다.\n\n이 때, fitting을 하기위해 s번 시도를 하는데, s번 동안 모두 outlier가 포함되어 피팅이 되는 확률은 $(1 - p^k)^s$ 이며, 이 확률은 RANSAC이 실패하여 피팅에 실패할 확률을 의미한다.\n\n따라서 P가 피팅에 성공할 확률이라 한다면 1-P는 피팅에 실패할 확률이란 뜻이고, 아래와 같은 관계식이 도출된다.\n\n$$\n1-P = (1 - p^k)^s\n$$\n\n$$\ns = log(1-P) / log(1-p^k)\n$$\n\n예로 들어 90%가 inlier이고(p=0.9), 특징점 샘플의 수는 50개(k=50) 이며, 99.9% 확률로 피팅에 성공(P=0.999)해야 한다고 했을 때,\n\n$$\ns = log(1-0.999) / log(1-0.9^{50}) \\approx 1337\n$$\n\n즉, 약 1300번 정도의 시도를 해야 99.9% 확률로 피팅에 성공할 수 있다는 뜻이다.","slug":"univ_com-vision/final_04","readingMinutes":6,"wordCount":489},{"title":"Feature Detection and Matching","description":"영상에서 특징점을 찾고 매칭하는 법을 알아봅니다.","icon":"","image":"","tags":["Feature point","Harris Corner","Scale Invairant Keypoint Detection","Bloc detection","SIFT descriptor"],"draft":false,"date":"2023-11-27 / 22:21","content":"\n영상에서 특징점을 찾고 이를 매칭하는 방식에 대한 기본적인 아이디어는 다음과 같습니다.\n\n1. 흥미로운 포인트를 찾는다.\n2. 흥미로운 포인트를 설명하기 위한 벡터를 추출한다.\n3. 흥미로운 포인트를 정보 벡터를 이용해서 매칭한다.\n\n이번 포스트에선 그 흥미로운 포인트를 찾는 방식(아이디어)와 정보 벡터를 구하는 방식을 알아보겠습니다.\n\n## Feature Point\n\n특징점을 찾을 때 중요한 요소가 있습니다.\n\n- 같은 특징은 다수의 영상에서 반복적으로 발견되어야 한다.\n    영상A와 영상B의 특징점이 다르게 추출되면 매칭이 성립되지 않기 때문입니다.\n    또한, 영상의 이동, 회전, 스케일링, 시점에 따른 왜곡, 빛의 변화, 노이즈가 있어도 동일한 특징점을 찾도록 하는게 좋습니다.\n\n- 특징점은 구분되는 설명(description)이 있어야 한다. (위의 벡터)\n- 정말 좋은 특징점 일부만 추출해야 하고, 찾는 과정이 효율적이어야 한다.\n- 특징점이 가능한 작은 영역에서만 존재해야 한다.\n    영상A에서 발견된 특징점(예로 얼굴을 구분하는 특징점들)이 영상B에서는 발견되지 않을 수 있기에 넓게잡지 않고 좁게 잡는것이 좋습니다.\n\n이를 염두에 둔 특징점을 찾는 알고리즘에 대해 알아보겠습니다.\n\n---\n\n## Harris Corner\n\nHarris Corner 방식은 꼭짓점을 특징점으로서 찾는 방법입니다.\n\n![231127-223020](/posts/final_03/231127-223020.png)\n\n꼭짓점임을 알 수 있는 방법은 영상에서의 특정 방향에 대한 변화량을 측정하면 됩니다.\n\n꼭짓점도, 모서리도 아닌 평탄한 부분에서의 x, y 축에 대한 변화량은 작거나 0에 가깝습니다.\n반면에 모서리에 해당하는 부분은 x 또는 y 축 둘 중 하나에 대한 변화량만 큽니다.\n\n이것과 대조되게 꼭짓점에 해장하는 부분은 x, y 모든 축에대한 변화량이 클 것입니다.\n변화량을 측정하는 함수식은 아래와 같습니다.\n\n$$\nE(u,v) = \\sum_{{x,y}}^{} W(x,y)[{I(x+u, y+v) - I(x,y)}]^2\n$$\n\n여기서 W는 탐색하는 윈도우 함수이고, I는 해당 좌표의 에너지 레벨입니다.\n이 때, $(u,v)$는 W가 이동하는 방향 벡터입니다.\n즉, $(u,v)$가 90$^{\\circ}$ 라면 이상적인 결과가 나올 것입니다.\n\n위 식을 테일러 급수로 근사하면 아래와 같은 식이 도출됩니다.\n\n$$\nE(u,v) \\approx [u \\; v] M \\begin{bmatrix}\nu \\\\\nv\n\\end{bmatrix}\n$$\n\n여기서 M은 아래와 같습니다.\n\n$$\nM = \\sum_{{x,y}}^{} W(x,y) \\begin{bmatrix}\nI_x^2 \u0026 I_xI_y \\\\\nI_xI_y \u0026 I_y^2\n\\end{bmatrix}\n= \\begin{bmatrix}\n\\lambda_1 \u0026 0 \\\\\n0 \u0026 \\lambda_2\n\\end{bmatrix}\n$$\n\n여기서 $\\lambda_1$, $\\lambda_2$는 각각 x, y축 방향으로의 gradient 크기를 의미합니다.\n\n즉, $\\lambda_1$, $\\lambda_2$의 크기 비교를 통해 Window가 가리키는 부분을 구분할 수 있습니다.\n\n| flat | edge | corner |\n|---|---|---|\n| $\\lambda_1 \\approx \\lambda_2$ | $\\lambda_1 \u003e\u003e \\lambda_2$ | $\\lambda_1 \\approx \\lambda_2$ |\n| $\\lambda_1$, $\\lambda_2$: small | $\\lambda_1 \u003c\u003c \\lambda_2$ | $\\lambda_1$, $\\lambda_2$: large |\n\n그렇다면, 얼마나 커야 corner로 판단할 수 있을까요?\n\n답은 설계하기 나름입니다.\n하지만 나름 설계하는 기준은 있습니다.\n\n![231207-234701](/posts/final_03/231207-234701.png)\n\nedge-corner는 아래와 같은 기준으로 판단할 수 있습니다.\n\n$$\n\\theta = det(M) - \\alpha trace(M)^2 = \\lambda_1 \\lambda_2 - \\alpha(\\lambda_1 + \\lambda_2)^2\n$$\n\n즉, 도심같이 복잡해서 아주 큰 특징들만 검출할 필요가 있는 경우에는 $\\alpha$를 크게 두어 크다고 판단하는 threshold를 높입니다. (corner영역을 줄임)\n반대로, 사막과 같이 미세한 특징도 검출할 필요가 있는 경우에는 $\\alpha$를 작게 두어 크다고 판단하는 threshold를 낮춥니다. (corner영역을 늘림)\n한마디로 $\\alpha$가 커질수록 특징점의 개수가 줄어듧니다.\n\nflat-corner는 $\\lambda$의 threshold 크기로 판단합니다.\n한마디로 threshold가 커질수록 특징점의 개수가 줄어듧니다.\n\n마지막으로 Harris corner(이하 HC)의 특징을 알아봅시다.\n\nHC는 rotation, transition invariant 합니다.\n즉, 영상을 회전시키거나 평행이동 시켜도 동일한 특징점을 찾아낼 수 있습니다.\n\n하지만, scale invariant 하지는 않습니다.\n![231127-230442](/posts/final_03/231127-230442.png)\n\n---\n\n## Scale Invariant Keypoint Detection\n\nHC의 개선판으로 Window의 크기(patch size)도 찾아내어 scale invariant하게 특징점을 찾는 방법입니다.\n\n![231127_231400](/posts/final_03/231127_231400.gif)\n\n위 영상은 Window 사이즈에 따른 특정 지점에서의 코너성을 함수로 표현한 것입니다.\n그렇가면, 좋은 함수란 무엇을까요?\n\n![231127-231710](/posts/final_03/231127-231710.png)\n\n좋은 함수는 코너성이 최고로 나타나는 지점이 유일하게 결정되는 함수가 좋은 함수라고 판단합니다.\n그렇다면 좋은 함수의 예시는 무엇이 있을까요?\n\n### Blob detection in 2D\n\n2D 가우시안의 라플라시안으로, 특정 크기의 원형 영상에만 반응하는 필터입니다.\n\n![231127-232134](/posts/final_03/231127-232134.png)\n\n어떤식으로 반응하는지는 아래의 영상을 보며 이해해봅시다.\n\n![231127_232600](/posts/final_03/231127_232600.gif)\n\n여기서 중요한 2가지 특징이 있습니다.\n\n1. 필터 크기에 맞는 원형 영상에 대해서만 반응을 한다.\n2. scale invariant 하게 반응한다.\n\n즉, 특정 픽셀에서 반응값이 클 때의 $\\sigma$값을 참고해서 Window 사이즈를 결정하면 Scale Invariant Keypoint Detection 를 구현할 수 있습니다.\n\n참고로 위 영상은 해바라기라서 잘 되는 것이 아닌가? 원형 영상이 없으면 못 감지하는게 아닌가 하실 수 있겠습니다.\n하지만, 극단적으로 원형이 아닌 영상이 아니고서야 여러 $\\sigma$에 해당하는 Blob 필터가 동시에 반응하는 형식으로 잘 반응합니다.\n(예시 영상이 있지만, 혐오스러울 수 있기에 올리진 않겠습니다)\n\n---\n\n## SIFT Descriptor\n\n지금까지 특징점을 찾는 방법을 알아보았다면, 이제는 특징점을 설명하는 방법을 알아봅시다.\n\nScale Invariant Feature Transform Descriptor는 픽셀별로 그레디언트(방향)을 구하고, 이를 히스토그램으로 정리한 뒤 벡터로 관리하여 정보를 담는 방식입니다.\n\n![231127-233809](/posts/final_03/231127-233809.png)\n\n예로 들어 특징점 주변의 16셀에 대한 방향을 8개의 벡터로 표현한다면, 각 특징점마다 16*8 = 128길이의 Descriptor가 생성될 것입니다.\n\n이 특징은 scale, rotation invariant 하기에 정보로서 이용 가치가 있습니다.\n\n---\n\n마지막으로 매칭은 어떻게 할까요?\n... 무식하게 모든 조합에 대해 특징점과 그 descriptor를 비교하면 됩니다.","slug":"univ_com-vision/final_03","readingMinutes":9,"wordCount":691},{"title":"Edge Detection","description":"영상에서 경계를 검출하는 방법을 알아봅니다.","icon":"","image":"","tags":["Edge Detector","Canny edge detector","Hough transform"],"draft":false,"date":"2023-11-25 / 17:05","content":"\n## Edge Detector\n\n이전에 [**`라플라시안 커널`**](https://wjlee611.github.io/blog/univ_com-vision/mid_05#laplacian) 에서 다뤘던 내용의 연장입니다.\n\n![231125-171834](/posts/final_02/231125-171834.png)\n\n값은 상관없지만, 방향성이 있어야 하며, 합이 0인 커널을 구현하면 해당 방향으로의 line edge를 검출할 수 있습니다.\n\n![231125-172028](/posts/final_02/231125-172028.png)\n\n하지만, 위 영상 I 처럼 극명하게 경계가 정해지는 영상은 드뭅니다.\n대부분의 영상은 아래의 가운데 영상처럼 경계가 명확하게 구분되는 편은 아닙니다.\n\n![231125-172325](/posts/final_02/231125-172325.png)\n\n따라서 이런 경우까지 고려하기 위해 2중 미분을 통해 edge를 검출하는 것이 좋습니다.\n\n![231125-172357](/posts/final_02/231125-172357.png)\n\n하지만, 영상에 노이즈가 낀 경우에는 2중 미분을 한다고 해서 edge를 검출할 수 없습니다.\n\n![231125-173158](/posts/final_02/231125-173158.png)\n\n따라서 우선 미분을 하기 전에 smoothing filter를 적용해서 노이즈를 줄인 후 edge를 검출하면 검출 성능이 올라갈 수 있습니다.\n\n물론, smoothing filter를 적용하면 경계 역시 블러될 수 있습니다.\n그럼에도 불구하고, 경계는 찾을 수 있습니다.\n\n![231125-173502](/posts/final_02/231125-173502.png)\n\n참고로 미분 역시 컨볼루전으로 간단하게 처리될 수 있기 때문에 아래와 같이 연산 과정을 간략하게 할 수 있습니다.\n(e.g. \\[1, 0\\]을 컨볼루전 하면 미분된 효과를 얻을 수 있습니다.)\n\n![231125-173638](/posts/final_02/231125-173638.png)\n\n이런식으로 경계를 강조한 뒤에 threshold를 하면 edge를 검출할 수 있습니다.\n\n---\n\n## Canny edge detector\n\nCanny edge detector은 위에서 살펴본 기본적인 edge 검출 방식을 개선시킨 방식입니다.\n\n| Edge detector | Canny edge detector |\n|---|---|\n| 1. smoothing filter (가우시안의 미분) 적용 | 1. smoothing filter (가우시안의 미분) 적용 |\n| 2. gradient의 크기만 구함 | 2. gradient의 크기와 뱡향을 구함 |\n| | 3. Non-maximum suppression |\n| | 4. Hysteresis thresholding |\n\n1, 2번 까지 진행하고 threshold 하는 경우에는 차이가 없습니다.\n하지만 3, 4 번의 과정을 추가로 진행하여 더 나은 edge를 검출할 수 있습니다.\n\n### Non-maximum suppression\n\n![231125-181229](/posts/final_02/231125-181229.png)\n\n기존의 방식대로 검출할 경우 gradient의 크기만을 구하기 때문에 검출하는 edge의 두께가 두꺼워지는 문제가 발생합니다.\n\n![231125-181445](/posts/final_02/231125-181445.png)\n\n하지만, Canny 방식은 방향 역시 구하기 때문에 선의 두께를 얇게 만들어주면서 edge를 결정할 수 있습니다.\n\n![231125-182005](/posts/final_02/231125-182005.png)\n\n그러나, 여전히 약한 edge가 존재하는 문제가 있습니다.\n\n### Hysteresis thresholding\n\n약한 edge는 주면의 edge와 linking 하는 방식으로 해결하게 됩니다.\n\n![231125-182203](/posts/final_02/231125-182203.png)\n\n그렇게 하기 위해 일단 Low, High threshold를 우선 정합니다.\n이후에 threshold시 아래와 같은 판단을 거쳐 edge를 확정합니다.\n\n- threshold 값이 Low 보다 낮다?\n  edge가 아님.\n\n- threshold 값이 high 보다 크다?\n  edge임.\n\n- threshold 값이 Low, High 사이이다?\n  약한 edge임. 따라서 양 쪽에 edge가 있을 경우에만 edge로 판단.\n\n이렇게 진행된 Canny 방식은 확실히 이전보다 나은 성능을 보입니다.\n\n![231125-182457](/posts/final_02/231125-182457.png)\n\n참고로, 처음의 가우시안 필터의 세기를 크게 한다면 강한 에지만 살아남게 됩니다.\n\n---\n\n## Hough transform\n\nHough transform은 line detector 중 하나인데, 그 방식이 피팅(투표)하는 방식으로 좀 특이하다.\n\n![231125-210610](/posts/final_02/231125-210610.png)\n\n우선 영상에서 edge points를 찾아내고, 이후에는 무수히 많은 직선을 그었을 때,\n가장 많은 edge points를 지나는 직선이 선택되는 방식이다.\n\n이 때 드는 의문점이 있다.\n무수히 많은 직선을 긋는다는게 시간복잡도 상으로 간단하게 구현 가능한걸까?\n일반적인 방식으로 영상에 긋는 방식으로는 불가능 할것이다.\n하지만, 영상을 변환하는 과정을 거치면 가능해지는데, 그 방식을 살펴보자.\n\n### Hough space\n\n![231125-210859](/posts/final_02/231125-210859.png)\n\nHough space는 직선의 방정식의 파라미터를 축으로 하는 공간이다.\n따라서 영상 공간에서의 직선은 Hough 공간에서는 점으로 표시된다.\n\n![231125-211018](/posts/final_02/231125-211018.png)\n\n반대로 영상 공간에서의 점은?\n해당 점을 지나는 직선은 무수히 많을 것이다.\n따라서 그 무수히 많은 직선을 Hough 공간상에서 무수히 많은 점으로 찍으면 하나의 직선 형태로 표현될 것이다.\n\n![231125-211151](/posts/final_02/231125-211151.png)\n\n이를 응용해서 무수히 많은 점을 지나는 직선을 찾는 방식은 위 그림과 같다.\n\n영상 공간의 점은 Hough 공간에서 직선으로 표현되기 때문에,\nHough 공간에서의 교점은 영상 공간에서의 모든 점을 지나는 직선이 된다.\n\n하지만, Hough 공간을 확대해보면 실제로 한 점에서 만나는 경우는 드물기 때문에 약간의 근사를 해야하며 거기서 약간의 오차가 발생할 수 있다.\n\n![231125-211441](/posts/final_02/231125-211441.png)","slug":"univ_com-vision/final_02","readingMinutes":7,"wordCount":525},{"title":"Image Restoration","description":"훼손된 영상을 최대한 복원해보는 방식에 대해 알아봅니다.","icon":"","image":"","tags":["Image Restoration","Noise","Mean filter","Median filter","Inverse filter"],"draft":false,"date":"2023-11-25 / 15:07","content":"\n\u003cnotice\u003e\n  이미지 훼손은 아래와 같은 공식에 의해 이루어졌다는 가정하에 진행됩니다.\n  따라서 현실 세계의 훼손을 복원할 때는 제대로 동작하지 않습니다.\n\n  $$\n  g(x,y) = h(x,y) * f(x,y) + \\eta(x,y)\n  $$\n\n  $h$: 훼손 함수\n  $\\eta$: 노이즈\n  \u003cbr /\u003e\n  즉, 이미지를 복원시킨다는 것은 훼손된 영상 $g$에 대해 $h$ 와 $\\eta$를 알고 있을 때, 그 영향을 제거하는 방향으로 진행합니다.\n\u003c/notice\u003e\n\n## Noise Restoration\n\n우선 영상의 노이즈를 줄이는 방식을 알아보겠습니다.\n\n### Noise Model\n\n노이즈를 줄이기 위해서는 노이즈가 어떻게 생겼는지 분석할 필요가 있습니다.\n100%는 아니지만, 자연계에서 노이즈가 발생하는 방식은 여러 방식으로 모델링하여 추상화 할 수 있지만, 그 중에 대표적인 노이즈 모델에 대해서만 알아보겠습니다.\n\n1. `Gaussian Noise`\n\n    ![231125-152000](/posts/final_01/231125-152000.png)\n    ![231125-152908](/posts/final_01/231125-152908.png)\n\n    Gaussian Noise는 말 그대로 가우시안 분포를 따르는 노이즈 패턴으로 자연계에서 발견할 수 있는 형태를 갖습니다.\n\n2. `Uniform Noise`\n\n    ![231125-153500](/posts/final_01/231125-153500.png)\n    ![231125-153644](/posts/final_01/231125-153644.png)\n\n    Uniform Noise는 동일한 확률 분포로 노이즈 패턴을 갖는 형태입니다.\n\n2. `Impulse (Salt-and-Pepper) Noise`\n  \n    ![231125-154000](/posts/final_01/231125-154000.png)\n    $$\n    p(z) = \\left\\{\\begin{matrix}\n    P_a \\; for \\; z=a \\\\\n    P_b \\; for \\; z=b \\\\\n    0 \\; otherwise\\end{matrix}\\right. \n    $$\n\n    Salt-and-Pepper Noise는 일정 확률로 0 또는 255로 노이즈가 생기는 형태입니다.\n\n### Mean filter\n\nMean filter는 간단하게 말해서 기존에 많이 써왔던 smoothing filter와 동일합니다.\n직역하면 평균값 필터 입니다.\n\n$$\n\\hat{f}(x,y) = \\frac{1}{mn} \\sum_{(s,t)\\in S_{xy}}^{} g(s,t)\n$$\n\n즉, 전체적인 노이즈를 뿌옇게 만듦으로서 노이즈를 줄이는 것이기에 가우시안 노이즈에 효과적 입니다.\n하지만, 영상의 디테일이 뭉게진다는 한계가 존재합니다.\n\n### Median filter\n\nMedian filter는 간단하게 말하면 특정 윈도우 $S$ 내부의 값을 일렬로 정렬했을 때 가운데 값으로 대체하는 필터입니다.\n직역하면 중앙값 필터 입니다.\n\n$$\n\\hat{f}(x,y) = \\underset{(s,t)\\in S_{xy}}{median} \\{g(s,t)\\}\n$$\n\n즉, 0, 255와 같은 특이값을 중앙값으로 대체할 수 있기 때문에 Salt-and-Pepper 노이즈에 효과적 입니다.\n하지만, 특정 윈도우 영역에 노이즈가 우연히 많이 분포하게 될 경우 복원이 불가능 합니다.\n\n### Adaptive Mean filter\n\nAdaptive filter는 기존 필터와 다르게 영상의 특징을 반영하여 영역별로 다르게 필터링을 한다는 특징이 있습니다.\n\n$$\n\\hat{f}(x,y) = g(x,y) - \\frac{\\sigma_\\eta^2}{\\sigma_L^2} (g(x,y) - m_L)\n$$\n\n이 수식을 자세히 분석해봅시다.\n\n$\\sigma_\\eta^2$가 0 이라는 뜻은 노이즈의 분산이 0이라는 뜻입니다. 즉, 노이즈가 없다는 뜻입니다.\n이 때의 위 수식의 좌변은 $g(x,y)$만 남게 됩니다.\n즉, 노이즈가 없는 영상은 별 다른 변환 없이 통과하게 됩니다.\n\n$\\sigma_L^2$가 $\\sigma_\\eta^2$에 비해 매우 높은 경우는?\n노이즈의 분산에 비해 영상 자체의 분산이 매우 크다는 의미입니다.\n즉, 영상의 변화율이 크기 때문에 디테일을 살리기 위해 필터($m_L$)의 강도를 매우 약하게 설정해야 한다는 의미입니다.\n실제로 $\\sigma_\\eta^2$/$\\sigma_L^2$를 0.1과 같은 작은 값을 넣고 계산하면 필터의 영향력이 10%만 발휘된 변환 영상을 얻을 수 있습니다.\n\n$\\sigma_L^2$가 $\\sigma_\\eta^2$와 같은 경우는?\n노이즈의 분산이 원본영상 + 노이즈의 분산과 같다는 의미입니다.\n즉, 영상의 변화율이 없다는 의미이므로, 필터를 강하게 해서 디테일을 뭉게도 영향이 없는 상태입니다.\n실제로 $\\sigma_\\eta^2$/$\\sigma_L^2$에 1을 넣고 계산하면 100% 필터링된 변환 영상을 얻을 수 있습니다.\n\n이렇듯, 노이즈의 분산($\\sigma_\\eta^2$)과 원본영상 + 노이즈의 분산($\\sigma_L^2$)을 비교하여 필터($m_L$)링 강도를 결정하면, 디테일이 필요한 부분은 필터링을 약하게, 디테일이 필요없는 부분은 필터링을 강하게 하여 노이즈를 줄일 수 있습니다.\n\n### Adaptive Median filter\n\n이 경우엔 수식이 아닌, 일련의 명령어 집합으로 소개가 되어있기에 일단 소개하고 한 줄 한 줄 분석해보도록 하겠습니다.\n\n![231125-163400](/posts/final_01/231125-163400.png)\n\n`Line 1~3`\nmedian이 min, max가 아닌 값이 있다?\n\u0026rarr; 주변에 salt, pepper도 있고, 원본 영상도 섞여있다.\n\u0026rarr; B에서 후 처리.\n\n`Line 4~6`\nmedian이 min, max값 중 하나라면 해당 부분이 salt, pepper인지, 아니면 원본 영상 자체가 0, 255 값을 갖는건지 알 수 없다.\n\u0026rarr; 윈도우 사이즈($S_{xy}$)를 키워서 A 재시도.\n\n`Line 7~9`\n픽셀 값이 min, max가 아니다?\n\u0026rarr; 노이즈가 아니고 원본 값이다.\n\u0026rarr; 원본 영상 그대로 리턴.\n\n`Line 10`\n픽셀 값이 min, max값 중 하나라면 해당 부분은 salt, pepper 노이즈일 것.\n\u0026rarr; 중앙값 리턴.\n\n---\n\n## Degradation Restoration\n\n### Estimating the Degradation Function\n\n이제 노이즈는 어느정도 제거했다고 가정하고, 훼손 함수 $h$를 추정하는 법을 알아봅시다.\n추정만 해낼 수 있다면 이를 역으로 연산하는 과정을 통해서 제거할 수 있기 때문에 추정하는 대표적인 3가지 방식에 대해 알아봅시다.\n\n- Observation\n\n    부분의 H는 전체의 H와 같기 때문에 부분을 잘 선택하고, 노가다(?)를 통한 원본 영상을 만들어내어 그 변환과정(H)을 얻을 수 있다면, 전체 영상에 대한 복원이 가능해집니다.\n\n- Experimentation\n\n    impulse에 대한 H의 response를 보면 그 변환과정(H)을 얻을 수 있습니다.\n\n- Mathematical modeling\n\n### Inverse filter\n\n이제 찾아낸 훼손 함수 H를 기반으로 복원을 해봅시다.\n그 전에 앞서 가정했던 이미지 훼손 공식을 푸리에 변환한 식을 살펴봅시다.\n\n$$\nG(u,v) = F(u,v)H(u,v) + N(u,v)\n$$\n\n노이즈(N)는 앞에서 많이 줄였기에 없다고 가정했을 때 우리가 복원해야 하는 원본 영상 F는 다음과 같이 정의할 수 있습니다.\n\n$$\n\\hat{F}(u,v) = \\frac{G(u,v)}{H(u,v)} = F(u,v) + \\frac{N(u,v)}{H(u,v)}\n$$\n\n복원이 완벽하게 이뤄질 수는 없기에 $\\hat{F}$의 형태로 표현하였습니다.\n이 식에서 $\\frac{N(u,v)}{H(u,v)}$ 부분을 유심히 살펴봅시다.\n\n![231125-165953](/posts/final_01/231125-165953.png)\n\n보통 노이즈는 모든 주파수 구간에서 동일하게 일어납니다.\n하지만, 훼손은 보통 저주파수 영역에서 크게 일어나는 특징이 있습니다. (그렇다네요)\n\n따라서 고주파수 영역에서는 $\\frac{N(u,v)}{H(u,v)}$ 값이 매우 커지는,\n즉, 노이즈가 부스트되는 현상이 발생하게 됩니다.\n\n![231125-170139](/posts/final_01/231125-170139.png)\n\n따라서 훼손을 줄이는 과정에서 적당히 lowpass 를 해주는 것이 영상 품질을 높이는데 도움이 될 수 있습니다.","slug":"univ_com-vision/final_01","readingMinutes":9,"wordCount":740},{"title":"Factory Pattern","description":"Factory 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Factory Pattern","Abstract Factory Pattern"],"draft":false,"date":"2023-11-19 / 21:52","content":"\n## 필요성\n\n이번엔 피자가게로 예시를 들어보자.\n피자 가게에서 피자의 주문을 처리하기 위해서는 아래와 같은 형식으로 코드를 작성해야 할 것이다.\n\n```java:PizzaStore.java\npublic class PizzaStore {\n  ...\n  Pizza orderPizza(String tpye) {\n    Pizza pizza;\n\n    if (type.equals(\"cheese\")) {\n      pizza = new CheesePizza();\n    } else if (type.equals(\"greek\")) {\n      pizza = new GreekPizza();\n    }\n\n    pizza.prepare();\n    pizza.bake();\n    pizza.cut();\n    pizza.box();\n    return pizza;\n  }\n}\n```\n\n느낌만 보면 피자의 종류가 추가되거나 변경될 경우 orderPizza 메서드의 수정이 이루어져야 한다.\n예시가 적절하지 않은 느낌이 없지않아 있지만, orderPizza의 직접적인 수정이 부담스러울 수 있다.\n그 이유는 객체의 생성과 반복되는 메서드 호출 부분이 같은 함수 내에 위치하고 있기 때문이다.\n\n따라서 피자의 생성부(constructor)를 별도의 factory로 관리하는 기법에 대해 알아보자.\n\n## Factory Pattern\n\n이제 객체의 생성부를 factory로 캡슐화를 해보자.\n\n```java:PizzaFactory.java\npublic class PizzaFactory {\n  public Pizza createPizza(String type) {\n    Pizza pizza;\n\n    if (type.equals(\"cheese\")) {\n      pizza = new CheesePizza();\n    } else if (type.equals(\"greek\")) {\n      pizza = new GreekPizza();\n    }\n\n    return pizza;\n  }\n}\n```\n\n이제 이를 위의 피자가게에 적용한다면 코드는 다음과 같이 수정된다.\n\n```diff-java:PizzaStore.java\n  public class PizzaStore {\n+   PizzaFactory factory;\n\n    public PizzaStore(Pizzafactory factory) {\n+     this.factory = factory;\n    }\n\n    public Pizza orderPizza(String type) {\n      Pizza pizza;\n\n+     pizza = factory.createPizza(type);\n-     if (type.equals(\"cheese\")) {\n-       pizza = new CheesePizza();\n-     } else if (type.equals(\"greek\")) {\n-       pizza = new GreekPizza();\n-     }\n\n      pizza.prepare();\n      pizza.bake();\n      pizza.cut();\n      pizza.box();\n      return pizza;\n    }\n  }\n```\n\n이제 코드가 객체의 생성부와 반복되는 메서드의 호출 부분이 분리가 되었다.\n따라서 피자의 종류를 추가하거나 변경할 때에는 PizzaStore의 코드를 수정해야할 필요가 없어졌다.\n\n이렇게 하면 또 장점이 PizzaFactory를 교체하는 것 만으로도 생성할 수 있는 객체의 종류를 런타임에 다르게 결정할 수도 있다.\n\nfactory 패턴을 이렇게 외부 클래스로 구현할 수도 있지만, 내부의 메서드 형식으로도 구현할 수 있다.\n아래 코드를 살펴보자.\n\n```java:PizzaStore.java {11}\npublic abstract class PizzaStore {\n  public Pizza orderPizza(String type) {\n    Pizza pizza;\n\n    pizza = createPizza(type);\n\n    ...\n    return pizza;\n  }\n\n  abstract Pizza createPizza(String type);\n}\n```\n\n위에서는 PizzaFactory를 교체하는 방식으로 생성하는 객체를 다르게 할 수 있었다.\n이제는 이 abstract class를 구현하는 방식으로 생성하는 객체를 다르게 할 수 있다.\n\n```java:NYPizzaStore.java\npublic class NYPizzaStore extends PizzaStore {\n  Pizza createPizza(String type) {\n    if (type.equals(\"cheese\")) {\n      return new NYStyleCheesePizza();\n    } else if (type.equals(\"greek\")) {\n      new NYStyleGreekPizza();\n    }\n    return null;\n  }\n}\n```\n\n참고로 모든 blahPizza는 Pizza 클래스를 상속받는 식으로 구현해야 하고, Pizza 클래스는 abstract로 만들어서 인스턴스로 만들 수 없게 해야한다.\n\n![231125-111929](/posts/final_04/231125-111929.png)\n\n정리하자면, Factory pattern은 객체를 생성하는 인터페이스(createPizza)를 정의할 때\n어떤 클래스(blahPizza)를 만들어야 하는지는 상위 클래스(PizzaStore)가 결정하는 것이 아닌,\n하위 클래스(NYPizzaStore)에게 일임하는 방식의 디자인 패턴을 의미한다.\n\n\u003ctip\u003e\n  참고로 위의 코드는 종속 역전 원칙을 준수한 코드인데, 이게 뭐냐하면\n  가능하면 추상 클래스에 대해 종속성을 갖고, 구현 클래스에 대해서는 종속성을 피해야 한다는 디자인 원칙이다.\n  \u003cbr /\u003e\n  즉, PizzaStore에서는 객체를 CheesePizza, GreekPizza 로 관리하는 것이 아닌, 오직 Pizza 인터페이스로만 관리하는 것이 좋다.\n\u003c/tip\u003e\n\n---\n\n## Abstract Factory Pattern\n\n그렇다면 NYPizza와 ChicagoPizza 모두 같은 종류의 피자를 판매한다면?\n사실살 들어가는 재료가 다를 뿐, 모두 CheesePizza, PepperoniPizza 등 같은 종류의 파지를 판매할 뿐인데,\n각각 다른 종류의 피자 클래스로 구현해야 한다는 문제점이 생길 것이다.\n\n생각해보면, 각 피자는 제조 방식은 같지만, 들어가는 재료가 다를 뿐이다.\n따라서 재료의 생성도 factory pattern으로 만든다면?\n\n```java:PizzaIngredientFactory.java\npublic interface PizzaIngredientFactory {\n  public Dough createDough();\n  public Sauce createSauce();\n  public Cheese createCheese();\n  public Veggies[] createVeggies();\n  public Pepperoni createPepperoni();\n  public Clame createClame();\n}\n```\n\n우선 각 지역의 피자에 들어갈 재료를 factory pattern으로 만들기에 앞서,\n하나의 인터페이스로 묶어주기 위해 인터페이스 클래스를 만들어준다.\n\n```java:NYPizzaIngredientFactory.java\npublic class NYPizzaIngredientFactory implements PizzaIngredientFactory {\n  public Dough createDough() {\n    return new ThinCrustDough();\n  }\n\n  public Sauce createSauce() {\n    return new MarinaraSauce();\n  }\n  ...\n}\n```\n\n이후에 각 지역에 맞는 재료 클래스를 반환하는 클래스를 구현해준다.\n따라서 각 지역에 피자 매장에 그 지역에 맞는 재료 factory를 종속시켜 준다면,\n같은 종류의 피자를 만든다고 할지라도, 재료가 다르게 들어가기 떄문에 지역 특색에 맞는 피자가 만들어 질 것이다.\n\n```java:Pizza.java\npublic abstract class Pizza { \n    String name;\n    Dough dough;\n    Sauce sauce;\n    Veggies veggies[]; \n    Cheese cheese; \n    Pepperoni pepperoni; \n    Clams clam;\n\n    abstract void prepare(); \n\n    void bake() {\n        System.out.println(“Bake for 25 minutes at 350”); \n    }\n    ...\n}\n```\n\n```java:CheesePizza.java\npublic class CheesePizza extends Pizza { \n    PizzaIngredientFactory ingredientFactory;\n\n    public CheesePizza(PizzaIngredientFactory ingredientFactory) { \n        this.ingredientFactory = ingredientFactory;\n    }\n\n    void prepare() {\n        System.out.println(“Preparing “ + name); \n        dough = ingredientFactory.createDough(); \n        sauce = ingredientFactory.createSauce(); \n        cheese = ingredientFactory.createCheese(); \n    }\n}\n```\n\n그렇기에 피자를 만들 때는 각 재료를 factory로 부터 가져오도록 구현해야 한다.\n\n```java:NYPizzaStore.java\npublic class NYPizzaStore extends PizzaStore { \n    ...\n    protected Pizza createPizza(String item) {\n        Pizza pizza = null;\n\n        PizzaIngredientFactory ingredientFactory = \n            new NYPizzaIngredientFactory();\n\n        if (item.equals(“cheese”)) {\n            pizza = new CheesePizza(ingredientFactory); \n            pizza.setName(“New York Style Cheese Pizza”);\n        } else if (item.equals(“veggie”)) {\n            pizza = new VeggiePizza(ingredientFactory); \n            pizza.setName(“New York Style Veggie Pizza”);\n        } else if (item.equals(“clam”)) {\n            pizza = new ClamPizza(ingredientFactory); \n            pizza.setName(“New York Style Clam Pizza”);\n        } else if (item.equals(“pepperoni”)) {\n            pizza = new PepperoniPizza(ingredientFactory); \n            pizza.setName(“New York Style Pepperoni Pizza”);\n        } \n\n        return pizza; \n    }\n}\n```\n\n마지막으로 각 지역에 피자 매장에 그 지역에 맞는 재료 factory를 종속시켜 주면,\n같은 종류의 피자를 만든다고 할지라도, 재료가 다르게 들어가기 떄문에 지역 특색에 맞는 피자가 만들어 질 것이다.\n\n![231125-111610](/posts/final_04/231125-111610.png)\n\n이렇게 구현 클래스(PizzaFactory)를 반환하는 것이 아닌, 클래스 생성 후 인터페이스(NYPizzaIngredientFactory)를 반환하는 디자인 패턴을 Abstract Factory Pattern 라고 한다.\n간단하게 말하면 factory(NYPizzaStore)의 factory(NYPizzaIngredientFactory) 인 것이다.","slug":"univ_design-pattern/final_04","readingMinutes":8,"wordCount":813},{"title":"Proxy Pattern","description":"Proxy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Proxy Pattern","Proxy","Remote Proxy"],"draft":false,"date":"2023-11-06 / 15:26","content":"\n\u003ctip\u003e\n  `Proxy`\n  다른 기능, 서버를 사용하기 전에 본인선에서 처리해버릴 때, 그 본인을 proxy 라고 한다.\n  즉, 중계기로서 대리로 처리하는 것을 의미한다.\n\u003c/tip\u003e\n\n## Remote Proxy Pattern\n\n![231106-155200](/posts/final_02/231106-155200.png)\n\n프로그램이 서로 다른 머신 혹은 프로세스에서 동작 중일 때, 한 프로그램에서 다른 프로그램의 메서드를 직접 사용하기 위해 서로 상대 프로그램의 proxy를 두어 통신한다.\n이렇게 구성하면 각 프로그램은 다른 프로그램의 메서드를 직접 호출한다고 착각하게 되는데, 실제로 통신은 프록시 사이에서 일어나게 되는 것이다.\n\n### 필요성\n\n저번에 만들었던 GumballMachine의 상태를 원격으로 확인하는 서비스를 만들어보자.\napi 통신하는 방법으로도 구현할 수 있겠지만, 이번엔 Java에서 지원하는 Remote 기능을 이용해서 구현해보자.\n\n\u003ctip\u003e\n  `Java RMI`\n  Java Remote Method Invocation은 분산되어 존재하는 객체 간의 메세지 전송을 가능케 하는 프로토콜로, CORBA의 Java 버전이라고 봐도 무방하다.\n  \u003cbr /\u003e\n  CORBA는 여러 언어로 구현된 분산 객체간 통신을 가능케 하기 위한 표준으로 이 기술도 함께 알아보면 좋을 듯 하다.\n\u003c/tip\u003e\n\n### Remote\n\nRemote는 Java에서 제공하는 인터페이스로 내부에 어떠한 메서드도 없다.\n즉, Marker interface로서 JVM에게 이 클래스는 RMI 기능을 내포하고 있음을 알려주는 역할로 사용하게 된다.\n\n```java:GumballMachineRemote.java\npublic interface GumballMachineRemote extends Remote {\n  public int getConut() throws RemoteException;\n  public String getLocation() throws RemoteException;\n  public State getState() throws RemoteException;\n}\n```\n\n여기서 눈여겨 봐야 할 점은 Remote 메서드들이 모두 RemoteException 에러를 던질 수 있도록 해야한다는 점이다.\n그 이유는, 네트워크가 끊기는 경우 프로그램이 정상동작 하지 않을 수 있기 때문이다.\n\n### Examples\n\n그에 따라 상태 클래스도 약간의 변경이 필요하다.\n\n```diff-java:State.java\n- public interface State {\n+ public interface State extends Serializable {\n    public void insertQuarter();\n    public void ejectQuarter();\n    public void turnCrank();\n    public void dispense();\n}\n```\n\nSerializable 하는 이유는, 네트워크 통신을 할 때 객체를 직렬화해서 전송해야 하기 때문이다.\n\n```diff-java:GumballMachine.java\n\n- public class GumballMachine {\n+ public class GumballMachine extends UnicastRemoteObject implements GumballMachineRemote {\n    ...\n\n-   public GumballMachine(int gums) {\n+   public GumballMachine(int gums, String location) throws RemoteException\n      ...\n    }\n\n    public int getConut() {\n      return count;\n    }\n    public String getLocation() {\n      return location;\n    }\n    public State getState() {\n      return state;\n    }\n\n    ...\n  }\n```\n\n여기까지 코드를 수정하고 나면, 이제 원격에서 머신을 실행시키며 RMI 레지스트리에 등록을 해줘야 한다.\n따라서 우선 RMI 레지스트리를 활성화 시켜준다.\n\n```bash:shall\n$ rmiregistry\n```\n\n그다음 원격 머신을 실행시켜준다.\n\n```java:RemoteMain.java\npublic class RemoteMain {\n  public static void main(String args[]) {\n    GumballMachineRemote gumballMachine = new GumballMachine(10, \"my-location\");\n    Naming.rebind(\"//my-location/gumballMachine\", gumballMachine);\n  }\n}\n```\n\n여기서 rebind 메서드를 통해 레지스트리에 stub을 등록시켜 주는 것이다.\n하지만, stub을 생성 시켜주기위해 아래의 rmic (RMI Compliler) 명령어를 실행하여 만들고 난 뒤 해당 코드를 실행해야 한다.\n\n```bash:shall\n$ rmic RemoteMain\n$ java RemoteMain\n```\n\n이렇게 하면 원격 저장소에 GumballMachineRemote의 stub가 레지스트리에 등록이 되었다!\n이제 클라이언트(모니터)에서 데이터를 받아보자.\n\n```java:GumballMonitor.java\npublic class GumballMonitor {\n  GumballMachineRemote machine;\n\n  public GumballMonitor(GumballMachineRemote machine) {\n    this.machine = machine;\n  }\n\n  public void report() {\n    machine.getLocation();\n    machine.getConut();\n    machine.getState();\n    ...\n  }\n}\n```\n\n```java:MonitorMain.java\npublic class MonitorMain {\n  public static void main(String args[]) {\n    GumballMachineRemote machine = Naming.lookup(\"rmi://my-location/gumballMachine\");\n    GumballMonitor monitor = new GumballMonitor(machine);\n    monitor.report();\n  }\n}\n```\n\n여기서 lookup 메서드를 통해 원격 레지스트리에 등록된 stub을 다운로드 받아 사용하는 것이다.\n\n위 과정을 그림으로 표현하면 다음과 같으니 참고하자.\n\n![231119-214628](/posts/final_03/231119-214628.png)","slug":"univ_design-pattern/final_03","readingMinutes":5,"wordCount":478},{"title":"State Pattern","description":"State 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["State Pattern"],"draft":false,"date":"2023-11-06 / 14:46","content":"\n## 필요성\n\n우리가 Gumball machine을 개발한다고 가정해보자.\nGumball machine은 다음과 같은 동작을 수행해야 할 것이다.\n\n![231106-144938](/posts/final_02/231106-144938.png)\n\n개발 경험이 많이 없다면, 해당 동작을 함수 기반으로 작성할 것이다.\n\n```java:GumballMachine.java {9, 12-14}\npublic class GumballMachine {\n  final static int SOLD_OUT = 0;\n  final static int NO_QUARTER = 1;\n  final static int HAS_QUARTER = 2;\n  final static int SOLD = 3;\n\n  private int state = SOLD_OUT;\n\n  public void insertQuarter() {\n    if (state == SOLD_OUT) {\n      // 껌이 비었기에 동전을 넣게 못하도록 처리\n    } else if (state == NO_QUARTER) {\n      // 동전을 받았기에 state를 변경\n      state = HAS_QUARTER;\n    } else if\n    ...\n  }\n}\n```\n\n이런식으로 작성한다면 미래의 발견할 문제점이 많다는 것은 둘째치고, 그냥 뭔가 딱 보기에도 불-편하지 않은가?\n실제로 다음과 같은 문제점도 발생할 가능성이 높다.\n\n- 상태가 많을수록 조건문이 많아짐\n- 상태 상수를 변경하거나, 추가, 삭제시 모든 함수에 대한 수정이 필요함\n\n한 마디로, `유지보수`하기에 너무나도 좋지 못한 방법이다.\n\n## State Pattern\n\n앞의 방식은 상태의 변화, **Transition을 중심**으로 한 코드 작성 방식이었다.\n\n하지만, 상태별로 취해야 할 행동을 다르게 정의하고, 그렇게 정의된 상태를 갖도록 하는 디자인 패턴을 `State Pattern` 라고 하는데,\n말로 하면 이해가 어려우니 이번엔 상태, **State를 중심**으로한 코드 작성 방식을 살펴보자.\n\n```java:State.java\npublic interface State {\n  public void insertQuarter();\n  public void ejectQuarter();\n  public void turnCrank();\n  public void dispense();\n}\n```\n\n우선 각 상태에서 수행해야 할 함수를 모아 State 인터페이스를 만들어주고, 각 상태는 State 인터페이스를 구현하는 방식으로 구현한다.\n\n```java:NoQuarterState.java {8-11}\npublic class NoQuarterState implements State {\n  GumballMachine machine;\n\n  public NoQuarterState(GumballMachine machine) {\n    this.machine = machine;\n  }\n\n  public void insertQuarter() {\n    // 동전을 받았기에 state를 변경\n    machine.setState(machine.getHasQuarterState());\n  }\n  ...\n}\n```\n\n이런식으로 상태에 따라 수행 가능한 기능을 구현하는 것이다.\n\n```diff-java:GumballMachine.java\n  public class GumballMachine {\n-   final static int SOLD_OUT = 0;\n-   final static int NO_QUARTER = 1;\n-   final static int HAS_QUARTER = 2;\n-   final static int SOLD = 3;\n    // getter 구현\n+   State soldOutState;\n+   State noQuarterState;\n+   State hasQuarterState;\n+   State soldState;\n\n-   private int state = SOLD_OUT;\n+   private State state = soldOutState;\n    int count = 0;\n\n    public GumballMachine(int gums) {\n      this.count = gums;\n      soldOutState = new SoldOutState(this);\n      noQuarterState = new NoQuarterState(this);\n      ...\n      if (gums \u003e 0) {\n        state = noQuarterState;\n      }\n    }\n\n    public void setState(State state) {\n      this.state = state;\n    }\n\n    public void insertQuarter() {\n-     if (state == SOLD_OUT) {\n-       // 껌이 비었기에 동전을 넣게 못하도록 처리\n-     } else if (state == NO_QUARTER) {\n-       // 동전을 받았기에 state를 변경\n-       state = HAS_QUARTER;\n-     } else if\n-     ...\n+     state.insertQuarter();\n    }\n  }\n```\n\n이제 GumballMachine은 상태를 상수로 관리하는 것이 아닌, 클래스로 관리하게 되고, 현재 상태에 따라 호출되는 함수의 기능이 달라지게 된다.\n\n이렇게 구현하면 유지보수도 간편해지는게, 상태를 변경한다고 하면, 해당 상태의 클래스만 수정하면 되고,\n상태를 추가한다고 하면 상태 클래스를 추가하고 GumballMachine의 상단에 상태를 보관할 수 있게만 추가하면 된다.","slug":"univ_design-pattern/final_02","readingMinutes":5,"wordCount":454},{"title":"Composite Pattern","description":"Composite 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Composite Pattern"],"draft":false,"date":"2023-11-06 / 12:26","content":"\n## 필요성\n\n트리구조와 같은 데이터에 순차 접근해야 하는 상황을 가정해보자.\nIterator pattern으로 구현된 자료구조에 접근할 때의 문제점은, Iterator로 반환되는 객체의 타입이 동일해야 한다는 것이다.\n무슨 말이냐면, i번째 접근하는 자료형과 k번째 접근하는 자료형(인터페이스)이 동일해야 한다는 것이다.\n\n이 때 만약, leaf node와 inner node가 다른 방식으로 동작한다고 해서 다른 자료형으로 구현한다면?\n노드 타입을 검사하고, 타입에 맞는 순차탐색 과정을 거치는 등 순차탐색하는 과정이 매우 복잡해질 것이다.\n\n## Composite Pattern\n\n이런 순차탐색에서의 불편함을 없애고자, leaf, inner node **모두 동일한 `component class`를 구현**하는 방식을 Composite Pattern 이라고 한다.\n예시 코드를 살펴보자.\n\n```java:MenuComponent.java\npublic abstract class MenuComponent {\n  // For inner node\n  public void add(MenuComponent c) {\n    throw new UnsupportedOperationException();\n  }\n  public void remove(MenuComponent c) {\n    throw new UnsupportedOperationException();\n  }\n  public MenuComponent getChild(int i) {\n    throw new UnsupportedOperationException();\n  }\n  // For all node\n  public void print() {\n    throw new UnsupportedOperationException();\n  }\n  public String getName() {\n    throw new UnsupportedOperationException();\n  }\n  ...\n}\n```\n\n이제 leaf, inner node에서 위 클래스를 extends 하여 구현하면 모두 동일한 인터페이스(메서드)를 갖게되어 Iterator를 이용한 순차탐색이 가능해진다.\n(Iterator\\\u003cMenuComponent\\\u003e 이런 느낌)\n\n```java:MenuItem.java\n// leaf node\npublic class MenuItem extends MenuComponent {\n  String name;\n  ...\n  public MenuItem(String name, ...) {\n    this.name = name;\n    ...\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void print() {\n    System.out.println(getName());\n  }\n  ...\n}\n```\n\n이런식으로 필요한 메서드만 override 해서 사용하면 된다.\n만약, override하지 않은 메서드를 호출한다면 UnsupportedOperationException이 발생하는 것이다.\n\n```java:Menu.java\npublic class Menu extends MenuComponent {\n  ArrayList menuComponents = new ArrayList();\n  String name;\n  ...\n  public Menu(String name, ...) {\n    this.name = name;\n    ...\n  }\n\n  public void add(MenuComponent c) {\n    menuComponents.add(c);\n  }\n  public void remove(MenuComponent c) {\n    menuComponents.remove(c);\n  }\n  public void getChild(int i) {\n    return (MenuComponent)menuComponents.get(i);\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void print() {\n    System.out.println(getName());\n    System.out.println(\"===========\");\n\n    Iterator iter = menuComponents.iterator();\n    while(iter.hasNext()) {\n      MenuComponent menuComp = (MenuComponent)iter.next();\n      menuComp.print();\n    }\n  }\n  ...\n}\n```\n\n이런식으로 MenuItem(leaf), Menu(inner) 모두 동일한 print 라는 메서드를 호출할 수 있지만,\n구현을 다르게 했기 때문에 동작이 달라진다.\n\n이제 메뉴를 출력하든, 메뉴의 각 음식을 출력하든, 나아가 모든 메뉴를 출력(`클라이언트`가 하는 일)하든 상관없이\nMenuComponent 클래스를 상속하여 만든 객체는 print를 호출하여 출력할 수 있다.\n\n### vs. Decorator\n\nMenu 클래스를 보면 뭔가 느낌이 Decorator Pattern을 보는 것과 비슷한 느낌을 받을 수 있다.\n자식 클래스에서 부모 클래스를 멤버 변수로 가지며, override 한다는 점에서 비슷하다.\n\n하지만, 사용 목적에 차이점이 있음을 알고가면 좋을 거 같다.\n\n`Decorator Pattern`은 leaf node에 해당하는 부분의 **변화를 가하지 않고 추가 기능 구현**을 위해 override 한다는 데 목적이 있다면,\n\n`Composite Pattern`은 계층 구조의 모든 노드가 **같은 인터페이스로 클라이언트에서 접근**할 수 있도록 하는데에 목적이 있다.","slug":"univ_design-pattern/final_01","readingMinutes":5,"wordCount":408},{"title":"Matrix and Transformations","description":"행렬에 대한 기본적인 내용과 이를 이용한 공간상에서의 변환에 대해 다뤄봅니다.","icon":"","image":"","tags":["Matrix","Transform","Translate","Basis","Linear Map","Homogeneous Coordinates"],"draft":false,"date":"2023-10-23 / 22:09","content":"\n## Matrix\n\n$$\n\\begin{pmatrix}\na_{11} \u0026 a_{12} \u0026 ... \u0026 a_{1n} \\\\\na_{21} \u0026 a_{22} \u0026 ... \u0026 a_{2n} \\\\\n... \u0026 ... \u0026 ... \u0026 ... \\\\\na_{m1} \u0026 a_{m2} \u0026 ... \u0026 a_{mn} \\\\\n\\end{pmatrix}\n$$\n\nm-by-n matrix, 또는 **m행(Row) n열(Column)** 의 행렬이라고 부른다.\n\n여기서 하나의 **행** 만으로 이루어진 행렬을 `Row vectors`, \n한 **열**로만 이루어진 행렬을 `Column vectors` 라고 부른다.\n\n### Transpose\n\n$$\n(A^T)_{ij} = A_{ji}\n$$\n\n각 행과 열을 뒤집은 행렬을 전치행렬 이라고 부른다.\n\n### Square Matrix\n\n행과 열의 개수가 같은 행렬을 의미한다.\n\n### Identity Matrix\n\n$$\n\\begin{pmatrix}\n1 \u0026 0 \\\\\n0 \u0026 1 \\\\\n\\end{pmatrix}\n, \\;\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \\\\\n0 \u0026 1 \u0026 0 \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{pmatrix}\n$$\n\n위와 같이 Square Matrix인데 대각선만 1이고, 나머지는 0으로 채워진 행렬을 의미한다.\n\n\u003e AI = IA = A\n\n이 행렬의 가장 큰 특징은 행렬 A에 Identity Matrix를 곱하면 다시 행렬 A가 나온다는 것이다.\n\n### Scalar Multiplication \u0026 Addition\n\n백터에 스칼라 곱을 하거나, 백터간 합이나 차를 구할 때는 [**이전 포스트**](https://wjlee611.github.io/blog/univ_virtual-worlds/mid_03)에서 벡터의 연산을 했을 때와 동일하게 **각 원소에 대해 연산**을 진행하면 된다.\n\n### Matrix Multiplication\n\n![231023-222141](/posts/mid_04/231023-222141.png)\n\n행렬간 곱 연산은 위의 이미지와 같이 계산된다.\n여기서 주의할 점은 **앞의 행렬의 `열`** 의 개수와 **뒤의 행렬의 `행`** 의 개수가 일치해야 한다는 점이다.\n\n---\n\n## Transformations\n\n### Basis\n\n변환에 앞서 기저에 대해 알 필요가 있다.\n선형 독립인 벡터들이 공간을 생성(span)할 때, 그 벡터의 집합을 기저(basis)라고 한다.\n\n\u003ctip\u003e\n`선형 독립 (Linear Independent)`\n\u003cbr /\u003e\nN차원에서 어떤 하나의 벡터가 나머지 N-1개의 벡터의 **선형 결합으로 표현할 수 없는 경우**, N개의 벡터들이 선형 독립이라고 한다.\n즉, 벡터간 의존성이 없어야 한다.\n\u003c/tip\u003e\n\n벡터가 공간을 생성한다는 의미를 잘 모를 수 있는데, 예로 들어보자.\n\n![231023-230449](/posts/mid_04/231023-230449.png)\n\nv는 한 평면위의 벡터이다.\n이 상태에서 $v_1, \\; v_2$의 값을 [-$\\infty$, $\\infty$] 범위로 임의 조정한다고 가정해보자.\n그럼 v는 어떤 범위의 종점 좌표를 가질 수 있을까?\n바로 벡터 a, b가 속한 평면의 모든 좌표를 가질 수 있을 것이다.\n\n즉, **평행하지 않은 벡터의 선형 결합으로 공간을 생성**할 수 있는 것이다.\n\n그렇다면 두 벡터가 평행하지 않는다는 조건도 이해가 될 것이다.\n만약 두 벡터가 **평행**하다, 즉, **하나의 벡터로 다른 벡터를 표현**할 수 있다, 다른 말로 두 벡터가 **선형 의존**이라면, v는 직선상에만 존재할 수 있기 때문이다.\n\n그럼 다시 basis 얘기로 돌아와서, basis의 선형 결합으로 basis가 span하는 공간의 모든 벡터를 표현할 수 있다는 것을 이해했다.\n이 때 성립하는 증명이 있다.\n\n\u003e 같은 basis의 선형결합으로 표현되는 벡터는 표현 방법이 1개로 유일하다.\n\n위의 증명된 내용 덕분에, basis의 선형 결합 시 사용하는 weight를 좌표로써 활용할 수 있는 것이다.\n그렇기에 basis를 바꾼다는 건 좌표값을 바꾸는 것일 뿐, 벡터 그 자체를 바꾸는게 아니다.\n\n### Linear Map\n\n선형 사상이란 벡터의 기저를 바꿀 때, 즉 **벡터 공간이 바뀔 때 변형시에 선형성이 유지되는 변환 함수($F$)** 를 말한다.\n\n예로 들어 아래는 선형 사상이다.\n![231023-232038](/posts/mid_04/231023-232038.png)\n\n하지만, 이 경우는 선형 사상이 아니다.\n![231023-232104](/posts/mid_04/231023-232104.png)\n\n음? 그런데 이게 기저가 바뀌는거랑 무슨 상관이냐고?\n이제 기저를 선형 사상(변환 함수)에 대입해보며 알아보자.\n\n$$\n\\widehat{\\textrm{v}} = F\\textrm{v} \\\\\n{} \\\\\n\\begin{pmatrix}\n\\widehat{v_1} \\\\\n\\widehat{v_2} \\\\\n\\widehat{v_3}\n\\end{pmatrix} =\n\\begin{bmatrix}\nf_{11} \u0026 f_{12} \u0026 f_{13} \\\\\nf_{21} \u0026 f_{22} \u0026 f_{23} \\\\\nf_{31} \u0026 f_{32} \u0026 f_{33} \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\nv_1 \\\\\nv_2 \\\\\nv_3\n\\end{pmatrix} \n$$\n\n이해를 돕기 위해 $v_1$, $v_2$, $v_3$을 $x$, $y$, $z$ 라고 생각해보자.\n\n이제 ($v_1$, $v_2$, $v_3$) 대신에 (1, 0, 0) 을 대입해보자.\n이 때, (1, 0, 0)은 x축을 가리키는 기저의 원소이다.\n\n\n$$\n\\begin{pmatrix}\n\\widehat{v_1} \\\\\n\\widehat{v_2} \\\\\n\\widehat{v_3}\n\\end{pmatrix} =\n\\begin{bmatrix}\nf_{11} \u0026 f_{12} \u0026 f_{13} \\\\\nf_{21} \u0026 f_{22} \u0026 f_{23} \\\\\nf_{31} \u0026 f_{32} \u0026 f_{33} \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{pmatrix} =\n\\begin{pmatrix}\nf_{11} \\\\\nf_{21} \\\\\nf_{31}\n\\end{pmatrix} \n$$\n\n즉, 선형 사상($F$) 로 인해 기저 x(1, 0, 0)는 $(f_{11}, \\; f_{21}, \\; f_{31})^T$로 변환되었다.\n\n여기서 알 수 있는 것은 선형 사상, **Linear Function $F$의 i번째 열 벡터는 i번째 축의 기저벡터가 어디로 대응**되는가를 알려준다.\n또한, 위의 변환 과정은 선형성이 유지된다.\n\n참고로 선형성이 유지되는 특성 덕분에 여러 선형 사상을 한 번에 처리하는 것 또한 가능해진다.\n\n\u003e A(B(C(D(x)))) = ABCDx = $\\textrm{x}^TD^TC^TB^TA^T$\n\n### 2D Linear Transformations\n\n우선 회전을 살펴보자.\n\n![231023-234010](/posts/mid_04/231023-234010.png)\n\n선형 사상을 이용한 기저의 변환을 어느정도 이해했다면 이제 변형식이 왜 이렇게 생겼는지도 이해할 수 있을 것이다.\n\n예로 들어 (1,0) 즉 x축의 기저벡터를 $\\theta$ 만큼 회전시킨 좌표는 ($cos \\theta$, $sin \\theta$)가 되는데, 이는 위에서 언급한 \"선형 사상, **Linear Function $F$의 i번째 열 벡터는 i번째 축의 기저벡터가 어디로 대응**되는가를 알려준다\" 와 완벽히 일치한다.\n\n\u003ctip\u003e\n  즉, 앞으로의 변환은 각 축의 기저 벡터가 어떻게 변하는지를 파악하고, 해당 **변화 후의 값을 이용**해서 선형 사상 함수를 작성하면 된다.\n\u003c/tip\u003e\n\n이런 내용을 염두하고 다른 변환들도 살펴보자.\n\n![231023-235906](/posts/mid_04/231023-235906.png)\n\n![231024-000043](/posts/mid_04/231024-000043.png)\n\n![231024-000102](/posts/mid_04/231024-000102.png)\n\n### Affine Maps\n\n2D Translation을 가능케하는 Transformations 이 있을까?\n\n![231024-000319](/posts/mid_04/231024-000319.png)\n\n없다.\n그 이유는 **이동은 선형 변환이 아니**라서 이를 표현할 선형 사상 함수가 없기 때문이다.\n\n즉, Affine Map은 Linear map + Translation 으로 표현할 수 밖에 없다.\n왜냐면 Affine은 Linear하지 않기 때문이다.\n\n### Homogeneous Coordinates\n\n그렇다면 Transform과 Translate를 동시에 처리할 수 있는 방법이 없을까?\n바로 Homogeneous Coordinates를 이용하면 된다.\n\n이게 뭐냐면, 2차원의 Homogeneous Coordinates는 3차원의 벡터가 된다는 건데, 예시를 들어보자.\n\n$$\n\\begin{pmatrix}\nwx' \\\\\nwy' \\\\\nw\n\\end{pmatrix} =\n\\begin{bmatrix}\n1 \u0026 0 \u0026 t_x \\\\\n0 \u0026 1 \u0026 t_y \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\nwx \\\\\nwy \\\\\nw\n\\end{pmatrix}\n$$\n\n적당하게 w 기저를 하나 더 만들어서 차원을 높였다.\n이 때, ($wx$, $wy$, $w$)를 Homogeneous Coordinates 라고 하는데, 이제 여기에 계산의 편의를 위해 $w$에 1을 대입해보자.\n\n$$\n\\begin{pmatrix}\nx' \\\\\ny' \\\\\n1\n\\end{pmatrix} =\n\\begin{bmatrix}\n1 \u0026 0 \u0026 t_x \\\\\n0 \u0026 1 \u0026 t_y \\\\\n0 \u0026 0 \u0026 1 \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\nx \\\\\ny \\\\\n1\n\\end{pmatrix} = \n\\begin{pmatrix}\nx + t_x \\\\\ny + t_y \\\\\n1\n\\end{pmatrix}\n$$\n\n결과는?\n놀랍게도 Transformations 한 방식과 동일하게 진행되었는데 결과는 Translate 한 결과가 나왔다.\n이를 이용하면 2D 에서의 모든 변형은 다음과 같은 4개의 행렬의 곱으로 표현이 가능해진다.\n\n![231024-002119](/posts/mid_04/231024-002119.png)\n\n즉, 좌상단의 2x2 행렬은 Transform을 위한 부분이고, 우상단의 2x1 행렬은 Translate를 위한 부분이다.\n\n참고용으로 3D에 대한 Homogeneous Coordinates도 남겨놓겠다.\n![231024-002347](/posts/mid_04/231024-002347.png)\n\n### Compound Transformations\n\nLinear Map의 마지막에 언급한 사실에 근거해 이제 모든 변환은 합성 변환으로 치환할 수 있다.\n\n\u003e A(B(C(D(x)))) = ABCDx = $\\textrm{x}^TD^TC^TB^TA^T$\n\n그렇게 하면 ABCDx 이 행렬곱을 정리하기만 하면 A~D 까지의 모든 변환을 한 번에 수행하는 결과를 얻을 수 있으니 연산량이 매우 감소하게 된다.\n\n\u003cnotice\u003e\n  단, 연산 순서에 주의해야 한다.\n  \u003cbr /\u003e\n  ![231024-002828](/posts/mid_04/231024-002828.png)\n\u003c/notice\u003e\n\n이제 연산량이 어떻게 변하는지 예시를 살펴보자.\n\n![231024-003050](/posts/mid_04/231024-003050.png)\n\n이를 응용하면 특정 방향으로만 스케일링 하는 것도 구현할 수 있다.\n\n![231024-003225](/posts/mid_04/231024-003225.png)","slug":"univ_virtual-worlds/mid_04","readingMinutes":11,"wordCount":1032},{"title":"Vector","description":"벡터에 대한 기본적인 내용에 대해 다뤄봅니다.","icon":"","image":"","tags":["Vector","Points"],"draft":false,"date":"2023-10-23 / 20:12","content":"\n\u003cnotice\u003e\n  Vector와 Points는 (1, 2, 3) 과 같이 숫자로된 좌표로 표현된다는 점에서는 비슷하다.\n  \u003cbr /\u003e\n  하지만, `Points`는 **공간의 위치**를 나타내지만, `Vector`은 **방향과 크기**를 나타낸다는 점이서 다르다.\n  (벡터는 위치 개념이 없음. 상대적인 방향과 크기만을 가질 뿐) \n\u003c/notice\u003e\n\n## Vector Algebra\n\n### Scalar Multiplication\n\n![231023-204033](/posts/mid_03/231023-204033.png)\n\n해당 방향으로 크기만 증가하는 연산이다.\n**벡터의 각 성분에 크기 c만큼 각각 곱해주면** 된다.\n\n### Addition\n\n![231023-204232](/posts/mid_03/231023-204232.png)\n\nA 벡터의 종점에 B 벡터의 시점을 이어붙이는 연산으로, 그 값은 A 벡터의 시점 \u0026rarr; B 벡터의 종점이 된다.\n평행 사변형법으로도 계산할 수 있으며, **벡터의 각 성분끼리 더하면** 된다.\n\n### Substraction\n\n![231023-204432](/posts/mid_03/231023-204432.png)\n\n벡터에 -1을 스칼라 곱을 한 후, Addition을 한 결과와 같은 연산이다.\n**벡터의 각 성분을 빼주면** 된다.\n\n### Length \u0026 Direction\n\n![231023-204636](/posts/mid_03/231023-204636.png)\n\n벡터의 크기($L$)와 x축에 대한 방향($\\theta$)는 다음과 같다.\n\n\u003e $L = \\sqrt{x^2 + y^2}$\n\u003e\n\u003e $\\theta = tan^{-1}\\frac{y}{x}$\n\n\u003ctip\u003e\n  크기가 1인 벡터를 `단위벡터` 라고 하며, 벡터를 단위벡터로 변환하는 것을 **Normalization** 이라고 한다.\n  백터를 Normalization 하는 법은 **벡터의 각 성분을 $L$로 나눠주면** 된다.\n\u003c/tip\u003e\n\n### Linear Combination\n\n벡터들을 선형결합 하는 것을 의미한다.\n\n\u003e $b = c_1v_1 + c_2v_2 + ... + c_kv_k$\n\n이는 $v_1$, $v_2$, ..., $v_k$의 선형 결합이며, 상수 c를 weight라고 부른다.\n\n이 weight 값에 따라 다른 명칭으로 불리기도 한다.\n\n- `Affine Combination`\n  weight의 합이 반드시 1이 되는 선형결합.\n\n- `Convex Combination`\n  weight이 모두 양수이고, 합이 반드시 1이 되는 선형결합.\n\n### Dot product (내적)\n\n![231023-211310](/posts/mid_03/231023-211310.png)\n\n내적의 연산 결과는 스칼라가 되는데 우선 식부터 살펴보자.\n\n\u003e $\\overrightarrow{a} \\cdot \\overrightarrow{b} = a_1b_1 + a_2b_2 = \\begin{Vmatrix} \\overrightarrow{a} \\end{Vmatrix} \\begin{Vmatrix} \\overrightarrow{b} \\end{Vmatrix} cos \\theta$\n\n내적은 사잇각을 알아내는데 사용할 수 있는데, 그런데 내적 그 자체는 무슨 의미를 가질까?\n유닛벡터에 대해 다음과 같은 내적값은 다음과 같은 의미를 갖는다.\n\n- `1`\n  두 벡터가 **같은 방향으로 평행**하다\n\n- `-1`\n  두 벡터가 **정 반대 방향으로 평행**하다\n\n- `0`\n  두 벡터가 **수직**한다\n\n- `\u003e0`\n  두 벡터가 **같은 방향**이다\n\n- `\u003c0`\n  두 벡터가 **다른 방향**이다\n\n### Projection\n\n내적을 응용하면 한 벡터를 다른 벡터에 사상한 벡터를 얻을 수 있다.\n\n![231023-212348](/posts/mid_03/231023-212348.png)\n\n$\\overrightarrow{a'}$ 벡터의 길이는 **$\\begin{Vmatrix} \\overrightarrow{a} \\end{Vmatrix} cos \\theta$** 와 같다.\n또한 $\\overrightarrow{a'}$ 벡터의 단위벡터는 **$\\frac{1}{||\\overrightarrow{b}||} \\overrightarrow{b}$** 이다.\n\n따라서 둘을 곱한 다음의 식이 벡터 a를 벡터 b에 사상한 벡터가 된다.\n\n![231023-213605](/posts/mid_03/231023-213605.png)\n\n### Cross produce (외적)\n\n![231023-213718](/posts/mid_03/231023-213718.png)\n\n\u003e $\\overrightarrow{a} \\times \\overrightarrow{b} = \\begin{Vmatrix} \\overrightarrow{a} \\end{Vmatrix} \\begin{Vmatrix} \\overrightarrow{b} \\end{Vmatrix} sin \\theta \\cdot \\overrightarrow{n}$\n\u003e\n\u003e 여기서 $\\overrightarrow{n}$은 벡터 a, b에 수직한 유닛 벡터\n\n외적 두 벡터의 수직인 벡터로, 그 크기는 두 벡터가 이루는 평행사변형의 넓이이다.\n\n계산은 아래와 같이 하면 된다.\n\n$$\n\\begin{pmatrix}\na_1 \\\\\na_2 \\\\\na_3\n\\end{pmatrix} \\times\n\\begin{pmatrix}\nb_1 \\\\\nb_2 \\\\\nb_3\n\\end{pmatrix} =\n\\begin{pmatrix}\na_2b_3 - a_3b_2 \\\\\na_3b_1 - a_1b_3 \\\\\na_1b_2 - a_2b_1\n\\end{pmatrix}\n$$\n\n### Normal Vector\n\n한 평면에 대한 수직 단위벡터로 외적을 이용하면 구할 수 있다.\n\n![231023-214703](/posts/mid_03/231023-214703.png)\n\n---\n\n## Points Algebra\n\nPoints 는 더하거나, 스칼라곱에 대한 정의가 없다.\n하지만, 특수 상황에서는 의미를 갖는데, 그것들에 대해 알아보자.\n\n### Point - Point\n\n![231023-210346](/posts/mid_03/231023-210346.png)\n\nPoint B에서 Point A를 뺴면, 그 결과는 A\u0026rarr;B `Vector`가 된다.\n\n### Point + Vector\n\n![231023-210527](/posts/mid_03/231023-210527.png)\n\nPoint에 Vector를 더하거나 빼면 다른 `Point`가 된다.\n\n### Affine Combination\n\n위에서 언급했 듯, Points 는 더하거나, 스칼라곱에 대한 정의가 없다.\n하지만, 스칼라 곱 중에서 그 weight의 합이 1이 되는 경우 내분, 또는 외분의 의미를 갖게된다.","slug":"univ_virtual-worlds/mid_03","readingMinutes":6,"wordCount":506},{"title":"Modeling","description":"모델을 저장하는 방법에 대해 알아봅나디.","icon":"","image":"","tags":["Coordinate Systems","Polygonal Meshes"],"draft":false,"date":"2023-10-23 / 19:47","content":"\n## Coordinate Systems\n\n어떤 데이터든 간에 3D 공간상에 표현하기 위해서는 좌표 시스템을 먼저 구현해야 한다.\n그래야 공간상의 좌표의 조합으로 모델을 생성할 수 있기 때문이다.\n\n![231023-195004](/posts/mid_02/231023-195004.png)\n\n개발 환경에 따라 왼손 좌표계를 쓰거나 오른손 좌표계를 쓰는데, 참고로 유니티는 왼손 좌표계를 사용한다.\n따라서 유니티 관련 포스트는 모두 왼손 좌표계 기준으로 기술될 예정이다.\n\n---\n\n## Polygonal Meshes\n\n![231023-195154](/posts/mid_02/231023-195154.png)\n\n모든 3D 오브젝트를 삼각형 평면을 이어붙힌 형태로 표현하는 기법으로, 가장 많이 사용되는 방식이다.\n이런 데이터를 저장하는 방식에는 크게 3가지로 나뉘는데 각각 어떤식으로 데이터를 관리하는지 살펴보자.\n\n\u003ctip\u003e\n  mesh들은 OBJ, 3DS, POV 등의 확장자로 관리되는데,\n  OBJ의 경우 아래와 같은 정보를 저장한다.\n  - vertex의 좌표\n  - 각 vertex의 택스쳐 좌표\n  - 각 vertex의 수직 vertex\n  - 위의 vertex들로 표현돤 face\n\u003c/tip\u003e\n\n### Vertex-Vertex\n\n![231023-195357](/posts/mid_02/231023-195357.png)\n\n오직 점들만 데이터로 관리하는 자료구조를 사용한다.\n각 vertex의 **좌표**와 인접한(연결된) **vertex**를 저장한다.\n\n면에 대한 정보는 저장하지 않기에 추가적인 연산을 통해 얻어낼 수 밖에 없다.\n그렇기에 용량은 가장 작지만, 연산에 대한 부담이 있는 모델이다.\n\n### Face-Vertex\n\n![231023-195627](/posts/mid_02/231023-195627.png)\n\n점과 면을 데이터로 관리하는 자료구조를 사용하며, 가장 많이 사용되는 방식이다.\n`face`는 face를 구성하고 있는 **vertex**들의 집합으로 관리되고,\n`vertex`는 vertex의 **좌표**와 인접한 **faces**들의 집합으로 관리된다.\n\n### Winged Edge\n\n![231023-195936](/posts/mid_02/231023-195936.png)\n\n점과 면, 추가로 모서리의 데이터로 관리하는 자료구조를 사용하며, mesh를 변화시켜야 할 상황에 유용하게 사용할 수 있다.\n`face`는 face를 구성하고 있는 **edge**들의 집합으로 관리되고,\n`vertex`는 vertex에 연결된 **edge**들의 집합으로 관리된다.\n마지막으로 `edge`는 **시점, 종점의 좌표**와 **분할하는 면**, 그리고 연결된 edge 중 4개의 edge로 관리되는데,\n4개의 edge는 **시점에 연결된 back CCW, back CW, 종점에 연결된 front CCW, front CW** 순으로 관리된다. (그림 참고)","slug":"univ_virtual-worlds/mid_02","readingMinutes":4,"wordCount":241},{"title":"Unity Engine","description":"유니티 게임 엔진에 대한 기초적인 이론을 알아봅니다.","icon":"","image":"","tags":["Unity","Resource Management","Game Loop","Delta Time"],"draft":false,"date":"2023-10-23 / 17:46","content":"\n## Engine Architecture\n\n정말 말도안되게 깊고 넓은 레이어가 있는데, 간략하게 무슨 역할만을 하는지 살펴보자.\n~~(괜히 게임이 종합 예술이 아닌...)~~\n\n- Platform Independence Layer\n  디바이스에 상관없이 구동시키기 위한 레이어\n\n- Core systems\n  각종 코어 유틸리티들의 집합.\n  메모리 관리, 수학 라이브러리, 자체 자료구조 알고리즘 등.\n\n- Resource Manager\n  각종 에셋글의 생성과 관리, 배치 등의 총괄적인 관리를 담당.\n  **생성은 개발단계**에서, **배치는 런타임**에 관리된다.\n\n- Rendering Engine\n  에셋 등 데이터를 픽셀로 랜더링.\n  Projection, Shading, Texture sampling 등이 여기서 처리됨.\n\n- Scene Graph/Culling Optimization\n  시야에 안보이는 부분을 잘라내여 보이는 부분만 랜더링하도록 최적화.\n\n- Visual Effects\n  광원, 명암 등, 이미지(비주얼) 향상을 위한 후처리 과정.\n\n- Collision and Physics\n  충돌 및 물리 계산.\n\n- Animation\n  에셋들의 물리법칙을 에외한 움직임.\n\n- Human Interface Devices (HID)\n  사용자 입력, 움직임 등의 장치 관리.\n\n- Gameplay Foundation systems\n  게임 개발 환경 제공.\n\n---\n\n## Resource Management\n\n리소스에는 Meshes, audio, animation 등등 여러 raw resources 가 존재하는데, 각 리소스가 어떻게 처리되어야 하는지는 각 리소스의 Metadata를 참고하면 알 수 있다.\n\n리소스 생성과정은 다음과 같다.\n1. Maya, Photoshop 등과 같은 서드파티 앱에서 Export 한다.\n2. 이후 유니티가 game-ready 에셋인 `prefeb`으로 변환하기 위해 리소스 컴파일러가 구동된다.\n3. 추가로 여러 리소스를 하나의 패키지로 합치기 위해 링커도 제공한다.\n\n### Runtime\n\n유니티가 런타임에 어떻게 리소스를 관리하는지 개념적으로 알아보자.\n\n우선 유니티는 동일한 리소스는 특정 시각에 반드시 **1개**만 메모리에 올라오도록 보장한다.\n무슨 말이냐면 원할 때 리소스가 불러와지고, 이게 중복되어 불러와져 메모리 낭비를 하지 않게끔 해준다는 뜻인데, 이는 유니티의 **로딩 정책** 덕분에 가능해졌다.\n\n![231023-181333](/posts/mid_01/231023-181333.png)\n\n유니티는 리소스를 `비동기 로드`하기 때문에 로드해야 할 시점보다 미리 로딩한다.\n예로 들어 Level 1 에서는 A, B, C 리소스가 필요한데, 레벨 실행 전에 먼저 필요한 리소스의 목록을 파악해서 로딩하고, 로딩이 완료된 후에 레벨을 진행하는 방식으로 진행된다.\n\n이 때, 각 리소스별로 `Reference count`를 둬서 쓸데없는 중복 로딩이나, 필요 없는 리소스를 메모리에서 제거하기도 한다.\nref count가 0보다 큰데 로딩되지 않은 리소스는 로딩하고, ref count가 0인데 로딩된 리소스는 언로드 하도록 하는 것이다.\n\n메모리에서 제거하는 원리는, GC(Garbage Collector)가 일정 주기로 ref count가 0인 리소스를 제거한다.\n`System.GC.Collect()` 를 이용하면 수동적으로 GC를 호출할 수 있지만, 가능하면 그러지 말자.\n\n정리하면 런타임에 리소스 매니저는 아래의 역할을 수행할 수 있어야 한다.\n1. 동일한 리소스는 특정 시각에 메모리에 1개만 올라오도록 보장\n2. 각 리소스의 생명주기를 관리\n3. prefeb과 같은 여러군데 흩어진 리소스의 묶음을 관리할 수 있어야 한다\n4. 리소스간 참조의 무결성을 보장해야 한다\n5. 이미 로드된 리소스의 메모리 사용량도 관리해야 한다\n\n### Location\n\n리소스가 어디에 존재하는지에 따라 런타임시 로드 방식이 달라진다.\n\n- AssetBundles\n  유니티 플레이어 외부의 리소스로, 보통 웹서버 상에 존재하는 리소스이다.\n  `AssetBundle.LoadAsset()` 으로 불러올 수 있다.\n\n- Resource folders\n  유니티 플레이어 내부의 리소스로, Project view의 Resources 폴더에 존재하는 리소스이다.\n  `Resources.Load()` 로 불러올 수 있다.\n\n---\n\n## Game Loop\n\n매 프레임 상태 변경을 하거나, 사용자 입력을 받거나, 화면 랜더링을 위한 무한 루프를 의미한다.\n1초에 얼마나 루프가 돌아가는지를 나타내는 척도가 FPS인데, 엄밀히 말하면 화면이 그려지는 횟수지만, 한 루프에 한 번 화면이 업데이트되니 거의 같이 사용할 수 있다.\n\n유니티에선 거의 대부분의 클래스가 `MonoBehavior`를 상속하여 정의하는데, 여기에서 `Update()` 함수가 프레임당 한 번 호출이 이루어진다.\n\n그 외에도 override할 수 있는 다른 함수 몇 개 더 알아보자.\n\n- `Start()`\n  첫 프레임 업데이트시 호출되는 함수.\n\n- `LateUpdate()`\n  Update() 함수가 종료되고나서 호출되는 함수.\n\n- `OnDestory()`\n  소멸자 비스무리한 함수.\n  마지막 프레임의 업데이트가 완료되고 나서 호출되는 함수.\n\n### Delta Time\n\n두 인접한 프레임 사이의 시간이 얼마나 흘렀는가를 나타내는 값으로, 보통 그 값은 FPS의 역수이다.\n즉, 30FPS 게임에서의 $\\Delta t$는 1/30 seconds, 즉, 3.33ms이다.\n\n두 프레임 사이의 시간이므로 물리 시뮬레이션시 시간 변화율로서 동작하게 되는데, 물리량을 수식화 하면 다음과 같다.\n\n| 의미 | 수식 |\n|---|---|\n| Position | $p_{t+\\Delta t} = p_t + v_t \\cdot \\Delta t$ |\n| Velocity | $v_{t+\\Delta t} = v_t + a_t \\cdot \\Delta t$ |\n| Acceleration | $a_{t+\\Delta t} = f_{ext}/m$ |\n\n즉, $\\Delta t$가 너무 크거나 일정하지 않으면 물리량에 오차가 커질 수 밖에 없다.\n만약 델타값을 고정시키고, 이를 게임 루프에 의존해서 증가시킨다면 컴퓨터 사양에 따라 다르게 동작하는 현상이 발생할 수 있다.\n\n따라서, 유니티는 **CPU**의 `high-resolution timer`를 이용해서 델타값을 구하기 때문에 현실세계와 유사한 플레이 경험을 얻을 수 있도록 합니다.","slug":"univ_virtual-worlds/mid_01","readingMinutes":8,"wordCount":640},{"title":"기계학습 - 비지도 \u0026 반지도학습","description":"비지도 \u0026 반지도학습에서 사용되는 개념에 대해 알아봅니다.","icon":"","image":"","tags":["Unsupervised learning","Clustering","Semi-supervised learning"],"draft":false,"date":"2023-10-22 / 22:58","content":"\n## 비지도학습\n\n지도학습은 학습 데이터에 입력-출력이 명시되어 있었는데, 비지도학습은 학습 데이터에 어떠한 레이블도 붙지 않은 데이터를 이용한 학습 방법을 의미한다.\n\n비지도학습을 통해 데이터에 대한 잠재적인 구조나 계층 구조를 찾을 수 있고, 문서들을 주제에 따라 구조화 하거나, 로그를 분석한 사용 패턴을 알아내는데 적용할 수 있다.\n\n---\n\n## 군집화\n\n유사성에 따라 데이터를 분할하는 것으로, 데이터가 하나의 군집에만 소속되는 일반 군집화(Hard clustering)와 퍼지 군집화(Fuzzy clustering)으로 나뉜다.\n\n군집화는 보통 아래와 같은 용도로 사용된다.\n\n- 데이터에 내제된/일반적 구조 추정/통찰\n- 가설 설정\n- 이상 감지\n- 데이터 압축\n- 데이터 전처리 (부류(class)를 부여하는 방식)\n\n성능은 군집 내의 분산은 작을수록, 군집간의 거리는 멀수록 좋다고 평가한다.\n\n### 밀도 추정\n\n![231022-230608](/posts/mid_08/231022-230608.png)\n\n부류(class)별로 데이터를 만들어 냈을 것으로 추정되는 확률 분포를 찾는 과정으로, 각 부류 별로 주어진 데이터를 발생시키는 확률을 계산하여 가장 확률이 높은 부류로 데이터를 분류한다.\n\n분포가 수학적인 형태를 갖고있을 것을 가정하여 데이터의 분포를 가장 잘 수학적으로 표현하려고 하는 추정 방식을 `모수적 밀도 추정` 이라고 하며, 전형적으로 **Gaussian 함수의 혼합**으로 표현한다.\n\n또는, 분포에 대한 수학적 함수를 가정하지 않고, 주어진 데이터를 사용하여 밀도함수의 형태로 표현하는 방식을 `비모수적 밀도 추정` 이라고 하며, 전형적으로 **히스토그램**과 같은 방식으로 표현한다.\n\n### 차원 축소\n\n고차원의 데이터를 정보의 손실을 최소화 하면서 저차원으로 변환하는 것으로, 시각화를 직관적으로 하기 위해, 그리고 `차원의 저주 문제`를 완화하기 위해 사용한다.\n\n\u003ctip\u003e\n  `차원의 저주 문제`\n  \u003cbr /\u003e\n  ![231022-231121](/posts/mid_08/231022-231121.png)\n  차원이 커질수록 거리분포가 일정해지는 경향\n\u003c/tip\u003e\n\n![231022-231254](/posts/mid_08/231022-231254.png)\n\n이를 위해 주성분을 분석하여 분산이 큰 축을 기준으로 데이터를 projection하는 방식을 사용해서 저차원으로 변환한다.\n\n### 이상치 탐지\n\n다른 데이터와 크게 달라서 관심 대상으로 봐야하는 데이터를 탐지하기 위해 사용한다.\n이런 관심대상의 데이터는 `노이즈`일 확률이 높으나, `신규성 탐지`의 경우도 항상 염두해야 한다.\n\n이상치는 아래와 같은 방식으로 탐지할 수 있다.\n\n- 점 이상치\n  다른 데이터와 비교하여 차이가 큰 데이터\n\n- 상황적 이상치\n  상황에 맞지 않는 데이터\n\n- 집단적 이상치\n  여러 데이터를 모아서 보면 비정상으로 보이는 데이터\n\n이러한 이상치 탐지는 **부정사용감지 시스템**이나 **침임감지 시스템** 등에 사용할 수 있다.\n\n---\n\n## 반지도학습\n\n비지도학습과 마찬가지로 미분류 데이터를 이용하는데, 이를 지도학습에 사용하는 방법이다.\n\n![231022-231828](/posts/mid_08/231022-231828.png)\n\n이런 식으로 같은 군집에 속하는 것은 가능한 동일한 부류에 소속하도록 학습하는 방식이다.\n미분류 데이터는 획득 비용이 낮기 때문에 이러한 지도학습 방식도 고려하면 좋다.\n\n단, 반지도학습을 위해서는 데이터가 아래와 같은 경향을 보인다는 가정하에 이루어져야 한다.\n\n- 평활성 가정\n  가까이 있는 점들은 서로 같은 부류에 속할 가능성이 높음\n\n- 군집 가정\n  같은 군집에 속하는 데이터는 서로 같은 부류에 속할 가능성이 높음\n\n- 매니폴드(Manifold) 가정\n  원래 차원보다 낮은 차원의 매니폴드에 데이터가 분포할 가능성이 높음","slug":"univ_ai/mid_08","readingMinutes":6,"wordCount":382},{"title":"기계학습 - 지도학습","description":"지도학습에서 사용되는 개념에 대해 알아봅니다.","icon":"","image":"","tags":["Supervised learning","Classification","Regression"],"draft":false,"date":"2023-10-22 / 22:02","content":"\n## 기계학습\n\n사례들(examples)을 일반화하여 패턴 또는 모델을 추출하는 과정으로 학습 데이터를 잘 설명할 수 있는 패턴을 기계 스스로 학습하는 것을 유도하는 것이다.\n\n![231022-220530](/posts/mid_07/231022-220530.png)\n\n단, 오컴의 면도날(Occam's razor) 원리에 따라 가능하면 학습 결과가 간단한 형태로 표현되면 좋다.\n\n기계학습의 종류에는 지도학습, 비지도학습, 반지도학습, 강화학습과 같은 방법이 있는데, 이번에는 지도학습에 대해서만 알아보자.\n\n### 지도학습\n\n주어진 학습 데이터 - **(입력, 출력)** 과 같은 데이터를 이용해서 학습하는 과정.\n학습이 완료된 모델은 새로운 **(입력)** 이 있을 때 **(출력)** 을 유추할 수 있어야 한다.\n\n출력이 불 연속적인 값이어야 한다면 데이터를 `분류`하는 방향으로 학습을 해야하고,\n출력이 연속적인 값이어야 한다면 `회귀`하는 방향으로 학습을 해야한다.\n\n---\n\n## 분류 (Classification)\n\n이상적인 분류기는 학습에 사용되지 않은 데이터에 대해서 분류를 잘 해야한다.\n즉, 일반화의 능력이 좋은것이 이상적인 분류기이다.\n\n\u003ctip\u003e\n  데이터의 종류\n  1. 학습 데이터\n    분류기를 학습하는데 사용하는 데이터 집합.\n  2. 테스트 데이터\n    학습된 모델의 성능을 평가하는데 사용하는 데이터 집합.\n    학습에 사용되지 않은 데이터여야 함.\n  3. 검증 데이터\n    학습 과정에서 학습을 중단할 시점을 결정하기 위해 사용하는 데이터 집합.\n\u003c/tip\u003e\n\n![231022-221446](/posts/mid_07/231022-221446.png)\n\n학습 데이터를 충분히 학습하지 않은 상태를 `부적합` 이라고 한다.\n\n반대로학습 데이터에 대해 지나치게 잘 학습된 상태를 `과적합` 이라고 하는데, 학습되지 않은 데이터에 대해 좋지 못할 성능을 보일 가능성이 크다.\n과적합을 회피하기 위해서 검증 데이터를 사용하게 된다.\n\n![231022-221636](/posts/mid_07/231022-221636.png)\n\n검증 데이터에 대한 오류가 증가하기 시작하면 학습 데이터에 대해 과적합이 일어나는 시점이기 때문에 이 때 학습을 중지하는 것이 좋다.\n\n### 불균형 데이터 문제\n\n특정 부류에 속하는 학습 데이터의 개수가 **다른 부류에 비해 지나치게 많은 경우** 정확도에 의한 성능 평가가 무의미해진다.\n이게 무슨 의미냐면, A 부류의 데이터가 전체 데이터의 99%를 차지한다면, 분류기의 출력을 항상 A로 설정하는 경우 해당 학습 데이터에 대해 99%의 정확도를 보일 것이다.\n하지만, 테스트 데이터에선 A/B가 각각 50% 비율로 들어있다면, 분류기의 정확도는 50%로 감소할 것이다.\n\n![231022-222326](/posts/mid_07/231022-222326.png)\n\n이런 경우 SMOTE 알고리즘을 이용해 어느정도 해결할 수 있다.\n간단하게 설명하면 빈도가 낮은 학습 데이터의 `k-근접 이웃`을 이용해 새로운 데이터를 생성하여 빈도가 낮은 부류의 데이터 개수를 늘리는 알고리즘이다.\n\n### 이진 분류기 성능 평가\n\n이진 분류기는 두 개의 부류만을 갖는 데이터에 대한 분류기로 A/B 둘 중 하나로 분류하는 분류기이다.\n이 분류기는 아래와 같은 예측-결과 표를 생성하는데,\n\n![231022-222646](/posts/mid_07/231022-222646.png)\n\n이것을 이용한 여러가지 지표로 성능을 평가한다.\n\n- 민감도/재현율/진양성율\n  실제 양성일 때, 양성이라고 예측하는 확률이다.\n  \u003e 민감도 = $\\frac{TP}{TP + FN}$\n  \u003e\n  \u003e e.g. 불이났을 때, 불이 났다고 민감하게 알려주는 화재경보기\n\n- 특이도/진음성률\n  실제 음성일 때, 음성이라고 예측하는 확률이다.\n  \u003e 특이도 = $\\frac{TN}{TN + FP}$\n  \u003e\n  \u003e e.g. 불이 안났을 때, 울리지 않는 화재경보기\n\n- 정밀도\n  양성으로 예측을 했는데, 실제로 양성일 확률.\n  \u003e 정밀도 = $\\frac{TP}{TP + FP}$\n  \u003e\n  \u003e e.g. 화재경보기가 경보를 울렸는데, 실제로 불이 난 상황이었음\n\n- 음성 예측도\n  음성으로 예측을 했는데, 실제로 음성일 확률.\n  \u003e 음성 예측도 = $\\frac{TN}{TN + FN}$\n  \u003e\n  \u003e e.g. 화재경보기가 안울렸는데, 실제로 불도나지 않았음\n\n- 위양성율\n  1에서 특이도를 뺀 값.\n  \u003e 위양성율 = $\\frac{FP}{TN + FP}$ = 1 - 특이도\n\n- 위발견율\n  1에서 정밀도를 뺀 값.\n  \u003e 위발견율 = $\\frac{FP}{TP + FP}$ = 1 - 정밀도\n\n- 정확도\n  예측한대로 결과가 나올 확률.\n  \u003e 정확도 = $\\frac{TP + TN}{TP + FP + TN + FN}$\n\n- F1 측도\n  \u003e F1 = 2$\\frac{정밀도 \\times 재현율}{정밀도 + 재현율}$\n\n### ROC 곡선\n\n위양성률, 민감도 그래프로 ROC 곡선의 아래 면적, AUC(Area Under the Curve)가 클수록 바람직하게 분류한다는 뜻이다.\n\n![231022-224153](/posts/mid_07/231022-224153.png)\n\n---\n\n## 회귀 (Regression)\n\n학습 데이터에 부합되는 출력값이 실수인 함수를 찾는 문제로, 앞에서 언급했 듯, 출력이 연속적이어야 하는 경우에 사용하는 방법이다.\n\n![231022-224546](/posts/mid_07/231022-224546.png)\n\n파란 점과 같은 학습 데이터가 주어졌을 떄, 해당 데이터를 가장 잘 설명하는 모델 **$f$** 를 찾기 위해서는 $f$의 오차를 계산하는 함수 **$f*$** 이 최소가 되도록 인자를 조정해야 한다.\n\n$$\nf*(x) = argmin_f \\sum_{i=1}^{n} (y_i - f(x_i))^2\n$$\n\n### 회귀 성능 평가\n\n학습 방향성과 같다.\n테스트 데이터에 대한 오차값의 평균이 작을수록 좋다.\n\n![231022-225021](/posts/mid_07/231022-225021.png)\n\n하지만 처음에 언급했 듯 과적합되는 현상은 피해야 한다.\n\n이를 위해 모델의 복잡도를 일종의 **패널티**로써 성능 평가(목적함수)에 반영하여, 모델의 복잡도를 최소화 하는 방향으로 학습을 유도해야 한다.\n\n### 로지스틱 회귀 (Logistic regression)\n\n모델의 출력이 [0, 1] 사이의 값을 갖도록 조정해야 하는 경우 sigmoid 함수와 같은 로지스틱 함수를 이용해서 학습 데이터의 출력을 근사하는 방식을 사용할 수도 있다.\n\n![231022-225434](/posts/mid_07/231022-225434.png)\n\n단, 이 때의 목적 함수는 `교차 엔트로피`(오차가 0~1 사이로 조정됨)가 적용된 함수를 사용해야 한다.\n\n로지스틱 회귀는 경사 하강법을 사용하는 학습에서 자주 사용된다.","slug":"univ_ai/mid_07","readingMinutes":9,"wordCount":660},{"title":"규칙 기반 시스템","description":"지식을 규칙의 형태로 표현하는 방법에 대해 알아봅니다.","icon":"","image":"","tags":["전향 추론","후향 추론","규칙 기반 시스템"],"draft":false,"date":"2023-10-22 / 19:59","content":"\n## 추론\n\n구축된 지식과 주어진 데이터, 정보를 이용해 새로운 사실을 생성하는 것으로 전향(순방향) 추론과 후향(역방향) 추론으로 나뉜다.\n\n### 전향 추론\n\n규칙의 조건부와 만족하는 사실이 있을 때 규칙의 결론부를 실행하거나 처리하는 방식으로 아래와 같이 순방향으로 추론하는 방식이다.\n\n![231022-200403](/posts/mid_06/231022-200403.png)\n\n### 후향 추론\n\n어떤 사실을 검증하거나 확인하고 싶은 경우에 관심 대상의 사실을 결론부에 갖고 있는 규칙을 찾아서 조건부가 만족하는지를 확힌하는 방식으로 아래와 같이 역방향으로 추론하는 방식이다.\n\n![231022-200616](/posts/mid_06/231022-200616.png)\n\n---\n\n## 규칙 기반 시스템\n\n지식을 규칙과 사실로 기술하며 아래와 같은 구조로 관리된다.\n\n![231022-200851](/posts/mid_06/231022-200851.png)\n\n**문제 해결을 위한 지식**인 `규칙`은 규칙 베이스에서 관리되며, 생성 메모리 라고도 불린다.\n\n**문제에 대해 알려진 데이터나 정보**인 `사실`은 작업 메모리에서 관리된다.\n참고로, 추론 과정의 중간 결과나 사용자로부터 받은 문제에 대한 정보 역시 여기서 관리된다.\n\n### 추론 엔진\n\n실행할 수 있는 규칙을 찾아 해당 규칙을 실행하는데 아래의 3단계의 과정을 반복한다.\n\n1. 패턴 매칭\n  작업 메모리의 사실과 규칙 메모리에 있는 규칙의 조건부를 대조하여 일치하는 규칙을 찾아냄.\n\n2. 경합 해소\n  찾아낸 규칙 중 경합되는 규칙(경합 집합)에 대해 하나의 규칙을 선택함.\n  경합 해소 전략에는 다음과 같은 전략이 있음.\n\n    \u003e 1. 규칙 우선\n    \u003e 미리 규칙에 우선순위를 부여하고, 경합시 우선순위가 높은 규칙을 우선 선택\n    \u003e 우선순위 태그 기준\n    \u003e ![231022-201805](/posts/mid_06/231022-201805.png)\n    \u003e\n    \u003e 2. 최신 우선\n    \u003e 가장 최근에 입력된 데이터와 매칭된 규칙을 우선 선택\n    \u003e 시간 태그 기준\n    \u003e ![231022-201845](/posts/mid_06/231022-201845.png)\n    \u003e\n    \u003e 3. 최초 우선\n    \u003e 경합 집합에서 가장 먼저 매칭된 규칙을 우선 선택\n    \u003e\n    \u003e 4. 상세 우선\n    \u003e 조건부가 가장 상세하거나 복잡한 규칙을 우선 선택\n    \u003e 태그말고 조건문의 길이 기준\n    \u003e ![231022-201826](/posts/mid_06/231022-201826.png)\n    \n\n3. 규칙 실행","slug":"univ_ai/mid_06","readingMinutes":4,"wordCount":241},{"title":"불확실한 지식 표현","description":"불확실한 지식을 표현하는 방법에 대해 알아봅니다.","icon":"","image":"","tags":["Certainty factor","Probability","Fuzzy"],"draft":false,"date":"2023-10-22 / 19:10","content":"\n인과성이 약하거나, 연관성이 애매하거나, '얼마나?'에 해당하는 정도가 모호한 문장을 정량화 하는 방법에 대해 알아봅니다.\n\n## 확신도 (Certainty factor)\n\n규칙과 사실의 신뢰정도를 [-1, 1] 구간의 값으로 표현합니다.\n\n| 확신도 | 대응되는 단어 |\n|---|---|\n| −1.0 | 절대 아니다 (definitely not)|\n| −0.8 | 거의 확실히 아니다 (almost certainly not) |\n| −0.6 | 아마 아니 것이다 (probably not) |\n| −0.4 | 어쩌면 아닐 것이다 (maybe not) |\n| −0.2 ~ 0.2 | 모르겠다 (unknown) |\n| 0.4 | 어쩌면 그럴 것이다 (maybe) |\n| 0.6 | 아마 그럴 것이다 (probably) |\n| 0.8 | 거의 확실하다 (almost certainly) |\n| 1.0 | 확실하다 (definitely)|\n\n### 추론결과의 확신도\n\n추론에 대한 확신도는 각 명제에 대한 확신도를 계산하여 도출해야 합니다.\n\n- IF A THEN B _($\\{A \\rightarrow B, \\; A\\} \\vdash B$)_\n  기본적으로 정형식들의 확신도를 곱하는 방식으로 구합니다.\n  \u003e **$cf(B) = cf(A) \\times cf(A \\rightarrow B)$**\n\n- IF A and B THEN C _($\\{A \\wedge B \\rightarrow C, \\; A, \\; B\\} \\vdash C$)_\n  **and**의 경우 조건부에 해당하는 정형식의 확신도 중 작은 값을 고릅니다.\n  \u003e **$cf(C) = min\\{cf(A), cf(B)\\} \\times cf(A \\wedge B \\rightarrow C)$**\n\n- IF A or B THEN C _($\\{A \\vee B \\rightarrow C, \\; A, \\; B\\} \\vdash C$)_\n  **or**의 경우 조건부에 해당하는 정형식의 확신도 중 큰 값을 고릅니다.\n  \u003e **$cf(C) = max\\{cf(A), cf(B)\\} \\times cf(A \\vee B \\rightarrow C)$**\n\n아래는 예시입니다.\n\n![231022-192422](/posts/mid_05/231022-192422.png)\n\n만약, 여러 사실에 의해 동일한 사실을 추론하는 경우 추론 결과는 같지만, 확신도는 다르게 계산될 수 있습니다.\n이런 경우, 확신도를 하나로 통합하는게 좋습니다.\n\n![231022-192640](/posts/mid_05/231022-192640.png)\n\n---\n\n## 확률 (Probability)\n\n어떤 사건이 일어날 가능성을 표현할 때 사용합니다.\n\n### 결합 확률\n\n사건 A, B가 동시에 일어날 확률을 가리키며, 아래와 같이 수식화 할 수 있습니다.\n\n\u003e A: 첫 번째 주사위가 짝수\n\u003e B: 두 번째 주사위가 홀수\n\u003e\n\u003e $P(A,B) = P(A \\cap B) = P(AB)$\n\u003e $= 1/2 \\times 1/2 = 0.25$\n\n### 조건부 확률\n\n사건 B가 일어났을 때, 사건 A가 일어날 확률을 가리키며, 아래와 같이 수식화 할 수 있습니다.\n\n\u003e A: 두 주사위의 합이 8\n\u003e B: 첫 번째 주사위가 3\n\u003e\n\u003e $P(A|B) = \\frac{P(A,B)}{P(B)}$\n\u003e $= \\frac{1/36}{1/6} = 1/6$\n\n`베이즈 정리`에 의해 조건부 확률의 조건부를 변형할 수 있습니다.\n\n\u003e $P(A|B) = \\frac{P(B|A)P(A)}{P(B)}$\n\n---\n\n## 퍼지 이론 (Fuzzy theory)\n\n기존 집합론과 다르게 퍼지 이론은 0/1의 이분법적으로 분류하지 않고, 0~1로 모호하게(어느정도 포함되게) 구분함.\n즉, 어느 정도(degree)의 문제는 퍼지 집합을 도입하여 해결.\n\n### 퍼지 집합\n\n원소가 모임(collection)에 어느 정도 속한다는 것을 표현한 것으로, 해당 집합은 부분적으로 참이 됨.\n소속정도는 [0, 1] 범위의 실수값으로 표현함.\n\n작다, 평균이다, 크다의 표현을 아래와 같이 다르게 할 수 있음.\n\n![231022-194330](/posts/mid_05/231022-194330.png)\n\n### 퍼지 규칙\n\n소속함수로 표현된 언어항을 표함하는 규칙.\n\n\u003e IF service = 나쁘다 OR food = 별로이다 THEN tip = 적다\n\u003e IF service = 보통이다 THEN tip = 보통이다\n\u003e IF service = 훌륭하다 OR food = 맛있다 THEN tip = 많다\n\n\u003ctip\u003e\n  `언어항`\n  '나쁘다', '맛있다', '많다'와 같은 자연어에 해당하는 항으로 소속함수로 표현될 수 있다. \n  ![231022-194851](/posts/mid_05/231022-194851.png)\n\u003c/tip\u003e\n\n### 퍼지 추론\n\n소속함수로 표현돤 언어항을 사용하는 퍼지 규칙들의 모음으로 수치적인 추론이 가능해진다.\n\n![231022-195645](/posts/mid_05/231022-195645.png)\n\n추론된 영역의 무게중심을 결과로 사용하면 `비퍼지화`가 가능하다.","slug":"univ_ai/mid_05","readingMinutes":5,"wordCount":496},{"title":"명제 논리 \u0026 술어 논리","description":"지식을 표현하는 방법 - 논리에 대해 알아봅니다.","icon":"","image":"","tags":["Proposition","Predicate"],"draft":false,"date":"2023-10-22 / 15:48","content":"\n말로 표현된 문장을 타당한 추론을 위해 기호를 사용하여 표현하고, 기호의 조작을 통해 참과 거짓을 판정하는 분야이다.\n\n## 명제 논리\n\n### 명제 (Proposition)\n\n`명제`란, 참과 거짓을 분평하게 판정할 수 있는 문장으로 P, Q와 같은 기호로 표현된다.\n\n중요한 점은, 명제 그 자체는 참, 거짓을 결정할 수 없고, 반드시 기호의 진리값을 설정해 줘야 한다는 점이다.\n이게 무슨 말이냐면, 아래의 문장을 예로 들어 설명해보겠다.\n\n\u003e 오징어 다리는 10개 이다.\n\n이 명제는 우리나라에서는 참이다.\n하지만 북한에서는 오징어 라는 명사는 우리나라의 낙지를 가리키는 말 이기 때문에 북한에서는 거짓인 명제이다.\n\n즉, 문장 자체의 내용에 대해서는 관심을 갖지 말고, 문장의 설정된 `진리값에만 관심`을 가져야 한다.\n\n_**용어 설명**_\n| 용어 | 의미 |\n|---|---|\n| 기본 명재 | 하나의 진술로만 이루어진 최소 단위의 명제 |\n| 복합 명제 | 기본 명제들이 결합되어 만들어진 명제 |\n\n### 논리식 (Logical expression)\n\n명제를 기호로 표현한 형식으로 명제기호, T/F, 논리 기호를 사용하여 구성되는데, 가장 기본이 되는 논리 기호는 다음과 같다.\n\n| 논리기호 | 이름 | 논리식 | 의미 |\n|---|---|---|---|\n| $\\neg$ | 부정 (negation) | $\\neg P$ | $P$가 아님 |\n| $\\vee$ | 논리합 (disjunction) | $P \\vee Q$ | $P$ 또는 $Q$ |\n| $\\wedge$ | 논리곱 (conjunction) | $P \\wedge Q$ | $P$ 그리고 $Q$ |\n| $\\rightarrow$ | 함의 (implication) | $P \\rightarrow Q$ | $P$ 이면 $Q$ |\n| $\\equiv$ | 동치 (equivalence) | $P \\equiv Q$ | $(P \\rightarrow Q) \\wedge (Q \\rightarrow P)$ |\n\n_**용어 설명**_\n| 용어 | 의미 |\n|---|---|\n| 리터럴 | 명제 기호 또는 명제 기호의 부정 |\n| 절 | 리터럴들이 논리합이나 논리곱으로만 연결 (논리합 절, 논리곱 절) |\n| 논리곱 정규형 (CNF) | 논리합 절들이 논리곱으로 연결되어 있는 논리식 |\n| 논리합 정규형 (DNF) | 논리곱 절들이 논리합으로 연결되어 있는 논리식 |\n| 정형식 (WFF) | 진리값(T/F)과 명제, 그들과 논리 기호를 사용하여 구성된 논리식을 의미함 |\n\n### 진리표 (Truth table)\n\n논리기호에 따라 T/F를 결합하는 방법을 나타낸 표\n\n| $P$ | $Q$ | $\\neg P$ | $P \\vee Q$ | $P \\wedge Q$ | $P \\rightarrow Q$ | $P \\equiv Q$ |\n|---|---|---|---|---|---|---|\n| F | F | **T** | F | F | **T** | **T** |\n| F | **T** | **T** | **T** | F | **T** | F |\n| **T** | F | F | **T** | F | F | F |\n| **T** | **T** | F | **T** | **T** | **T** | **T** |\n\n- 타당한 논리식 (Valid logical expression), 항진식\n  모든 가능한 해석에 대해 항상 참인 논리식\n  _e.g. $P \\vee \\neg P$_\n\n- 항위식\n  모든 가능한 해석에 대해 항상 거짓인 논리식\n  _e.g. $P \\wedge \\neg P$_\n\n- 츙족가능한 논리식\n  참으로 만들 수 있는 해석이 하나라도 있는 논리식\n\n- 충족불가능한 논리식\n  참으로 만들 수 있는 해석이 하나도 없는 논리식. 즉, 항위식.\n\n### 동치 관계 (Equivalence relation)\n\n어떠한 해석에 대해서도 같은 진리 값을 갖는 두 논리식\n\n- $\\neg(\\neg p) \\equiv p$\n- $p \\vee F \\equiv p$\n  $p \\wedge T \\equiv p$\n- $P \\vee \\neg P \\equiv T$\n  $P \\wedge \\neg P \\equiv F$\n- **$\\neg (p \\wedge q) \\equiv \\neg p \\vee \\neg q$**\n  **$\\neg (p \\vee q) \\equiv \\neg p \\wedge \\neg q$**\n- **$p \\rightarrow q \\equiv \\neg p \\vee q$**\n- $p \\vee (q \\vee r) \\equiv p \\vee q \\vee r$\n  $(p \\wedge q) \\wedge r \\equiv p \\wedge q \\wedge r$\n- **$p \\vee (q \\wedge r) \\equiv (p \\vee q) \\wedge (p \\vee r)$**\n  **$p \\wedge (q \\vee r) \\equiv (p \\wedge q) \\vee (p \\wedge r)$**\n\n### 논리적 귀결 (Logical entailment)\n\n정형식(Well-Formed Formula, WFF)의 집합 $\\Delta$가 다른 정형식 $\\omega$를 참으로 만든다면 두 관계를 아래와 같이 정의한다.\n\n\u003e $\\Delta \\models \\omega$\n\u003e e.g. $\\{P, \\; P \\rightarrow Q\\} \\models Q$\n\u003e\n\u003e $\\Delta$는 $\\omega$를 논리적으로 귀결한다.\n\u003e $\\omega$는 $\\Delta$를 논리적으로 따른다.\n\u003e $\\omega$는 $\\Delta$의 논리적 결론이다.\n\n### 추론 (Inference)\n\n논리적 귀결을 도출하는 과정을 추론이라고 한다.\n\n관측된 복수의 사실들을 일반화하여 일반적인 패턴(명제)를 도출하는 것을 `귀납적 추론` 이라고 하고,\n참인 명제(사실)들로부터 새로운 명제(사실)을 도출하는 것을 `연역적 추론` 이라고 한다.\n\n논리에서의 추론은 보통 **연역적 추론**을 가리키는데, 이걸 도출하는 테크닉에 대해 살펴보자.\n\n- 긍정 논법\n  $\\{p \\rightarrow q, \\; p\\} \\vdash q$\n  _(\\{새이다 \u0026rarr; 날 수 있다, 새이다\\} \u0026rarr; 날 수 있다)_\n\n- 부정 논법\n  $\\{p \\rightarrow q, \\; \\neg q\\} \\vdash \\neg p$\n  _(\\{새이다 \u0026rarr; 날 수 있다, 날 수 없다\\} \u0026rarr; 새가 아니다)_\n\n- 삼단 논법\n  $\\{p \\rightarrow q, \\; q \\rightarrow r\\} \\vdash p \\rightarrow r$\n  _(\\{새이다 \u0026rarr; 날개가 있다, 날개가 있다 \u0026rarr; 날 수 있다\\} \u0026rarr; 새이다 \u0026rarr; 날 수 있다)_\n\n- **논리 융합 (Resolution)**\n  긍정, 부정, 삼단 논법을 포함한 일반화된 추론 규칙으로 \n  두 개의 **논리합 절**이 같은 기호의 긍정-부정 리터럴을 서로 포함하고 있을 때, 해당 리터럴을 제외한 나머지 리터럴의 논리합 절을 만들어 내는 것.\n\n  | 논법 | 변환 | WFF (논리 융합식, Resolvent) |\n  |---|---|---|\n  | $p \\rightarrow q, \\; p$ | **$\\neg p$** $\\vee q$, **$p$** | $q$ |\n  | $p \\rightarrow q, \\; \\neg q$ | $\\neg p \\vee$ **$q$**, **$\\neg q$** | $\\neg p$ |\n  | $p \\rightarrow q, \\; q \\rightarrow r$ | $\\neg p \\vee$ **$q$**, **$\\neg q$** $\\vee r$ | $\\neg p \\vee r$ ($p \\rightarrow r$) |\n\n  즉, 논리 융합을 사용하면 모든 추론 규칙을 일반화 할 수 있다.\n\n- 정당성 (sound)\n  $\\Delta \\vdash \\omega \\; \\rightarrow \\; \\Delta \\models \\omega$ (아야 sound)\n\n- 완전성 (complete)\n  $\\Delta \\models \\omega \\; \\rightarrow \\; \\Delta \\vdash \\omega$ (야아 complete 하네)\n\n  \u003ctip\u003e\n    정당성과 완전성을 동시에 만족하는 추론 규칙은 논리적인 귀결과 동일시 할 수 있다.\n  \u003c/tip\u003e\n\n### 증명 (Proof)\n\n- 구성적 증명 (Constructive proof)\n  공리(참인 논리식)들에 추론 규칙을 적용하여 참을 만들어 보이는 증명.\n  정리하다가 결론이 참으로 끝나면 된다.\n\n- 논리융합 반박 (Resoultion refutation)\n  증명할 정리를 일단 부정하고, 논리융합 방법을 적용해 모순이 발생함으로 보이는 증명.\n  부정된 정리가 모순이니, 원상태의 정리는 참이 된다.\n\n  ![231022-171322](/posts/mid_04/231022-171322.png)\n\n---\n\n## 술어 논리\n\n명제의 내용을 다루기 위해 변수, 함수 등을 도입하고, 이들의 값에따라 T/F가 결정되도록 명제 논리를 확장한 논리.\n\n### 술어 (Predicate)\n\n대상의 속성이나 관계를 기술하는 기호로, 대상에게 T/F를 부여하는 명제의 기본 형식이다.\n\n| 문장 | 명제 논리 | 술어 논리 |\n|---|---|---|\n| 모든 사람은 죽는다 | P | $\\forall x(사람(x) \\rightarrow 죽는다(x))$ |\n| 소크라테스는 사람이다 | Q | $사람(소크라테스)$ |\n| 소크라테스는 죽는다 | R | $죽는다(소크라테스)$ |\n\n\u003ctip\u003e\n  `존재 한정사`\n  Existential quantifier로 존재함을 알려준다. (**$\\exist$**)\n  \u003cbr /\u003e\n  `전칭 한정사`\n  Universal quantifier로 모든 범위를 가리킨다. (**$\\forall$**)\n\u003c/tip\u003e\n\n### 함수 (function) / 항 (term)\n\n주어진 인자에 대해 T/F를 반환하는 것이 아닌, 일반작인 값을 반환하는 것을 `함수`라고 한다.\n즉, 인자를 지칭하기 위해 쓰인다.\n\n함수의 인자가 될 수 있는 것을 `항` 이라고 한다.\n**상수, 변수, 함수**만이 항이 될 수 있다.\n\n\u003ctip\u003e\n  명제 논리식의 정형식(WFF)과 마찬가지로, 술어 논리식의 정형식 역시 비슷한 정의를 갖는다.\n  항, 논리 기호, 한정사로만 이루어진 식을 정형식이라고 부른다.\n\u003c/tip\u003e\n\n### N차 술어 논리 (N-order predicate logic)\n\n**변수에만** 한정사를 사용할 수 있도록 한 술어 논리를 `일차 술어논리(FOL)` 라고 한다.\n엄밀히는, 술어기호의 인자로 사용될 수 있는 객체나 대상만을 변수화 할 수 있고, 이들 변수에만 전칭 한정사와 존재 한정사를 쓸 수 있도록 한 술어논리를 말한다.\n\n**변수, 함수, 술어기호**에 대해 한정사를 쓸 수 있도록 한 술어 논리를 `고차 술어논리(HOL)` 라고 한다.\n엄밀히는, 함수나 술어기호도 변수화 할 수 있고, 이들 변수에만 전칭 한정사와 존재 한정사를 쓸 수 있도록 한 술어논리를 말한다.\n\n인공지능 분야에서는 **연산량의 한계** 때문에 `일차 술어논리`를 주로 사용한다.\n\n### CNF 변환\n\n아래의 변환 과정을 거친면 된다.\n\n1. 한정사를 논리식의 맨 앞으로 끌어내는 변환\n  일반적으로 한정사를 맨 앞으로 끌어내도 의미는 변하지 않지만, 그래도 최다한 할 수 있는 변환을 한 뒤에 끌어내자.\n\n2. 전칭 한정사 제거\n  $\\forall$은 바로 제거해도 상관없다.\n\n3. 존재 한정사 제거\n  우선 아래와 같은 방식으로 전칭 한정사로 변환한 뒤 전칭 한정사를 제거하는 방법을 사용한다.\n  **$\\neg \\exist x P \\equiv \\forall x \\neg P$**\n\n    만일 함수에 변수가 2개 이상 사용된 경우 변환이 어려울 때는 상수를 집어넣거나 스콜렘 함수로 변환한다.\n    $\\forall x \\exist y [P(x) \\wedge$ **$Q(x, y)$**$] \\rightarrow \\forall x [P(x) \\wedge$ **$Q(x, s(x))$**$]$\n\n4. 단일화\n  논리 융합을 적용할 때, 대응되는 리터럴이 같아지도록 상수를 변수화 함.\n  ![231022-175353](/posts/mid_04/231022-175353.png)\n\n변환 과정을 거쳐 논리융합 반박을 통해 증명하는 예시를 살펴보자.\n아래의 예시는 (5)의 모순을 보임으로써 $\\neg$(5)가 참임을 보이는 논리융합 반박이다.\n\n![231022-175534](/posts/mid_04/231022-175534.png)","slug":"univ_ai/mid_04","readingMinutes":13,"wordCount":1309},{"title":"프레임 \u0026 의미망 \u0026 스크립트","description":"지식을 표현하는 방법 - 프레임, 의미망, 스크립트에 대해 알아봅니다.","icon":"","image":"","tags":["Frame"],"draft":false,"date":"2023-10-22 / 15:35","content":"\n## 프레임 (Frame)\n\n특정 객체 또는 개념에 대한 전형적인 지식을 슬롯(slot)의 집합으로 표현하는 것으로, 컴퓨터를 표현한 프레임은 다음과 같이 기술할 수 있다.\n\n![231022-153840](/posts/mid_03/231022-153840.png)\n\n### 슬롯 (slot)\n\n객체의 속성(attribute)를 기술하는 것으로 슬롯 이름과 값으로 구성된다.\n슬롯 값은 복수개의 `패싯`과 `데몬`으로 구성된다.\n\n- 패싯 (facet)\n  속성에 대한 부가적인 정보를 저장하기 위해 사용되며 아래와 같은 패싯 이름들을 사용할 수 있다.\n  - value: 속성 값\n  - data-type: 속성의 자료형\n  - default: 기본 값\n  - require: 슬롯에 들어갈 수 있는 값이 만족해야 할 제약조건\n\n- 데몬 (demon)\n  ![231022-154436](/posts/mid_03/231022-154436.png)\n\n  지정된 조건을 만족할 때 실행할 절차적 지식을 기술하는데 사용되며, 아래와 같은 데몬 이름들을 사용할 수 있다.\n  - if_needed: 슬롯 값을 알아야 할 때(즉, 사용하려고 할 때)\n  - if_added: 슬롯 값이 추가될 때\n  - if_removed: 슬롯 값이 제거될 때\n  - if_modified: 슬롯 값이 수정될 때\n\n### 클래스 프레임\n\n위에서 프레임을 설명할 때 사용한 프레임이 클래스 프레임이다.\n\n\u003ctip\u003e\n  하위 프레임이 상위 프레임을 상속받는 계층구조도 가질 수 있음.\n\u003c/tip\u003e\n\n### 인스턴스 프레임\n\n![231022-154657](/posts/mid_03/231022-154657.png)\n\n클래스 프레임을 특정 객체에 대한 정보로 표현하면 인스턴스 프레임이 된다.\n그냥 OOP와 같은 개념이다.\n\n---\n\n## 의미망 (Semantic network)\n\n![231022-184947](/posts/mid_03/231022-184947.png)\n\n노드와 방향성 간선으로 구성되는 그래프를 이용해 지식을 표현하는 방법으로, 이항 관계만을 표현한다.\n그렇기에 다항 관계도 이항 관계로 전개하여 표현해야 하는데, 그 때문에 관계(relation) 역시 객체로 간주하여 표현한다.\n\n![231022-185755](/posts/mid_03/231022-185755.png)\n\n- `is-a`\n  자식 is-a 부모, 인스턴스 is-a 클래스와 같은 관계의 간선을 표현한다.\n\n- `has-a`\n  전체 has-a 부분, 부분 part-of 전체와 같은 관계의 간선을 표현한다.\n\n\u003ctip\u003e\n  is-a, has-a는 추이적 관계를 만족하는데, 추이적 관계란, 3단논법과 같은 관계를 의미함.\n  \n  \u003e is-a(팽귄, 조류) $\\wedge$ is-a(조류, 동물) \u0026rarr; is-a(팽귄, 동물)\n\u003c/tip\u003e\n\n지식을 시각적으로 표현할 수 있어 직관적으로 이해할 수 있고, 노드 추가 및 변경이 자유롭다는 장점이 있다.\n하지만, 양이 많아지면 관리가 복잡해지고, 개념이나 관계를 임의로 정의하기에 통일성이 떨어진다는 단점이 있다.\n\n### 추론\n\n상속관계를 이용해서 추론한다.\n예로 들어 '바둑기사의 키는?' 이라는 질문은 다음과 같이 추론할 수 있다.\n\n![231022-190024](/posts/mid_03/231022-190024.png)\n\n뿐만 아니라, 주어진 지식으로부터 새로운 사실을 이끌어내는 추론도 가능하다.\n예로 들어 '사람1이 사람2에게 사물1을 준다'는 지식으로부터, '사람2는 사물1을 소유하게 된다'는 사실을 추론한다.\n\n![231022-190213](/posts/mid_03/231022-190213.png)\n\n### 프레임으로 변환\n\n![231022-190324](/posts/mid_03/231022-190324.png)\n\n노드별로 프레임으로 변환할 수 있는데, 노드에서 나가는 간선들을 슬롯으로 구성하면 된다.\n\n---\n\n## 스크립트 (Script)\n\n일반적으로 발생할 수 있는 전형적인 상황에 대한 절차적 지식을 일목요연하게 표현한 것이다.\n\n![231022-190644](/posts/mid_03/231022-190644.png)\n\n- 진입 조건\n  스크립트에 기술된 사건들이 일어나기 전에 만족되어야 하는 전제조건\n\n- 역할자\n  스크립트에 관련된 사람, 대상\n\n- 자산\n  사건 진행 과정에서 사용되는 객체\n\n- 트랙\n  스크립트에서 발생할 수 있는 사건들이 변형된 형태 식별자 (장소)\n\n- 장면\n  실제 일어나는 일련의 사건\n  \n- 결과 조건\n  스크립트의 장면에 있는 사건들이 일어난 후에 만족되는 조건","slug":"univ_ai/mid_03","readingMinutes":6,"wordCount":401},{"title":"게임에서의 탐색 및 최적화","description":"게임 트리를 탐색하는 기법과 최적화에 대해 알아봅니다.","icon":"","image":"","tags":["Mini-Max algorithm","Alpha-Beta prunning","Monte Carlo","Backtracking search","Constraint propagation","Genetic algorithm","Regression"],"draft":false,"date":"2023-10-21 / 22:53","content":"\n## 게임 트리\n\n`상대가 있는 게임`에서 자신과 상대방의 가능한 게임 상태를 나타낸 트리.\n자신의 턴인지, 상대의 턴인지에 따라 탐색하는 방식이 다르게 적용됨.\n(나에겐 유리하게, 상대에겐 불리하게)\n\n정해진 시간 내에 최대한 많은 수를 보는 것이 유리하기 때문에 탐색 효율을 높이는 것이 중요하다.\n\n### Mini-max Algorithm\n\n특이하게 단말 노드로부터 위로 올라가면서 최소-최대 연산을 반복하여 자신이 선택할 수 있는 방법 중 가장 좋은 값을 선택하는 방법이다.\n\n자신의 턴인 Max 노드에서는 자신에게 유리한 값을 선택하고,\n상대의 턴인 Min 노드에서는 상대에게 불리한 값을 선택하는 방식을 취한다.\n\n![231021-230224](/posts/mid_02/231021-230224.png)\n\n하지만 트리가 넓을 수록 모든 상태공간을 탐색하는건 시간상 너무 오래 걸리기 때문에 최적화 기법이 들어가야 한다.\n바로 **$\\alpha - \\beta$ 가지치기(prunning)** 기법이다.\n\n검토해 볼 필요가 없는 부분을 탐색하지 않도록 하는 기법인데, 어떻게 해야 검토할 필요가 없다는 걸 알 수 있을까?\n\n깊이 우선 탐색(DFS)로 제한 깊이까지 탐색을 하면서 Min, Max 노드의 $\\alpha$, $\\beta$값을 업데이트 하는데, 각 $\\alpha$, $\\beta$값은 다음과 같은 값을 저장한다.\n\n- $\\alpha$\n  Max 노드에서만 값이 업데이트되며, 현재까지 확보한 자식의 값 중 최댓값을 저장함\n\n- $\\beta$\n  Min 노드에서만 값이 업데이트되며, 현재까지 확보한 자식의 값 중 최솟값을 저장함\n\n이 때, 탐색 후 값을 업데이트 하다가 **$\\alpha \\geq \\beta$** 되는 순간이 오는데, 그 때부터 나머지 자식노드는 탐색할 필요가 없어진다.\n그 이유는, 상한선($\\alpha$)과 하한선($\\beta$)이 정해질 때, 그 부모노드의 상한선과 하한선을 넘지 못하면 부모노드를 업데이트 할 수 없기에, 업데이트를 할 가능성이 없다면 가지치기를 해버리는 것이다.\n\n알고리즘의 이해가 안된다면 아래 영상을 참고하면 좋을 거 같다.\n\n\u003cYT id=\"_i-lZcbWkps\" /\u003e\n\n속성으로 빠르게 탐색하고 싶다면 이런 방식으로 탐색해도 된다.\n\n\u003cYT id=\"6qN5ReC2SUA\" /\u003e\n\n빠르게 업데이트 가능한 조건을 적어놓고, 그 조건이 업데이트가 절대로 불가능하다면 나머지 노드를 가지치기 하는 방식이다.\n\n### 몬테카를로 트리 탐색 기법 (Monte Carlo Simulation)\n\n![231022-003000](/posts/mid_02/231022-003000.png)\n\n탐색 공간을 무작위 표본추출을 하면서 탐색 트리를 확장하여 가장 좋아보이는 것을 선택하는 휴리스틱 탐색 방법으로,\n시간이 허용되는 동안 위의 4단계를 반복하여 시뮬레이션 및 트리를 확장한다.\n\n1. 선택\n  선택은 **트리 정책**을 적용하여 선택한다.\n  정책은 개발자 마음대로 정하는 거지만, 보통 승률과 노드 방문횟수를 고려하여 선택한다.\n  일반적으로 `승률이 높으며`, `방문횟수가 적은` 노드에 우선권을 부여한다 (UCB, Upper Confidence Bound 정책).\n\n2. 확장\n  단말 노드에서 트리 정책에 따라 노드를 추가한다.\n\n3. 시뮬레이션\n  기본 정책에 의한 `몬테카를로 시뮬레이션`을 적용한다.\n  무작위 선택, 또는 약간 똑똑한 방법으로 게임이 끝날 때 까지 진행한다.\n\n  \u003ctip\u003e\n  `몬테카를로 시뮬레이션`\n  \u003cbr /\u003e\n  특정 확률 분포로 부터 무작위 표본(또는 약간 똑똑한 방법으로)을 생성하고, 이 표본에 따라 행동을 하는 과정을 반복하여 결과를 확인하고 이 과정을 반복해 최정 결정을 하는 것.\n  \u003cbr /\u003e\n  특정 상태의 유불리를 상태판단함수로 판단하는 것이 아닌, 시뮬레이션으로 판단하게 된다.\n  \u003c/tip\u003e\n\n4. 역전파\n  게임의 결과를 단말 노드에서 루트 노드까지 올라가면서 반영한다.\n\n---\n\n## 제약조건 만족 문제\n\n주어진 제약조건을 만족하는 조합 해(combination solution)을 찾는 문제로 N-Queens problem과 같은 문제가 이에 해당한다.\n\n### 백 트래킹 탐색 (Backtracking search)\n\n깊이 우선 탐색(DFS)을 하는 것처럼 변수에 허용되는 값을 하나씩 대입해보고, 가능한 모든 값을 대입했는데도 만족하는 것이 없으면 이전 단계로 돌아가서 이전 단계의 변수에 다른 값을 대입하는 전형적인 백 트래킹 방식이다.\n\n### 제약조건 전파 (Constraint propagation)\n\n인접 변수 간의 제약 조건에 따라 각 변수에 허용될 수 없는 값들을 제거하는 방식으로, 이름 그대로 주변에 제약조건을 전파하여 선택 가능한 가지수를 줄여가는 방식이다.\n\n![231022-004410](/posts/mid_02/231022-004410.png)\n\nA에 1을 선택하는 순간 B\\~D에 각각 제약사항이 전파되어 B\\~D에서 선택할 수 있는 가지수가 제한된다.\n여기서 B가 3을 선택하는 순간 C, D에 각각 제약사항이 또 전파되는데, 이 때 C는 더이상 아무것도 선택할 수 없기에 이전 스탭에서 다른 제약사항을 걸어야 한다.\n\n---\n\n## 최적화\n\n여러가지 가능, 혀용되는 값들 중에서 주어진 기준을 가장 잘 만족하는 것을 선택하는 것으로, 크게 `조합 최적화`와 `함수 최적화`로 나뉜다.\n\n### 조합 최적화\n\nTSP와 같이 주어진 항목들의 조합으로 해가 표현되는 최적화 문제로, 이 경우에는 경로의 길이를 최소화 하는 문제이다.\n\n![231022-005505](/posts/mid_02/231022-005505.png)\n\n이를 달성하기 위해 생물의 진화를 모방한 집단 기반 확률적 탐색 기법인 `유전 알고리즘`을 사용하기도 한다.\n\n개체는 염색체로 표현되며 다음과 같이 기술된다.\n\n![231022-005704](/posts/mid_02/231022-005704.png)\n\n이런 염색체들의 집합을 `모집단`이라고 하는데, 이런 모집단(후보해)가 문제의 해로서 적합한 정도를 `적합도 함수`가 판단하게 되고, 적합하다면 최적 개체로서 알고리즘이 종료되지만, 적합하지 않다면 **진화의 과정**을 거치게 된다.\n\n모집단이 진화를 할 때는 우선 `부모 모집단` 중 개체를 선택하게 되는데, **가능한 높은 적합도의 개체가 선택되도록 확률을 높게** 조정한다.\n자연선택과 같이 **랜덤**한 요소가 있어야 하기에 반드시 적합한 녀석이 선택되지는 않는다.\n\n이후에는 선택된 부모 개체가 `유전 연산`을 거쳐 자식 개체를 양산하게 되는데, 유전 연산에는 다음과 같은 연산을 고려할 수 있다.\n\n![231022-010201](/posts/mid_02/231022-010201.png)\n\n이후에는 생성된 여러 자식 개체를 이용해서 `세대를 교체`하게 되는데, **최대한 많은 우수한 계체가 다음 세대에 유지**될 수 있도록 `엘리트주의`를 적용한다.\n\n### 목적 최적화\n\n어떤 목적 함수(Objective function)가 있을 때, 이 함수를 최대로 하거나 최소로 하는 변수 값을 찾는 최적화 문제이다.\n\n![231022-010440](/posts/mid_02/231022-010440.png)\n\n`최소 평균제곱법`을 사용해서 회귀(Regression) 문제의 최적함수를 찾거나,\n\n![231022-010602](/posts/mid_02/231022-010602.png)\n\n함수의 최소값 위치를 찾는 문제에서 `경사 하강법`과 같은 방법을 사용할 수 있다.","slug":"univ_ai/mid_02","readingMinutes":11,"wordCount":724},{"title":"Iterator Pattern","description":"Iterator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Iterator Pattern"],"draft":false,"date":"2023-10-21 / 20:22","content":"\n## 필요성\n\n사람마다 개발 스타일이 다르다.\n하물며 List, ArrayList 등, 어떤 자료구조가 익숙하냐에 따라 사용하는 데이터 타입 역시 다르다.\n\n만약 분업을 하는데 있어 사람 A는 List, B는 ArrayList를 사용했다고 해보자.\n이렇게 자료구조가 다를 경우, 순차탐색에 있어 코드의 구현이 달라진다.\n\n```java:.java\n// List\nfor (int i=0; i\u003cmyList.length; i++) {\n  myList[i];\n}\n\n// ArrayList\nfor (int i=0; i\u003cmyArrayList.size(); i++) {\n  myArrayList.get(i);\n}\n```\n\n만약 위의 순차탐색에서 동작하는 기능이 동알하다면?\n자료구조가 다르다는 이유로 같은 기능을 수행하는 동작을 중복해서 작성해야 하는 이슈가 생긴다.\n\n더 심각한건, list를 arrayList와 같이 자료구조를 바꾸기라도 하는 날에는 클라이언트가 코드를 수정해야 한다는 치명적인 문제도 있다.\n\n## Iterator Pattern\n\nData Collection을 순차적 접근이 필요할 때 그 방식을 Iterator와 같이 제공하는 디자인 패턴을 Iterator Pattern이라고 한다.\n위의 코드를 이 디자인 패턴을 적용해 개선해보자.\n\n```java:MyListIterator.java {5, 11}\npublic class MyListIterator implements Iterator {\n  Object[] data;\n  int position = 0;\n\n  public MyListIterator(Object[] data) {\n    this.data = data;\n  }\n\n  public Object next() {\n    Object obj = data[position];\n    position += 1;\n    return obj;\n  }\n\n  public boolean hasNext() {\n    if (position \u003e= data.length || data[position] == null) {\n      return false;\n    }\n    return true;\n  }\n}\n```\n\n```java:MyList.java {5, 11}\npublic class MyList {\n  ...\n\n  public Iterator createIterator() {\n    return new MyListIterator(data);\n  }\n}\n```\n\n이런식으로 나만의 클래스나 Iterator를 제공하지 않는 클래스의 경우 Iterator를 생성하기 위한 클래스를 생성하여 이를 createIterator 에서 반환해주면,\n순차 탐색은 createIterator에서 반환된 Iterator를 이용해서 하면 인터페이스를 통일할 수 있다.\n\n\u003ctip\u003e\n  MyArrayListIterator는 왜 안 만드는지?\n  \u003cbr /\u003e\n  기본적으로 Java에서 `Collection`을 implement 하는 자료구조는 Iterator를 제공하기 때문.\n  따라서 얘는 Iterator 클래스를 별도로 구현하지 않아도, 바로 createIterator 메서드 내부에서 `myArrayList.iterator()` 와 같은 방식으로 Iterator를 생성할 수 있음.\n  \u003cbr /\u003e\n  예로 들어 Hashtable 자료구조는 values() 라는 메서드를 제공하는데, 해당 메서드는 Collection 객체(아마 ArrayList)를 반환한다.\n  즉, Hashtable 자료구조는 myHashtable.values().iterator() 형식으로 Iterator를 얻을 수 있음.\n\u003c/tip\u003e\n\n```java:.java\n// List, ArrayList\nwhile (myIterator.hasNext()) {\n  Object obj = myIterator.next();\n}\n```\n\n한 단계 더 나아가 MyList, MyArrayList를 인터페이스로 묶어 createIterator를 강제할 수 있다.\n공통 메서드로 createIterator를 만들어 순차 탐색시에는 Iterator를 사용하도록 유도하는 것이다.\n\n### Single Responsibility\n\n그런데 MyListIterator 클래스를 따로 만들지 않고, 그냥 MyList에서 Iterator를 바로 implements 해서 구현하면 안되는 걸까?\n\n그래도 상관없긴 하다.\n하지만, 하나의 클래스는 하나의 역할만 수행한다는 디자인 원칙을 준수하는 것이 코드를 깔끔하게 관리할 수 있도록 도와줄 것이다.\n\n하나의 클래스가 데이터도 관리하고, Iterator도 관리하면... 기능이 너무 복잡해지기 때문이다.","slug":"univ_design-pattern/mid_09","readingMinutes":5,"wordCount":370},{"title":"Template Method Pattern","description":"Template Method 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Template Method Pattern"],"draft":false,"date":"2023-10-21 / 18:52","content":"\n## 필요성\n\n아래와 같은 음료 제조법이 있다고 가정해보자.\n\n\u003e Coffee Recipe\n\u003e 1. **Boil some water**\n\u003e 2. Brew coffee in Boiling water\n\u003e 3. **Pour beverage in cup**\n\u003e 4. Add sugar and milk\n\u003e\n\u003e Tea Recipe\n\u003e 1. **Boil some water**\n\u003e 2. Steep tea in Boiling water\n\u003e 3. **Pour beverage in cup**\n\u003e 4. Add lemon\n\n1, 3번 과정은 동일하다.\n하지만 음료가 다르다고 같은 제조 과정을 중복해서 적으면 시간도 낭비되고, 수정할 때도 둘 다 수정해야 하는 불편함이 있다.\n\n따라서 **동일한 부분은 함수**로 빼버리고, **다른 부분만 abstract**로 처리하는 기법을 사용하면 이런 불편함을 줄일 수 있을 것이다.\n\n## Template Method Pattern\n\n알고리즘의 뼈대를 정의하고, 서로 다른 부분은 subclass에 미루어 처리하는 디자인 패턴을 Template Method Pattern 이라고 한다.\n\n위의 상황을 코드로 구현하며 알아보자.\n\n```java:Beverage.java {9-10}\npublic class Beverage {\n  final void prepareRecipe() {\n    boilWater();\n    brew();\n    pourInCup();\n    addCondiments();\n  }\n\n  abstract void brew();\n  abstract void addCondiments();\n\n  void boilWater() {\n    // boil water\n  }\n\n  void pourInCup() {\n    // pouring in cup\n  }\n}\n```\n\n```java:Cafe.java\npublic class Coffee extends Beverage {\n  public void brew() {\n    // Brew coffee in Boiling water\n  }\n\n  public void addCondiments() {\n    // Add sugar and milk\n  }\n}\n\npublic class Tea extends Beverage {\n  public void brew() {\n    // Steep tea in Boiling water\n  }\n\n  public void addCondiments() {\n    // Add lemon\n  }\n}\n```\n\n이런식으로 하면 두 음료 모두 boilWater, pourInCup 과정은 동일한 코드를 사용할 수 있고,\n음료에 따라 다른 brew, addCondiments 과정을 갖게 된다.\n\n또한, 두 음료 모두 Beverage 클래스로 다형성을 유지할 수 있고, 음료 제작 과정은 둘 다 prepareRecipe를 호출하여 실행할 수 있다.\n\n\u003ctip\u003e\n  이 방식은 **Hollywood 디자인 원칙** 역시 준수하는데, 이게 뭐냐하면,\n  **상위 컴포넌트(클래스)만 호출**하고, **하위 컴포넌트는 호출하지 않고 등록**만 하는 원칙이다.\n  \u003cbr /\u003e\n  위의 예시에선 Coffee, tea에서 기능을 수행하지 않고, brew, addCondiments만 등록을 했다.\n  실제 호출은 Beverage에서 prepareRecipe에서만 수행했다.\n\u003c/tip\u003e\n\n## IRL\n\nsort에서도 이와 비슷한 기능이 있다.\n\n```java:MergeSort.java {5}\nprivate static void mergeSort(Object src[], Object dest[],\n                    int low, int high, int off) {\n  for (int i=low; i\u003chigh; i++) {\n    for (int j=i; j\u003elow \n         \u0026\u0026 ((Comparable)dest[j-i]).compareTo((Comparable)dest[j])\u003e0; j--) {\n      swap(dest, j, j-1);\n    }\n  }\n}\n```\n\nComparable의 compareTo 메서드에서 객체의 비교하는 방법을 정의하게 되는데, 객체간 비교를 하고싶을 때 Comparable 인터페이스의 compareTo 메서드를 구현하면,\n이에 따라 객체의 비교 방법이 달라져 mergeSort가 객체간 비교를 가능케 하는 것이다.","slug":"univ_design-pattern/mid_08","readingMinutes":4,"wordCount":373},{"title":"Facade Pattern","description":"Facade 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Facade Pattern"],"draft":false,"date":"2023-10-21 / 18:18","content":"\n## 필요성\n\n집에서 나만의 영화관을 만든다고 가정해보자.\n편-안하게 영화를 보고싶지만, 영화 보기 전 선행되어야 할 일들이 많다.\n\n```java:HomeTheater.java\npublic class HomeTheater {\n  public static void main(String[] args) {\n    ...\n    // 팝콘을 튀기고\n    popper.on(); \n    popper.pop();\n    // 조명을 낮추고\n    lights.dim(10); \n    // 스크린을 내리고\n    screen.down();\n    // 빔 프로젝터를 설정하고\n    projector.on();\n    projector.setInput(dvd);\n    projector.wideScreenMode();\n    // 앱프에 영화를 넣고\n    amp.on();\n    amp.setDvd(dvd);\n    amp.setSurroundSound();\n    amp.setVolume(5);\n    // 영화 실행...\n    dvd.on();\n    dvd.play(movie);\n  }\n}\n```\n\n이런 일련의 과정을 클라이언트에게 할당하면, 개발자 입장에선 피곤할 뿐만 아니라, 장치의 메서드에 변화가 생기면 클라이언트가 해당 부분을 수정해야 한다는 단점이 있다.\n\n## Facade Pattern\n\nFacade 디자인 패턴은 **단일화된 인터페이스로 서브 시스템을 다루는 패턴**으로, 위의 일련의 과정을 클라이언트에게 맡기는 것이 아닌, 하나의 인터페이스로 묶고, 그 인터페이스만 클라이언트에게 제공하는 것이다.\n\n```java:HomeTheaterFacade.java\npublic class HomeTheaterFacade {\n  Amplifire amp;\n  DvdPlayer dvd;\n  Projector projector;\n  ...\n\n  public HomeTheaterFacade (Amplifire amp, ...) {\n    this.amp = amp;\n    ...  \n  }\n\n  public void watchMovie(String movie) {\n    // 팝콘을 튀기고\n    popper.on(); \n    popper.pop();\n    // 조명을 낮추고\n    lights.dim(10); \n    // 스크린을 내리고\n    screen.down();\n    // 빔 프로젝터를 설정하고\n    projector.on();\n    projector.setInput(dvd);\n    projector.wideScreenMode();\n    // 앱프에 영화를 넣고\n    amp.on();\n    amp.setDvd(dvd);\n    amp.setSurroundSound();\n    amp.setVolume(5);\n    // 영화 실행...\n    dvd.on();\n    dvd.play(movie);\n  }\n}\n```\n\n```java:HomeTheater.java\npublic class HomeTheater {\n  public static void main(String[] args) {\n    ...\n\n    HomeTheaterFacade homeTheater = new HomeTheaterFacade(...);\n\n    homeTheater.watchMovie(\"movie\");\n  }\n}\n```\n\n일련의 모든 과정을 Facade에게 일임하여 클라이언트는 Facade를 이용해 나름 매크로 기능을 이용할 수 있다.\n\n\u003ctip\u003e\n  눈여겨 봐야 할 디자인 원칙: **직접적인 친구와만 대화하라**\n  \u003cbr /\u003e\n  객체의 메서드는 다음과 같은 경우에만 호출하는 것이 바람직하다.\n  1. 객체 자신의 멤버 메서드를 호출\n  2. 인자로서 넘어온 객체의 메서드를 호출\n  3. 메서드 내부에서 생성된 객체의 메서드를 호출\n  4. 객체의 멤버변수로 저장된 객체의 메서드 호출\n\n  예를 들어보자.\n  아래와 같은 경우는 부적절한 경우이다.\n\n  ```java:.java\n  public float getTemp() {\n    Thermometer thermometer = station.getThermometer();\n    return thermometer.getTemperature();\n  }\n  ```\n\n  thermometer가 getTemp() **메서드 내부에서 생성되지 않았**는데, 해당 객체의 getTemperature() 메서드를 호출했기 때문이다.\n  \u003cbr /\u003e\n  대신에 아래와 같이 하는 것이 바람직하다.\n\n  ```java:.java\n  public float getTemp() {\n    return station.getTemperature();\n  }\n  ```\n\n  \u003cbr /\u003e\n  정리하면, 객체의 메서드를 호출할 때에는 객체간의 인과관계가 명확한 상황에서만 호출하라는 뜻이다.\n\u003c/tip\u003e","slug":"univ_design-pattern/mid_07","readingMinutes":4,"wordCount":321},{"title":"Finding Similar Items","description":"유사도 높은 문서를 찾아내는 방법을 알아봅니다.","icon":"","image":"","tags":["Shingling","Minhashing","Jaccard Similarity"],"draft":false,"date":"2023-10-20 / 22:12","content":"\n생김새가 비슷한 사이트를 묶거나, 표절 검사를 하거나, 비슷한 내용의 뉴스를 클러스터링 하는 등 여러 분야에서 사용될 수 있는 기술에 대해 설명합니다.\n\n\u003cnotice\u003e\n  생김새가 비슷한 문서를 찾아내는 기술이지, 비슷한 토픽을 찾아내는 기술은 아닙니다.\n\u003c/notice\u003e\n\n아래의 단계를 거쳐 비슷한 문서를 찾게 되는데, 각 단계에 대한 세부적인 내용은 추후에 설명합니다.\n\n1. `Shingling`을 통해 데이터(문서)를 집합으로 변환\n2. `Minhashing`을 통해 큰 집합을 작은 시그니처로 변환\n3. `LSH`를 통해 시그니처를 분류 후 비슷한 집합 찾기\n\n## Jaccard Similarity\n\n세부내용 설명 전 개념 하나만 짚고 넘어가자.\n유사도를 검사할 때, 다음과 같은 경우를 고려해보자.\n\nA, B 모두 메이져한 게임들을 주로 플레이하고, A는 RPG를, B는 FPS를 주로 플레이한다고 가정하자.\n이 때, 마이너한 장르의 게임을 예시로 들며 유사도를 검사하는데, A, B 모두 해당 게임을 보유하지 않는다고 두 사람의 유사도가 높다고 이야기 할 수 있을까?\n두 사람은 그런 마이너한 장르의 게임에 관심이 없어서 갖고있지 않을 뿐인데, 둘 다 갖고있지 않다고 두 사람의 플레이스타일이 유사하다고 판단하는 것은 무리가 있다.\n\n따라서 이런 유사도 파악의 오류를 해결하기 위해 Jaccard 유사도를 사용하여 유사도를 측정하게 된다.\n\n$$\nSim(C_1, C_2) = \\frac{|C_1 \\cap C_2|}{|C_1 \\cup C_2|}\n$$\n\n즉, **두 사람 중 한 사람이라도 해당 게임을 보유하고 있는 경우에만 두 사람이 동시에 해당 게임을 보유하는가**로 유사도를 검사하는 것이다.\n\n---\n\n## Shingling\n\n문서의 유사도를 측정할 때 그 기준이 되는 토큰을 생성하는 방법입니다.\n`k-shingle` 과 같은 용어를 사용하는데, 이는 k개의 문자로 이루어진 shingle을 의미합니다.\n실제로 비슷한 문서를 싱글링 했을 때 집합의 원소도 일치하는 부분이 매우 많습니다.\n\n예로 들어 \\\"The dog which chased the cat\\\" 이라는 문장이 있다고 했을 때, 여기서 2-shingle를 구하면 다음과 같습니다.\n\n\u003e th(보통 소문자로 변환), he, e_, _d, do, og, ...\n\n하지만, 2-shingle로 하면 th, he, do와 같이 문장으로 볼 때는 상당히 유니크한 의미를 갖는 문장이 이렇게 아무데서나 나올법한 shingle이 되어버립니다.\n따라서 보통은 `8~10`-shingle로 하는 것이 적당합니다.\n\n### Tokens\n\n10-shingle을 사용하는 경우에는 최대 $27^{10} \\approx 200조$ 개의 싱글이 생성되게 됩니다.\n이를 메모리상에서 관리하는 것은 현실적으로 불가능한 일입니다.\n\n따라서 싱글을 해싱하여 4bytes의 자료형으로 변환하여 `Token`으로서 사용하게 됩니다.\n4bytes로 최대 약 42억개의 서로 다른 싱글을 표현할 수 있습니다.\n물론 다른 싱글에 대해 같은 토큰이 생성될 수 있지만, 그리 빈번한 경우는 아닐 것이며, 효율상 이 방법이 더 좋습니다.\n\n즉, 같은 토큰을 보유한 문서가 있다면, 그 문서들은 같은 싱글을 갖고있다는 얘기이므로, 유사도가 있다고 판단할 수 있겠습니다.\n\n---\n\n## Minhashing\n\nMinhashing을 알아보기 전, 데이터를 표현하는 행렬을 읽는 법을 알고가자.\n\n| (token) | $C_1$ | $C_2$ |\n|---|---|---|\n| a | 0 | 0 |\n| b | 1 | 0 |\n| c | 0 | 1 |\n| d | 1 | 1 |\n\na 토큰(싱글)은 문서(Column) 1, 2에서 모두 없다는 뜻이고, b는 문서 1에서만 갖고있다는 뜻으로 해석하면 된다.\n참고로 위의 경우 두 문서의 Jaccard 유사도는 **1/3**이다. (a는 둘 다 없기에 비교대상이 아니다)\n\n### Permute the rows\n\n우선 행을 핸덤으로 뒤죽박죽 섞는다.\n섞는다는 것은 실제로 맊 섞는다는 것이 아닌, 탐색 순서를 섞는다는 것을 의미하는데, 구현 관점에서 해싱을 돌리는 것과 같다.\n예시를 보며 이해해보자.\n\n| (row) | $C_1$ | $C_2$ | $C_3$ |\n|---|---|---|---|\n| 1 | 0 | 1 | 1 |\n| 2 | 1 | 0 | 1 |\n| 3 | 0 | 1 | 0 |\n| 4 | 0 | 0 | 0 |\n| 5 | 1 | 0 | 1 |\n\n$h_1(x) = x \\% 5$ 해시함수를 적용하면 탐색 순서는 다음과 같아진다.\n\n\u003e **5**(0) \u0026rarr; **1**(1) \u0026rarr; **2**(2) \u0026rarr; **3**(3) \u0026rarr; **4**(4)\n\n$h_2(x) = (2x+1) \\% 5$ 해시함수를 적용하면 탐색 순서는 다음과 같아진다.\n\n\u003e **2**(0) \u0026rarr; **5**(1) \u0026rarr; **3**(2) \u0026rarr; **1**(3) \u0026rarr; **4**(4)\n\n### Create signature\n\n탐색 순서에 맞게 처음으로 1(토큰 보유)을 만나는 탐색 순서를 기록한다.\n\n\u003e $h_1$를 적용한 탐색시 생성되는 Singature matrix\n\u003e [1, 2, 1]\n\u003e\n\u003e $h_2$를 적용한 탐색시 생성되는 Singature matrix\n\u003e [1, 3, 1]\n\n즉, $C_1$에 대한 시그니처는 11, $C_2$는 23, $C_3$은 11이 된다.\n\n여기서 중요한 특징이 있는데, 시그니처의 길이가 길어질 수록(무작위 순서에 의한 탐색 횟수가 늘어날 수록) 시그니처가 일치할 확률이 Jaccard 유사도와 확률이 같아진다.\n그 이유를 간단한 예시로 이해해보자.\n\n우선, $C_2$과 $C_3$의 Jaccard 유사도는 **1/4**이다.\n그런데 이 때, Singature가 같아지는 경우는 무엇일까? 바로 **최초로 1이 나오는 시점이 같다**는 이야기이다.\n즉, 같은 row에 대해 둘 다 1이 들어가 있는 row를 고를 확률과 같아진다.\n둘 다 0인 경우를 제외하면 4개 중에 둘 다 1인 row는 1개 존재하기에 Jaccard 유사도와 동일한 **1/4** 확률을 갖는다.\n\n![231020-235719](/posts/mid_05/231020-235719.png)\n\n이해를 돕기 위해 다른 예시도 보자.\n\n원래대로라면 생성되는 모든 토큰(42억개)에 대해 유사도를 검사 했어야 했다.\n하지만, 시그니처를 만드는 과정에서 무작위 순서로 탐색을 진핼할 때, 탐색개수를 제한을 걸면 검사 시간을 줄일 수 있다.\n예로 들어 해시함수의 결과를 50까지만 검색한다면 42억개의 항목에 대해 검사를 진행하지 않아도 된다. \n\n이 때 검사 개수를 줄인 만큼 서로다른 해시를 여러 번 진행하면 신뢰도 역시 어느정도 확보할 수 있다.\n예로 들어 서로 다른 해시함수 100개를 적용한다면, 시그니처의 길이가 100으로 결정되는데, 이 길이는 충분히 신뢰도를 확보할 수 있을 것이다.\n즉, 42억개에서 100개로 압축되는 효과가 발생하는 것이다.\n\n위의 사진을 예시로 실제 Jaccard 유사도와 시그니처 유사도를 비교해보며 시그니처 길이가 신뢰도에 어느정도 영향을 주는지 알아보자.\n\n\u003e Column 1, 2\n\u003e Jaccard Similarity: **1/4**\n\u003e Singature Similarity: **1/3**\n\u003e\n\u003e Column 2, 3\n\u003e Jaccard Similarity: **1/5**\n\u003e Singature Similarity: **1/3**\n\u003e\n\u003e Column 3, 4\n\u003e Jaccard Similarity: **1/5**\n\u003e Singature Similarity: **0**\n\n### implement\n\n의사코드로 구현해보고 시그니처 생성과정을 살펴보자.\n\n```cpp:의사코드\n// 처음에 무한대로 초기화\nfor (all i and c) M(i, c) = inf;\n\n// 각 행에 대해 반복하는데, 여기에 탐색개수 50개와 같은 제한을 걸 수 있음\nfor (each row r) {\n  for (each hash function h_i) {\n    compute h_i(r);\n  }\n  for (each column c) {\n    // 탐색지점에 1이 있는 경우\n    if (c has 1 in row r) {\n      for (each hash function h_1) {\n        // 저장된 시그니처보다 새 탐색값이 작은 경우에만 업데이트\n        if (h_i(r) is smaller them M(i, c)) {\n          M(i, c) = h_i(r);\n        }\n      }\n    }\n  }\n}\n```\n\n![231021-001859](/posts/mid_05/231021-001859.png)","slug":"univ_mmds/mid_05","readingMinutes":11,"wordCount":927},{"title":"Association Rules","description":"빅데이터에서 연관 규칙을 찾아내는 방법에 대해 알아봅니다.","icon":"","image":"","tags":["Association Rules","Support","Confidence","Interest"],"draft":false,"date":"2023-10-20 / 20:08","content":"\n## Application\n\n연관 규칙을 응용할 수 있는 분야를 살펴보면서 대략적인 이해와 필요성에 대해 알아보자.\n\n![231020-201233](/posts/mid_04/231020-201233.png)\n\n장을볼 때 각 장바구니에 어떤 물건을 샀는지를 나타내는 표이다.\n이 표를 간단하게 분석해보면, `Milk`를 산 사람은 대체로 `Coke`를 사는 경향이 있고, `Diaper, Milk`를 동시에 산 사람은 대체로 `Beer`를 산 경향이 있는걸로 보인다.\n이렇게 사람들의 구매 경향을 분석할 때 사용하기도 한다.\n\n또한 문서 상에서 **\\{the\\} \u0026rarr; \\{cat\\}** 이라는 규칙이 있다면 the 라는 단어 뒤에는 대체적으로 cat 이라는 단어가 나온다는 뜻으로, 자연어처리시 문법을 파악하고 학습시키는데 도움이 될 수도 있다.\n\n그 외에도 여러 분야에서 활용될 수 있지만, 섣부른 일반화는 안된다.\n예로 들어 **비타민C를 많이 먹는 사람들은 불면증을 겪는 경향이 있다**는 규칙을 발견했다면, **비타민C를 안먹는 경우**에도 불면증 경향이 있는지 검사해봐야 확실해는 것이다.\n\n## Frequent Itemset\n\nFrequent Itemset을 구하는 방법은 [**`저번 포스트`**](https://wjlee611.github.io/blog/univ_mmds/mid_03)에서 알아봤으니, 이젠 용어과 수식을 통해 연관 규칙을 정의하는 것을 알아보자.\n\n### Support\n\n**Support for itemset I** 라고 한다면 itemset I가 등장한 횟수를 의미한다.\n전체 basket에서 itemset I가 등장한 횟수를 카운트 하면 된다.\n이 때, Support threshold S 보다 크다면 빈번하다고 판단하게 되는 것이다.\n\n| Baskets | m(ilk), c(oke), p(epsi), b(read), j(am) |\n| --- | --- |\n| $B_1$ = **\\{m, c, b\\}** | $B_2$ = **\\{m, p, j\\}** |\n| $B_3$ = **\\{m, b\\}** | $B_4$ = **\\{c, j\\}** |\n| $B_5$ = **\\{m, p, b\\}** | $B_6$ = **\\{m, c, b, j\\}** |\n| $B_7$ = **\\{c, b, j\\}** | $B_8$ = **\\{b, c\\}** |\n\n예로 들어 위와 같이 목록들이 존재하고, Support threshold가 `3 baskets` 라고 주어진다면,\nFrequent itemset은 아래와 같이 나오게 된다.\n\n\u003e **\\{m\\}, \\{c\\}, \\{b\\}, \\{j\\}, \\{m, b\\}, \\{b, c\\}, \\{c, j\\}**\n\n## Association Rules\n\n**특정 집합($I$)이 등장할 때 $j$ 하는 경향이 있다** 라는 연관 규칙을 수식화 하면 아래와 같이 표현이 가능하다.\n\n\u003e $\\{i_1, \\; i_2, \\; ,... \\; , i_k\\}$ \u0026rarr; $j$\n\n### Confidence\n\n이 떄, 그 경향에 대한 신뢰도, `Confidence`는 아래와 같이 수식화 할 수 있다.\n\n$$\nconf(I \\rightarrow j) = \\frac{support(I \\cup j)}{support(I)}\n$$\n\n즉 조건부에 해당하는 itemset이 등장할 확률 기반으로 itemset + j 가 동시에 등장할 확률을 구하면 되는 것이다.\n\n### Interest\n\n하지만 신뢰도가 높다고 반드시 의미있는 규칙이 발견된 것은 아니다.\n\n예로 들어 **X \u0026rarr; milk** 라는 규칙을 발견했다고 가정하자.\n그러나, 굳이 X가 아니더라고 그냥 milk는 많이 사기때문에 둘 사이에 연관성이 깊다고 판단하기에는 무리가 있다.\n\n이 떄문에 `Interest`의 개념이 존재한다.\n\n$$\nInterest(I \\rightarrow j) = | conf(I \\rightarrow j) - Pr[j] | \\\\\nPr[j] = \\frac{support(j)}{표본 \\; 수}\n$$\n\n흥미도는 I 신뢰도에서 j가 등장할 확률을 뺀 값의 절댓값과 같다.\n\n보통 해당 값이 `0.5보다 크다`면 해당 규칙이 의존성이 있다는 의미가 된다.\n만약 `-0.5보다 작은` 경우에도 의존성이 있다는 의미가 있는데 이 경우에는 **I, j를 둘 다 사는 경우는 없다**는 뜻으로 해석할 수 있다.\n\n| Baskets | m(ilk), c(oke), p(epsi), b(read), j(am) |\n| --- | --- |\n| $B_1$ = **\\{m, c, b\\}** | $B_2$ = **\\{m, p, j\\}** |\n| $B_3$ = **\\{m, b\\}** | $B_4$ = **\\{c, j\\}** |\n| $B_5$ = **\\{m, p, b\\}** | $B_6$ = **\\{m, c, b, j\\}** |\n| $B_7$ = **\\{c, b, j\\}** | $B_8$ = **\\{b, c\\}** |\n\n위애서 예시로 든 baskets에서 다음과 같은 연관 규칙을 찾았다고 해보자.\n\n\u003e **\\{m, b\\} \u0026rarr; c**\n\u003e\n\u003e $support(\\{m, b\\} \\cup c)$ = **2** (m, b, c 동시 등장 횟수)\n\u003e $support(\\{m, b\\})$ = **4** (m, b 동시 등장 횟수)\n\u003e $conf(\\{m, b\\} \\rightarrow c)$ = 2/4 = **0.5**\n\u003e $Interest(\\{m, b\\} \\rightarrow c)$ = | 0.5 - 5/8 | = **1/8**\n\n즉, 이 경우에는 Interest가 낮기 때문에 그다지 의미 없는 규칙이라는 뜻이다.\n\n### Mining Association Rules\n\n1. 모든 빈발 항목 집합 I를 찾는다.\n  (이건 [**`이전 포스트`**](https://wjlee611.github.io/blog/univ_mmds/mid_03)에서 찾는 법을 다룸)\n\n2. 규칙 생성\n\n이제 규칙을 생성하는 방식을 알아보자.\n\n우선 생성된 빈발 항목 집합 I의 부분집합을 이용해서 생성 가능한 모든 연관 규칙을 만든다.\n예로 들어 **I = \\{a, b, c, d\\}** 라면, **\\{a, b, d\\} \u0026rarr; c, \\{a, b\\} \u0026rarr; \\{c, d\\}** 등등과 같이 모든 조합에 대해 만들어 주는 것이다.\n\n그 다음은 생성된 모든 규칙에 대해 Confidence, Interest를 분석해서 의미있는 규칙만 남도록 걸러내면 된다.\n여기서 특정 규칙을 검사하고 나면 나머지 특정 규칙들은 검사할 필요가 없어지는 최적화가 가능한데, 그 이유를 알아보자.\n\n예로 들어 **\\{a, b, c\\} \u0026rarr; d** 의 confidence가 threshold 이하라면 **\\{a, b, c\\}** 의 부분집합이 조건부가 되는 규칙들(**\\{a, b\\} \u0026rarr; \\{c, d\\}**, **\\{b\\} \u0026rarr; \\{a, c, d\\}**, ...)은 검사를 진행할 필요가 없어진다.\n왜냐하면 아래의 식을 잘 살펴보자.\n\n$$\nconf(I \\rightarrow j) = \\frac{support(I \\cup j)}{support(I)}\n$$\n\n여기서 동일한 빈발 항목 집합에 대해 생성된 규칙이면 분자는 동일하다는 것은 자명하다.\n즉, 분모만 변화하게 되는데, 원소의 개수가 줄어들 수록 분모의 값은 필연적으로 같거나 커질 수 밖에 없다.\n그렇기에, confidence는 반드시 같거나 작아질 수 밖에 없는 것이다. (하물며 threshold와 비교하면? 분명 더 작을거다.)\n\n| Baskets | m(ilk), c(oke), p(epsi), b(read), j(am) |\n| --- | --- |\n| $B_1$ = **\\{m, c, b\\}** | $B_2$ = **\\{m, p, j\\}** |\n| $B_3$ = **\\{m, c, b, n\\}** | $B_4$ = **\\{c, j\\}** |\n| $B_5$ = **\\{m, p, b\\}** | $B_6$ = **\\{m, c, b, j\\}** |\n| $B_7$ = **\\{c, b, j\\}** | $B_8$ = **\\{b, c\\}** |\n\n마지막으로 실제로 연관 규칙을 찾아보며 마무리해보자.\nthreshold = 3, confidence = 0.75 로 제한한다고 가정하자.\n\n\u003e Frequent itemsets: \n\u003e **\\{b, m\\} \\{b, c\\} \\{c, m\\} \\{c, j\\} \\{m, c, b\\}**\n\n| Generate rules | | | |\n| --- | --- | --- | --- |\n| ~~b \u0026rarr; m [c=0.67]~~ | b \u0026rarr; c [c=0.83] | ... | ~~b,c \u0026rarr; m [c=0.6]~~ |\n| m \u0026rarr; b [c=0.8] | c \u0026rarr; b [c=0.83] | | ~~b \u0026rarr; c,m (검사 필요 없음)~~ |\n| | | | ~~c \u0026rarr; b,m (검사 필요 없음)~~ |\n| | | | c,m \u0026rarr; b [c=1] |\n| | | | b,m \u0026rarr; c [c=0.75] |\n| | | | ~~m \u0026rarr; b,c [c=0.6]~~ |\n이후에 interest도 진행\n\n### Compacting the output\n\n생성되는 연관 규칙이 너무 많기에 이를 압축하는 방식도 있다.\n\n1. Maximal frequent itemsets\n  threshold 기준으로 압축한다.\n2. Closed itemsets\n  support 기준으로 압축한다.\n\n다음 표를 보면서 이해해보자.\n(Yes인 경우에만 연관 규칙을 출력한다는 뜻이다)\n\n| Itemset | Support | Maximal | Closed |\n| --- | --- | --- | --- |\n| A | 4 | No | No |\n| B | 5 | No | Yes |\n| C | 3 | No | No |\n| AB | 4 | Yes | Yes |\n| AC | 2 | No | No |\n| BC | 3 | Yes | Yes |\n| ABC | 2 | No | Yes |\n**Threshold = 3**\n\n`Maximal 기준`\n- C를 보면 support가 threshold보다 크지만 출력하지 않는다.\n그 이유는 C의 superset BC가 `frequent 해서` 이미 출력하기 때문에 중복해서 출력하지 않는 것이다.\n- 반대로 AB를 보면 support가 threshold보다 커서 출력한다.\n그 이유는 AB의 superset ABC가 `frequent 하지 않기 때문`에 출력해야하기 때문이다.\n\n\n`Closed 기준`\n- C를 보면 support가 threshold보다 크지만 출력하지 않는다.\n그 이유는 C의 superset BC의 `support와 같기 때문`에 출력하지 않는 것이다.\n- 반대로 AB를 보면 support가 threshold보다 커서 출력한다.\n그 이유는 AB의 superset ABC의 `support가 보다 작기 때문`에 출력하는 것이다.","slug":"univ_mmds/mid_04","readingMinutes":11,"wordCount":1147},{"title":"Frequent Itemset","description":"빈발 항목 집합을 구하는 방법을 알아봅니다.","icon":"","image":"","tags":["Frequent Itemset","A-Priroi","PCY","Random Sampling","SON","Toivonen"],"draft":false,"date":"2023-10-19 / 16:33","content":"\n## Naive Algorithm\n\n우선 나이브한 방법으로 빈발 항목 집합을 찾는 방법부터 알아보자.\n처음에는 frequent pair를 찾는 것을 목표로 하고, 이후에 원소의 개수가 더 많은 집합을 찾는 방식으로 확장하자.\n\n간단하게 요약하면 아래의 두 단계에 걸쳐 모든 pair를 생성한다.\n\n1. 가능한 모든 조합의 쌍 생성\n  n개의 아이템이 들어있는 Basket에서는 `n(n-1)/2` 개의 조합 쌍이 생성된다.\n2. 해당 조합 쌍이 동시에 등장하는 경우 1씩 카운트하며 개수를 센다.\n\n이 방식은 구현이 제일 간단하지만 치명적인 문제가 있다.\n개수를 `4bytes`의 int형으로 저장한다고 가정하면 n개의 아이템이 존재하는 Basket에 대해 `2n(n-1)bytes`의 메모리 공간이 할당되어야 하는데, 이런 크기의 메모리 공간을 할당할 수 없을 뿐더러, 존재하지도 않은 페어의 메모리 공간을 할당해야만 하는 문제점이 있다.\n\n### Triples\n\n이런 한계를 극복하기 위해 원소를 triples로 관리하는 기법도 있다.\n`[i, j, c]` 로 관리하는 기법인데, **\\\"\\{i, j\\} 페어가 c번 등장함\\\"** 이라는 의미로 관리하는 것이다.\n이렇게 하면 하나의 페어당 12bytes가 들어가긴 하지만, 존재하지도 않은 페어에 대한 메모리 공간 할당은 방지할 수 있다.\n\n하지만 메모리 주소 관리를 위해 별도의 `해시 테이블`을 할당해야 하기에 그다지 메리트가 크지는 않다.\nTriples 방식이 더 효율적으로 작동하기 위해서는 가능한 모든 페어 조합 수의 1/3 수준으로 실제로 등장하는 페어수가 존재해야 한다.\n\n---\n\n## A-Priori Algorithm\n\n페어가 메인 메모리에 올라갈 정도로 적다면 나이브한 방식을 사용하는것이 좋다.\nBasket을 한 번만 읽어도 되는, 1pass만에 빈발 항목 집합을 찾을 수 있으니 속도가 빠르기 때문이다.\n\n\u003ctip\u003e\n  `pass`\n  Basket(파일)을 처음부터 끝까지 읽는 횟수로, Disk I/O의 cost가 큰 만큼 pass 횟수에 따라 알고리즘의 성능을 평가하는 요소로 작동한다.\n\u003c/tip\u003e\n\n하지만, 그렇지 않은 대다수의 경우에는 다른 방식을 고안해야 한다.\nA-Priori 알고리즘의 경우에는 2pass로 pair를 찾을 수 있지만, 그 대신 메모리 효율성이 극대화되어 매우 큰 파일도 메모리에 적재할 수 있다.\n하지만 이게 어떻게 가능한 것일까?\n\n기본적인 아이디어는 이렇다.\n이 파일에는 아이템이 **a, b, c** 이렇게 존재한다고 해보자.\n만약 **\\{a, b\\}** 가 10번 등장했다면, 진 부분집합 **\\{a\\}, \\{b\\}** 역시 10변 이상 등장했을 것이다.\n반대로 말하면 **\\{a\\}, \\{b\\}** 가 10번도 안나왔다면, **\\{a, b\\}** 역시 10번도 안나올 것이다.\n\n따라서 빈발 항목 집합을 세기 전에 우선 threshold보다 큰 경우에만 빈번하다고 기준을 정의하고 시작한다.\n\n### Pass 1\n\npass 1에서는 우선 파일을 읽어보며 개별적인 아이템 개수부터 세어본다.\n이 때, 아이템 개수가 threshold보다 큰 경우에만 다음 pass에서 고려하게 된다.\n\n![231019-205437](/posts/mid_03/231019-205437.png)\n\n참고로 pass 2에서 빈번하게 등장한 아이템에 접근하기 위해 빈번하게 등장한 아이템들의 주소를 저장하기 위해 메모리 공간을 약간 할당한다.\n\n### Pass 2\n\npass 2에서는 pass 1에서 통과한 아이템들을 이용해서 페어를 생성한다.\n그리고 나이브한 방법과 마찬가지로 파일을 읽으면서 등장 횟수를 카운트한다.\n\n이 방식이 훨씬 효율적인게, 만약 pass 1에서 읽어야 할 아이템의 개수가 1/10 으로 줄었다면,\npass 2에서 생성되는 pair의 개수는 1/100 수준으로 줄어든다.\n따라서 메모리 효율성이 거의 100배 증가하는 것이다.\n\n### Frequent Triples\n\npair에서 확장되어 원소의 개수가 3개, 4개인 경우의 처리 방식도 알아보자.\n근데 사실 별 거 없다. 그냥 앞에서 봤던 방법의 반복이다.\n\n빈번하게 등장한 페어를 이루는 아이템들로 triple을 만든다.\n이후 각 triple의 진 부분집합이 빈번하게 등장한 pair인 경우에만 파일을 읽어보며 세어보면 된다.\n\n예시들 들어 이해해보자.\n\n\u003e $C_1$ = \\{\\{b\\} \\{c\\} \\{j\\} \\{m\\} \\{n\\} \\{p\\}\\}\n\u003e threshold보다 많이 등장한 원소는 아래 4개라고 해보자.\n\u003e $L_1$ = \\{b, c, j, m\\}\n\u003e $L_1$을 이용해서 다름 pass 진행\n\u003e \n\u003e $C_2$ = \\{\\{b, c\\} \\{b, j\\} \\{b, m\\} \\{c, j\\} \\{c, m\\} \\{j, m\\}\\}\n\u003e threshold보다 많이 등장한 원소는 아래 4개라고 해보자.\n\u003e $L_2$ = \\{\\{b, c\\} \\{b, m\\} \\{c, j\\} \\{c, m\\}\\}\n\u003e $L_2$을 이용해서 다름 pass 진행\n\u003e\n\u003e $C_3$ = \\{\\{b, c, m\\} \\{b, c, j\\} \\{b, m, j\\} \\{c, m, j\\}\\}\n\u003e 이 때 \\{b, c, j\\} \\{b, m, j\\} \\{c, m, j\\}의 부분 집합은 $L_2$에 포함되지 않으니 세어볼 필요 없음 (반드시 threshold보다 적게 등장할 것)\n\n즉, A-Priori 알고리즘은 k-pass 단계에서 k-tuple의 집합을 생성하게 되는데,\n일반적으로 k=2일 때, 메모리 사용량이 가장 많다.\n\n---\n\n## PCY Algorithm\n\nPark-Chen-Yu 알고리즘으로 A-Priori 알고리즘의 pass 1에서 메모리의 빈 공간을 활용하여 탐색 효율을 높인 알고리즘이다.\n그 이후의 과정은 A-Priori와 같으니, pass 1에서의 메모리 관리 방법에 대해서만 알아보자.\n\n![231019-211632](/posts/mid_03/231019-211632.png)\n\n### Bucket's Hash Table\npass 1에서 개별적인 아이템 등장 횟수를 카운트 할 때, 동시에 아이템으로 만들 수 있는 pair의 개수도 동시에 카운트 하는 것이다.\n이 때 페어를 해싱하여 버킷으로 만들고, 그 버킷을 Hash table for pairs에 최대한 가득 채운다.\n\n예로 들어 a, b, c의 개수를 세어보면서 \\{a, b\\} \\{b, c\\} \\{a, c\\}를 해싱한 주소에 등장할 때 마다 1씩 카운트 하는 것이다.\n만약 \\{a, b\\} \\{a, c\\} 의 해시 결과가 같은데, 해당 pair을 해시한 곳의 값이 threshold보다 작다면 pass 2에서 \\{a, b\\} \\{a, c\\} 를 셀 필요가 없다는 뜻이된다.\n\n그럼에도 불구하고 pass 2에서는 파일을 한 번 더 탐색을 해야만 하는데, 버킷만으로 pair가 threshold보다 크다고 단정지을 수 없는 이유는 해시의 특성 때문이다.\n다른 입력에 대해 같은 출력이 나올 수 있는 해시는 여러 pair가 하나의 버킷에 카운트 될 수 있음을 시사한다.\n즉, 버킷이 threshold보다 작다면 해싱후 그 버킷을 가리키는 pair는 세어볼 필요가 없지만,\nthreshold보다 큰 경우에는 threshold보다 작은 값이 여러개 모여 threshold보다 커졌을 가능성이 있기 때문에 다시 파일을 읽어보며 확인을 해봐야 하는 것이다.\n\n### Bit-vector (bitmap)\n\n아무튼, pass 1에서 pair의 해싱을 통한 버킷이 저장된 해시 테이블을 만들어 추후 파일 탐색시 검사해야 할 pair의 수를 줄이게 되는데,\n해시 테이블을 암축하지 않으면 pass 2로 넘어갈 수 없다. (메모리에 꽉 차게 할당했기 때문)\n어떻게 압축해야 필요한 정보를 유지할 수 있을까?\n\n우리가 필요한 정보는 n번째 버킷이 threshold보다 많이 등장했는지(1) 아닌지(0) 이다.\n따라서 해시 테이블에 n번째 버킷이 threshold보다 크다면 1, 아니면 0으로 압축할 수 있다.\n4bytes(32bits)에서 1bit로 압축되는 셈이다.\n\n그리고 이제 pass 2에서 \\{b, c\\}를 파일에서 몇 번 등장하는지 세어보기 전에 우선 해싱을 하여 bitmap에 해당 해시의 위치가 1이면 실제로 세어보고 0이면 셀 필요 없이 threshold보다 작다는 뜻이 된다.\n\n---\n\n## Random Sampling\n\n지금까지 알아본 빈번 항목 집합을 찾는 방식은 k-tuple의 개수를 세어보기 위해서는 k-pass를 거쳐야만 했다.\n이번부터 알아볼 알고리즘은 단 2-pass만에 세어볼 수 있는 방식을 알아볼 것이다.\n\n랜덤 샘플링 기법은 파일을 메모리에 올릴 수 있을 만큼만 적당히 샘플링 해와서 모든 카운트 과정을 메모리 내부에서 해결하는 것이다.\n하지만, 샘플링 비율만큼 실제 데이터 양도 줄어들기 때문에 threshold도 샘플링 비율만큼 줄여서 측정한다.\n\n하지만 이 경우에는 False Positive, False Negative 문제가 발생할 수 있다.\n\n\u003ctip\u003e\n  `False Positive`\n  실제로는 빈번하지 않은데 샘플링된 데이터에서는 빈번하다고 나온 경우\n  \u003cbr /\u003e\n  `False Negative`\n  실제로는 빈번한데 샘플링된 데이터에서는 빈번하지 않다고 나온 경우\n\u003c/tip\u003e\n\nFalse Positive의 경우에는 pass 2에서 빈번 집합의 경우 실제로 빈번하게 등장하는지 검사해 봄으로써 해결할 수 있다.\n하지만 False Negative의 경우에는 찾아낼 방법이 없다.\n\nthreshold를 더 작게 설정하는 방식으로 False Negative가 나올 확률을 줄일수는 있겠지만, 해결책은 아니다.\n\n---\n\n## SON Algorithm\n\n기본적인 방식은 랜덤 샘플링과 동일하다.\n차이점은 SON Algorithm음 모든 파일을 다 읽는다는 것이다.\n즉, 한 번 읽을 때 샘플링한 작은 청크를 읽지만, 이 과정을 여러번 반복해서 전체 파일을 읽어온다는 차이점이다.\n\n이 방식은 False Negative도 없다고 확신할 수 있다.\n왜냐하면 실제로 빈번한 집합이라면 읽어오는 모든 청크에 대해 최소 1개의 청크에서는 빈번하게 등장할 것이기 때문이다.\n\n하지만 모든 청크를 결국 메모리에 1번은 올려야 하기 때문에 시간이 오래 걸린다는 단점이 있다.\n\n---\n\n## Toivonen's Algorithm\n\n시작은 랜덤 샘플링과 같다.\n하지만 랜덤 샘플링에서 샘플을 파일의 1/100 수준으로 샘플링 한다면 threshold도 1/100 수준으로 설정할텐데 이 경우에는 좀 넉넉하게 1/125 정도로 설정한다는 차이가 있다.\n\n추가로 pass 1에서 Negative Border 라는 개념을 도입하여 False Negative를 방지한다.\n이 외에는 랜덤 샘플링 방식과 동일하다.\n\n### Negative Border\n\nNegative Border에 포함되는 집합은 본인은 빈번하지 않지만, 본인의 진 부분집합은 빈번하게 등장한 경우 포함된다.\n예시를 들어 알아보자.\n\n\u003e 모든 집합이 **\\{\\} \\{a\\} \\{b\\} \\{c\\} \\{a b\\} \\{b c\\} \\{a c\\} \\{a b c\\}** 만 존재한다고 가정해보자.\n\u003e\n\u003e `Case 1` **\\{a\\} \\{b\\}** 만 빈번하게 등장함 \u0026rarr; **\\{a b\\} \\{c\\}** 를 Negative Border로 추가.\n\u003e **\\{a b\\}** 의 경우에는 본인의 진 부분집합이 빈번하게 등장했으니 본인도 빈번하게 등장했을 가능성이 있다.\n\u003e 따라서 추가 검사를 진행해봐야 하는 것이다.\n\u003e **\\{c\\}** 의 경우에는 진 부분집합이랄게 없기 때문에 추가 검사를 진행해 봐야 하는 것이다.\n\u003e\n\u003e `Case 2` **\\{a\\} \\{b\\} \\{c\\}** 만 빈번하게 등장함 \u0026rarr; **\\{a b\\} \\{b c\\} \\{a c\\}** 를 Negative Border로 추가.\n\u003e 빈번하게 등장한 집합의 다음 스탭만 의심해야지, 나아가서 **\\{a b c\\}** 까지는 검사하지 않는다.\n\u003e\n\u003e `Case 3` **\\{\\}** (아무것도 빈번하지 않음) \u0026rarr; **\\{a\\} \\{b\\} \\{c\\}** 를 Negative Border로 추가.\n\u003e 샘플링을 너무 못했을 가능성이 높기에 일단 원소 1개짜리는 추가 검사를 해봐야 한다.\n\n이후 pass 2에서 빈번 항목 집합과 Negative Border에 대해 검사를 진행한다.\nFalse Positive의 경우에는 랜덤 샘플링과 마찬가지로 여기서 걸린다.\n\nFalse Negative의 경우에는 Negative Border에 포함된 집합을 검사하면서 나오게 될텐데,\n만약 Negative Border에 있는 집합이 실제로는 빈번하게 등장했다면 False Negative가 존재한다는 뜻이 된다.\n이런 경우에는 다른 샘플로 pass 1부터 다시 시도하게 된다.\n따라서 정확히는 2 pass안에 끝나지 않을 수는 있다.","slug":"univ_mmds/mid_03","readingMinutes":17,"wordCount":1340},{"title":"Spark 개념","description":"MapReduce 모델의 확장판, Spark에 대해 알아봅니다.","icon":"","image":"","tags":["Spark","RDD"],"draft":false,"date":"2023-10-19 / 15:04","content":"\n## MapReduce 문제점\n\n기존 MapReduce 모델의 문제점은 데이터 복제, Disk I/O 등의 오버헤드가 크다는 점이었다.\n\n하지만, ranks를 2개(map, reduce)로 나누어 관리하여 한 반향으로 데이터를 흐르게 만들어 \n시스템이 다운될 경우 재시작의 효율성이 올라가는 점도 고려하여 구현되었다.\n(단방향으로 흐르기에 처리 실패가 발생한 지점부터 다시 처리하면 됌)\n\n그러나, rank가 2개라 모든 문제를 map-reduce 패턴으로 묘사하기가 쉽지 않다는 점도 있었다.\n\n## Spark\n\n스파크는 오늘날 가장 많이 쓰이는 Data-Flow system으로 MapReduce에 비해 여러 부분에서 개선이 이루어졌다.\n\n1. rank를 2개로 제한하지 않음.\n  map, reduce 외의 tasks, ranks와 같은 여러 단계를 허용함.\n2. Map, Reduce 외의 별도의 유용한 함수 제공.\n3. 바로 디스크에 중간 결과를 저장하지 않고, 메모리에 캐싱하기도 함.\n  적당한 크기의 중간 결과는 메모리에 캐싱하기에 속도로 보다 빠르다\n4. MapReduce와 마찬가지로 단방향으로 데이터가 흐르는 DAGs 형식을 따른다.\n  (Directed Acycle Graphs)\n5. 여러 언어와 api를 제공하고, 오픈소스이며 호환성도 좋다.\n\n\u003ctip\u003e\n  `vs. Hadoop MapReduce`\n  Spark이 더 빠른대신 메모리 사용량도 더 많다.\n  Spark에서 제공하는 api가 더 많아 사용하기에 더 편하다.\n  둘 다 map-reduce 부분에서는 성능차이는 없다.\n\u003c/tip\u003e\n\n### RDD\n\nResilient Distributed Dataset의 약어로 Spark에서는 큰 데이터를 RDD 라는 청크로 쪼개어 key-value 페어로 저장한다.\n즉, RDD가 여러개의 클러스터에 분산 저장되는데, 가장 큰 특징은 RDD는 **읽기 전용**이라는 점이다.\n그렇기에 **파일로부터** RDD를 얻어오기도 하며, **RDD로부터** 새로운 RDD를 만드는 식으로 작업된다.\n또한, RDD는 일반적으로 **메모리에 캐싱**되며, 필요에 따라 디스크에 저장하기도 한다.\n\n\u003ctip\u003e\n  `DataFrame`\n  RDD와는 다르게 데이터들이 테이블 형태로 저장되먀 column별로 이름도 있다.\n  \u003cbr /\u003e\n  `DataSet`\n  DF의 상위호환으로 타입 세이프, 객체지향 프로그래밍 인터페이스를 지원하며, 컴파일 타임에 에러도 잡아낼 수 있다.\n\u003c/tip\u003e\n\n### Transformations\n\nRDD에서 새로운 RDD로의 변환을 Transformations라고 하는데, `map`, filter, join, union, intersection, distinct와 같은 변환이 있다.\n\n중요한 점은 이러한 변환은 `Lazy evaluation` 하게 동작한다는 점인데, 이게 무슨 말이냐면\n뭔가를 지시를 해도 실제로 수행을 하지 않는다는 뜻이다.\n지시를 하면 지시 사항을 기록하다가 사용자가 실제로 값을 요청시 기록된 요청을 최적화 알고리즘을 적용하여 한 번에 실행하기 때문에 효율적으로 동작하게 된다.\n\n### Actions\n\nLazy evaluation 중 실제로 동작을 수행하게 하는 명령이다.\ncount, collect, `reduce`, save 와 같은 명령이 있다.\n\n### Task Scheduler (General DAGs)\n\n![231019-153939](/posts/mid_02/231019-153939.png)\n\nSpark 스케쥴러는 스마트하게 동작하는데 그 특징은 다음과 같다.\n\n1. 파이프라인 함수를 제공한다.\n  Stage 1, Stage 2와 같이 여러 단계를 추상화하여 하나의 단계로 취급해 성능을 최적화 한다.\n2. 감당 가능한 크기의 데이터는 캐싱한다.\n  데이터를 캐싱하여 재사용성을 높이고, 속도도 빠르게 한다.\n3. key값 분포상태를 파악하여 불필요한 shuffle을 피한다.\n  일례로 A \u0026rarr; B로 넘어가며 키 값이 정렬되었으니, B \u0026rarr; F로 넘어갈때는 불필요한 셔플을 하지 않음.\n\n---\n\n## methods (real-code)\n\n\u003cnotice\u003e\n  Finding Similar Item까지 본 뒤에 코드를 보는 것이 더 좋습니다.\n\u003c/notice\u003e\n\n### (Spark) DataFrame\n\n- `printSchema()`\n  해당 데이터프레임의 스키마를 보여줍니다.\n\n- `take(N)`\n  N개의 행을 보여줍니다.\n\n- `show(n=N, truncate=boolean)`\n  N개의 행을 표 형태로 정리하여 보여줍니다.\n  truncate=False시 ...으로 요약되지 않은 전체 문자열을 출력합니다.\n\n- `select(columnName[])`\n  columnName에 해당하는 column들만 남긴 spark dataframe 객체를 반환합니다.\n\n- `selectExpr(sqlSelect[])`\n  sql select문에서 사용할 수 있는 문법을 이용하여 해당 column을 가져온 뒤 dataframe 객체로 반환합니다.\n\n- `sort(columnName, ascending=boolean)`\n  columnName을 기준으로 오름차순 정렬합니다.\n  ascending=False시 내림차순으로 정렬합니다.\n\n- `join(dataframe, this.column == dataframe.column)`\n  본인(this) dataframe과 인자로 넣은(dataframe) dataframe의 공통 column을 기준으로 natural join을 수행 후 dataframe 객체를 반환합니다.\n  단, 일반 sql과 다르게 공통 column이 하나만 표시되는게 아닌 중복되서 표시됩니다.\n\n- `toPandas()`\n  데이터가 pandas로 옮길 수 있을 만큼 작다면, spark dataframe에서 pandas dataframe으로 변환합니다.\n\n- `groupBy(columnName[])`\n  배열에 들어있는 모든 columnName을 기준으로 그루핑한 후 GroupedData 객체를 반환합니다.\n\n- `rdd`\n  spark dataframe에서 RDD 인스턴스를 생성합니다.\n\n### (spark) GroupedData\n\n- `count()`\n  각 그룹의 행의 개수를 카운트하여 count column을 만들고 dataframe 객체를 반환합니다.\n\n- `agg(column)`\n  column에 대해 집계함수를 수행합니다.\n  아래와 같이 응용하여 사용하면 item을 직렬화할 수 있습니다.\n  alias를 이용해 column의 이름을 변경할 수 있습니다.\n\n  ```python:.py\n  df = orders_joined.groupBy('order_id').agg(collect_set('product_name').alias('items'))\n  df.show()\n  ```\n\n  | order_id | items |\n  |---|---|\n  | 1 | [Bag of Organic B... ] |\n  | 96 | [Roasted Turkey, ... ] |\n  | 112 | [Umcka Elderberry... ] |\n\n### RDD (PipelinedRDD)\n\n- `collect()`\n  RDD를 출력합니다.\n\n- `map(function(row))`\n  RDD에 대해 function를 적용합니다.\n  파라미터로 RDD의 row가 전달됩니다.\n\n  ```python:.py\n  all_locations = jun_29_operations.rdd.map(lambda row: (row.TakeoffLocation, 1))\n  all_locations.take(3) \n  ```\n\n  적용 후 PipelinedRDD 객체를 반환합니다.\n\n  \u003e [('TAKHLI', 1), ('DANANG', 1), ('CONSTELLATION', 1)]\n\n- `flatMap(function)`\n  map과 동일한 기능을 수행합니다.\n  단, 결과가 1차원 배열만을 반환합니다.\n\n  ```python:.py\n  RDDs1 = RDDs1.flatMap(lambda line: line.split(' '))\n  ```\n\n- `reduceByKey(function(number, number))`\n  PipelinedRDD에 대해 function을 적용합니다.\n  파라미터로 2개의 key-value pair에 대해 value가 전달됩니다.\n\n  ```python:.py\n  locations_counts_rdd = all_locations.reduceByKey(lambda a, b: a+b).sortBy(lambda r: -r[1])\n  locations_counts_rdd.take(3)\n  ```\n\n  적용 후 PipelinedRDD 객체를 반환합니다.\n\n  \u003e [('CONSTELLATION', 87), ('TAKHLI', 56), ('KORAT', 55)]\n\n- `sortByKey(ascending=boolean)`\n  RDD key-value pair에 대해 key값을 기준으로 정렬합니다.\n\n- `filter(function)`\n  function이 true를 반환하는 값만 통과시켜 RDD객체를 반환합니다.\n\n### spark instance\n\n- `sql(queryString)`\n  sql문법을 queryString를 실행한 후 spark dataframe 객체를 반환합니다.\n\n- `createDataFrame(RDD)`\n  RDD를 spark dataframe 인스턴스로 변환합니다.\n  단, 인스턴스의 Row에 따라 Column의 이름이 결정됩니다.\n\n  예로 들어 reduceByKey 이후 바로 createDataFrame 생성시 Row의 이름이 작성되지 않아 Column명이 _1, _2와 같은 식으로 초기화됩니다.\n\n  따라서 아래의 코드로 이름을 지정하는 것이 시각화에 도움이 됩니다.\n\n  ```python:.py\n  locations_counts_with_schema = locations_counts_rdd.map(lambda r: Row(TakeoffLocation=r[0], MissionsCount=r[1]))\n  locations_counts = spark.createDataFrame(locations_counts_with_schema)\n  locations_counts.show()\n  ```\n\n- `sparkContext.textFile(path)`\n  path에 해당하는 파일을 읽은 뒤 RDD 인스턴스를 반환합니다.\n\n### FPGrowth\n\n- `FPGrowth(itemsCol=columnName, minSupport=number, minConfidence=number)`\n  dataframe의 columnName에 대해 연관규칙을 생성하는 FPGrowth 인스턴스를 생성합니다.\n  이 때 minSupport, minConfidence를 설정해야 합니다.\n\n- `fit(dataframe)`\n  생성된 FPGrowth 인스턴스에 대해 dataframe을 적용하여 FPGrowthModel을 만듭니다.\n\n- `freqItemsets, associationRules`\n  생성된 FPGrowthModel에 대해 `빈발 항목 집합`과 `연관 규칙`을 생성합니다.\n\n  ```python:.py\n  # grouping with order_id\n  df = orders_joined.groupBy('order_id').agg(collect_set('product_name').alias('items'))\n\n  # change to spark dataframe\n  df = spark.createDataFrame(df.toPandas(), ['id', 'items'])\n\n  # analysis using FP-Growth\n  from pyspark.ml.fpm import FPGrowth\n  fpGrowth = FPGrowth(itemsCol='items', minSupport=0.01, minConfidence=0.5)\n  model = fpGrowth.fit(df)\n\n  num_freqItemsets1 = model.freqItemsets.count()\n  num_associationRules1 = model.associationRules.count()\n  ```","slug":"univ_mmds/mid_02","readingMinutes":10,"wordCount":871},{"title":"분산 파일관리 시스템","description":"분산 파일관리 시스템에 관련한 기초 지식을 배웁니다.","icon":"","image":"","tags":["분산 파일관리","Chunk","Map","Reduce"],"draft":false,"date":"2023-10-19 / 14:13","content":"\n## 분산 파일관리 시스템\n\n방대한 데이터 보관, 또는 백업을 위해 데이터를 분산 저장하는 경우 여러대의 컴퓨터를 연결하여 하나처럼 동작하도록 구성해야 한다.\n\n하지만, 실시간으로 데이터를 처리해야 하는 부분에 대해서는 데이터를 복사하여 네트워크 전송을 통해 처리하는 방식은 네트워크 속도가 상대적으로 매우 느리기 때문에 문제가 있다.\n\n이런 경우에는 데이터를 옮기는 것이 아닌, 필요한 데이터를 보관하는 컴퓨터에게 `연산 작업을 맡기고`, `동기화는 주기적`으로 하는 방식을 사용하는 것이 좋다.\n\n이렇게 데이터를 분산하여 저장하는 시스템을 분산 파일관리 시스템이라 불리고, `Spark`, `MapReduce`와 같은 시스템이 이런 방식을 사용한다.\n하지만, 이런 파일관리 시스템은 1개의 머신만을 사용하는 시스템에 비해 속도가 느리기 때문에 아래의 조건을 만족하는 경우에만 사용하는 것이 바람직하다.\n\n1. 데이터 양이 매우 많은 경우\n2. 데이터의 수정은 왠만하면 일어나지 않는 경우\n3. 읽고 이어쓰기가 빈번하게 일어나는 경우\n\n### Chunk servers\n\n16~64MB 정도의 파일을 하나의 Chunk로 묶어 관리하는데, 이런 청크를 2, 3배 중복으로 다른 물리적 공간에 저장하는 식으로 분산 관리를 하게 되는데,\n이런 다른 물리적 공간을 Chunk server 라고 부른다.\n\n![231019-143146](/posts/mid_01/231019-143146.png)\n\n따라서 여러 청크서버에 동일한 청크가 분산 저장되어 있기 때문에 하나의 청크서버가 다운되더라도 데이터는 온전히 남는다.\n\n또한, 위에서 언급했 듯, 데이터를 움직이는 것이 아닌 연산을 일임한다고 했는데,\n서버의 과부화 방지를 위해 각 청크서버가 특정 청크에 필요한 연산을 전담하여 수행하고 결과를 반환한다.\n\n### Master node\n\n파일이 저장된 위치인 메타데이터를 저장한 서버이다.\n따라서 파일 엑세스 요청이 들어오면, 일단 모든 요청은 마스터 노드로 향하여 요청한 파일이 어느 청크서버에 있는지 알아낸다.\n이후 그 요청에 대한 응답은 청크서버로 직접 엑세스되어 청크서버에서 요청이 처리되게 된다.\n\n여기서 드는 의문점은 **왜 마스터 노드가 직접 데이터를 전달하지 않는가**이다.\n그 이유는 마스터 노드에 엑세스가 제일 많은데 데이터까지 전달하게 되면 과부화가 걸리기 때문에 그렇다.\n\n---\n\n## MapReduce\n\n초창기 분산 컴퓨팅 프로그래밍 모델이다.\n이 기술의 구현체로 Hadoop, Spark, Flink 등이 있는데, 이 모델의 동작 과정을 살펴보자.\n\n### overview\n\n![231019-144045](/posts/mid_01/231019-144045.png)\n\nMap, Group by Key(보통 자동으로 일어남), Reduce의 3단계로 이루어지는데, 각 단계에서 어떻게 일이 처리되는지 알아보자.\n\n참고로 Map, Reduce의 과정은 하나의 머신에서 일어나는 것이 아닌, 다중 머신에서 병렬적으로 일어난다는 점을 기억하자.\n\n### Map\n\n우선 개발자가 Map 함수를 작성한다.\nMap 함수는 읽은 데이터를 처리하기 위해 `key-value pair`로 변환하는 작업을 수행하게 된다.\n\n하지만 MapReduce에서 사용 가능한 규격으로 데이터를 처리해야 하는데 이 과정이 좀 까다로울 수 있다.\n\n추가로 이 이후에 생성된 key값을 이용해서 해싱같은 방식을 이용해 생성된 페어를 Reduce를 수행할 컴퓨터로 보내게 된다.\n\n### Group by Key\n\nMap으로 얻어진 pair을 key값을 중심으로 정렬하고, 중복된 key들에 대해 value 들을 배열로 묶어주는 일을 처리한다.\n대부분의 시스템에서 이 과정은 자동으로 일어나기 때문에 개발자가 개입할 부분이 상대적으로 적다.\n\n하지만 성능적으로 이 단계에서 `병목현상`이 발생할 수 있다.\nMap, Reduce는 파일이나 청크를 한 번만 탐색하면 끝나지만($O(n)$),\nGroup by Key는 정렬 및 그루핑을 해야하기 때문에 상대적으로 느리기 때문이다($O(n log(n))$).\n\n### Reduce\n\n개발자가 개발한 Reduce 함수를 이용해 배열로 되어있는 values들을 하나로 합쳐준다.\n이 과정이 종료되면 유니크한 key-value pairs가 생성될 것이다.\n\n### Dealing with Failures\n\n`Map worker`가 다운된 경우에는 일이 진행 중이든 완료되었든 간에 무조건 다른 worker에게 일을 처음부터 재시작하게 한다.\n왜냐하면 일이 완료된 경우 그 결과를 시간 비용의 문제 때문에 `로컬 디스크`에 데이터를 저장하기 때문이다.\n\n반면에 `Reduce worker`가 다운된 경우에는 일이 진행 중인 경우에만 다른 worker에게 일을 처음부터 재시작하도록 한다.\nReduce일이 완료된 경우, 그 결과는 중요한 데이터이니 `분산 저장`하기 때문에 완료된 경우에 다운되어도 재시작할 필요가 없는 것이다.\n\n### Cost Measure\n\nMapReduce 내부적으로 사용되는 알고리즘의 비용을 측정해보자.\n\n1. Communication cost\n  모든 프로세스의 **I/O bytes**\n\u003e (아래 항목을 모두 더하면 됌)\n\u003e - 입력 파일 사이즈\n\u003e - 2 $\\times$ Map process \u0026rarr; Reduce process 로 이동한 파일 사이즈 (2를 곱한 이유는 Map, Reduce 2개이기 때문)\n\u003e - Reduce process에서 나온 출력 사이즈의 합\n2. Elapsed communication cost\n  Communication cost 중 가장 큰(peak) 비용 (정확히는 파일 사이즈가 가장 큰 입력 파일 기준)\n  \u0026rarr; 이 비용이 작을수록 병렬(분산)화가 잘 되었다는 뜻이다.\n3. (Elapsed) Computation cost\n  1, 2와 동일, 단, 기준이 byte 단위가 아닌 **I/O 시간** 단위 기준임.\n\n\u003ctip\u003e\n  대부분의 클라우드 서비스는 Communication cost 기준으로 비용이 청구됌.\n  (Elapsed는 기준은 아님)\n\u003c/tip\u003e\n\n---\n\n## Problems Suited for MapReduce\n\nSpark과 같은 라이브러리 말고 MapReduce만 사용하기에도 충분한 문제들을 알아보자.\n보통 데이터 `순차탐색` 문제나, `비 실시간`으로 처리되어도 상관없는 여유로운 작업에 적합하다.\n\n### Host size\n\nurl로 부터 host를 추출하고, 해당 호스트에서 제공하는 많고 거대한 데이터의 총 크기(용량)을 알고싶을 때 사용할 수 있다.\n\n\u003e (host1, size1)\n\u003e (host2, size2)\n\u003e ...\n\n### Language Model\n\n언어 모델 개발시에도 이용할 수 있다.\n\n\u003e 5개의 단어 뭉치가 문서에서 얼마나 등장하는지\n\u003e (5-word seq, count)\n\n이런 경우도 map, reduce로 간단하게 만들 수 있다.\n\n### join\n\njoin 연산도 MapReduce로 할 수 있다.\n\n![231019-155529](/posts/mid_01/231019-155529.png)\n\n$R(A,B) \\Join S(B,C)$를 `natural join`한다로 해보자.\n\n\u003e `Map`\n\u003e 1. join에 사용될 column을 key로 사용하는 key-value 페어로 만든다.\n\u003e\n\u003e   ($b_1$, ($a_1$, R))\n\u003e   ($b_1$, ($a_2$, R))\n\u003e   ($b_2$, ($a_3$, R))\n\u003e   ($b_3$, ($a_4$, R))\n\u003e   ($b_2$, ($c_1$, S))\n\u003e   ($b_2$, ($c_2$, S))\n\u003e   ($b_3$, ($c_3$, S))\n\u003e\n\u003e 2. 키값을 해싱한 후 Reduce 프로세스로 보낸다.\n\n\u003e `Reduce`\n\u003e 1. Reduce를 진행한다.\n\u003e\n\u003e   ($h(b_1)$, [($a_1$, R), ($a_2$, R)])\n\u003e   ($h(b_2)$, [($a_3$, R), ($c_1$, S), ($c_2$, S)])\n\u003e   ($h(b_3)$, [($a_4$, R), ($c_3$, S)])\n\u003e\n\u003e 2. values에 R-S로 되어있는 value들만 묶어서 (a,b,c)로 출력한다.\n\u003e   (R-R, S-S를 제외하기 위해서 value pair에 R, S를 포함시킨 것이다)\n\u003e\n\u003e   ($a_3$, $b_2$, $c_1$)\n\u003e   ($a_3$, $b_2$, $c_2$)\n\u003e   ($a_4$, $b_3$, $c_3$)\n\n### Not Suited\n\n적합하지 않은 문제상황은 뭐가 있을까?\ngraph 탐색이나, ML에서의 `비 순차탐색` 하는 경우에는 적합치 않다.","slug":"univ_mmds/mid_01","readingMinutes":11,"wordCount":837},{"title":"Filtering in the Frequency Domain","description":"주파수 도메인에서의 필터링에 대해 다뤄봅니다.","icon":"","image":"","tags":["Fourier Transform","Frequency Domain","Highpass","Lowpass"],"draft":false,"date":"2023-10-18 / 21:11","content":"\n## Fourier Transform\n\n푸리에 변환을 간단하게 말하면 시간, 공간 도메인의 주기를 갖는 사인파의 합을 주파수 도메인의 함수로의 변환을 말한다.\n\n\u003ctip\u003e\n  `도메인 간의 관계`\n  \u003cbr /\u003e\n  ![231018-211849](/posts/mid_06/231018-211849.png)\n  \u003cbr /\u003e\n  시간 도메인이 길다는 의미는 주파수가 낮다는 뜻이다.\n  따라서 푸리에 변환시 저주파수 영역에서 값이 크게 나타난다.\n  반대의 경우도 마찬가지.\n  \u003cbr /\u003e\n  [**`전에 헷갈렸던 내용`**](https://wjlee611.github.io/blog/univ_com-vision/mid_02#sampling)으로 다시 돌아가서 보면 이해될 것.\n\u003c/tip\u003e\n\n### Property\n\n이제 영상을 푸리에 변환을 통해 주파수 도메인으로 변화를 시킬건데, 그 결과물을 분석하는 법을 알아보자.\n\n![231018-212424](/posts/mid_06/231018-212424.png)\n\nDC, 즉, 원점에 가까워 질 수록 주파수가 낮은 영역, 멀 수록 주파수가 높은 영역을 나타내는데,\n영상에서의 주파수는 변화율이라고 보면 된다.\n즉, 주파수가 크다 라는 의미는 영상이 변화하는 부분이 많다는 뜻이다.\n\n![231018-213206](/posts/mid_06/231018-213206.png)\n\n이 변환결과를 보고 이해해보자.\n\n우선 주파수 데이터를 보면 먼 곳이 어둡다.\n즉 영상 전체적으로 확확 변하는 부분이 적다는 뜻이다.\n\n그런데 X 모양으로는 밝은 것을 볼 수 있다.\n이 뜻은 해당 방향과 수직한 방향으로 변화가 많다는 것을 의미한다.\n실제로 원본 영상을 보면 같은 방향으로 홈도 파져있고, 변화가 많은 모습을 확인할 수 있다.\n\n그리고 미세하게 세로 방향으로 점선과 같은 무늬가 있다.\n이는 원본 영상에서 가로 방향으로 긴 무언가가 변화가 큼을 의미한다.\n실제로 원본 영상에는 가로로 흰 실같은 무언가가 있다.\n\n마지막으로 주파스 데이터 전체적으로 노이즈가 있다.\n이는 원본 영상에서도 노이즈가 있다는 뜻이다.\n\n---\n\n## Frequency Domain Filtering\n\n이제 푸리에 변환을 이용해서 주파수 도메인으로 변환된 영상을 이용한 필터링을 해보자.\n\n이 것이 가능한 이유는 LTI System 이기에 가능한 것이다.\nLTI System과 푸리에 변환을 이용한 연산의 단순화에 대한 내용은 [**`여기`**](https://wjlee611.github.io/blog/univ_com-vision/mid_02)에서 확인하자.\n\n![231018-214840](/posts/mid_06/231018-214840.png)\n\n앞으로 살펴볼 필터링에 대해 이 영상과 주파수 영상을 사용할 예정이다.\n여기서 주파수 영상의 얇은 흰 원 부분은 무시하자.\n일종의 $D_0$로 반지름을 나타내는 것인데, 원본 영상을 푸리에 변환 할 경우에는 나오지 않는다.\n\n### Ideal Lowpass Filter\n\n![231018-214145](/posts/mid_06/231018-214145.png)\n\n원본 영상을 푸리에 변환을 하고, 그 주파수 영상에 대해 위 사진의 흰색 영역만 살리고 나머지는 검게 만든 후 다시 역 푸리에 변환을 해볼 것이다.\n이 때, 위의 흰색 영역을 보면 낮은 주파수 영역만을 통과시킴을 알 수 있다.\n즉, 고주파수 영역, 변화량이 많은 영역을 없앤다는 뜻인데, 변화량이 많은 영역을 없앤다?\n즉, 영상을 뿌옇게 만들어 변화량이 적어지도록 하겠다는 의미이다.\n\n정리하면 Lowpass filter를 통과시키면 영상 전반적으로 Smoothing filter처리를 한 결과를 얻을 수 있다.\n\n해당 주파수 필터는 다음과 같이 정의할 수 있는데,\n\n$$\nH(u,v) = \\left\\{\\begin{matrix}\n1 \\;\\; if \\;\\; D(u,v) \\leq D_0 \\\\\n0 \\;\\; if \\;\\; D(u,v) \u003e D_0 \n\\end{matrix}\\right.\n$$\n\n이렇게 이상적으로 0과 1이 나뉘는 필터를 Ideal Lowpass filter라고 부른다.\n\n![231018-215052](/posts/mid_06/231018-215052.png)\n\n상단부터 지그재그 모양으로 $D_0$가 5, 15, 30, 80, 230 값으로 통과시키는 주파수 대역을 점점 늘린 변환 결과이다.\n\n$D_0$ = 5, 즉 매우 낮은 주파수를 갖는 대역만 통과시킨 영상은 영상이 매우 Smoothing 처리된 것을 확인할 수 있다.\n이게 무슨 의미냐면 그정도의 낮은 변화율로는 원본 영상의 가파른 변화를 표현하지 못하고,\n변환된 영상 정도의 완만한 변화율만 표현 가능하다는 뜻이다.\n\n따라서 $D_0$의 값을 키울수록 높은 변화도 표현 가능해져 점점 영상이 선명해지는 것을 볼 수 있다.\n다르게 말하면 **$D_0$ 값이 클수록 필터링 강도가 약해진다**.\n\n이때 주의깊게 볼 점은 변환된 영상에서 뭔가 일렁이는 듯한 노이즈가 생겼다는 점이다.\n왜 이런게 생긴걸까?\n\n바로 Ideal filter 특성 때문에 고주파수 영역을 깔끔하게 날려버렸기 때문에 세밀한 변화를 묘사하지 못해 화질이 떨어진 것이다.\n이를 개선할 수 없을까?\n\n### Butterworth Lowpass Filter\n\n\\'가능.\\' 당연히 개선할 수 있다.\n주파수 영역을 필터링할 때 적절하게 고주파수 영역을 통과시킨다면 화질 개선이 가능한데, 그 방법이 Butterworth 방식이다.\n\n![231018-215943](/posts/mid_06/231018-215943.png)\n\n약간의 곡률을 추가함으로서 일부 고주파수 영역을 통과시킨다.\n이 그래프를 구현하는 식은 다음과 같이 생겼다.\n\n$$\nH(u,v) = \\frac{1}{1+[D(u,v) / D_0]^{2n}}\n$$\n\n실제로 개선이 되었을까?\n\n![231018-220523](/posts/mid_06/231018-220523.png)\n\nSmoothing 효과는 살짝 약해졌지만, 확실이 울렁이는 듯한 노이즈는 제거되었다.\n약간의 화질 개선이 이루어 진 것이다.\n\n### Gaussian Lowpass Filter\n\n![231018-220657](/posts/mid_06/231018-220657.png)\n\n$$\nH(u,v) = e^{-D^2(u,v)/2D_0^2}\n$$\n\n위에 두 필터보다 성능이 좋은 가우시안 필터도 있다.\n그런데 Butterworth와 육안으로 구별되는 정도는 아니다.\n\n---\n\n### Highpass Filter\n\nLowpass는 영상을 뿌옇게 만들었는데, 반대로 Highpass는?\n그렇다. 영상을 더 샤프하게 만든다.\n정확하게 말하면 변화가 큰 부분만을 남기기에 Laplacian filter와 유사한 기능을 수행한다.\n\n![231018-221102](/posts/mid_06/231018-221102.png)\n\n위에서 부터 차례대로 Ideal, Butterworth, Gaussian Highpass Filter이다.\n함수를 구하는 방법은 그저 1에서 Lowpass 함수를 빼주면 된다.\n(Butterworth의 경우에는 $D$(분모) 와 $D_0$(분자)의 위치를 변환하면 된다)\n\n![231018-221329](/posts/mid_06/231018-221329.png)\n\nIdeal Highpass의 결과이다.\n역시 $D_0$값을 키울수록 필터의 강도가 약해진다.\n그렇기에 노이즈 역시 줄어든다.\n\n![231018-221426](/posts/mid_06/231018-221426.png)\n\n같은 필터 강도의 결과이다. 왼쪽부터 차례대로 Ideal, Butterworth, Gaussian Highpass이다.\n이번엔 Butterworth와 Gaussian도 육안으로 차이가 난다.\n여기서도 마찬가지로 Gaussian filter가 노이즈가 없고 깔끔하다.","slug":"univ_com-vision/mid_06","readingMinutes":9,"wordCount":672},{"title":"Filtering and Convolution","description":"Filtering 과 Convolution 의 동작방식과 차이를 다뤄봅니다.","icon":"","image":"","tags":["Kernel","Filtering","Convolution"],"draft":false,"date":"2023-10-17 / 21:51","content":"\n## Kernel\n\nFiltering과 Convolution에 적용할 데이터를 Kernel 이라고 부른다.\n즉, 원본 영상에 어떤 커널을 Filtering 혹은 Convolution 하느냐에 따라 다른 출력물이 나오는 것이다.\n\n커널에 적용방식은 뒤에 Filtering과 Convolution에서 다룰 예정이니 참고만 하고 나중에 다시오자.\n\n### Moving Average (Smoothing)\n\n가로, 세로가 N인 배열의 원소가 모두 $1/N^2$ 로 채워진 커널이다.\n이 커널을 적용하면 이미지가 뿌옇게 변하게 된다.\n\n### Laplacian\n\n3$\\times$3 배열에 중심이 -4, 상하좌우가 1, 나머지가 0으로 채워진 커널이다.\n이 커널을 적용하면 이미지 주변부가 강조되고, 중심부는 약화된다.\n\nLaplacian을 적용한 필터를 원본 이미지에서 빼는 방식으로 Sharping Filter를 구현할 수 있다.\n\n### Shift\n\n중심으로부터 n만큼 떨어진 거리에 1, 나머지는 0으로 채우면 Filtering의 경우 해당 방향의 반대 방향으로 영상이 이동한다.\n예로 들어 3$\\times$3 배열 중 가운데 왼쪽만 1, 나머지는 0인 커널로 영상을 Filtering시 영상은 오른쪽으로 1픽셀 Shift된다.\n\n---\n\n## Filtering\n\n![231017-225146](/posts/mid_05/231017-225146.png)\n\n영상의 주변부의 값을 이용해 변형시키는 과정을 필터링이라고 한다.\n필터링 과정은 [**`LTI System`**](https://wjlee611.github.io/blog/univ_com-vision/mid_02#lti-system)에서 이루어진다.\n\n이 필터링은 크게 Correlation Filtering (just Filtering)과 Convolution Filtering (just Convolution)으로 나뉘게 되는데,\n두 방식의 차이를 비교해보며 위에서 소개한 두 커널을 적용하면 이미지가 어떤식으로 바뀌는지 알아보자.\n\n### Filtering (Correlation)\n\n$$\ng(m,n) = f(m,n) * h(m,n) \\\\\n= \\sum_{k=m-a}^{m+a}\\sum_{l=n-a}^{n+a}f[k,l]\\times h[m-k,n-l]\n$$\n\n필터링은 `커널의 변형이 없이` 연산된다.\n\n위 수식을 보면 픽셀별로 주변 $a$만큼의 픽셀의 값을 참고하여 연산이 진행됨을 알 수 있는데, 이를 아래 그림으로 살펴보자.\n이 때 사용한 커널은 위에서 언급한 `Moving Average` 커널이다.\n\n![filtering_gif](/posts/mid_05/moving_average_filtering.gif)\n\n위 영상은 커널사이즈가 3$\\times$3 ($a=1$)인 Moving Average Kernel을 Filtering 한 결과이다.\n전반적으로 화면이 뿌옇게 변하는 영상을 얻을 수 있다.  \n\n### Convolution\n\n$$\ng(m,n) = f(m,n) * h(m,n) \\\\\n= \\sum_{k=m-a}^{m+a}\\sum_{l=n-a}^{n+a}f[k,l]\\times h[n-k,m-l]\n$$\n\n자세히 보면 h의 **m, n**의 위치가 Filtering과 `반대`이다.\n즉, 컨볼루전은 `커널이 대각선 반전`되어 연산된다.\n\n![231018-204207](/posts/mid_05/231018-204207.png)\n\n좌상단은 원본 영상, 우상단은 그 원본 영상에 Laplacian 커널을 Convolution한 결과이다.\n좌상단 영상에서 우상단 영상을 빼면 좌하단과 같이 영상의 윤곽선이 선명해지는 Sharping Filter를 구현할 수 있다.\n그런데 이게 어떻게 가능한걸까?\n\n이걸 가능케 하기 위해선 우선 사람이 빛을 인지할 때 그 민감도를 인지하는 법을 알아야 한다.\n\n![231018-204430](/posts/mid_05/231018-204430.png)\n\n사람이 밝은 빛을 보다가 어두운 빛을 보면은 원색보다 더 어둡게 느끼고,\n어두운 빛을 보다가 밝은 빛을 보면은 원색보다 더 밝게 느끼는 현상이 발생하는데, 이를 이용하는 것이다.\n\n구현할 때 빛의 밝기 `변화`에 초점을 맞춰보자.\n변화, 즉, 미분을 이용하는 것이다.\n\n\u003e 밝아진다 \u0026rarr; 기울기가 양의 기울기 \u0026rarr; 기울기가 증가함\n\n그림으로 살펴보자.\n\n![231018-204831](/posts/mid_05/231018-204831.png)\n\n밝기가 감소하기 시작하는 부분의 밝기는 높여주고, 감소가 끝나는 부분의 밝기는 높여주면 선명해지는 효과가 있다.\n그런데 2번 미분한 값을 보자.\n우리가 원하는 변화량과 정확히 반대의 값을 갖는다.\n\n즉, `2차 미분값을 원본 영상에서 빼주면`, 우리가 원하는 Sharping Filter를 구현할 수 있다.\n\n그런데 영상처리에서 미분계산이 너무 코스트가 크지 않을까 걱정이 된다.\n\n$$\nf'(x) = \\frac{df}{dx} = \\frac{f(x + \\Delta x) - f(x)}{x + \\Delta x - x}\n$$\n\n하지만, 실제로 그렇지 않다.\n디지털에서 영상 처리를 할 때는 Quantization를 했기 때문에 $\\Delta x$의 매우 작은 값은 1이 된다.\n따라서 다음과 같은 식으로 정리된다.\n\n$$\n\\frac{df}{dx} = f(x + 1) - f(x) \\\\\n{} \\\\\n\\frac{d^2f}{dx^2} = f(x + 1) - 2f(x) + f(x - 1) \n$$\n\n이 값은 사실 각각 `h[0, -1, 1]` / `h[1, -2, 1]`의 컨볼루전과 같다.\n따라서 1차원 영상의 경우에는 영상에 `h[1, -2, 1]` 커널을 컨볼루전 하면 된다.\n\n2차원은 위 방식을 편미분을 사용하여 비슷한 방식으로 진행하면 된다.\n`x에 대한 편미분` + `y에 대한 편미분` 값을 더하면 다음과 같은 3 $\\times$ 3 배열이 나오는데, 이 배열을 컨볼루전하면 원하는 Laplacian Filter를 구현할 수 있다.\n\n![231018-210553](/posts/mid_05/231018-210553.png)\n\n## Boundary (Edge)\n\nFiltering 부분에서 gif영상으로 봤을 때 가장자리는 데이터를 채워주지 못했다.\n그 이유는 커널 중심을 가장자리 영역으로 잡았을 때, 영상 외부의 값을 참조해야 값을 계산해야 하기 때문이다.\n\n이런 부분에 대한 해결책으로 간단하게 3가지만 알아보자.\n\n![231018-210916](/posts/mid_05/231018-210916.png)\n\n`zero padding` 방식은 없는 영상 영역을 0으로 채우고 하는 간단한 기법이다.\n\n`boundary value repetition`은 최외각 픽셀의 데이터를 반복하여 채우는 간단한 기법이다.\n\n`mirroring`은 마치 거울이 있는것 처럼 픽셀값을 반사하여 채우는 기법이다.","slug":"univ_com-vision/mid_05","readingMinutes":8,"wordCount":594},{"title":"Color Image","description":"색상과 관련된 용어와 변환을 다뤄봅니다.","icon":"","image":"","tags":["RGB","HSI"],"draft":false,"date":"2023-10-16 / 23:05","content":"\n## Color\n\n![231017-141752](/posts/mid_04/231017-141752.png)\n\n하얀색 빛은 RGB 색상의 빛을 모두 합칠 때 나타난다는 건 많이들 알고있을 것이다.\n하지만, 빛의 삼원색과 색상의 합을 두고는 의문이 든다.\n왜 마젠타와 노란색을 섞으면 밝아지는 것이 아닌 어두워지는 걸까.. 하고.\n\n색상이 보인다 라는 것은 사물이 `해당 색상의 빛을 반사`하고 `나머지 색상의 빛을 흡수`하기 때문이다.\n마젠타는 RB의 빛의 혼합이다. 즉 Green 색을 흡수한다는 뜻이다.\n노랑은 RG의 빛의 혼합이다. 즉 Blue 색을 흡수한다는 뜻이다.\n따라서 마젠타와 노랑을 섞은 색은 Green, Blue 색을 흡수한다는 뜻이니 R만 반사할 것이다.\n그렇기에 밝아지는게 아닌 어두워져서 Red 색상을 띄게 되는 것이다.\n\n### RGB Model\n\n![231017-142916](/posts/mid_04/231017-142916.png)\n\nRGB 모델은 아주 익숙한 색상 모델이다.\n빛의 삼원색인 Red, Green, Blue 색상의 빛의 밝기로 색상을 표현한다.\n\n### HSI Model\n\n![231017-143217](/posts/mid_04/231017-143217.png)\n\nHSI 모델은 생소하지만, 활용성이 뛰어난 색상 모델이다.\nHue, Saturation, Intensity의 3요소로 색상을 표현한다.\n\n`Hue`는 색상을 표현하는 각도로 `색조` 라고도 부른다.\n0$\\degree$는 Red, 180$\\degree$는 Cyan 등 각도 하나만으로 모든 색상을 나타내게 된다.\n\n`Saturation`은 색상의 포함 정도로 `채도` 라고도 부른다.\nSaturation값이 클수록 색상을 많이 함유하고 있다는 뜻이다.\n따라서 Saturation이 0이 되면 색상이 존재하지 않는, Gray 색상이 되어버린다.\n\n`Intensity`는 빛의 세기를 표현하는 정도로 `강도` 라도도 부른다.\nIntensity값이 클수록 빛이 강하다는 뜻이니 흰색에 가까워진다.\n\n### RGB vs HSI\n\n두 모델간의 가장 큰 차이라면 '빛의 밝기가 색상에 영향을 주는 가' 이다.\n\nRGB는 각 채널을 같은 비율로 늘리고 줄이는 방식으로 빛의 밝기를 조절한다.\n따라서 빛의 밝기가 변하면 다른 색상이라고 취급된다.\n\n하지만 HSI는 빛의 밝기를 I채널에서 관리한다.\n따라서 빛의 밝기가 변해도 같은 색상으로 취급된다. (정확히는 H, S값이 변하지 않는다)\n\n두 모델간 차이를 확인하기 위한 이미지이니 참고하자.\n\n![231017-211125](/posts/mid_04/231017-211125.png)\n\n---\n\n## Pseudocolor Image Processing\n\n흑백 데이터를 사람이 보기 쉽게 컬러로 대응시키는 과정을 의미한다.\n\n### Intensity Slicing\n\n![231017-211341](/posts/mid_04/231017-211341.png)\n\nIntensity 값을 기준으로 다르게 색상일 입히는 방식이다.\nSlicing plane을 여러개 두면 여러 색상으로 여러 범위의 색상을 입힐 수도 있다.\n\n![231017-211515](/posts/mid_04/231017-211515.png)\n\n---\n\n## Color Transformations\n\n기본적으로 앞서 배웠던 영상 변환과 같은 공식을 사용해서 변환한다.\n\n$$\ng(x,y) = T[f(x,y)]\n$$\n\n하지만 수식적인 부분은 뒤로 미뤄두고 어떤 채널을 어떻게 변화하면 영상이 어떻게 변화하는지를 중점적으로 알아보자.\n\n### Intensity\n\n![231017-212214](/posts/mid_04/231017-212214.png)\n\n위 영상은 Intensity만 30% 줄인 영상이다.\n\n![231017-212235](/posts/mid_04/231017-212235.png)\n\n그 결과 RGB 모델은 모든 채널이 30% 감소했지만,\nHSI 모델은 I 채널만 30% 감소한 모습을 볼 수 있다.\n\n### Color Complements\n\n![231017-212435](/posts/mid_04/231017-212435.png)\n\n위 영상은 보색으로 색상을 반전시킨 영상이다.\n그 결과 RGB 모델은 각 색상 채널이 상하반전된 모습을 취하게 되었다.\n\nHSI 모델은 색상이 반전되었기에,\nHue는 180$\\degree$만큼 shift된 모습의 그래프를 보이게 되었고, Intensity 역시 반전되었다.\n하지만, S는 역시 변화가 없다.\n\n---\n\n## Tone and Color Correction\n\n이번엔 색상과 밝기 등을 수정하면서 어떻게 하면 영상을 보기좋게 만들 수 있는지 알아보자.\n\n![231017-214520](/posts/mid_04/231017-214520.png)\n\nRGB 채널에 ease 커브를 줄 경우 어두운 부분은 더 어둡게, 밝은 부분은 더 밝게 만들 수 있다.\n하지만 역시 밝기만 건드렸기 때문에 H, S값의 변화는 없다.\n\n![231017-214624](/posts/mid_04/231017-214624.png)\n\n전체적으로 너무 밝은 영상의 경우에는 곡률을 아래로 주게 될 경우\n영상 톤을 전체적으로 어둡게 바꿀 수 있다.\n\n![231017-214711](/posts/mid_04/231017-214711.png)\n\n반대의 경우도 가능하다.\n\n![231017-215001](/posts/mid_04/231017-215001.png)\n\n색상별로 톤 변화를 줄 수 있다.\n이 경우 색상도 바뀐다.\n\n본인 기준 특이하다고 생각되었던건 특정 색상을 어둡게 커브를 줬더니 영상에서는 오히려 해당 색이 많이 보이도록 조정되었다는 점이 인상적이었다.\n\n---\n\n## Color Slicing\n\n특정 색상영역을 추출하는 기법이다.\n예로들어 피부색을 추출하고 싶다면, 피부색과 오차범위에 해당하는 색상만을 선택하여 남기는 작업을 수행하게 된다.\n\n특정 영역을 선별하는 공식은 아래 2가지 방법이 있다.\n\n$$\ns_i = \\left\\{\\begin{matrix}\n0.5 \\;\\; if[|r_j-a_j| \u003e \\frac{W}{2}]_{any \\; 1 \\leq j \\leq n} \\\\\nr_i \\;\\; otherwise\n\\end{matrix}\\right.\n$$\n\nRGB 3채널을 기준으로($n=3$) 픽셀의 색상($r_j$)과 기준값($a_j$)의 차이가 오차범위($W/2$)보다 크면 0.5로 세팅하고,\n오차범위 내부, 즉, 추출하고자 하는 색상 영역이면 원색상을 유지한다.\n\n이 때, 허용범위는 RGB 스페이스에서 `정육면체` 모양으로 구성되게 된다.\n따라서 실제 원했던 색상영역보다 약간 더(꼭짓점 부분) 색상을 포함할 수 있다.\n\n\u003cbr /\u003e\n\n$$\ns_i = \\left\\{\\begin{matrix}\n0.5 \\;\\; if\\sum_{j=1}^{n}(r_j-a_j)^2 \u003e R_0^2, \\\\\nr_i \\;\\; otherwise\n\\end{matrix}\\right.\n$$\n\nRGB 3채널을 기준으로($n=3$) 픽셀의 색상($r_j$)과 기준값($a_j$)의 차이가 오차범위($R_0$)보다 크면 0.5로 세팅하고,\n오차범위 내부, 즉, 추출하고자 하는 색상 영역이면 원색상을 유지한다.\n\n이 때, 허용범위는 RGB 스페이스에서 `구` 모양으로 구성되게 된다.\n따라서 실제 원했던 색상영역을 정확하게 표현할 수 있다.\n\n![231017-214142](/posts/mid_04/231017-214142.png)\n\n왼쪽은 첫번째 방법으로, 오른쪽은 두번째 방법으로 Slicing한 영상이다.\n더 나아보이는 방식으로 취사선택하면 될 거 같다.","slug":"univ_com-vision/mid_04","readingMinutes":9,"wordCount":638},{"title":"Intensity Transformations","description":"이미지 밝기 변환에 대한 내용을 다뤄봅니다.","icon":"","image":"","tags":["Transform Function","Histogram","Equalization"],"draft":false,"date":"2023-10-16 / 21:09","content":"\n## Transform Functions\n\n입력 영상에 대해 밝기값(에너지 레벨)의 변화를 가하고 싶다면 단순히 픽셀값의 데이터에 변화를 가하면 된다.\n\n$$\ns = T(r)\n$$\n\n하지만, 특정 데이터를 어떻게 변화시키는지에 따라 출력 영상이 달라지고, 거기에서 얻을 수 있는 정보도 달라진다.\n그 데이터를 변화시키는 기준인 변환 함수의 종류와, 그 결과를 알아보자.\n\n\u003cnotice\u003e\n  얻을 수 있는 정보가 달라진다는 표현을 사용했는데,\n  **강조**하고싶은 정보가 달라진다는 것이지 **실제** 정보량 자체는 변하지 않는다.\n  물론 임의로 특정 밝기 영역을 0으로 만든다면 정보량이 줄어들 수는 있다.\n  하지만 **물리적인 정보량은 절대 늘어나지 않는다**. (사람 눈에 보기 편하게 바꿀 뿐)\n\u003c/notice\u003e\n\n### Basic\n\n![231016-212632](/posts/mid_03/231016-212632.png)\n\n이제부터 그래프를 해석하는 능력이 중요해진다.\n예로 들어 `Log` 함수를 변환 함수로 선택한다면 `전반적으로 영상이 밝아짐`을 알 수 있어야 한다.\n$y=-x$ 형태의 `Negative` 함수를 선택한다면 영상 명암이 아래와같이 `반전`될 것이다.\n\n![231016-213010](/posts/mid_03/231016-213010.png)\n\n### Power-Law (Gamma)\n\n위의 기본 함수로는 세부적으로 변화시키기 힘들것이다.\n하지만 아래의 함수를 이용하면 상수값($\\gamma$)를 변화시켜 변환을 세부적으로 처리할 수 있게된다.\n\n$$\ns = cr^\\gamma\n$$\n\n감마값이 커질수록 변환된 영상이 어두워지는 특징이 있다.\n\n![231016-213224](/posts/mid_03/231016-213224.png)\n\n감마 함수는 Gamma correction에 자주 사용되곤 하는데,\n이게 뭐냐면, 출력 장치의 빛의 세기를 조정해 원본 영상과 같은 영상을 디스플레이 할 수 있도록 하는 과정이다.\n\n![231016-213529](/posts/mid_03/231016-213529.png)\n\n### Piecewise-Linear\n\n선형 커브를 여러 범위로 쪼갠 함수로\n특정 범위의 값을 확장하거나, 임의의 값으로 변경할 때 사용한다.\n\n![231016-214238](/posts/mid_03/231016-214238.png)\n\n함수가 좌상단과 같이 주어질 경우 우상단의 이미지가 좌하단의 이미지처럼 변환된다.\n특정 범위의 값을 확장시켜 비슷한 레벨의 빛을 분산시켜 차이를 만든 것이다.\n\n$\\overline{(r_1,s_1)(r_2,s_2)}$의 기울기를 수직으로 만들면 `Threshold` 함수라고 불리우게 되는데,\n그렇게 되면 특정 범위 이하의 빛은 검은색, 이상의 빛은 흰색으로 이분된다.\n\n이러한 처리 기법을 `Contrast Stretching` 라고 부른다.\n\n![231016-214728](/posts/mid_03/231016-214728.png)\n\n이렇게 함수가 주어진 경우에는 영상이 다음과 같이 변환된다.\n\n![231016-214753](/posts/mid_03/231016-214753.png)\n\n특정 부분을 제외한 나머지 영역을 죽이거나, 특정 부분만을 강조할 때 사용하는데,\n이런 처리 기법을 `Intensity-Level Slicing` 라고 부른다.\n\n---\n\n## Histogram Processing\n\n\u003ctip\u003e\n  `Histogram`\n  데이터의 분포를 한 눈에 볼 수 있는 그림 혹은 그래프\n\u003c/tip\u003e\n\n영상의 에너지 레벨 분포를 알고싶다면 다음과 같은 과정으로 구할 수 있다.\n\n$$\nh(r_k) = n_k\n$$\n\n여기서 $r_k$는 k번째 gray level(에너지 레벨 0~255)를 나타내고,\n$n_k$는 그 에너리 레벨을 갖는 픽셀의 개수를 의미한다.\n코드로 구현한다면 다음과 같이 구현할 수도 있을것이다.\n\n```cpp:.cpp\nunsigned int Histogram[256] = {0};\n\nfor (h=0; h\u003cH; h++) {\n  for (w=0; w\u003cW; w++) {\n    Histogram[img[w][h]]++;\n  }\n}\n```\n\n하지만 단순 픽셀 수를 세기만 한다면, 매우 큰 영상의 경우 평균적인 빛의 밝기가 어두움에도 값이 크게 나오는 문제가 발생할 수 있다.\n따라서 영상 크기에 따라 자료해석의 차이를 없애도록 영상 크기로 나누어 확률로서 일반화하게 된다.\n\n$$\np(r_k) = \\frac{n_k}{WH}\n$$\n\n이걸 왜 하는건지 알아보기 전에 우선 서로 다른 영상별로 수집된 히스토그램을 살펴보자.\n\n![231016-220848](/posts/mid_03/231016-220848.png)\n\n히스토그램의 분포를 살펴보면 모든 영역에 골고루 분배된 영상이 가장 보기 좋음을 알 수 있다.\n그렇다면 히스토그램 분포를 분산시키는게 영상 품질 개선에 도움이 된다는 것을 알게 되었다.\n\n### Equalization\n\n그렇다면 히스토그램 분포를 골고루 분배할 수 있을까?\n\n![231016-221610](/posts/mid_03/231016-221610.png)\n\n결론부터 말하면 이렇게 이상적으로 분배는 불가능하다.\n0이었던 데이터를 0과 1로 적절히 분산하는 방법이 없기 때문이다.\n\n![231016-222414](/posts/mid_03/231016-222414.png)\n\n이렇게 구현하는 것이 최선일 것이다.\n\n구현에 있어 중요한 점은 **일정 범위 내**의 변환 전과 변환 후의 `확률 분포는 같아야 한다`는 점이다.\n예로 들어 변환 전의 범위 `0~1`은 변환 후의 범위 `0~3`으로 대응되는데, `각 구간의 확률의 합은 동일`함을 알 수 있다.\n이 사실을 식으로 일반화 하면 다음과 같아진다.\n\n$$\n\\sum_{i=0}^{r}p_r(i) = \\sum_{i=0}^{s}p_s(i)\n$$\n\n이를 연속적인 값으로 표현하기 위해 적분식으로 변환하면 다음과 같아진다.\n\n$$\n\\int_{0}^{r}p_r(w)dw = \\int_{0}^{s}p_s(w)dw\n$$\n\n여기서 다시 상기해보자면 $p_r$은 원본 히스토그램 분포(확률 함수)이고, $p_s$는 목표로 하는 히스토그램 분포이다.\n이상적인 확률 함수는 다음 그림과 같을 것이다.\n\n![231016-222950](/posts/mid_03/231016-222950.png)\n\n해당 함수는 $p_s = \\frac{1}{L-1}$ 로 표현 가능한데 이를 위의 적분식에 대입하면 다음과 같이 정리할 수 있다.\n\n$$\n\\int_{0}^{r}p_r(w)dw = \\int_{0}^{s}p_s(w)dw = \\int_{0}^{s}\\frac{1}{L-1}dw = \\frac{s}{L-1} \\\\\n{} \\\\\ns = T(r) = (L-1)\\int_{0}^{r}p_r(w)dw\n$$\n\n이제 이 공식을 이용해서 프로그래밍하기 위해 다시 불연속적인 값의 합으로 바꿔보자.\n\n$$\ns_k = T(r_k) = (L-1)\\sum_{j=0}^{k}p_r(r_j)\n$$\n($k$는 일정 범위에 해당하는 x축의 값이다.)\n\n이 때, $p_r(r_j)$는 위에서 히스토그램의 확률로서 일반화 한 식을 대입하면 된다.\n즉 최종 변환식은 다음과 같다.\n\n$$\ns_k = T(r_k) = \\frac{L-1}{MN}\\sum_{j=0}^{k}n_j \\; , \\;\\; k=0, 1, ..., L-1\n$$\n\n아래 표를 기준으로 연습을 해보자.\n\n| $r_k$ | $n_k$ | $p_r(r_k) = n_k/MN$ | s_k\n|---|---|---|---|\n| $r_0$ = 0 | 790 | 0.19 | $s_0$ = 1.33 \u0026rarr; 1 |\n| $r_1$ = 1 | 1023 | 0.25 | $s_1$ = 3.08 \u0026rarr; 3 |\n| $r_2$ = 2 | 850 | 0.21 | $s_2$ = 4.55 \u0026rarr; 5 |\n| $r_3$ = 3 | 656 | 0.16 | $s_3$ = 5.67 \u0026rarr; 6 |\n| $r_4$ = 4 | 329 | 0.08 | $s_4$ = 6.23 \u0026rarr; 6 |\n| $r_5$ = 5 | 245 | 0.06 | $s_5$ = 6.65 \u0026rarr; 7 |\n| $r_6$ = 6 | 122 | 0.03 | $s_6$ = 6.86 \u0026rarr; 7 |\n| $r_7$ = 7 | 81 | 0.02 | $s_7$ = 7.00 \u0026rarr; 7 |\n$L=8$\n\n$$\ns_0 = T(r_0) = (8-1)\\sum_{j=0}^{0}p_r(r_j) = 7 \\times 0.19 = 1.33 \\\\\ns_1 = T(r_1) = (8-1)\\sum_{j=0}^{1}p_r(r_j) = 7 \\times (0.19 + 0.25) = 3.08 \\\\\n$$\n\n즉, $s_0$가 1이기 때문에, $r_0$(0)에 존재하던 에너지 레벨을 1로 올리고,\n$s_1$가 3이기 때문에, $r_0$(1)에 존재하던 에너지 레벨을 3로 올리는 과정을 거치면 Equalization을 달성할 수 있다.\n\n이련 변환의 경우 히스토그램과 $T(r)$의 그래프는 다음과 같은 모양을 갖게 된다.\n\n![231016-225134](/posts/mid_03/231016-225134.png)\n\n이런 경우 Equalization을 진행한 영상은 원본 영상에 비해 물리적인 정보량은 줄어들게 된다.\n하지만, 사람의 눈으로 보기에는 더 보기 좋은 영상이 된다.\n\n서로 다른 영상에 대해 Equalization을 적용한 예시와 그 $T(r)$ 함수를 살펴보자.\n\n![231016-225624](/posts/mid_03/231016-225624.png)\n![231016-225636](/posts/mid_03/231016-225636.png)\n\n여기서 알 수 있는 점은 원본의 히스토그램 분포가 빽빽하게 모여있을 수록 변환된 영상의 히스토그램 분포에 빈공간이 많이 생긴다는 것이다. (정보량의 손실이 많아진다)\n\n### Specification\n\n하지만 히스토그램을 이용한 Equalization이 만능인 것은 아니다.\n\n![231016-225928](/posts/mid_03/231016-225928.png)\n\n이런 영상처럼 너무 극단으로 몰린 경우에 적용한 결과는 다음과 같이 나올 수 있는데,\n\n![231016-230011](/posts/mid_03/231016-230011.png)\n\n이런 경우에는 단순히 $p_s = \\frac{1}{L-1}$ 를 사용하여 변환 함수를 구하는 것 보다,\n사용자 정의 함수 $p_z$를 만들어서 처리하는게 더 좋은 영상을 만들 수 있다.\n\n![231016-230350](/posts/mid_03/231016-230350.png)","slug":"univ_com-vision/mid_03","readingMinutes":11,"wordCount":936},{"title":"Singal Processing Fundamentals","description":"신호 처리에 대한 기초적인 정보입니다.","icon":"","image":"","tags":["LTI System","Convolution","Fourier Transform"],"draft":false,"date":"2023-10-15 / 21:57","content":"\n## LTI System\n\nLinear Time Invariant System은 다음과 같은 성질을 갖는다.\n\n1. Linear\n  선형성을 유지한다.\n\n  \u003ctip\u003e\n    `선형성`\n\n    $$\n    H[a_if_i(x,y) + a_jf_j(x,y)] \\\\\n    = a_iH[f_i(x,y)] + a_jH[f_j(x,y)] \\\\\n    = a_ig_i(x,y) + a_jg_j(x,y)\n    $$\n  \u003c/tip\u003e\n\n2. Time Invariant\n  시간에 대해 불변성을 갖는다.\n  즉, 시간이 변해도 delay만 있을 뿐, 동일한 input에 대해 동일한 output을 내보낸다.\n\n### System Response\n\n신호 처리를 위해 신호를 디지털화 한 다음 변환(filter)을 가해서 다시 연속적인 신호로 변환하기 위한 과정을 살펴보자.\n\n![231015-222017](/posts/mid_02/231015-222017.png)\n\n우선 신호를 특정 구간에서 일정한 값으로 근사한다.\n그리고 특정 구간에 대해 근사된 데이터에 변환(filter)를 가한다. \n(참고로 filtering에 대해선 추후에 소개할 예정. 지금은 LTI System을 이용해서 신호를 변환하는 과정만 살펴보자.)\n\n그렇게 변환된 데이터를 다시 연속적인 신호로 변환하기 위해선 LTI System에 Pulse를 적용한 결과를 응용하면 된다.\n\n![231015-222538](/posts/mid_02/231015-222538.png)\n\n넓이가 1인 Pulse를 LTI System에 통과시키면 위와 같은 그래프로 변형된다고 하자.\n이 때, LTI System은 선형성을 유지하고 시간 불변성을 갖기 때문에 Pulse의 세기가 커지거나, 시간이 shift돼도,\nLTI System을 통과해도 그 변화가 유지된다.\n\n그렇기에 위에서 변환된 데이터를 특정 구간에 대해 Pulse라고 생각한다면,\n그 데이터를 LTI System에 통과시키면 다음과 같이 변환될 것이다.\n\n![231015-222954](/posts/mid_02/231015-222954.png)\n\n## Convolution\n\n위에서 언급한 Pulse에 대해 단위 시간(T)를 0에 가깝게 보내면 연속적인 신호에 대한 Pulse가 되는데, 이를 Impulse라고 한다.\n이런 Impulse를 LTI System에 통과시키면 위에서 봤던 그래프 형태로 나오게 되는데, 이를 임펄스 반응 이라고 하고, $h(t)$ 라고 하자.\n\n![231015-223956](/posts/mid_02/231015-223956.png)\n\n입력 신호 $f$와 출력 신호 $y$는 다음과 같은 관계를 갖게 된다.\n\n$$\ny(t) = f(t) * h(t)\n$$\n\n즉, LTI System의 출력($y$)은 시스텝의 임펄스 반응($h$)과 입력($f$)의 Convolution이다.\n\n## Fourier Transform\n\n![231015-224927](/posts/mid_02/231015-224927.png)\n\n푸리에 변환의 기본적인 아이디어는 주기적인 어떠한 함수는 모두 sin파 또는 cos파의 합으로 표현(근사)될 수 있다에서 출발한다.\n\n푸리에 변환을 거치면 시간에 대한 함수가 주파수에 대한 함수로 변환되는데,\n시간 축이 주파수 축으로 변환된다는 뜻이다.\n단적인 예로, 주기가 $2\\pi$이고, 크기가 1인 sin함수는 크기가 1이고, $u=1 (2\\pi)$인 Impulse 형태로 그려진다.\n\n\u003ctip\u003e\n  `푸리에 변환`\n  $$\n  F(u) = \\int_{-\\infty}^{\\infty} f(x)e^{-i2\\pi ux}dx\n  $$\n\n  `역 푸리에 변환`\n  $$\n  f(x) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} F(u)e^{iux}dx\n  $$\n\u003c/tip\u003e\n\n그런데 왜 푸리에 변환을 알아야 할까?\n바로 푸리에 변환을 사용하면 Convolution 연산이 매우 간단한 형태로 변환되기 때문이다.\n\n$$\nG(u) = \\int_{-\\infty}^{\\infty}g(x)e^{-i2\\pi ux}dx \\\\\n= \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(\\tau)h(x-\\tau)e^{-i2\\pi ux}dx \\\\\n= \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}[f(\\tau)e^{-i2\\pi u\\tau}d\\tau][h(x-\\tau)e^{-i2\\pi u(x-\\tau)}dx] \\\\\n= \\int_{-\\infty}^{\\infty}[f(\\tau)e^{-i2\\pi u\\tau}d\\tau]\\int_{-\\infty}^{\\infty}[h(x')e^{-i2\\pi ux'}dx'] \\\\ \n= F(u)H(u)\n$$\n\n즉, 기존 도메인($x$)에서의 Convolution 연산이 푸리에 변환된 주파수 도메인($u$)에서는 단순 곱셈으로 표현된다.\n\n![231015-230238](/posts/mid_02/231015-230238.png)\n\n따라서 Convolution 연산을 간단하게 하기 위해서는 일단 푸리에 변환 후 곱연산을 수행해서 다시 역 푸리에 변환을 거치는 과정을 수행하는게 좋다.\n\n### Sampling\n\n[**`이전 포스트`**](https://wjlee611.github.io/blog/univ_com-vision/mid_01#aliasing)에서 Sampling이 적으면 Aliasing이 발생한다고 했었는데, 그 이유을 알아보자.\n\n![231015-230835](/posts/mid_02/231015-230835.png)\n\n왼쪽은 시간 도메인 기준으로 입력 신호에 적절하게 샘플링된 Impulse를 Convolution하면 좌하단처럼 샘플링이 이루어진다.\n오른쪽은 왼쪽을 푸리에 변환한 결과로 Convolution 대신 곱연산한 결과이다.\n\n~~(본인도 이해는 안되지만)~~ 여기서 중요한 것은 샘플링이 촘촘할 수록\n푸리에 변환된 스펙트럼이 듬성듬성 해진다는 점이다.\n\n만약, 샘플링이 적은수가 되었다면 우하단의 입력 신호의 스펙트럼 봉우리(?)가 오버랩될 것이다.\n오버랩 되는 경우 원본을 복구할 수 없기에 Aliasing이 발생하는 것이다.","slug":"univ_com-vision/mid_02","readingMinutes":6,"wordCount":449},{"title":"Digital Image Fundamentals","description":"디지털 이미지에 대한 기초적인 정보입니다.","icon":"","image":"","tags":["Sampling","Quantization","Interpolation"],"draft":false,"date":"2023-10-15 / 20:05","content":"\n## Sampling \u0026 Quantization\n\n연속적인 자연계의 현상을 기록하기 위해서는 이미지를 불 연속적인 형태. 즉, 디지털로 변환해야 한다.\n\n예로 들어 이미지의 좌표가 100.32라면? 반올림을 하던지 적당히 100과 같은 불 연속적인 값으로 치환해야 하며,\n에너지레벨 역시 이와 같은 방식으로 디지털화 해야한다.\n\n이렇게 자연계의 연속적인(무한한) 값을 `디지털화 하기 위해 유한하게` 자르는 과정을 `Sampling`이라 하고,\n무한 소수의 데이터를 `양자화시켜 비트에 저장할 수 있게` 자르는 과정을 `Quantization`라고 한다.\n\n![231015-201653](/posts/mid_01/231015-201653.png)\n\n**좌상단**의 이미지 중에서 $\\overline{AB}$ 를 디지털화 해본다면,\n**우상단**의 그래프처럼 에너지레벨(빛의 밝기)이 표현될 것이다. (지글지글 거리는 것은 센서의 한계로인한 노이즈)\n샘플링을 일정 구간으로 잘라 네모난 점으로 표현하면 **좌하단**의 이미지처럼 될 것이고,\n이를 양자화하면 **우하단**의 이미지처렴 변화하여 디지털로 저장할 수 있게 된다.\n\n![231015-202204](/posts/mid_01/231015-202204.png)\n\n이런 방식으로 2차원 이미지를 디지털화 하면 위와 같은 모양이 될텐데,\n연속적인 데이터를 불연속적인 데이터로 변환하면서 어쩔 수 없는 데이터의 손실이 발생할 수 있다.\n\n\u003ctip\u003e\n  픽셀의 가로축은 x축, 세로축은 y축이며,\n  x좌표는 늘 보던 좌표계와 마찬가지로 오른쪽으로 갈 수록 커지지만,\n  y좌표는 반대로 내려갈수록 커진다. **(y축 반전 주의)**\n  \u003cbr /\u003e\n  M행 N열(M$\\times$N)의 이미지는 다음과 같은 배열에 저장할 수 있다.\n\n  $$\n  f(x,y) = \\begin{bmatrix}\n  f(0,0) \u0026 f(0,1) \u0026 ... \u0026 f(0,N-1) \\\\\n  f(1,0) \u0026 f(1,1) \u0026 ... \u0026 f(1,N-1) \\\\\n  ... \u0026 ... \u0026 ... \u0026 ... \\\\\n  f(M-1,0) \u0026 f(M-1,1) \u0026 ... \u0026 f(M-1,N-1) \\\\\n  \\end{bmatrix}\n  $$\n\u003c/tip\u003e\n\n### Aliasing\n\n![231015-205116](/posts/mid_01/231015-205116.png)\n\n샘플링을 위 이미지와 같이 극단적으로 적게 할 경우, 조건이 없다면 원본 데이터를 유추할 수 없게 된다.\n또는 변화량이 너무 큰 경우에도 위와 같은 Aliasing 현상이 발생할 수 있다.\n예로 들어서 선풍기를 영상으로 찍으면 멈춰있는 듯한 현상이 그런 경우이다.\n\n### Quantization Level\n\n![231015-204846](/posts/mid_01/231015-204846.png)\n\n양자화를 얼마나 세밀하게 할지를 Quantization Level이 결정한다.\n레벨이 적을수록 듬성듬성 양자화하게 되고(점선 간격이 늘어남), 이는 화질 저하로 이어진다.\n하지만 용량은 절약될 것이다.\n\n### Size (Storage bits)\n\n이렇게 저장된 영상의 크기를 구해보자.\n\n\u003cnotice\u003e\n  이미지의 화질은 M$\\times$N으로 가정하고,\n  각 픽셀은 0~255, 즉, 8 bits의 에너지 레벨을 갖는다고 가정하자.\n\u003c/notice\u003e\n\n단색 이미지(Gray Image)의 경우 1픽셀은 8bits가 필요하기에 1byte.\n이 픽셀이 M$\\times$N개 있으니 M$\\times$Nbytes.\n컬러 이미지의 경우 RGB 3개의 색상 채널이 있으니 3을 곱해서 M$\\times$N$\\times$3bytes 가 된다.\n\n위 계산 결과는 하나의 이미지에 대한 사이즈로, 동영상의 경우에는 30프레임의 경우 추가로 30을 더 곱해줘야 할 것이다.\n\n### Saturation\n\n![231015-203543](/posts/mid_01/231015-203543.png)\n\n센서까지 차이가 있던 데이터가 샘플링 과정에서 차이가 없어지는, Saturation 현상이 발생할 수 있다.\n\n### Gray Level\n\n![231015-203931](/posts/mid_01/231015-203931.png)\n![231015-203946](/posts/mid_01/231015-203946.png)\n\nGray Level이 높을 수록 에너지 레벨을 세분화해서 표현할 수 있다.\n따라서 디스플레이 장치가 좋지 않아서 Gray Level이 낮을 경우 같은 이미지라도 위 사진처럼 다르게 표현될 수 있다.\n\n## Interpolation\n\n디지털화된 이미지의 사잇값을 적절히 채워 실제 데이터를 추측하는 과정,\n또는, 저화질의 영상의 픽셀값을 채워 고화질로 바꾸거나, 영상의 회전, 축소시 픽셀값을 추측하는 과정을 Interpolation 라고 한다.\n\n### Pixel math\n\n보통 아래와 같은 행렬간의 연산 혹은 픽셀별 계산으로 처리된다.\n\n$$\n\\begin{bmatrix}\na_{11} \u0026 a_{12} \\\\\na_{21} \u0026 a_{22} \\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nb_{11} \u0026 b_{12} \\\\\nb_{21} \u0026 b_{22} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11} + b_{11} \u0026 a_{12} + b_{12} \\\\\na_{21} + b_{21} \u0026 a_{22} + b_{22} \\\\\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\na_{11} \u0026 a_{12} \\\\\na_{21} \u0026 a_{22} \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nb_{11} \u0026 b_{12} \\\\\nb_{21} \u0026 b_{22} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11}b_{11} + a_{12}b_{21} \u0026 a_{11}b_{12} + a_{12}b_{22} \\\\\na_{21}b_{11} + a_{22}b_{21} \u0026 a_{21}b_{12} + a_{22}b_{22} \\\\\n\\end{bmatrix}\n$$\n\n단, 보통 픽셀값은 0~255 사이의 값을 갖기 때문에, overflow, underflow에 대해 적절하게 처리해줘야 한다.\n\n### Linear\n\n$H[f(x,y)] = g(x,y)$ 와 같은 변환 함수 $H$가 있을 때,\n아래의 특성을 만족하면 $H$가 선형이라고 한다.\n\n$$\nH[a_if_i(x,y) + a_jf_j(x,y)] \\\\\n= a_iH[f_i(x,y)] + a_jH[f_j(x,y)] \\\\\n= a_ig_i(x,y) + a_jg_j(x,y)\n$$\n\n즉 연산 순서에 상관없다면 선형이라 하며, 대부분의 이미지 처리 연산은 선형이다.\n\n### Image Rotation\n\n![231015-212235](/posts/mid_01/231015-212235.png)\n\n특정 픽셀을 $\\theta$만큼 반 시계방향으로 회전시킬 경우 아래와 같은 연산을 가해주면 된다.\n\n$$\n\\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n=\nR(\\theta)\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ncos\\theta \u0026 -sin\\theta \\\\\nsin\\theta \u0026 cos\\theta\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n$$\n\n하지만, 이 경우에는 원점을 중심으로 회전되기 때문에,\n영상을 중심으로 회전시켜야 하는 경우에는 다음과 같은 스탭을 거쳐야 한다.\n\n1. 영상을 중심으로 평행 이동 시킨다.\n2. 삼각함수를 이용해 영상을 회전시킨다.\n3. 다시 영상을 원위치로 평행 이동 시킨다.\n\n하지만, 위 연산은 선형이기 때문에 각 픽셀별로 아래 하나의 연산으로 처리해도 상관없다.\n\n$$\n\\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ncos\\theta \u0026 -sin\\theta \\\\\nsin\\theta \u0026 cos\\theta\n\\end{bmatrix}\n\\begin{bmatrix}\nx - W/2\\\\\ny - H/2\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nW/2\\\\\nH/2\n\\end{bmatrix}\n$$\n\n\u003cnotice\u003e\n  영상 변환을 하기 위해서는 `변환 후(x, y)`의 좌표를 연산을 통해 `변환 전(x', y')`의 좌표를 구하고,\n  그 좌표의 데이터를 가져와 Quantization하여 변환 후의 좌표에 대입하는 과정을 거쳐야 한다.\n\u003c/notice\u003e\n\n### Image Interpolation\n\n![231015-214108](/posts/mid_01/231015-214108.png)\n\n검은색 input 영상을 흰색 output 영상으로 upscaling하거나, 영상 회전과 같이\n변환 후의 영상의 좌표가 픽셀에 정확히 들어가지 않는 경우, 검은색 픽셀값을 이용해 흰색 픽셀값을 추측해야 한다.\n추측하는 방식에는 보통 아래와 같은 방법들이 있다.\n\n1. Replication\n  이전 픽셀값의 데이터를 그대로 사용하는 방법이다.\n2. Nearest Neighbor\n  본인과 가까운 픽셀의 데이터를 그대로 사용하는 방법이다.\n\n위 두 방법의 경우 Interpolation은 가능하지만, 이미지 화질의 개선이 이루어지지는 않는다.\n적당한 화질 개선을 위해서는 아래의 방법을 고려해볼 수 있다.\n\n3. (Bi)linear Interpolation\n  근처 픽셀값을 이용해 평균 데이터를 계산하여 사용하는 방법이다.\n\n![231015-214947](/posts/mid_01/231015-214947.png)\n\n$$\nq_1 = (1-a)p_1 + ap_2 \\\\\nq_2 = (1-a)p_3 + ap_4 \\\\\n{} \\\\ \nq = (1-b)q_1 + bq_2\n$$\n","slug":"univ_com-vision/mid_01","readingMinutes":10,"wordCount":824},{"title":"Adapter Pattern","description":"Adapter 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Adapter Pattern"],"draft":false,"date":"2023-10-11 / 17:13","content":"\n## 필요성\n\n개발하다 보면, 이전에 개발했던 코드가 있는데, 새로 개발된 코드 사양에 맞게 변경시켜야 하는 상황이 많을 것이다.\n마음같아선 새로 짜고 싶지만, dependency가 높은 코드나 배포가 진행된 코드의 경우 수정하는데 부담이 클 수 밖에 없다.\n이런 경우에 오래된 코드를 새로운 코드 사양에 맞게 변형시켜줘야 할 필요성이 생기는데, 이 때 `Adapter Pattern`을 사용하게 된다.\n\n## Adapter Pattern\n\n예를 들어보기 위해 우리의 오랜 친구(?) Duck 시뮬레이터를 다시 불러와보자.\n\n```java:Duck.java\npublic interface Duck {\n  public void quack();\n  public void fly();\n}\n```\n\n이제 새로운 동물을 시뮬레이터에 추가해보자. 바로 Turkey!\n\n```java:Turkey.java\npublic interface Turkey {\n  public void gobble();\n  public void fly();\n}\n```\n\n인터페이스를 보면 알겠지만, 울음 소리가 다르다.\n따라서 기존에 많은 곳에서 사용되었던 quack() 메서드를 사용하는 곳에선 Turkey 인터페이스를 구현한 클래스의 인스턴스를 사용할 수가 없게된다.\n이 경우 **코드의 재사용성**을 높이기 위해 `Adapter`를 구현해서 사용하게 된다!\n\n```java:TurkeyAdapter.java {1 8-10}\npublic class TurkeyAdapter implements Duck {\n  Turkey turkey;\n\n  public TurkeyAdapter(Turkey turkey) {\n    this.turkey = turkey;\n  }\n\n  public void quack() {\n    turkey.gobble();\n  }\n\n  public void fly() {\n    turkey.fly();\n  }\n}\n```\n\n이렇게 TurkeyAdapter를 만들어주면 이 어댑터의 인스턴스는 Duck 취급을 받기에 quack() 메서드를 사용하는 부분에 이 인스턴스를 넣을 수 있다.\n즉, Turkey를 Duck 처럼 사용할 수 있다는 뜻이다!\n\n```java:DuckSimulator.java {6}\npublic class DuckSimulator {\n  public static void main(String[] args) {\n    MallardDuck duck = new MallardDuck(); // implement Duck\n    WildTurkey turkey = new WildTurkey(); // inplement Turkey\n\n    Duck turkeyAdapter = new TurkeyAdapter(turkey);\n\n    // 둘 다 가능.\n    duck.quack();\n    turkeyAdapter.quack(); // 내부적으로 turkey.gobble() 호출\n  }\n}\n```\n\n## IRL\n\n실제로 Adapter Pattern이 적용되는 사례를 살펴보자.\n\njava에서 일련의 객체를 나타낼 때 `Iterator`를 많이들 사용하는데, 예전에 Iterator가 없을 때는 `Enumerators`을 사용했다고 한다.\n버전업이 되고 Iterator를 사용하는게 권장됐는데, legacy system에서는 아직도 Enumerators를 사용했기에 이를 강제할 수는 없었다.\n따라서 이를 위해 EnumerationAdapter를 만들었다고 한다.\n\n```java:Enumerators.java\npublic interface Enumerators {\n  public boolean hasMoreElements();\n  public T nextElement();\n}\n```\n\n```java:Iterator.java\npublic interface Iterator {\n  public boolean hasNext();\n  public T next();\n  public void remove();\n}\n```\n\n```java:EnumerationAdapter.java\npublic class EnumerationAdapter implements Iterator {\n  Enumerators enumerators;\n\n  public EnumerationAdapter(Enumerators enumerators) {\n    this.enumerators = enumerators;\n  }\n\n  public boolean hasNext() {\n    return enumerators.hasMoreElements();\n  }\n\n  public T next() {\n    return enumerators.nextElement();\n  }\n\n  public void remove() {\n    throw new UnsupportedOperationException();\n  }\n}\n```\n\n","slug":"univ_design-pattern/mid_06","readingMinutes":4,"wordCount":352},{"title":"Command Pattern","description":"Command 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Command Pattern"],"draft":false,"date":"2023-10-10 / 14:45","content":"\n## 필요성\n\n개발하다보면, 특정 버튼을 누르면 이벤트가 발생하도록 처리하는 패턴을 구현해야 하는 경우가 생길 것이다.\n예로들어 만능 리모컨을 만든다고 가정해보자.\n\n버튼 1 - ON을 누르면 tv가 켜지고 OFF를 누르면 꺼지고,\n\n```java:TV.java\npublic class TV {\n  private boolean isOn;\n  private int channel;\n\n  public TV() {\n    this.isOn = false;\n    this.channel = 1;\n  }\n\n  public void on() {\n    this.isOn = true\n  }\n\n  public void off() {\n    this.isOn = false;\n  }\n\n  public void changeChannel(int channel) {\n    this.channel = channel;\n  }\n}\n```\n\n버튼 2는 전등, 3은 선풍기 등등...\n\n이런 경우에 보통의 경우 `if - else`로 처리하는 경우가 많을 것이다.\n\n```java:Example\nif (버튼 1 - ON) {\n  tv.on();\n} else if (버튼 2 - OFF) {\n  tv.off();\n}\n```\n\n하지만 이런 경우에는 새로운 기능을 추가하거나, 기존에 있는 기능을 수정하려면 그 유지보수가 매우 불편하다.\n\n따라서 이를 해결하기 위한 디자인 패턴을 소개한다.\n\n## Command Pattern\n\nCommand Pattern의 기본적인 아이디어는 모든 기능 요청들을 `하나의 명령어(Command)`로서 관리하여 은닉화 하는데에 있다.\n바로 코드를 보며 이해해보자.\n\n```java:Command.java\npublic interface Command {\n  public void execute();\n}\n```\n\n```java:TVOnCommand.java {1, 8-10}\npublic class TVOnCommand implements Command {\n  TV tv;\n\n  public TVOnCommand(TV tv) {\n    this.tv = tv;\n  }\n\n  public void execute() {\n    tv.on();\n  }\n}\n```\n\n모든 명령어는 무조건 `execute()`로 실행하고, 각 명령어의 실행 방법은 그 명령어가 어떤 장치를 조작하는지에 따라 다르게 구현한다.\n따라서 이렇게 구현한다면 TV를 켜든 끄든 전등을 제어하든 모든 명령은 `execute()`를 호출하면 되는 것이다.\n\n```java:RemoteController.java {2-3}\npublic class RemoteController {\n  Command[] onCommands;\n  Command[] offCommands;\n\n  public RemoteController() {\n    onCommands = new Command[7];\n    offCommands = new Command[7];\n\n    Command empty = new Command();\n    for (int i=0; i\u003conCommands.length; i++) {\n      onCommands[i] = empty;\n      offCommands[i] = empty;\n    }\n  }\n\n  public void setCommand(int slot, Command onCom, Command offCom) {\n    onCommands[slot] = onCom;\n    offCommands[slot] = offCom;\n  }\n\n  public void onBtnPushed(int slot) {\n    onCommands[slot].execute();\n  }\n\n  public void offBtnPushed(int slot) {\n    offCommands[slot].execute();\n  }\n}\n```\n\n그리고 만능 리모컨을 이렇게 구현한다면, 사용자 입장에서는 원하는 기능을 `Command interface`로 구현하고, 원하는 slot에 `setCommand()`를 이용해 넣어주기만 하면 된다.\n\n### 추가 기능\n\n명령어 인터페이스를 이용해 하나로 구현하면 다른 기능을 추가하고 싶을 때도 용이하다.\n예로 들어 undo 기능을 구현해보자.\n\n```diff-java:Command.java\n  public interface Command {\n    public void execute();\n+   public void undo();\n  }\n```\n\n그럼 각 명령어에서 수행할 undo 기능을 추가만 하면 된다.\n\n```diff-java:TVOnCommand.java\n  public class TVOnCommand implements Command {\n    TV tv;\n\n    public TVOnCommand(TV tv) {\n      this.tv = tv;\n    }\n\n    public void execute() {\n      tv.on();\n    }\n\n+   public void undo() {\n+     tv.off(); // on의 반대는 off\n+   }\n  }\n```\n\n그렇다면 컨드롤러의 구현은 이렇게만 수정되면 undo 기능을 쉽게 구현할 수 있게된다!\n\n```diff-java:RemoteController.java\n  public class RemoteController {\n    Command[] onCommands;\n    Command[] offCommands;\n+   Command undoCommand;\n\n    ...\n\n    public void onBtnPushed(int slot) {\n      onCommands[slot].execute();\n+     undoCommand = onCommands[slot];\n    }\n\n    public void offBtnPushed(int slot) {\n      offCommands[slot].execute();\n+     undoCommand = offCommands[slot];\n    }\n\n+   public void undoBtnPushed() {\n+     undoCommand.undo();\n+   }\n  }\n```\n\nundo 뿐만 아니라, 매크로 기능과 같은 서드파티 기능도 쉽게 구현할 수 있을 것이다.\n\n```java:MacroCommand.java\npublic class MacroCommand implements Command {\n  Command[] commands;\n\n  public MacroCommand(Command[] commands) {\n    this.commands = commands;\n  }\n\n  public void execute() {\n    for (int i=0; i\u003ccommands.length; i++) {\n      commands[i].execute();\n    }\n  }\n\n  public void undo() {\n    for (int i=commands.length-1; i\u003e=0 i--) {\n      commands[i].undo();\n    }\n  }\n}\n```\n\n### IRL\n\nIn Real Life에서는 Command Pattern이 어떻게 쓰이고 있을까?\n\n1. 명령어 queuing\n**Command queue**를 만들어 `enqueue`, `dequeue`를 구현하여, 각각의 명령어를 순차처리, 스레드에 할당하는 방식으로 사용하는 경우가 있다.\n\n2. logging\n**Command**에 `store`, `load` 따위의 메서드를 추가하여 명령어가 실행되면 disk에 로깅 및 불러올 수 있도록 기능을 추가하여 에러 및 데이터 분석을 용이하게 하는 경우도 있다.\n\n\n## 결론\n\n클라이언트 별로 다른 요청을 처리하는 경우나, 요청 queue, 로깅이 필요한 경우에는\n명령어, 요청을 `은닉화(encapsulates)`하는 Command Pattern을 활용해보자.","slug":"univ_design-pattern/mid_05","readingMinutes":6,"wordCount":583},{"title":"Singleton Pattern","description":"Singleton 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Singleton Pattern"],"draft":false,"date":"2023-10-08 / 21:31","content":"\n## 필요성\n\n시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용한다.\n\n## Singleton Pattern\n\n```java:Singleton.java {2, 4} showLineNumbers\n  public class Singleton {\n    private static Singleton _instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      if (_instance == null) {\n        _instance = new Singleton();\n      }\n      return _instance;\n    }\n  }\n```\n\n기존에 봐오던 클래스들과 많이 다르게 클래스 내부에 본인의 인스턴스를 저장하는 공간이 있으며,\n**생성자가 외부로 노출되지 않는다**.\n\n인스턴스 생성은 오직 `getInstance()` 메서드 호출을 통해서만 이루어지며,\n내부적으로 null값인 경우에만 인스턴스를 생성하기 때문에 `1개의 인스턴스만 생성`이 된다.\n\n### Multithreading\n\n하지만 멀티스레딩 환경에서는 인스턴스가 2개 이상 생성되는 경우가 발생할 수 있다.\n`Line 7`과 `Line 8` 사이에서 `Context switching`이 일어나는 경우가 그러하다.\n\n이런 경우를 막기 위해서 getInstance()는 `동기화 처리`를 해주는 편이 좋다.\n\n```java:Singleton.java {2}\npublic class Singleton {\n  private static Singleton _instance = new Singleton();\n  ...\n}\n```\n\n이렇게 하면 프로그램 실행시점에 인스턴스가 생성되어 반드시 1개의 인스턴스만 생성할 수 있다.\n하지만, 해당 클래스의 생성시점을 제어할 수 없기에 프로그램 성능이 저하되는 문제가 발생할 수 있다.\n\n```java:Singleton.java {6}\n  public class Singleton {\n    private static Singleton _instance;\n\n    private Singleton() {}\n\n    public static synchronized Singleton getInstance() {\n      if (_instance == null) {\n        _instance = new Singleton();\n      }\n      return _instance;\n    }\n  }\n```\n\njava처럼 동기화 키워드를 제공하는 경우 인스턴스를 생성하는 함수를 동기화 걸어주면 된다.\n하지만 이 경우에도 해당 함수가 매우 무거운 기능을 수행하는 경우에는 동기화 시간이 매우 길어져 성능 저하의 원인이 될 수 있다.\n\n\n```java:Singleton.java {6}\n  public class Singleton {\n    private volatile static Singleton _instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      if (_instance == null) {\n        synchronized (Singleton.class) {\n          if (_instance == null) {\n            _instance = new Singleton();\n          }\n        }\n      }\n      return _instance;\n    }\n  }\n```\n\n위의 코드는 인스턴스 생성 함수 내부에서 정확히 인스턴스를 생성하는 부분만 동기화되기 때문에\n성능상의 이슈도 없앨 수 있다.\n\n## 결론\n\n필요성과 같다.\n시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용하자.","slug":"univ_design-pattern/mid_04","readingMinutes":4,"wordCount":300},{"title":"Decorator Pattern","description":"Decorator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Decorator Pattern","OCP","Java I/O"],"draft":false,"date":"2023-10-08 / 14:49","content":"\n## 필요성\n\n키오스크 개발자라고 가정하고 음료를 정의할 인터페이스를 만들어보자.\n\n```java:Beverage.java\npublic abstract class Beverage {\n  private String description;\n\n  public Beverage(String des) {\n    this.description = des;\n  }\n\n  public String getDescription() {\n      return description;\n  }\n  public abstract double cost();\n}\n```\n\n그렇다면 음료들은 이 클래스를 상속받아서 구현하면 될 것이다.\n하지만 이 경우에 다음과 같은 문제점이 발생할 수 있다.\n\n아아, 아아 샷추가, 아아 우유추가 등 여러 `베리에이션 음료`에 대해 모두 **각각** 클래스로 구현해야 한다는 점이다.\n단순히 샷추가나 우유추가의 경우에는 가격만 좀 더 받으면 될터인데 이를 각각 따로 구현하는거는 코드의 중복 뿐만 아니라, 유지보수도 어렵게 만든다.\n\n### OCP\n\n그렇다면 Beverage에서 옵션도 관리하게 하면 되지 않을까?\n\n```diff-java:Beverage.java\n  public abstract class Beverage {\n    private String description;\n+   private boolean milk;\n+   private boolean soy;\n\n    public Beverage(String des) {\n      this.description = des;\n    }\n\n    public abstract String getDescription() {\n      return description;\n    }\n    public abstract double cost();\n\n+   setMilk();\n+   hasMilk();\n+   setSoy();\n+   hasSoy();\n  }\n```\n\n처음 생각해볼 수 있는 간단한 해결법이지만, 좋은 방법은 아니다.\n다른 옵션을 추가하거나 옵션에 따른 가격 변동을 수정하려는 경우에는 Beverage 클래스에 대한 전면적인 수정이 필요해지기 때문이다.\n\n`새로운 옵션`에 대해서는 **변수 추가 및 get, set을 추가**해야 하고,\n`가격 변동`의 경우에는 **cost 함수가 전면적으로 수정**되어야 한다.\n이 과정에 Beverage를 상속받은 `모든 클래스`에서 일어나야 한다.\n\n이런 경우를 방지하기 위해 `OCP` 방법론을 준수하여 코딩하는게 좋다.\n\nOCP는 Open-Closed Principle의 약어로, 확장엔 유연하게, 변경엔 엄격하게 디자인 해야함을 추구하는 원칙이다.\n\n## Decorator Pattern\n\n이를 해결하기 위해 `Decorator Pattern`을 사용할 수 있다.\n\n우선 Beverage는 다시 원상복구를 시키고, 옵션에 대한 클래스를 구현하자.\n\n```java:CondimentDecorator.java\npublic abstract class CondimentDecorator extends Beverage {\n  public abstract String getDescription();\n}\n```\n\n이제 음료는 Beverage를 상속받아 구현하고, 옵션은 CondimentDecorator를 상속받아 구현하면 된다.\n계속 예시를 살펴보며 이해하자.\n\n```java:Espresso.java\npublic class Espresso extends Beverage {\n  public Espresso() {\n    description = 'Espresso';\n  }\n\n  public double cost() {\n    return 0.89;\n  }\n}\n```\n\n```java:Milk.java\npublic class Milk extends CondimentDecorator {\n  Beverage beverage;\n\n  public Milk(Beverage beverage) {\n    this.beverage = beverage;\n  }\n\n  public String getDescription() {\n    return beverage.getDescription() + ', Milk';\n  }\n\n  public double cost() {\n    return beverage.cost() + 0.20;\n  }\n}\n```\n\n이런식으로 구현한다면 사용할 때는 Espresso를 Milk가 감싸는 방식으로 옵션을 추가할 수 있게된다.\n\n```java:Kiosk.java\npublic class Kiosk {\n  public static void main(String args[]) {\n    Beverage espressoWithMilk = new Milk(new Espresso());\n    System.out.println(espressoWithMilk.getDescription() + “ $” + espressoWithMilk.cost());\n    ...\n  }\n}\n```\n\n\u003e Espresso, Milk $1.09\n\n실제로 Java의 I/O를 사용하다보면 이런 코드를 많이 본 적이 있을 것이다.\n\n```java:FileIO.java\nInputStream in = new LineNumberInputStream(\n                    new BufferedInputStream(\n                       new FileInputStream('text.txt')));\n```\n\n이런 Stream도 모두 Decorator Pattern이 적용된 것이다.\n\n## 결론\n\nDecorator Pattern은 `새로운 기능이 추가`되거나, `적용 순서를 자유롭게` 해야하는 경우에 사용하는 것이 좋다.","slug":"univ_design-pattern/mid_03","readingMinutes":5,"wordCount":417},{"title":"Dart 언어 마스터","description":"Dart 언어에 대한 보다 심화된 내용을 정리해봤습니다.","icon":"","image":"","tags":["Dart","factory","get","set","stream","async*","yield","mixin","with"],"draft":false,"date":"2023-09-25 / 14:55","content":"\n## factory constructor\n\n`factory` 키워드를 사용하면 아래와 같은 기능을 구현할 수 있다고 공식문서에 나와 있습니다.\n\n1. 인스턴스를 `캐시에서 반환`하여 클래스의 인스턴스를 한 번만 생성할 수 있도록 합니다. (일종의 Singleton 패턴 구현법)\n2. 생성자에서 `서브 클래스`(상속 받은 클래스)의 인스턴스를 반환할 수 있습니다.\n\n둘 다 신기한 기능입니다. (다만 언제 사용하는게 적재적소인지는 잘 모르겠네요..)\n1번부터 알아봅시다.\n\n### caching\n\n```dart:.dart\nclass Singleton {\n  static final Singleton _instance = Singleton._internal();\n\n  Singleton._internal() {}\n\n  factory Singleton() {\n    return _instance;\n  }\n\n  void getHash() {\n    print(this.hashCode);\n  }\n}\n\nvoid main() {\n  Singleton s1 = new Singleton();\n  Singleton s2 = new Singleton();\n\n  s1.getHash(); // 302000605\n  s2.getHash(); // 302000605\n}\n```\n\n위와 같이 구현한다면, Singleton 클래스의 인스턴스는 `단 한개`만 생성되게 됩니다.\n클래스 로드 시점에 static으로 이미 인스턴스가 만들어지기 때문이죠.\n하지만 이런 사용용법은 의미가 없어보입니다.\n차라리 아래의 예시가 더 의미 있어보입니다.\n\n```dart:.dart\nclass SingletonLog {\n  final String value;\n\n  static final Map\u003cString, SingletonLog\u003e _cache = {};\n\n  SingletonLog._internal(this.value);\n\n  factory SingletonLog(String value) {\n    return _cache.putIfAbsent(value, () =\u003e SingletonLog._internal(value));\n  }\n\n  void getHash() {\n    print(this.hashCode);\n  }\n\n  String getValue() {\n    return value;\n  }\n\n  Map\u003cString, String\u003e getLogs() {\n    Map\u003cString, String\u003e result = {};\n    _cache.forEach((key, value) {\n      result[key] = value.value;\n    });\n    return result;\n  }\n}\n\nvoid main() {\n  SingletonLog s1 = new SingletonLog('log1');\n  SingletonLog s2 = new SingletonLog('log2');\n\n  s1.getHash();        // 888013580\n  s2.getHash();        // 870182876\n\n  print(s1.value);     // log1\n  print(s2.value);     // log2\n\n  print(s1.getLogs()); // {log1: log1, log2: log2}\n  print(s2.getLogs()); // {log1: log1, log2: log2}\n}\n```\n\n이렇게 하면 s1, s2가 같은 인스턴스를 반환받기 때문에, 어디에서 로그를 추가해도 모든 객체가 같은 로그기록을 보관할 수 있습니다.\n\n\u003ctip\u003e\n  그럼 이런 의문이 듭니다.\n  hashCode가 다르게 나오는데, 그럼 다른 객체 아닌가요?\n  \u003cbr /\u003e\n  실제로 s1 == s2의 값은 `false`입니다. 따라서 `다른 객체`가 맞습니다.\n  하지만 **약간 변형**이 이루어지긴 했으나, `싱글톤 패턴` 역시 맞습니다.\n  \u003cbr /\u003e\n  왜냐하면, 인스턴스의 생성을 **클래스 내부**에서 `_internal`로 생성하고, 생성자를 외부에서 호출하지 못합니다.\n  또한, static으로 선언된 `_cache` 내부에서 인스턴스를 보관하기 때문에 _cache를 통해서 **전역적으로 인스턴스를 공유**하게 됩니다.\n  \u003cbr /\u003e\n  그렇다고 항상 다른 객체를 반환하는 것은 아닙니다.\n  실제로, s2를 생성할 때, s1과 동일하게 `'log1'`을 주입시키면 s1, s2 동일한 hashCode를 갖게 됩니다.\n  왜냐하면, factory 생성자는 일단 캐시되어있는 인스턴스를 반환하기 때문에,\n  _cache 내부에 인스턴스를 저장하고 있고, s1, s2 모두 같은 데이터를 갖고 있기에 메모리주소 역시 같아집니다.\n\u003c/tip\u003e\n\n### return subclass constructor\n\n그럼 2번도 알아봐야겠죠?\n\n```dart:.dart\nclass Human {\n  final String name;\n\n  Human(this.name);\n\n  factory Human.create(String name, {required bool isMan}) {\n    if (isMan) {\n      return Male(name);\n    }\n    return Female(name);\n  }\n}\n\nclass Male extends Human {\n  Male(String name) : super(name);\n}\n\nclass Female extends Human {\n  Female(String name) : super(name);\n}\n\nvoid main() {\n  Human man = new Human.create('h1', isMan: true);\n  Human woman = new Human.create('h2', isMan: false);\n\n  print(man.name);   // h1\n  print(woman.name); // h2\n}\n```\n\n이 방식은 객체지향 프로그래밍의 다형성의 원리를 충족시키기에 좋은 문법입니다.\n\n신기한 점은 부모 클래스 생성자에서 자식 클래스의 생성자를 호출해 반환한다는 점입니다.\n이렇게하면 인스턴스 생성 시점에 조건을 달아 다른 인스턴스를 반환하는 것이 가능해집니다.\n_(상태나 이벤트를 클래스로 관리할 때 유용해 보이네요!)_\n\n### constructor body\n\n사실 공식문서에는 자세히 설명하진 않지만, factory 생성자의 가장 큰 이점은 `final variable`을 생성자에서 `initialize list`로 **초기화하지 않아도 된다는 점** 이라고 생각합니다.\n정확히 말하자면, 생성자를 내부에서 호출함으로서 생성자 호출 전, `전처리`를 할 수 있다는 점이 이점이라고 생각합니다.\n\n예시를 봐야겠죠?\n\n```dart:.dart {7-10}\nclass Human {\n  final String name;\n\n  Human(this.name);\n\n  // Human.withSir(String name) : this.name = 'Sir - ' + name;\n  factory Human.withSir(String name) {\n    String newName = 'Sir - ' + name;\n    return Human(newName);\n  }\n}\n\nvoid main() {\n  Human man = new Human.withSir('h1');\n\n  print(man.name);\n}\n```\n\n위 코드에서 주석처리 된 부분과 하이라이트 된 부분 모두 동일한 기능을 수행합니다.\n지금은 간단하게 문자열 앞에 `Sir - `을 붙이도록 했지만, 만약 배열을 직렬화 해야하는 상황이라면?\n한 줄로 처리하기 복잡한 기능은 분명 일반 생성자의 initialize list로 처리하는덴 한계가 있을 것입니다.\n\n\u003ctip\u003e\n  한 줄로 처리하기 복잡한 코드는 예로들어 `json serialize` 부분이 있겠죠?\n  \u003cbr /\u003e\n  그래서 우리가 무의식적으로 사용하던 factory가 사실은 인스턴스 생성을 편-안하게 생성하기 위해 사용했던 것이었습니다!\n\u003c/tip\u003e\n\n---\n\n## get, set\n\ngetter, setter 메서드를 이용해서 객체의 가상 멤버변수(`property`)를 읽고 쓰는게 가능해진다는 건 다른 객체지향 언어에도 있는 기능입니다.\ndart에선 이를 가능케 하는 키워드가 `get`, `set` 입니다.\n\n공식문서에 있는 코드를 분석해봅시다.\n\n```dart:.dart\nclass Rectangle {\n  double left, top, width, height;\n\n  Rectangle(this.left, this.top, this.width, this.height);\n\n  // right, bottom 이라는 두 개의 계산된 프로퍼티 정의.\n  double get right =\u003e left + width;\n  set right(double value) =\u003e left = value - width;\n  double get bottom =\u003e top + height;\n  set bottom(double value) =\u003e top = value - height;\n}\n\nvoid main() {\n  var rect = Rectangle(3, 4, 20, 15);\n\n  print(rect.right); // 23.0\n  print(rect.left);  // 3.0\n  rect.right = 20;\n  print(rect.right); // 20.0\n  print(rect.left);  // 0.0\n}\n```\n\n제 개인적인 생각에는 get은 가상의 멤버변수를 만들어서 이를 사용하게 해주고,\nset은 이 가상의 멤버변수를 위해 처리해야 하는 기능을 함수 내부에서 별도로 처리하게 해준다가 주된 사용법인거 같습니다.\n\n\u003cnotice\u003e\n  제가 `가상`의 멤버변수라고 표현한 이유는, get으로 정의된 변수는 그 자체가 특정 값을 저장할 수 없고, 별도로 정의된 멤버변수에 의존해야 하기 때문입니다.\n\u003c/notice\u003e\n\n### interface\n\n그렇다면 get, set을 언제 사용해야 잘 사용한걸까요?\n보통은 멤버변수를 `은닉화`하고 이를 `접근제어`를 할 때 사용하는 방식이 대부분일 것입니다.\n\n하지만, 개인적으로 `인터페이스`를 구현할 때 역시 get의 적절한 사용처라고 개인적으로 생각합니다.\n예를 들어봅시다.\n\n```dart:.dart {2}\nabstract class IColor {\n  String get color;\n}\n\nclass Car implements IColor {\n  final String name;\n  @override\n  final String color;\n\n  Car(this.name, this.color);\n}\n\nclass Boat implements IColor {\n  final String name;\n  @override\n  final String color;\n\n  Boat(this.name, this.color);\n}\n\nvoid main() {\n  Car car = Car('car1', 'red');\n  Boat boat = Boat('boat1', 'red');\n\n  print(car.color == boat.color); // true\n}\n```\n\n\u003ctip\u003e\n  dart에선 abstract class로 구현해도 될 정도로 interface의 의미가 약합니다.\n  최근에는 interface 키워드가 추가되었으나, implements 하는 것이 아닌 extends 해도 에러가 안 날정도로 중요하진 않은 거 같습니다.\n  abstract interface와 같이 키워드를 중복해서 쓰는 경우도 있으므로 자세한 내용은 [**`공식문서`**](https://dart.dev/language/class-modifiers#interface)를 참고해주세요.\n\u003c/tip\u003e\n\n두 클래스간 `필요에 따라` 공통속성을 갖고싶게 할 때 interface를 사용하곤 하는데요,\ndart는 `null-safety` 언어이기 떄문에, get 키워드가 없다면 **abstract class라 하더라도 멤버변수를 초기화** 해줘야만 합니다.\n그러면 코드가 아래처럼 복잡해지겠죠.\n\n```diff-dart:.dart {2}\n  abstract class IColor {\n    String color;\n\n+   IColor(this.color);\n  }\n\n  class Car implements IColor {\n    final String name;\n    @override\n    final String color;\n\n    Car(this.name, this.color);\n\n+   @override\n+   set color(String _color) {\n+     color = _color;\n+   }\n  }\n```\n\n## stream\n\n비동기의 4번타자, `future`는 완료되지 않은 연산을 나타냅니다.\n비동기 함수가 return을 해야만 future은 연산이 완료되었다는 것을 알려줍니다.\n\n그에 반면, `stream`은 **일련, iterable**한 비동기 이벤트입니다.\n따라서 iterable과 같이 동작하게 됩니다만, 그 과정이 비동기인 것이죠.\n\n즉, future은 요청시 다음에 올 이벤트를 받는 방식이라면,\nstream은 준비가 된 후 이벤트가 있음을 알려주는 방식입니다.\n\n### async* / yield\n\n`async*`는 async와 마찬가치로 이 함수가 비동기 함수라는 것임을 선언하는 키워드 입니다.\n차이점은 이 함수는 `Stream\u003cT\u003e`을 반환하기 때문에 일련의 비동기로 연산된 결과를 반환하게 됩니다.\n즉, **지속적으로 값을 반환**하기 위해 `yield` 키워드가 return을 대신하여 값을 반환합니다.\n_(return 키워드는 여기서 사용 불가합니다)_\n\n예시를 살펴봅시다.\n\n```dart:.dart\nFuture\u003cint\u003e sumStream(Stream\u003cint\u003e stream) async {\n  var sum = 0;\n  await for (final value in stream) {\n    print('get stream value $value');\n    sum += value;\n  }\n  return sum;\n}\n\nStream\u003cint\u003e countStream(int to) async* {\n  for (int i = 1; i \u003c= to; i++) {\n    await Future.delayed(Duration(milliseconds: 200));\n    print('stream $i ready');\n    yield i;\n  }\n}\n\nvoid main() async {\n  var stream = countStream(3);\n  var sum = await sumStream(stream);\n  print(sum);\n}\n```\n\n\u003e (0.2초 대기)\n\u003e stream 1 ready\n\u003e get stream value 1\n\u003e (0.2초 대기)\n\u003e stream 2 ready\n\u003e get stream value 2\n\u003e (0.2초 대기)\n\u003e stream 3 ready\n\u003e get stream value 3\n\u003e 6\n\nStream 역시 비동기로 처리되는 **일련**의 연산이라는 것을 알려주는 객체이기 때문에,\n실제 연산 결과를 받으려면 await을 사용해서 값이 전달받을 때 까지 대기해야 합니다.\n\n따라서, dart에서는 `await for` 키워드를 제공하여 iterable한 비동기 이벤트를 처리할 수 있도록 도와줍니다.\n\n\u003ctip\u003e\n  동기적은 `Iterable\u003cT\u003e` 객체를 반환하고 싶다면 `sync*` / `yield` 키워드를 사용하면 됩니다.\n\u003c/tip\u003e\n\n\u003ctip\u003e\n  stream은 파일읽기와 같이 한 번의 요청이 있으면 처음부터 끝까지 끊김없이 진행되어야 하는 `Single subscription streams`, \n  브라우저의 마우스 이벤트와 같이 Observer pattern을 사용하기에 언제든지 누구나 stream을 들을 수 있는 `Broadcast streams` 으로 나뉩니다.\n  \u003cbr /\u003e\n  뿐만 아니라, stream은 iterable한 성격을 갖는다 했었는데, 이런 stream을 제어할 수 있는 여러 메서드 또한 존재합니다.\n  따라서 자세한 내용은 [**`공식문서`**](https://dart-ko.dev/tutorials/language/streams#working-with-streams)를 참고하시는걸 추천 드립니다.\n\u003c/tip\u003e\n\n## mixin, with\n\n간단하게 말하면 class \u0026rarr; `mixin`, extends \u0026rarr; `with`와 같은 개념입니다.\n물론 이해를 돕기위해 위와같이 적었을 뿐, 완전히 다른 키워드이니 혼동하지 마시길 바랍니다.\n\n클래스를 상속할 때는 부모 클래스에서 미리 정의된 변수나 메서드를 자식 클래스에서 구현하지 않아도 바로 사용할 수 있습니다.\n하지만, 계층구조를 나타내기 위해 **반드시 한 개의 클래스를 상속**해야 한다는 단점이 있죠.\n\n여러개의 자료 구조를 공유하기 위해서는 인터페이스를 구현 하는 방법으로 사용해야 합니다.\n하지만, 인터페이스는 말 그대로 틀만 제공하고 **구현은 별도로 해야한다**는 단점이 있습니다.\n\n이 떄, extends와 implements의 **중간 포지션**에 위치한 키워드가 with이고, with은 mixin을 받을 수 있습니다.\n\n```dart:.dart\nmixin SwimBehabior {\n  void swim() {\n    print('swim');\n  }\n}\n\nmixin FlyBehiabior {\n  void fly() {\n    print('fly');\n  }\n}\n\nclass Duck {\n  final String name;\n\n  Duck(this.name);\n}\n\nclass RealDuck extends Duck with SwimBehabior, FlyBehiabior {\n  RealDuck(super.name);\n}\n\nclass RubberDuck extends Duck with SwimBehabior {\n  RubberDuck(super.name);\n}\n\nvoid main() {\n  RealDuck duck = RealDuck('duck');\n\n  duck.fly();\n  duck.swim();\n}\n```\n\n이런식으로 implements 처럼 여러 인터페이스를 사용할 수 있지만, extends 처럼 재정의할 필요 없이 사용할 수 있습니다.\n하지만, mixin을 사용할 때는 클래스 구성요소가 `매우 세분화` 되어있는게 좋습니다.\n이런저런 메서드를 잔뜩 만들어놓으면 상속했을 때 **필요없는 기능도 수행**할 수 있는 상황이 발생할 수 있기 때문입니다.\n\n이런 상황이 생길 가능성이 있는 코드는 mixin 보단 `Strategy pattern`으로 구현하는 것이 더 좋습니다.\n\n```dart:.dart {18, 22-24}\nabstract class SwimBehavior {\n  void swim();\n}\n\nabstract class FlyBehavior {\n  void fly();\n}\n\nclass CanSwim implements SwimBehavior {\n  @override\n  void swim() {\n    print('swim');\n  }\n}\n\nclass Duck {\n  final String name;\n  SwimBehavior swimBehavior;\n\n  Duck(this.name, this.swimBehavior);\n\n  void performSwim() {\n    swimBehavior.swim();\n  }\n}\n\nclass RealDuck extends Duck implements FlyBehavior {\n  RealDuck(String name) : super(name, CanSwim());\n\n  @override\n  void fly() {\n    print('fly');\n  }\n}\n\nclass RubberDuck extends Duck {\n  RubberDuck(String name) : super(name, CanSwim());\n}\n\nvoid main() {\n  RealDuck real = RealDuck('duck');\n  RubberDuck rubber = RubberDuck('duck');\n\n  real.performSwim();\n  real.fly();\n  rubber.performSwim();\n}\n```\n\n사실 mixin을 사용하지 않더라도 class의 `상속 depth를 깊게` 하는 방법도 있으니, 본인의 상황에 맞게 취사선택을 잘 하는 것이 좋은 개발습관이 될 것입니다.","slug":"flutter/005_dart_expert","readingMinutes":17,"wordCount":1610},{"title":"Dart 언어 심화","description":"Dart 언어에 대한 심화된 내용을 정리해봤습니다.","icon":"","image":"","tags":["Dart","Asynchronous","Isolate","Callback"],"draft":false,"date":"2023-09-15 / 11:24","content":"\n\u003cnotice\u003e\n  기초적인 지식이 필요하신 분들은 [**`Dart 언어 기초`**](https://wjlee611.github.io/blog/flutter/003_dart_basic) 포스트를 읽어보시길 권장드립니다.\n\u003c/notice\u003e\n\n## async / await\n\n`async`, `await` 키워드는 **비동기 프로그래밍**시 빠지지 않는 키워드입니다.\n여기서 `.then()` 메서드나 Dart 에서 `Future\u003cT\u003e` 도 포함해서 원리와 적절한 사용법까지 알아보고자 합니다.\n\n\u003ctip\u003e\n  `비동기 프로그래밍`\n  특정 코드가 완료되기 전, 다른 코드를 수행함으로서 코드의 실행 순서가 순차적(동기적)으로 실행되지 않는 프로그래밍 방식입니다.\n  보통 처리완료까지 시간이 많이 걸리는 네트워크 통신이나 파일 입출력 등에 많이 사용됩니다.\n\u003c/tip\u003e\n\n\u003cnotice\u003e\n  비동기 처리는 `단일 스레드(Dart의 경우 단일 Isolate) 환경`에서 이루어집니다.\n  따라서 비동기 처리를 한다고 해도, 비동기 함수가 `컴퓨팅 자원 사용량이 많다`면 해당 스레드(Isolate)는 `일시 정지`되는 현상이 발생할 수 있습니다.\n  \u003cbr /\u003e\n  이와 관련한 자세한 내용은 아래 [**`Isolate`**](https://wjlee611.github.io/blog/flutter/004_dart_advanced#isolate) 파트에서 다루겠습니다.\n\u003c/notice\u003e\n\n### Future\n\n`Future` 객체는 지금 당장은 처리되지 않았지만, 미래에 처리가 완료될 데이터를 알려주는 객체입니다.\n예를 들어봅시다.\n\n```dart:.dart\nFuture\u003cString\u003e futureStr() async {\n  print('do something');\n  return Future.delayed(Duration(seconds: 2), () =\u003e 'future string');\n}\n\nvoid main() {\n  print('start');\n  print(futureStr());\n}\n```\n\n위의 futureStr() 함수는 호출 후 2초뒤에 'future string'을 반환하는 함수입니다.\n실행결과는 어떻게 될까요?\n\n\u003e start\n\u003e do something\n\u003e Instance of 'Future\\\u003cString\\\u003e'\n\u003e (2초 후 종료)\n\n답은 `future 객체` 입니다.\n어찌보면 당연합니다. `main` 함수는 비동기 함수도 아닐 뿐더러 futureStr의 리턴값은 `Future\u003cString\u003e` 이라고 명시해두었으니 말이죠.\n\n![230917-211924](/posts/004_dart_advanced/230917-211924.png)\n\nfuture는 `Uncompleted`, `Completed` 상태를 갖습니다.\n비동기 함수 호출시에 future은 Uncompleted 상태를 갖습니다.\n따라서 `Instance of 'Future\u003cString\u003e'`와 같은 결과를 출력한 것이죠.\n하지만 함수가 성공적으로 종료되면 future은 비로소 Completed 상태를 갖습니다.\n따라서 `future string`과 같은 결과를 출력하게 될 것입니다.\n\n사용자 입장에서는 Future 객체는 중요하지 않습니다. 중요한 것은 Future 객체가 처리되고 나서 반환되는 데이터인거죠.\n따라서, Future 객체의 처리(비동기 함수)를 원활히 하기위해 `async`, `await` 키워드를 사용하는 것입니다.\n\n### async\n\nasync 키워드는 이 함수가 비동기 처리를 수행하는 함수임을 명시하는 키워드 입니다.\n다만 위의 예시에서 보듯, 반드시 `Future\u003cT\u003e` 객체 또는 `void`를 반환해야만 합니다.\n\n그렇다면, main 함수를 async 키워드를 붙여 실행한다면 제대로된 결과가 나올까요?\n\n```dart:.dart\nFuture\u003cString\u003e futureStr() async {\n  print('do something');\n  return Future.delayed(Duration(seconds: 2), () =\u003e 'future string');\n}\n\nvoid main() async {\n  print('start');\n  print(futureStr());\n}\n```\n\n\u003e start\n\u003e do something\n\u003e Instance of 'Future\\\u003cString\\\u003e'\n\u003e (2초 후 종료)\n\n그렇습니다. 함수를 비동기 처리하는 함수로 선언한다고 해서 해결되지는 않습니다.\n함수 내부에서 비동기 처리가 진행될 수 있다는 것을 암시할 뿐, `어디서` 비동기 처리를 해야하는 지는 명시하지 않았기 때문이죠.\n\n### await\n\nawait 키워드는 **해당 키워드가 명시된 비동기 처리**(futureStr)가 완료될 때 까지 **비동기 함수**(main)의 처리를 `멈추겠다`는 의미입니다.\n그렇기에 await 키워드는 반드시 async 키워드가 명시된 함수 내부에서만 사용할 수 있는 것입니다.\n\n그렇다면 futureStr의 함수 앞에 await를 명시하여 비동기 함수가 끝날 때 까지 대기시킨다면 어떨까요?\n\n```dart:.dart\nFuture\u003cString\u003e futureStr() async {\n  print('do something');\n  // return Future.delayed(Duration(seconds: 2), () =\u003e 'future string');\n  await Future.delayed(Duration(seconds: 2));\n  return 'future string';\n}\n\n\nvoid main() async {\n  print('start');\n  print(await futureStr());\n}\n```\n\n\u003e start\n\u003e do something\n\u003e (2초 대기)\n\u003e future string\n\u003e (즉시 종료)\n\n비로소 원하던 결과가 나왔습니다.\n\n---\n\n## Isolate\n\n`Isolate`는 Dart에서 스레드를 부르는 용어라고 생각하시면 됩니다.\n\n![230917-221122](/posts/004_dart_advanced/230917-221122.png)\n\nIsolate는 스레드와 마찬가지로 멀티 코어 CPU의 장점을 살리는 프로그래밍 기법으로 `별도의 이벤트 루프`를 갖는 실행 흐름을 만들어 `병렬적인 처리`를 가능케 합니다.\n하지만, 스레드와 용어에서의 차이점을 두는 이유가 있습니다.\n\n보통 **스레드**라 하면 `메모리 영역을 공유`한다고 배웠습니다. 하지만 그 때문에 `race-condition`이 발생하는 문제점을 고려하여 프로그래밍을 했어야 합니다.\n\n하지만, **Isolate**는 스레드와 다르게 `메모리 영역 또한 공유하지 않습니다`.(물론 코드 영역은 공유합니다) \n그렇기에 mutex, lock 등을 고려할 필요가 없는 편의성이 있습니다.\n\n하지만 왜 Isolate를 알아야 하고, 사용해야만 할까요?\n\n### Isolate vs Async\n\n아래의 영상을 확인해봅시다.\n\n\u003cYT id='HkBaS098BrE' /\u003e\n\n`Main isolate`부분은 json 데이터 파싱과 화면 빌드를 `하나의 isolate`에서 구동한 결과입니다.\n영상에서 보시는 바와 같듯 십몇만줄의 json 파싱은 단일 isolate 환경에서 구동하기에는 다소 무리가 있습니다.\n아무리 async로 실행 결과를 뒤로 미룬다 할지라도 실제 데이터 파싱하는 동작과 화면을 그리는 동작 모두 `동일한 isolate`에서 처리되기 때문에 `성능상 이슈`가 생길 수 밖에 없습니다.\n\n하지만 `Worker isolate`부분은 json 데이터 파싱을 `별도의 worker isolate`에서 구동한 결과입니다.\n차이는 명확합니다. 화면에 그리는 동작과 파싱 동작이 `별도의 isolate`에서 처리되기 때문에 화면을 그리는 부분에서 `랙이 걸리지 않습니다`.\n\n이렇듯 단일 isolate에서 동작이 버벅일 정도로 무거운 기능을 수행해야 한다면, 해당 기능은 별도의 isolate로 빼서 처리하는 것이 사용자에게 더 나은 경험을 제공하게 됩니다.\n\n해당 영상에서 구동하는 코드는 [**`Arkhive repo`**](https://github.com/wjlee611/arkhive/blob/main/lib/bloc/enemy/enemy_data/enemy_data_bloc.dart)에서 확인하실 수 있습니다.\n\n---\n\n## function\n\n### callback function\n\n콜백 함수는 함수의 인자로 넘겨주어 넘겨받은 함수 내부에서 실행 가능한 함수를 의미합니다.\n예시를 살펴봅시다.\n\n```dart:.dart\nvoid main() {\n  int value = 0;\n\n  print(valueModifire(value: value, modifire: add1)); // 1\n  print(valueModifire(value: value, modifire: sub1)); // -1\n}\n\nint add1(int value) =\u003e value + 1;\nint sub1(int value) =\u003e value - 1;\n\nint valueModifire({\n  required int value,\n  required Function(int) modifire,\n}) {\n  return modifire(value);\n}\n```\n\n위 코드에서는 `valueModifire`의 인자로서 `add1`, `sub1`을 전달했습니다.\n이 때, 이 두 함수를 `callback function`라고 부르고, 이 함수는 valueModifire 내부에서 `modifire`의 형태로 호출됩니다.\n\n보통은 이런식으로 `동일한 함수` 내부에서 `서로 다른 기능`을 수행해야 할 때 콜백 함수로서 전달하는 경우가 많습니다.\n\n```dart:.dart\nvoid main() async {\n  int value = 0;\n\n  print(await valueModifire(value: value, modifire: add1)); // await 1 second -\u003e 1\n  print(await valueModifire(value: value, modifire: sub1)); // await 1 second -\u003e -1\n}\n\nint add1(int value) =\u003e value + 1;\nint sub1(int value) =\u003e value - 1;\n\nFuture\u003cint\u003e valueModifire({\n  required int value,\n  required Function(int) modifire,\n}) async {\n  await Future.delayed(Duration(seconds: 1)); // something actions\n  return modifire(value);\n}\n```\n\n또는, `특정 함수의 동작이 끝난 후` 수행해야 할 기능이 있을 때 많이 사용되곤 합니다.","slug":"flutter/004_dart_advanced","readingMinutes":10,"wordCount":836},{"title":"Dart 언어 기초","description":"Dart 언어에 대한 기초지식을 정리해봤습니다.","icon":"","image":"","tags":["Dart"],"draft":false,"date":"2023-09-14 / 17:41","content":"\n\u003cwarning\u003e\n  제가 생각하기에 **너무 기초지식**이다 하는 부분은 과감하게 **제외**했습니다.\n  다만, 기초지식이다 하더라도 `개념적으로 매우 중요`하거나 `많이들 알려주지 않는 내용`은 포함하였습니다.\n\u003c/warning\u003e\n\n## variables\n\n변수 네이밍 방법은 다음과 같습니다.\n\n```dart:.dart\n  \u003c제어자\u003e \u003c타입\u003e \u003c변수이름\u003e = \u003c값\u003e;\n```\n\n타입은 int, String 과 같은 타입들이 오거나, `var` 와 같은 타입 추론 키워드도 사용할 수 있습니다.\n제어자에는 `final`, `const`, `late`, `static` 와 같은 키워드가 오게 됩니다.\n\n### var\n\ndart에선 var는 타입 추론 키워드로 사용되는 예약어입니다.\n따라서 `\u003c값\u003e`에 어떤 데이터가 오는지에 따라 변수의 타입이 결정됩니다.\n단, 값을 지정하지 않을 때는 `dynamic` 타입으로 자동 결정됩니다.\n\n\u003ctip\u003e\n  `dynamic?`\n  타입 안정성이 보장되지 않지만, 모든 타입의 데이터를 할당할 수 있도록 해줍니다.\n  보통 json 파일을 파싱할 때 임시로 데이터 형식을 지정할 때 많이 사용합니다.\n\u003c/tip\u003e\n\n### final vs const\n\n`final`과 `const` 둘 모두 데이터의 불변성을 보장하고 싶을 때 사용하는 키워드 라는 점에서는 공통점을 갖습니다.\n또한, 이 키워드를 사용한다면 타입을 굳이 지정하지 않아도 알아서 `var`로 타입을 지정하는 효과가 있습니다.\n하지만 둘 사이의 중요한 차이점이 있습니다.\n\n`final`은 런타임에 값이 지정됩니다.\n따라서 메모리상의 `heap 영역`에 데이터가 저장됩니다.\n그렇기에 생명주기는 스코프 내부로 한정되기 떄문에 flutter 에서 **build 메서드**가 호출될 때 이 부분은 `반복적`으로 메모리에 올라왔다 내려갔다를 반복하게 됩니다.\n\n`const`는 컴파일타임에 값이 지정됩니다.\n특이한 점인 const 키워드로 지정된 데이터는 메모리상에 별도로 적재되지 않고, `컴파일된 코드의 상수 풀(constant pool)`상에 저장됩니다.\n따라서 별도의 인스턴스가 생성되지 않고, 생명주기도 프로그램 수명과 동잃하기에 flutter 에서 **build 메서드**가 호출될 때 이 부분은 `다시 랜더링되지 않습니다`.\n\n### late\n\ndart는 **null-safety** 언어입니다.\n따라서 `\u003c타입\u003e?` 와 같이 `?`로 null값이 가능하다고 지정해 주지 않는한 변수 선언시(혹은 인스턴스 생성시) 반드시 값을 지정해야 합니다.\n하지만, `late`의 경우에는 인스턴스 생성 시점에 null값을 허용하지만, 이후에 `단 한번` 값을 할당할 수 있도록 해주는 키워드입니다.\n\n물론, null값이 임시 허용이 되는만큼 사용에 주의가 필요합니다.\n\n### static\n\n`static`은 클래스가 로드될 때 값이 지정됩니다.\n따라서 heap영역이 아닌 `클래스 자체 메모리 영역`에 저장됩니다.\n그렇기에 일반 메서드에선 static 변수에 접근할 수 있지만, static 메서드에선 일반 변수에 접근할 수 없습니다.\n하지만 그렇기에 클래스를 인스턴스화 하지 않아도 바로 접근이 가능합니다.\n\n---\n\n## function\n\ndart는 사실 js를 대체하기 위해 나온 언어라고 합니다.\n그래서일까요, dart의 모든 데이터 타입도 사실은 모두 `Object`입니다.\n\n뿐만 아니라, `변수에 함수를 할당`하거나, `익명 함수`, `람다 함수` 모두 사용 가능합니다.\n\n### named parameter\n\n보통 함수의 파라미터는 아래와 같이 작성하곤 합니다.\n\n```dart:.dart\n  void myFunction(int num) {\n    ...\n  }\n  ...\n  myFunction(1);\n```\n\n하지만 입력받고자 하는 파라미터가 많아진다면, 인자를 넘겨줄 때 어느 자리에 어느 데이터를 넘겨야 할지 알기가 어렵습니다.\n특히 flutter에서는 위젯을 만들 때 인자를 십수개씩 넘기는 경우가 많죠...\n\n그렇기에 `named parameter` 기능을 제공합니다. (마치 js에서 객체를 인자로 넘기 듯)\n\n```dart:.dart\n  void myFunction({required int myNum}) {\n    ...\n  }\n  ...\n  myFunction(myNum: 1);\n```\n\n이렇게 하면 함수 호출이나, 클래스 생성자 호출시 어느 인자에 어느 데이터를 넘겨야 하는지 명확해집니다.\n\n물론, 위 두 방식을 `혼합`하여 사용할 수도 있습니다.\n\n```dart:.dart\n  void myFunction(String str, {required int val}) {\n    ...\n  }\n  ...\n  myFunction(\"string\", myNum: 1);\n```\n\n---\n\n## class\n\n### constructor\n\n```dart:.dart\nclass Car {\n  final String color;\n  int wheels;\n  String? name;\n\n  Car({\n    required this.color,\n    required this.wheels,\n    this.name,\n  });\n}\n```\n\n기본적으로 생성자는 위와 같이 정의할 수 있습니다.\n`named parameter` 형식으로도 사용이 가능합니다. (대부분의 flutter 위젯은 위와 같이 정의합니다)\n\n### named constructor\n\n```dart:.dart\nCar {\n  final String color;\n  late int wheels;\n  String? name;\n\n  Car.fourWheels({required this.color, this.name}) {\n    this.wheels = 4;\n  }\n}\n```\n\n클래스를 생성할 때 특별한 기능을 붙인채로 인스턴스화 할 수 있도록 `named constructor`를 지원합니다.\n보통 초기상태를 위한 `.init`, 모델링을 위한 `.fromJson`와 같이 쓰이곤 합니다.\n(참고로 이 때 factory 키워드를 이용해서 싱글톤 패턴으로 많이 구현하는데 이는 다음에 소개하겠습니다)\n\n### initializer list\n\n위에 `wheels`을 별도로 초기화하기 위해 late 한정자를 사용했는데요, 보기가 안좋습니다.\n`final` 멤버변수는 생성자 body에서 값을 지정할 수 없기에 저런식으로 표현했는데요,\n`initializer list`를 이용하면 final 멤버변수도 생성자 호출시 별도로 처리할 수 있습니다.\n\n```dart:.dart\nclass Car {\n  final String color;\n  final int wheels;\n  String? name;\n\n  Car.prototype({required this.color}) : wheels = 4 {\n    this.name = 'proto';\n  }\n}\n```\n\n`:`를 붙여 `: wheels = 4`와 같이 사용할 수 있습니다.\n또한, 뒤에 body를 붙여 추가작업 또한 할 수 있습니다.\n\ninitializer **list**에서 알 수 있듯 `wheels = 4` 와 같은 initializer를 `,`를 이용해서 여려개 연달아 초기화할 수 있습니다.\n\n### redirecting constructor\n\n```dart:.dart\nclass Car {\n  final String color;\n  final int wheels;\n  String? name;\n\n  Car({\n    required this.color,\n    required this.wheels,\n    this.name,\n  });\n\n  Car.fourWheels({required String color, String? name})\n      : this(\n          color: color,\n          wheels: 4,\n          name: name,\n        );\n}\n```\n\n기존의 생성자를 `this`로 호출하여 named constructor를 구현한 방식입니다.\n다만, 이 경우에는 생성자의 body를 구현할 수 없습니다.\n","slug":"flutter/003_dart_basic","readingMinutes":9,"wordCount":703},{"title":"플러터 프로젝트 만들기","description":"플러터 프로젝트 생성 가이드 입니다.","icon":"","image":"","tags":["Flutter","Getting started"],"draft":false,"date":"2023-09-14 / 16:37","content":"\n## 시작 전 주의사항\n\n\u003cnotice\u003e\n  이 포스트에선 플러터 프로젝트를 생성하는 방법을 다뤄봅니다.\n  따라서 플러터 SDK 설치나, 관련 환경설정이 안되신 분은 [**`플러터 시작하기`**](https://wjlee611.github.io/blog/flutter/001_installation)를 꼭 읽어보시고 다시 와주시기 바랍니다.\n\u003c/notice\u003e\n\n\u003cnotice\u003e\n  본 블로그의 플러터 개발환경은 `VSCode`와 `터미널`로 고정됩니다.\n  따라서 다른 개발환경에 대한 정보는 없으므로 이 점 참고 부탁드립니다.\n\u003c/notice\u003e\n\n## 프로젝트 생성\n\n프로젝트 생성을 위해 우선 본인이 프로젝트를 관리할 폴더로 이동해주세요.\n제 경우에는 깃허브로 버전관리를 하는 프로젝트의 경우 `~/Documents/GitHub` 폴더에서 일괄적으로 관리하는 편입니다.\n\n```bash:Terminal\ncd ~/Documents/GitHub\n```\n\n이후에는 아래의 명령어로 플러터 프로젝트를 생성합니다.\n\n```bash:Terminal\nflutter create \u003cproj_name\u003e\n```\n\n이 때, 프로젝트를 생성할 때 알아두면 유용한 (거의 필수) 몇 가지 옵션을 소개드립니다.\n\n### --org\n\n이 옵션을 지정하면 프로젝트를 생성할 때 패키지명을 지정할 수 있습니다.\n\n```bash:Terminal\nflutter create \u003cproj_name\u003e --org \u003cpackage_name\u003e\n```\n\n\u003cnotice\u003e\n  \\\u003cpackage_name\\\u003e이 100% 동일하게 패키지 이름이 되는 것은 아닙니다.\n  옵션명에서 유추할 수 있듯 기관의 이름을 적는 것입니다.\n\n  따라서 진짜 패키지 이름은 `\u003cpackage_name\u003e.\u003cproj_name\u003e` 형식이 됩니다.\n\u003c/notice\u003e\n\n예로들어 아래와 같이 프로젝트를 생성했다고 가정해봅시다.\n\n![230914-164837](/posts/002_project_initalize/230914-164837.png)\n\n이 경우에는 프로젝트명 - `gdsc_study` / 패키지명 - `com.gmail.wjlee611` 입니다.\n따라서 프로젝트에서 실제로 적용되는 패키지명은 아래와 같아집니다.\n\n![230914-165226](/posts/002_project_initalize/230914-165226.png)\n\n\u003e Android - `com.gmail.wjlee611.gdsc_study`\n\u003e iOS - `com.gmail.wjlee611.gdscStudy`\n\n같은 명령어라도 다른 패키지명이 생성되니 나중에 앱을 배포할 때 반드시 패키지명을 확인하도록 합시다.\n\n### -i swift\n\n기본적으로 생성되는 iOS 코드는 `Objective-C` 입니다.\n하지만 이 옵션을 추가하면 `Swift`로 생성되게 됩니다.\n\n### -a kotlin\n\n기본적으로 생성되는 Android 코드는 `Java` 입니다.\n하지만 이 옵션을 추가하면 `Kotlin`으로 생성되게 됩니다.\n\n\n","slug":"flutter/002_project_initalize","readingMinutes":3,"wordCount":223},{"title":"플러터 시작하기","description":"플러터 설치 및 VSCode 세팅 가이드입니다.","icon":"","image":"","tags":["Flutter","VSCode","Package manager"],"draft":false,"date":"2023-09-13 / 21:12","content":"\n## 들어가며...\n\n이 포스트에선 플러터(Flutter) 개발을 시작할 때 세팅해야할 전 과정에 대해 설명합니다.\nFlutter SDK 설치부터 에뮬레이터 세팅, VSCode 세팅, 추가로 유용한 단축키에 대해서 알아봅니다.\n다만, 단축키는 운영체제, 에디터 환경, 설정에 따라 다를 수 있으니 이점 참고 바랍니다.\n\n\u003cnotice\u003e\n  **이미 설치를 완료하신 분들도 시간 내셔서 [**`VSCode 세팅`**](https://wjlee611.github.io/blog/flutter/001_installation#vscode-%EC%84%B8%ED%8C%85)부터 읽어보시는 것을 강력 추천드립니다.**\n\u003c/notice\u003e\n\n블로그 주인장은 M1 Mac 환경에서 세팅하였기에 리눅스 계열 세팅방법을 기준으로 다뤄봅니다만,\n윈도우 머신에서의 세팅도 다뤄볼 겁니다. (다만, 실제 테스트는 하지 않았기에 오류가 있을지도 모릅니다)\n\n참고로 아래의 모든 설치과정은 [**노마드코더**](https://nomadcoders.co/flutter-for-beginners)의 강좌를 정리한 자료입니다.\n\n- https://nomadcoders.co/flutter-for-beginners/lectures/4133\n- https://nomadcoders.co/flutter-for-beginners/lectures/4142\n\n---\n\n## Flutter SDK 설치\n\nFlutter SDK를 설치할 때 방법이 크게 두 가지로 나뉩니다.\n첫 번째는 Flutter 공식 사이트에서 제공하는 방식을 따라가는 방법\n두 번째는 패키지 매니저를 이용해서 설치하는 방법\n\n제 개인적인 생각에는 패키지 매니저를 이용하는 방법이 더 간단해 보입니다.\n첫 번째 방법을 따라하려면 환경 PATH도 설정해야 하기에 좀 무서워 보이기 때문이죠...\n~_(그리고 제가 이 방법밖에 안해보기도 했구요...)_~\n\n그래도 일단은 두 방법 모두 소개해 드리겠습니다.\n\n### 공식 사이트\n\n1. [**플러터 공식 페이지**](https://flutter.dev)로 접속합니다.\n\n2. `Get started`로 들어갑니다.\n   ![230913-211858](/posts/001_installation/230913-211858.png)\n\n3. 본인 운영체제에 맞는 Flutter SDK를 설치합니다.\n   ![230913-212121](/posts/001_installation/230913-212121.png)\n\n   이후에는 공식 사이트에서 제공하는 문서를 천천히 따라하시면 됩니다.\n\n---\n\n### 패키지 매니저 (MacOS)\n\n1. [**Homebrew**](https://brew.sh/)에 들어갑니다.\n   ![230913-214251](/posts/001_installation/230913-214251.png)\n\n\u003cnotice\u003e\n  _참고로 Homebrew는 MacOS에서 사용할 수 있는 **대부분의 개발자도구를 터미널로 설치할 수 있는 강력한 도구**입니다._\n  _Flutter가 아니더라도 **반드시** 설치하는게 정신건강에 이롭습니다._\n\u003c/notice\u003e\n\n2. `터미널`을 열어줍니다.\n\n3. 아래의 명령어를 입력하여 Homebrew를 설치합니다.\n   (공식 사이트에서 복사하는 것을 권장합니다)\n\n```bash:Terminal\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n4. 아래의 명령어로 Flutter SDK를 설치합니다.\n\n```bash:Terminal\nbrew install --cask flutter\n```\n\n---\n\n### 패키지 매니저 (Windows)\n\n1. [**Chocolatey - individual**](https://chocolatey.org/install#individual)에 들어갑니다.\n   ![230913-213419](/posts/001_installation/230913-213419.png)\n\n2. `PowerShell`을 관리자 권한으로 실행합니다.\n\n3. 아래의 명령어를 입력하여 Chocolatey를 설치합니다.\n\n```shell:PowerShell\nGet-ExecutionPolicy\n```\n\n만약 `Restricted` 라고 뜬다면 아래의 명령어 중 하나를 입력하면 됩니다.\n\n```shell:PowerShell\nSet-ExecutionPolicy AllSigned\n또는\nSet-ExecutionPolicy Bypass -Scope Process\n```\n\n그 이후에 아래의 긴- 명령어를 입력합니다.\n(공식 사이트에서 복사하는 것을 권장합니다)\n\n```shell:PowerShell\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n```\n\n`Chocolatey` 설치가 완료되었다면 `choco` 라는 명령어가 실행 가능할 겁니다.\n\n4. 아래의 명령어로 Flutter SDK를 설치합니다.\n\n```shell:PowerShell\nchoco install flutter\n```\n\n### 설치 확인 방법 (1)\n\n터미널 창에 `flutter` 를 입력해봅시다.\n`Command not found` 와 같은 에러를 제외하고 뭐라도 뜬다면 설치가 완료된 것입니다.\n\n---\n\n## 애뮬레이터 설치\n\n아래의 공식 문서를 통해 설치하는 것이 가장 바람직합니다.\n설명도 친절해서 왠만하면 설치하는데 문제가 없을겁니다. (아예 없진 않음...)\n관련 링크를 아래에 정리합니다.\n\n🫧[**MacOS - ios setup**](https://docs.flutter.dev/get-started/install/macos#ios-setup)\n🫧[**MacOS - android setup**](https://docs.flutter.dev/get-started/install/macos#android-setup)\n\n🫧[**Windows - android setup**](https://docs.flutter.dev/get-started/install/windows#android-setup)\n\n### 설치 확인 방법 (2)\n\n터미널 창에 `flutter doctor` 를 입력해봅시다.\n![230913-220216](/posts/001_installation/230913-220216.png)\n\nSDK, 애뮬레이터, 에디터까지 발생하는 문제사항을 한 눈에 파악할 수 있습니다.\n\n\u003ctip\u003e\n  참고로 최초 실행시 안드로이드 라이센스에 동의하라는 에러 혹은 경고가 나타날 수 있습니다. \n  그럴 땐 당황하지 마시고 아래의 명령어를 입력하면 됩니다.\n  (_설치할 때 꼼꼼히 읽어보면 이런 내용도 있다는 걸 확인할 수 있죠..._)\n\n  \u003cbr /\u003e\n\n  ```bash:Terminal\n  flutter doctor --android-licenses\n  ```\n\u003c/tip\u003e\n\n### Troubleshooting\n\n간혹가다 Xcode `command line tools`에서 문제가 발생하는 경우가 있습니다.\n명령어 라인 도구는 Xcode를 설치할 때 자동적으로 설치됩니다.\n\n하지만 제 경우에는 Xcode를 설치하기 전에 아래의 명령어로 미리 설치한 적이 있었습니다.\n\n```bash:Terminal\nxcode-select --install\n```\n\n명령어 라인 도구를 먼저 설치하고 Xcode를 설치하면 가끔 정상동작하지 않는 에러가 발생하는 거 같습니다.\n이런 경우에는 명령어 라인 도구를 제거하고 다시 설치하면 해결됩니다.\n\n---\n\n## VSCode 세팅\n\n사실 마켓플레이스에서 `Flutter`, `Dart` 확장을 설치하기만 하면 개발할 준비가 끝나긴 합니다.\n하지만, 개발 편의성과 코드 통일을 위해서 필요한, 혹은 유용한 `확장`과 `setting.json`을 공유할까 합니다.\n\n### setting.json\n\n아래와 같은 키값을 추가하면 개발에 있어 편의성이 증진됩니다.\n하지만, 설정을 건드릴 땐, 본인의 설정과 충돌이 생기는지 반드시 확인한 후에 추가하시는 것을 권장합니다.\n\n참고로, setting.json은 `명령 팔레트`를 열고 `settings.json`을 검색하면 바로 나옵니다.\n또 참고로, 명령 팔레트는 `Command(Window) + Shift + P` 명령어 조합으로 열 수 있습니다.\n\n```json:settings.json showLineNumbers\n{\n  ...\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll\": true\n  },\n  \"dart.previewFlutterUiGuides\": true,\n}\n```\n\n`Line 3-5`의 설정은 자동으로 필요한 모든 곳에 `const` 키워드를 삽입해주는 설정입니다.\nflutter에서 const를 사용하는 것은 매우 중요한데 그 이유에 대해서는 다음에 설명하도록 하겠습니다.\n일단은 가능하다면 반드시 const를 붙이는게 좋고, 이를 자동으로 붙여줄 수 있다는 것만 기억합니다.\n\n`Line 6`의 설정은 flutter 위젯을 트리 구조로 선으로 연결해주는 설정입니다.\n![230913-222546](/posts/001_installation/230913-222546.png)\n\nflutter은 위젯의 depth가 깊어지는 단점이 있는데 이를 어느정도 극복하게 해주는 유용한 설정입니다.\n\n### Error Lens\n\n![230913-223129](/posts/001_installation/230913-223129.png)\n\nError Lens는 코드 문제의 원인을 에디터상에 바로 띄워주는 확장입니다.\n실시간으로 무슨 에러가 있는지 한 눈에 확인할 수 있는게 개인적으로 매우 만족하면서 사용하고 있습니다.\n\n![230913-223528](/posts/001_installation/230913-223528.png)\n\n개인적으로 눈뽕(?) 방지를 위해 `line` 이 아닌, `message` 로 설정하는 것을 추천드립니다.\n\n![230913-224036](/posts/001_installation/230913-224036.png)\n\n또한, 분석 레벨에서 `info` 는 제거해주시는 것을 추천 드립니다.\n\nflutter의 경우 info가 중첩되서 뜨는 경우가 많기에 위 두 세팅을 바꾸지 않으면 아래와 같은 눈뽕(?)을 자주 겪게 될 지도 모릅니다...\n![230913-223954](/posts/001_installation/230913-223954.png)\n\n### Image preview\n\n![230913-224456](/posts/001_installation/230913-224456.png)\n\nImage preview는 로컬, 네트워크 이미지를 미리보기 형식으로 띄워주는 확장입니다.\nFE 개발 입장에서 이미지나 svg, icon을 사용할 일이 많은데, 이를 미리볼 수 있다는 것 만으로도 많은 시간을 절약할 수 있습니다.\n\n---\n\n## VSCode 단축키\n\n개발 시간을 줄여주는 유용한 단축키 및 snippets 를 소개합니다.\n\n### Code Action\n\n![230913-224956](/posts/001_installation/230913-224956.png)\n\nflutter 개발을 하다보면 중간에 위젯을 다른 위젯으로 감싸거나, 부모 위젯을 통째로 드러내야 하는 경우가 잦은데,\n이를 일일이 코드를 잘라내고 붙여넣기 하는건 매우 귀찮은 작업입니다.\n\n하지만 이 기능을 수행하는데 있어 Code Action은 매우 유용한 도구들을 제공합니다.\n\n기능을 수행하고자 하는 위젯의 좌측에 `💡(전구) 모양 아이콘`을 클릭하면 해당 위젯에서 수행할 수 있는 여러 기능들을 보여줍니다.\n\n또는 `Command(Window) + .` 단축키로 빠르게 Code Action에 접근할 수 있습니다.\n매우매우 자주쓰는 기능이니 본인 에디터 환경에 맞는 단축키를 외우도록 합시다.\n~_(사실 외울 필요도 없이 쓰다보면 손가락이 알아서 움직이게 된다는...)_~\n\n### Intellisense\n\n쉽게 말하면 `코드 추천 + 자동완성` 기능입니다.\n\n코드를 입력하다 보면 자동으로 코드를 추천해줄텐데, 실수로 이를 꺼버리는 일이 발생합니다.\n이 경우 코드를 지웠다가 다시 치는 것 보단, `Option(Alt) + Space`로 다시 활성화 시키는 것이 더 유용합니다.\n\n### st + (intellisense)\n\n![230913-230035](/posts/001_installation/230913-230035.png)\n\n플러터의 위젯의 대부분은 Stateful, Stateless 위젯을 상속 받습니다.\n그에 따라 여러 메서드를 override해서 사용해야만 하는데요,\n이 모든 코드를 일일이 입력하는 것도, 기억하는 것도 쉽지 않습니다.\n\n이 경우에는 `st`를 입력하고 intellisense 기능을 이용하면 VSCode가 알아서\nStateful, Stateless 위젯의 필수 부분을 알아서 완성해주고,\n클래스 이름과 관련한 부분 모두를 선택한 상태로 사용자의 입력을 기다리게 됩니다.\n\n따라서 사용자는 아래의 절차를 밟으면 간단하게 위젯 하나를 생성할 수 있게 됩니다.\n\n1. st + (intellisense)\n2. 원하는 부모위젯(Stateful, Stateless) 선택\n3. 원하는 클래스 이름 입력\n\n## 마무리\n\n지금까지 Flutter SDK 설치부터 VSCode 단축키까지 개발에 앞서 필요한 모든 준비단계를 알아봤습니다.\n추가로 필요한 설정이나 기능은 알아보시고 추가하여 사용하신다면, 개발이 조금이라도 더 즐거워지리라 생각됩니다.\n\n긴 글 읽어주셔서 감사드리고, 모두 알찬 `Flutt-er` 생활 되시길 바랍니다!\n","slug":"flutter/001_installation","readingMinutes":14,"wordCount":1023},{"title":"상태공간 \u0026 탐색","description":"상태공간과 탐색의 의미와 예시를 알아봅니다.","icon":"","image":"","tags":["Depth First Search","Breadth First Search","Depth Limited Search","Best First Search","Beam Search","A* Algorithm"],"draft":false,"date":"2023-09-12 / 15:44","content":"\n## 상태공간\n\n문제 해결 과정에서 초기 상태로부터 도달할 수 있는 모든 상태들의 집합을 의미한다.\n한 마디로 `문제의 해가 될 가능성`이 있는 모든 상태들의 집합을 의미한다.\n\n## 탐색\n\n상태공간에서 최적의 해를 찾기위해 공간을 체계적으로 찾아보는 것을 의미한다.\n탐색은 아래와 같은 방식으로 크게 구분지을 수 있다.\n\n1. 맹목적 탐색\n2. 정보이용 탐색\n\n이렇게 구분짓는 이유는 탐색의 방식에 따라 달라지는데,\n탐색 방식이 다양해 질 수 밖에 없는 이유는 일반적인 문제에서는 상태공간이 매우 크기 때문에\n미리 공간 그래프를 그릴 수 없어 탐색 과정에서 그래프를 생성할 수 밖에 없기 때문이다.\n\n---\n\n## 맹목적 탐색\n\n정해진 순서에 따라 상태공간 그래프를 점차 생성해 가면서 해를 탐색하는 방법을 의미한다.\n\n### 깊이 우선 탐색 (Depth-first search)\n\n![231021-223045](/posts/mid_01/231021-223045.png)\n\n초기 노드부터 깊이가 깊어지는 방향으로 우선 탐색하는 기법.\n더이상 진행할 수 없다면 백 트리킹으로 돌아와 다음 노드 탐색.\n\n루트 노드에서 현재 노드까지의 경로 하나만 유지한다는 특징이 있기에 메모리 공간 사용이 효율적이라는 장점이 있다.\n하지만, 깊이가 무한히 깊어지는 무한루프의 가능성 때문에 항상 최단 경로의 해를 보장할 수 없다는 단점이 있다.\n\n### 너비 우선 탐색 (Breadth-first search)\n\n![231021-223311](/posts/mid_01/231021-223311.png)\n\n초기 노드부터 시작하여 모든 자식 노드를 확장하여 탐색하는 기법.\n목표 노드가 없다면 단말 노드에서 다시 자식노드 확장 탐색.\n\n최단 경로의 해를 보장하지만, 메모리 효율적이지 못하다.\n\n### 깊이 제한 탐색 (Depth-limited search)\n\n![231021-223510](/posts/mid_01/231021-223510.png)\n\n기본적인 탐색 방식은 깊이 우선 탐색 방식임.\n단, 깊이에 제한을 둬서 특정 깊이 이하로는 탐색을 진행하지 않고 백 트래킹 하는 것이 특징임.\n특정 깊이에서 목표를 찾지 못한 경우 깊이를 늘려가며 처음부터 다시 탐색을 진행함.\n\n최단 경로의 해를 보장하며, 메모리 사용도 효율적이다.\n상위 노드는 반복해서 탐색하기에 약간의 비효율성이 있으나, 무시할만한 수준임.\n\n즉 맹목적 탐색시에는 이 방식을 우선적으로 고려하는 것이 좋음.\n\n---\n\n## 정보이용 탐색\n\n휴리스틱한 방법으로 목표까지의 예상 비용을 구하고, 그 값에 의거해 순간순간 최선의 선택을 해가며 탐색하는 방법을 의미한다.\n\n\u003ctip\u003e\n  `휴리스틱 (heuristic)`\n  신속하게 어림짐작 하는 것.\n\u003c/tip\u003e\n\n### 언덕 오르기 방법 (Hill climbing method)\n\n![231021-224206](/posts/mid_01/231021-224206.png)\n\n현재 노드에서 휴리스틱에 의한 평가값이 가장 좋은 이웃 노드 하나를 확장해가는 탐색기법.\n단, 국소 최적해에 빠질 가능성이 있다.\n(경사 하강법과 유사)\n\n### 최상 우선 탐색 (Best-first search)\n\n확장 중인 노드들 중에서 목표 노드까지 남은 거리가 가장 짧은 노드를 확장하여 탐색하는 기법.\n일종의 그리디한 방식임.\n\n![231021-224403](/posts/mid_01/231021-224403.png)\n\n예시로 휴리스틱 함수를 제자리가 아닌 타일의 개수라고 할 때, 다음과 같은 순서로 탐색을 진행하게 된다.\n\n\u003e a \u0026rarr; c \u0026rarr; e/f \u0026rarr; h \u0026rarr; j\n\n### 빔 탐색 (Beam search)\n\n최상 우선 탐색(BFS) 의 확장판으로, 휴리스틱에 의한 평가값이 우수한 일정 개수(K개)의 확장 가능한 노드만을 메모리에서 관리하면서 탐색.\n\n![231021-224723](/posts/mid_01/231021-224723.png)\n\n예시로 K=2일 때, A~E를 일단 탐색하고, 평가값이 우수한 B, E를 제외한 노드는 메모리에서 제거하며 B, E에서 그 자식노드에 대해 같은 방식을 적용하며 탐색한다.\n\n### A* 알고리즘 (A-star algorithm)\n\n최상 우선 탐색(BFS) 의 개선판으로, 휴리스틱에 의한 평가값 + 현재까지의 코스트의 결과인 휴리스틱한 전체 비용을 기준으로 탐색하는 기법.\n\n![231021-225028](/posts/mid_01/231021-225028.png)\n\n최초 상태를 탐색한 후, 그 자식 노드 3개의 휴리스틱한 전체 비용을 계산하면 `1(현재까지의 코스트)+3(휴리스틱 평가값)`의 값을 갖는 가운데 자식 노드가 비용이 가장 작기에 다음 탐색 대상으로 한다.\n\n이런 식으로 **탐색한 모든 노드를 메모리 상에서 관리**하며, 그 순간 휴리스틱 전체 비용이 가장 낮은 노드를 다음 탐색 대상으로 삼는다.","slug":"univ_ai/mid_01","readingMinutes":7,"wordCount":479},{"title":"Observer Pattern","description":"Observer 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Observer Pattern","interface"],"draft":false,"date":"2023-09-11 / 10:33","content":"\n## Strategy Pattern\n\n[**저번 포스트**](https://wjlee611.github.io/blog/univ_design-pattern/mid_01)에서 배운 `Strategy 디자인 패턴`을 이용해서 한 가지 예를 살펴보자.\n\n```java:WeatherData.java {7} showLineNumbers\npublic class WeatherData {\n  public void measurementsChanged() {\n    float temp = getTemperature();\n    float humidity = getHumidity();\n    float pressure = getPressure();\n\n     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n    currentConditionsDisplay.update(temp, humidity, pressure);\n    statisticsDisplay.update(temp, humidity, pressure);\n    forecastDisplay.update(temp, humidity, pressure);\n  }\n}\n```\n\n이 코드는 `Display`장치들이 `WeatherData`에서 제공하는 데이터를 이용하려는 코드이다.\n\n예로 들어 `forecastDisplay`에서 날씨 정보를 출력하기 위해서는\n`WeatherData`에서 `forecastDisplay.update()` 메서드를 호출해야\n날씨 정보가 비로소 `forecastDisplay`로 전달되는 것이다.\n\n### 문제점\n\n여기서 문제가 발생한다.\n만약 새로운 장치 futureDisplay를 구현하려면 Strategy Pattern을 사용하는 코드는 아래와 같은 코드수정이 필요해진다.\n\n1. update() 전략을 갖고있는 인터페이스로 구현한 전략(Display) 클래스를 만든다.\n2. `Line 7`에 새로운 장치를 등록한다.\n\n지금 당장은 문제될게 없어 보이지만, 만약 당신이 WeatherData를 `라이브러리화 해서 배포`하는 입장일 경우를 고려해보자.\n`사용자`는 단지 새로운 Display를 추가하여 바로 날씨 정보를 받아오고 싶을 것이다.\n하지만, 위와 같은 코드라면 사용자는 라이브러리 파일을 뜯어서 WeatherData 클래스 내부에\n직접적으로 `새로운 Display를 의존성 주입`을 해줘야만 할 것이다.\n\n이 경우는 꽤나 치명적이다.\n생각해보면 우리가 사용하는 대부분의 라이브러리는 이런 과정을 겪지 않으니 말이다.\n\n따라서 이런 문제를 해결하기 위한 디자인 패턴이 필요하다.\n\n## Observer Pattern\n\nObserver Pattern의 정의는 다음과 같다.\n\n\u003e 객체들이 1:N의 관계를 갖을 때, 한 객체의 상태가 변하면 다른 모든 객체들에 업데이트 통지가 떨어지는 관계로,\n\u003e `객체(Subject)`와 `객체들(Observers)`간의 `종속성이 없는 관계`를 의미한다.\n\n코드로 살펴보며 이해해보자.\n\n### interface\n\n```java:IObserverPattern.java {1-5, 7-9}\npublic interface Subject {\n    public void registerObserver(Observer o);\n    public void removeObserver(Observer o);\n    public void notifyObservers();\n}\n\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\n\npublic interface DisplayElement {\n    public void display();\n}\n```\n\n위 코드는 Observer Pattern에서 사용하는 인터페이스이다.\n`1`의 입장인 클래스(Subject)는 `Subject 인터페이스`를 구현해야 하고,\n`N`의 입장인 클래스(Observers)는 `Observer 인터페이스`를 구현해야 한다.\n\n### Subject class\n\n```diff-java:WeatherData.java {24, 35}\n  public class WeatherData implements Subject {\n+   private ArrayList\u003cObserver\u003e observers;\n\n    public WeatherData() {\n      observers = new ArrayList\u003cObserver\u003e();\n    }\n\n+   @implements\n+   public void registerObserver(Observer o) {\n+     observers.add(o);\n+   }\n+\n+   @implements\n+   public void removeObserver(Observer o) {\n+     int i = observers.indexOf(o);\n+     if (i \u003c 0) return;\n+     observers.remove(i);\n+   }\n+\n+   @implements\n+   public void notifyObservers() {\n+     for (int i=0; i\u003cobservers.length; i++) {\n+       Observer o = observers.get(i);\n+       o.update(temp, humidity, pressure);\n+     }\n+   }\n\n    public void setMeasurements(float temp, float humidity, float pressure) {\n      this.temp = temp;\n      this.humidity = humidity;\n      this.pressure = pressure;\n      measurementsChanged();\n    }\n\n    // 더이상 WeatherData 클래스는 수정할 일이 없어진다.\n    public void measurementsChanged() {\n+     notifyObservers()\n-     float temp = getTemperature();\n-     float humidity = getHumidity();\n-     float pressure = getPressure();\n-\n-     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n-     currentConditionsDisplay.update(temp, humidity, pressure);\n-     statisticsDisplay.update(temp, humidity, pressure);\n-     forecastDisplay.update(temp, humidity, pressure);\n    }\n  }\n```\n\nSubject class의 역할은 Observer의 `구독과 해지`하는 역할을 담당하고,\n구독된 Observers에게 `본인의 변경사항을 알려`주는 역할을 한다.\n\n본인의 변경사항을 알려주기 위해 `Observer는 update 전략`을 포함하고 있어야 한다.\n\n이제 Subject 클래스는 `구독된 Observer를 배열로 관리`하고, `관리되고 있는 Observer를 대상`으로 `변경사항을 emit(update)`하기 때문에\n**더이상 Subject 클래스를 수정할 필요가 없어진다.**\n\n### Observer class\n\n```java:FutureDisplay.java {6-8}\npublic class FutureDisplay implements Observer, DisplayElement {\n  private Subject weatherData;\n\n  public FutureDisplay(Subject weatherData) {\n    this.weatherData = weatherData;\n    // Observer가 Subject를 구독한다.\n    // 비로소 Subject가 update를 쏴줄 수 있다.\n    weatherData .registerObserver(this);\n  }\n\n  public void update(float temp, float humidity, float pressure) {\n    this.temp = temp;\n    this.humidity = humidity;\n    this.pressure = pressure;\n    display();\n  }\n\n  @implements\n  public void display() {\n    // ...\n  }\n}\n```\n\nObserver는 생성시 자동으로 `Subject를 구독`하게 되고,\n구독했기에 Subject의 상태 변경시 자동으로 Observer를 업데이트 할 수 있다.\n_Subject의 observers 배열에 추가되어 관리됨_\n\n\u003e 여기서 눈여겨 봐야 할 점은 `Observer의 update` 전략 메서드는 `Subject`에서,\n\u003e `Subject의 register, remove` 전략 메서드는 `Observer`에서 호출된다는 점이다.\n\u003e 서로 `크로스`되어 메서드를 호출한다는 점을 주목하자.\n\n### main (사용자 입장)\n\n```diff-java:WeatherStation.java {5-6}\n  public class WeatherStation {\n    public static void main(String[] args) {\n      WeatherData weatherData = new WeatherData();\n\n      // another displays\n+     FutureDisplay futureDisplay = new FutureDisplay(weatherData);\n\n      weatherData.setMeasurements(80, 65, 30.4f);\n      weatherData.setMeasurements(82, 70, 29.2f);\n      weatherData.setMeasurements(78, 90, 29.3f);\n    }\n  }\n```\n\n사용자 입장에서는 새로운 Display객체 생성시 WeatherData를 의존성 주입만 해주면,\n그 뒤의 모든 과정은 Observer Pattern에 의해 자동으로 업데이트가 가능해진다.\n\n## 결론\n\n`의존성이 없어`야 하지만 `여러 클래스와 관계`를 가져야하고,\n동시에 `코드가 수정되는 일이 적어`야만 하는 클래스는\nObserver Pattern을 그 클리스와 관계를 갖는 여러 클래스에 적용하는 것이 좋다.\n","slug":"univ_design-pattern/mid_02","readingMinutes":7,"wordCount":693},{"title":"Strategy Pattern","description":"Strategy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Strategy Pattern","extends","implements"],"draft":false,"date":"2023-09-11 / 09:09","content":"\n## 상속\n\n### extends\n\n오리 시뮬레이터를 만든다고 가정해보자.\n그렇다면 일단 오리 객체를 만들어야 할 것이다.\n\n```java:Duck.java {5}\nclass Duck() {\n  quack() {};\n  swim() {};\n  fly() {};\n  display() {};\n  // other duck-like methods\n}\n```\n\n그리고 여러 종류의 오리는 이 `Duck` 클래스를 상속받아서 사용하면 될 것이다.\n\n```java:Ducks.java {2-3, 7-8}\nclass MallardDuck extends Duck {\n  @override\n  display() {};\n}\n\nclass RedheadDuck extends Duck {\n  @override\n  display() {};\n}\n```\n\n물론 생김새는 다르기에 일부 메서드는 `override`해서 사용해야 할 것이다.\n이 때 자식 클래스와 부모 클래스는 `is a` 관계를 갖는다고 말한다.\n_e.g. MallardDuck is a Duck_\n\n### implements (interface)\n\n이제 고무 오리를 만들어보자.\n\n```java:Ducks.java {4-7}\nclass RubberDuck extends Duck {\n  @override\n  display() {}\n  @override\n  quack() {}\n  @override\n  fly() {}\n}\n```\n\n고무 오리는 `꽥` 소리를 내지 않고 `삑`소리를 내기 때문에 `quack()` 메서드 역시 override 해야한다.\n또한, 날지도 않기에 `fly()` 메서드 역시 override 해야한다.\n\nDecoyDuck을 또 만든다면?\n이 역시 quack, fly 메서드를 override 해야한다.\n\n이렇게 모든 Duck들이 공유하지 않는 속성은 매번 override 해야하는 문제점이 있다.\n\n이 때, `interface`를 사용하면 이 문제를 해결할 수 있다.\n\n```diff-java:DucksWithInterfece.java {12, 18}\n  class Duck() {\n    swim() {};\n    display() {};\n  }\n+ interface Flyable() {\n+   fly();\n+ }\n+ interface Quackable() {\n+   quack();\n+ }\n\n  class MallardDuck extends Duck implements Flyable, Quackable {\n+   fly() {};\n+   quack() {};\n    @override\n    display() {};\n  }\n  class RubberDuck extends Duck implements Quackable {\n+   quack() {};\n    @override\n    display() {};\n  }\n```\n\n이렇게 변할 수 있는 부분은 interface로 띄어내면 쓸데없이 메서드를 override할 일이 줄어든다.\n이 때 구현 클래스와 인터페이스는 `has a` 관계를 갖는다고 한다.\n_e.g. RubberDuck has a Quackable_\n\n_참고:_\n_class, interfece의 차이는 사실 거의 없다._\n\n### interface 다형성\n\n하지만 위 방식 역시 문제가 존재한다.\nMallardDuck, RedheadDuck 두 오리 모두 같은 quack 메서드로 동작해야 하지만,\n이를 implements 하는 과정에서 두 메서드를 중복해서 구현해야 한다는 문제점이 발생한다.\n\n이를 해결하기 위해서는 인터페이스의 다형성의 원리를 이용하는게 좋다.\n\n```diff-java:DucksWithPolymorphism.java {18, 20-24}\n  interface QuackBehavior {\n    quack();\n  }\n+ class Quack implements QuackBehavior {\n    @override\n    quack() {'꽥'};\n  }\n+ class Squack implements QuackBehavior {\n    @override\n    quack() {'삑'};\n  }\n+ class MuteQuack implements QuackBehavior {\n    @override\n    quack() {};\n  }\n\n  class Duck {\n    QuackBehavior quackBehavior;\n\n    performQuack() {\n      // delegate to the behavior class\n      // 한 마디로 짬때리기...\n      quackBehavior.quack();\n    }\n    // ...\n  }\n\n  class MallardDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Quack 객체를 지정할 수 있다.\n+     quackBehavior = new Quack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(꽥)를 사용할 수 있음.\n    // ...\n  }\n  class RubberDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Squack 객체를 지정할 수 있다.\n+     quackBehavior = new Squack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(삑)를 사용할 수 있음.\n    // ...\n  }\n```\n\n이렇게 하면 필요한 부분에만 기능을 추가할 수 있고, 코드의 재사용성도 올라간다.\n뿐만 아니라 새로운 기능 (예로 들어 새로운 울음 소리)의 추가도 쉬워진다.\n\n## Strategy Pattern\n\n위에서 알아본 적절한 상속관계를 준수한 패턴을 `Strategy Pattern` 라고 한다.\n정확한 정의는 다음과 같다.\n\n\u003e 객체들이 할 수 있는 행위 각각에 대해 `전략 클래스 (Quack, Squack)`를 생성하고,\n\u003e `유사한 행위들을 캡슐화` 하는 `인터페이스 (QuackBehavior)`를 정의하여,\n\u003e 객체의 행위를 동적으로 바꾸고 싶은 경우 `직접 행위를 수정하지 않고 (performQuack())`\n\u003e 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.\n\n간단히 말해서 객체가 할 수 있는 행위들을 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것만으로 행위의 수정이 가능하도록 만든 패턴이다.\n\n## 결론\n\n`has a (구현)`관계가 `is a (상속)`관계보다 낫다.\n\n상속은 뭘 상속해야 하는지 일일이 파악해야 하는 귀찮음이 있기 때문이다.\n하지만, 구현은 필요한 기능만 가져다 쓰면 되기에 사용및 개발적 측면에서 좋고,\n새로운 기능은 인터페이스를 추가로 구현하면 끝이기에 유지보수 측면에서도 좋다.\n\n따라서 단순히 상속을 이용한 객체지향 프로그래밍 보단,\n전략 패턴을 적용한 코딩 습관을 기르도록 하자.\n","slug":"univ_design-pattern/mid_01","readingMinutes":6,"wordCount":594}]},"__N_SSG":true},"page":"/blog/posts","query":{},"buildId":"deatTRx3qrRnvuKFWMv7Z","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>