<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>웅덩이</title><link rel="canonical" href="https://wjlee611.github.io/blog/univ_design-pattern/final_05"/><meta name="next-head-count" content="4"/><link rel="icon" href="/images/icon_circle.png"/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" rel="stylesheet"/><meta name="description" content="웅덩이"/><meta name="apple-mobile-web-app-title" content="웅덩이"/><meta name="application-name" content="웅덩이"/><meta name="theme-color" content="#009c39"/><meta name="google-site-verification" content="vhQ9DaDdUJcSBHKI_U6tAtE61zwz2i2pLQXyZ62GRLk"/><meta name="naver-site-verification" content="07764cc1a8eda55b4bdf78cf846d6811d042b9ee"/><link rel="preload" href="/_next/static/media/a37cf3809adb2c63-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/dd50543ba70be8e9-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/c372a630cbda84f2-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/c244cd6be2a69a75.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c244cd6be2a69a75.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-401a9806b070f31a.js" defer=""></script><script src="/_next/static/chunks/main-6b74302918225334.js" defer=""></script><script src="/_next/static/chunks/pages/_app-01dc60c7ef7ccbd8.js" defer=""></script><script src="/_next/static/chunks/95b64a6e-5c1c80ce1af5e491.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5B...slugs%5D-d30256c1e19801d0.js" defer=""></script><script src="/_next/static/zjlLyPj8az7Fp8gQlOqTr/_buildManifest.js" defer=""></script><script src="/_next/static/zjlLyPj8az7Fp8gQlOqTr/_ssgManifest.js" defer=""></script></head><body class="text-primary transition-[background] bg-white dark:bg-[#1A1C23]"><script>
            const theme = localStorage.getItem("theme");
            const getUserTheme = () => {
             if(theme){
              return theme
             } 
             return window.matchMedia('(prefers-color-scheme: dark)').matches
             ? 'dark'
             : 'light'
          }
          document.body.dataset.theme = getUserTheme();
          </script><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="__className_e7b8b0 text-center transition-all "><header class="fixed top-0 left-0 right-0 mx-anuo w-screen h-12 md:h-16 flex justify-between items-center px-2 md:px-10 backdrop-blur bg-blue-200 bg-opacity-20 z-50"><div class="h-full flex items-center"><a class="h-full aspect-square flex justify-center items-center text-3xl select-none cursor-pointer" href="/">🫧</a><nav class="h-full hidden md:flex space-x-8 overflow-hidden ml-10"><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-black dark:text-white " href="/">Portfolio</a></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-blue-500 " href="/blog">Blog</a><div class="hidden md:flex w-full h-[2px] bg-blue-500 absolute bottom-0 left-0 blur-[2px]"></div></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-black dark:text-white " href="/arkhive">Arkhive</a></li></nav></div><div class="flex items-center h-full"><button aria-label="Toggle Dark Mode" type="button" class="flex h-9 w-9 items-center justify-center rounded-lg transition-all text-secondary hover:bg-secondary "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="h-6 w-6 text-yellow-400 drop-shadow-base"></svg></button><button class="flex md:hidden items-center justify-center w-16 h-full text-2xl text-black dark:text-white"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.5 11.5A.5.5 0 0 1 5 11h10a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 1 3h10a.5.5 0 0 1 0 1H1a.5.5 0 0 1-.5-.5z"></path></svg></button></div></header><main class="inline-block w-full relative pt-16 px-8 max-w-5xl 2xl:max-w-7xl" style="opacity:1;transform:none"><div class="flex flex-col items-start pb-16"><header class="flex w-full flex-col items-center my-10"><h1 class="bg-gradient-to-br from-blue-600 to-blue-400 bg-clip-text text-transparent text-3xl font-bold mb-5 drop-shadow">Bridge Pattern</h1><span class="text-blue-500 text-lg">Bridge 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.</span><span class="space-x-10 mt-5 text-blue-400 text-sm">읽는데<span class="text-blue-500 text-xl font-semibold"> <!-- -->3</span>분 정도 걸려요.</span></header><section class="w-full flex justify-between space-x-5"><div class="w-full flex flex-col items-start prose dark:prose-dark max-w-full lg:max-w-2xl 2xl:max-w-4xl"><h2 id="필요성"><a class="anchor" href="#필요성"><span class="icon icon-link"></span></a>필요성</h2>
<p>자동차를 만든다고 가정해보자.<br/>
<!-- -->자동차에는 셀 수 없는 여러 부품들이 종합적으로 들어가서 만들어질텐데, 만약 그 부품이 모두 종속적으로 연결되어 있다면?<br/>
<!-- -->부품 교체는 물론이고, 개발하는 것도 여러 사람이 분산해서 개발하지 못할 것이다.</p>
<p>각 부분을 독립적으로 개발하고, 확장을 유연하게 하기 위해 Bridge pattern을 사용한다.</p>
<h2 id="bridge-pattern"><a class="anchor" href="#bridge-pattern"><span class="icon icon-link"></span></a>Bridge Pattern</h2>
<div class="rehype-code-title">Product.java</div><pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">productName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>유연한 확장을 위해 인터페이스를 정의한다.<br/>
<!-- -->자동차의 부품에 해당하는 부분이다.</p>
<div class="rehype-code-title">CentralLocking.java</div><pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CentralLocking</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> productName<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token class-name">CentralLocking</span><span class="token punctuation">(</span><span class="token class-name">String</span> productName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>productName <span class="token operator">=</span> productName<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token comment">// override methods</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<div class="rehype-code-title">GearLocking.java</div><pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GearLocking</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> productName<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token class-name">GearLocking</span><span class="token punctuation">(</span><span class="token class-name">String</span> productName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>productName <span class="token operator">=</span> productName<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token comment">// override methods</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>그리고, 여러 사람이 인터페이스에 맞게 부품을 개발한다.</p>
<div class="rehype-code-title">Car.java</div><pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
</span><span class="code-line highlight-line">  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Product</span> product<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> carType<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token class-name">Product</span> product<span class="token punctuation">,</span> <span class="token class-name">String</span> carType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>product <span class="token operator">=</span> product<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">this</span><span class="token punctuation">.</span>carType <span class="token operator">=</span> carType<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">assemble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">produceProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>그리고 자동차의 뼈대를 만들어준다.</p>
<p>이 때, product를 인터페이스로 만들었기에 유연한 확장과, Car과 독립적으로 product를 개발할 수 있게되는데, 이것이 Bridge pattern 이다.</p>
<div class="rehype-code-title">Motoren.java</div><pre class="language-java"><code class="language-java code-highlight"><span class="code-line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Motoren</span> <span class="token keyword">extends</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token class-name">Motoren</span><span class="token punctuation">(</span><span class="token class-name">Product</span> product<span class="token punctuation">,</span> <span class="token class-name">Strint</span> carType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">super</span><span class="token punctuation">(</span>product<span class="token punctuation">,</span> carType<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token annotation punctuation">@override</span>
</span><span class="code-line">  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">produceProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line highlight-line">    product <span class="token punctuation">.</span><span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">// ...</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code></pre>
<p>그럼 자동차를 조립하는 입장에서는 produce의 내부 구조는 알 필요없이 인터페이스만을 가지고 독립적으로 개발할 수 있게 된다.</p></div><div class="w-72 hidden h-fit max-h-[calc(100vh-10rem)] lg:flex flex-col overflow-x-hidden overflow-y-scroll scrollbar-hide rounded-xl transition-all sticky top-32 bg-gradient-to-br from-blue-400 to-blue-950"><div class=""><p id="toc-header" class="py-3 font-extrabold leading-6 bg-black bg-opacity-20 text-white">🫧 한 눈에 보기</p><ul id="toc-content" class="px-4 pb-2 mt-2 flex flex-col items-start justify-start text-sm text-start"><li><a href="#필요성" class="group block py-1  text-white hover:text-blue-200 hover:drop-shadow-base-bold">필요성</a></li><li><a href="#bridge-pattern" class="group block py-1  text-white hover:text-blue-200 hover:drop-shadow-base-bold">Bridge Pattern</a></li></ul></div></div></section><footer class="w-full flex flex-col mt-10"><span class="text-blue-400 italic text-start">2023-12-07 / 11:17<!-- --> 에 작성을 시작했어요.</span><div class="w-full flex items-start mt-5 mb-10 space-x-5"><span>Tag</span><ul class="w-full flex list-none m-0 flex-wrap gap-1"><li class="bg-gradient-to-br from-blue-500 to-blue-400 px-3 text-white rounded-md shadow-md whitespace-nowrap"># <!-- -->Bridge Pattern</li></ul></div><div class="flex flex-col items-center mb-5"><div class="w-full bg-gradient-to-br from-blue-400 to-blue-950 mt-5 rounded-md overflow-hidden"><h3 class="bg-black bg-opacity-50 px-1 py-3"><span class="bg-gradient-to-br from-blue-600 to-blue-400 bg-clip-text text-transparent font-bold drop-shadow">대학 - 프로그래밍 언어론</span><span class="text-white">의 다른 글</span></h3><ol class="w-full p-1 space-y-1"><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/final_10">Visitor Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/final_09">Prototype Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/final_08">Mediator Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/final_07">Chain of Responsibility</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/final_06">Builder Pattern</a></li><li class="w-full bg-black bg-opacity-20 rounded-md"><a class="w-full flex justify-center text-white before:content-[&#x27;🫧&#x27;] before:mr-2 after:content-[&#x27;🫧&#x27;] after:ml-2" href="/blog/univ_design-pattern/final_05">Bridge Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/final_04">Factory Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/final_03">Proxy Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/final_02">State Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/final_01">Composite Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/mid_09">Iterator Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/mid_08">Template Method Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/mid_07">Facade Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/mid_06">Adapter Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/mid_05">Command Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/mid_04">Singleton Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/mid_03">Decorator Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/mid_02">Observer Pattern</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_design-pattern/mid_01">Strategy Pattern</a></li></ol></div></div><section class="w-full self-center"></section></footer></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Bridge Pattern","description":"Bridge 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Bridge Pattern"],"draft":false,"date":"2023-12-07 / 11:17","content":"\n## 필요성\n\n자동차를 만든다고 가정해보자.\n자동차에는 셀 수 없는 여러 부품들이 종합적으로 들어가서 만들어질텐데, 만약 그 부품이 모두 종속적으로 연결되어 있다면?\n부품 교체는 물론이고, 개발하는 것도 여러 사람이 분산해서 개발하지 못할 것이다.\n\n각 부분을 독립적으로 개발하고, 확장을 유연하게 하기 위해 Bridge pattern을 사용한다.\n\n## Bridge Pattern\n\n```java:Product.java\npublic interface Product {\n  public String productName();\n  public void produce();\n}\n```\n\n유연한 확장을 위해 인터페이스를 정의한다.\n자동차의 부품에 해당하는 부분이다.\n\n```java:CentralLocking.java\npublic class CentralLocking implements Product {\n  private final String productName;\n\n  public CentralLocking(String productName) {\n    this.productName = productName;\n  }\n  // override methods\n}\n```\n```java:GearLocking.java\npublic class GearLocking implements Product {\n  private final String productName;\n\n  public GearLocking(String productName) {\n    this.productName = productName;\n  }\n  // override methods\n}\n```\n\n그리고, 여러 사람이 인터페이스에 맞게 부품을 개발한다.\n\n```java:Car.java {2}\npublic abstract class Car {\n  private final Product product;\n  private final String carType;\n\n  public Car(Product product, String carType) {\n    this.product = product;\n    this.carType = carType;\n  }\n\n  public abstract void assemble();\n  public abstract void produceProduct();\n}\n```\n\n그리고 자동차의 뼈대를 만들어준다.\n\n이 때, product를 인터페이스로 만들었기에 유연한 확장과, Car과 독립적으로 product를 개발할 수 있게되는데, 이것이 Bridge pattern 이다.\n\n```java:Motoren.java {8}\npublic class Motoren extends Car {\n  public Motoren(Product product, Strint carType) {\n    super(product, carType);\n  }\n\n  @override\n  public void produceProduct() {\n    product .produce();\n    // ...\n  }\n}\n```\n\n그럼 자동차를 조립하는 입장에서는 produce의 내부 구조는 알 필요없이 인터페이스만을 가지고 독립적으로 개발할 수 있게 된다.","slug":"univ_design-pattern/final_05","readingMinutes":3,"wordCount":228},"posts":[{"title":"Visitor Pattern","description":"Visitor 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Visitor Pattern"],"draft":false,"date":"2023-12-07 / 21:03","content":"\n## 필요성\n\nComposite pattern을 사용하면서 동적으로 어떤 기능을 추가해야 하는 경우가 있다.\n\n이 경우 컴포넌트가 visitor의 접근 수락(accept) 하여 기능을 수행하는 패턴을 Visitor Pattern 라고 한다.\n\n## Visitor Pattern\n\n예시를 위해 java코드로 html 파일을 작성하는 코드를 구현한다고 가정해보자.\n\n```java:VisitorPattern.java\npublic interface Element {\n  public void accept(Visitor visitor);\n}\n\npublic interface Visitor {\n  public void visit(HtmlElement element);\n  public void visit(HtmlParentElement parentElement);\n}\n```\n\n우선 모든 `방문 대상의 클래스`를 하나의 Element 인터페이스로 묶기 위해 인터페이스를 만든다.\n또한, 방문하여 `수정을 가할 클래스`는 Visitor 인터페이스로 묶기게 되는데, 해당 클래스의 visit 메서드는 모든 방문 대상의 구현 클래스를 방문할 수 있어야 한다.\n\n```java:HtmlTag.java\npublic abstract class HtmlTag implements Element {\n  public String getTagName() {\n    throw new UnsupportedOperationException();\n  }\n  public void setTagBody(String tagBody) {\n    throw new UnsupportedOperationException();\n  }\n  // ...\n}\n```\n\n`구현할 방문 대상의 클래스`는 모두 HtmlTag를 상속받게 되는데, 이 부분은 Composite pattern과 동일하다.\n\n```java:HtmlElement.java\npublic class HtmlElement extends HtmlTag {\n  private String tagName;\n  private String startTag;\n  private String tagBody;\n\n  public HtmlElement(String tagName) {\n    this.tagName = tagName;\n    this.tagName = '';\n  }\n\n  @override\n  public String getTagName() {\n    return tagName;\n  }\n  ...\n  @override\n  public void accept(Visitor visitor) {\n    visitor.visit(this);\n  }\n}\n```\n\n```java:HtmlParentElement.java\npublic class HtmlParentElement extends HtmlTag {\n  private String tagName;\n  private String startTag;\n  private List\u003cHtmlTag\u003e childrenTag;\n\n  public HtmlParentElement(String tagName) {\n    this.tagName = tagName;\n    this.childrenTag = new ArrayList\u003cHtmlTag\u003e();\n  }\n\n  @override\n  public String getTagName() {\n    return tagName;\n  }\n  ...\n  @override\n  public void accept(Visitor visitor) {\n    visitor.visit(this);\n  }\n}\n```\n\n`방문 대상의 구현 클래스`를 HtmlTag(Element)를 상속받아 만들어준다.\n이 역시 인터페이스를 HtmlTag로 통일하기 위함이므로 Composite pattern과 동일하다.\n\n```java:ClassNameVisitor.java\npublic class ClassNameVisitor implements Visitor {\n  @override\n  public void visit(HtmlElement element) {\n    element.setStartTag(element.getStartTag().replace(\"\u003e\", \" class='children'\"))\n  }\n\n  @override\n  public void visit(HtmlParentElement element) {\n    element.setStartTag(element.getStartTag().replace(\"\u003e\", \" class='parent'\"))\n  }\n} \n```\n\n```java:StyleVisitor.java\npublic class StyleVisitor implements Visitor {\n  @override\n  public void visit(HtmlElement element) {\n    element.setStartTag(element.getStartTag().replace(\"\u003e\", \" style='width: 46px;'\"))\n  }\n\n  @override\n  public void visit(HtmlParentElement element) {\n    element.setStartTag(element.getStartTag().replace(\"\u003e\", \" style='width: 58px;'\"))\n  }\n} \n```\n\n그리고 `수정을 가할 클래스`를 Visitor를 상속받아 만들어준다.\n\n```java:.java {12-17}\npsvm() {\n  HtmlTag parentTag = new HtmlParentElement(\"\u003cdiv\u003e\");\n  HtmlTag cTag1 = new HtmlElement(\"\u003cp\u003e\");\n  HtmlTag cTag2 = new HtmlElement(\"\u003cp\u003e\");\n\n  parentTag.addChildTag(cTag1);\n  parentTag.addChildTag(cTag2);\n\n  Visitor className = new ClassNameVisitor();\n  VIsitor style = new StyleVisitor();\n\n  parentTag.accept(className);\n  parentTag.accept(style);\n  cTag1.accept(className);\n  cTag1.accept(style);\n  cTag2.accept(className);\n  cTag2.accept(style);\n}\n```\n\n그럼 위와 같은 방식으로 HtmlTag를 수정할 수 있다.\n\n이렇게 하면, Composite들은 accept 메서드만 제공할 뿐, 실제 기능의 추가와 변경은 visitor가 수행하게 된다.\n즉, 동적으로 기능을 확장할 수 있고, 기능을 visitor로 분리하여 코드를 관리할 수도 있다.","slug":"univ_design-pattern/final_10","readingMinutes":4,"wordCount":389},{"title":"Prototype Pattern","description":"Prototype 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Prototype Pattern"],"draft":false,"date":"2023-12-07 / 20:40","content":"\n## 필요성\n\n객체를 만들 때, 상당히 자주 만들어야 하는 객체의 생성방법이 귀찮거나, 오래 걸리는 경우에는 객체를 deep copy 하여 만드는 것이 효율적이다.\njava의 경우에는 clone() 메서드를 이용해서 객체를 deep copy할 수 있다.\n\n하나의 객체(Prototype)을 하드코딩하여 생성하고, 이후의 객체는 이 객체를 복사(일부 수정)하는 방식으로 생성하는 패턴을 prototype pattern 이라고 한다.\n\n## Prototype Pattern\n\n```java:Prototype.java\npublic interface Prototype extends Cloneable {\n  public AccessControl clone() throws CloneNotSupportedException;\n}\n```\n\njava에서는 객체를 clone할 때는 Cloneable marker interface를 상속받는 것이 좋다.\n따라서 이 인터페이스를 상속받아 prototype 인터페이스를 만든다.\n(AccessControl은 clone 메서드로 생성할 클래스로, 아래에서 구현예정)\n\n\u003ctip\u003e\n  clone() 메서드는 최상위 클래스 Object 클래스로부터 상속받을 수 있다.\n\u003c/tip\u003e\n\n```java:AccessControl.java\npublic class AccessControl implements Prototype {\n  private final String controlLevel;\n  private String access;\n\n  public AccessControl(String controlLevel, String access) {\n    this.controlLevel = controlLevel;\n    this.access = access;\n  }\n\n  @override\n  public AccessControl clone() {\n    try {\n      return (AccessControl) super.clone();\n    } catch (CloneNotSupportedException e) {\n      e.printStackTrace();\n    }\n    return null;\n  }\n  // getter...\n}\n```\n\n그리고 prototype pattern으로 생성할 클래스는 Prototype 인터페이스를 구현하여 만든다.\n\n```java:AccessControlProvider.java {13}\npublic class AccessControlProvider {\n  private static Map\u003cString, AccessControl\u003e new HashMap\u003cString, AccessControl\u003e();\n  static {\n    map.put(\"USER\", new AccessControl(\"USER\", \"DO_WORK\"));\n    map.put(\"ADMIN\", new AccessControl(\"ADMIN\", \"ADD/REMOVE_USER\"));\n    map.put(\"MANAGER\", new AccessControl(\"MANAGER\", \"GENERATE/READ_REPORTS\"));\n  }\n\n  public static AccessControl getAccessControlObject(String controlLevel) {\n    AccessControl ac = null;\n    ac = map.get(controlLevel);\n    if (ac != null) {\n      return ac.clone();\n    }\n    return null;\n  }\n}\n```\n\n그리고 필요에 따라 객체를 복사하여 사용한다.\n\n\u003ctip\u003e\n  왜 ac가 아닌 ac.clone 을 return 하냐면, 그냥 ac를 return할 경우, 모든 객체가 하나의 ac를 포인팅하게 된다.\n  즉, shallow copy가 일어나게 된다.\n  \u003cbr /\u003e\n  참고롤 객체를 clone 하더라도, 객체의 멤버 변수로 객체를 갖고있다면, 해당 멤버 객체까지 clone되지는 않는다는 점 주의하자.\n  (A가 멤버 객체 B를 갖고있을 경우, A' = A.clone()을 한다면, A'는 B'를 포인팅하는 것이 아닌, B를 포인팅하게 된다는 것.)\n\u003c/tip\u003e","slug":"univ_design-pattern/final_09","readingMinutes":3,"wordCount":283},{"title":"Mediator Pattern","description":"Mediator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Mediator Pattern"],"draft":false,"date":"2023-12-07 / 18:57","content":"\n## 필요성\n\n여러 군데에 있는 컴포넌트가 서로 의존성을 갖고있다면, 유지보수하기 어려울 것이다.\n그렇다고 해서 도저히 그 의존성을 줄일 방법이 존재하지 않는다면?\n\nMediator pattern은 모든 컴포넌트가 mediator와 1:1 관계를 갖도록 만들어서 모든 클래스가 종속성있게 복잡하게 구현해야 할 것을 mediator만 의존성을 갖도록 하여 mediator만 복잡하게 구현하도록 하는 방식이다.\n(facade pattern과 유사)\n\n## Mediator Pattern\n\n```java:MachineMediator.java\npublic interface MachineMediator {\n  public void start();\n  public void wash();\n  public void open();\n  public void closed();\n  public void on();\n  public void off();\n}\n```\n\n우선 여러 컴포넌트가 수행하는 역할의 집약체인 기계가 수행해야 할 기능들을 mediator 인터페이스로 묶어줍니다.\n\n```java:Colleague.java \npublic class Colleague {\n  public void setMediator(MachineMediator mediator);\n}\n```\n\n그리고, 여러 컴포넌트가 mediator와 종속성을 갖도록 하기 위해 colleague 인터페이스를 만들어줍니다.\n\n```java:Button.java\npublic class Button implements Colleague {\n  private MachineMediator mediator;\n\n  @override\n  public void setMediator(MachineMediator mediator) {\n    this.mediator = mediator;\n  }\n\n  public void press() {\n    mediator.start();\n  }\n}\n```\n\n```java:Machine.java\npublic class Machine implements Colleague {\n  private MachineMediator mediator; \n\n  @Override\n  public void setMediator(MachineMediator mediator) {\n    this.mediator = mediator;   \n  }\n\n  public void start() { \n    mediator.open();\n  }\n  public void wash() { \n    mediator.wash();\n  }\n}\n```\n\n그리고 각 컴포넌트에서 각각 기계가 수행해야 할 기능을 mediator 인터페이스와 연결해줍니다.\n\n```java:CottonMediator.java\npublic class CottonMediator implements MachineMediator {\n  private final Machine machine;\n  private final Heater heater;\n  ...\n  public CottonMediator(Machine machine, Heater heater, ...) {\n    this.machine = machine;\n    this.heater = heater;\n    ...\n  }\n\n  @override\n  public void start() {\n    machine.start();\n  }\n\n  @override\n  public void wach() {\n    motor.startMotor();\n    motor.rotateDrum(700);\n    soilRemoval.low();\n  }\n  // override other methods\n}\n```\n\n그리고 마지막으로 하나의 기계에 모든 컴포넌트를 의존성 주입시키면 된다.\n\n그렇다면 코드 실행 부분에서 모든 컴포넌트에 대해 `setMediator()`로 mediator를 등록시켜주고,\n위 예시의 경우에는 `button.press()` 만 실행시키면 관련된 모든 코드가 연쇄적으로 실행된다.\n\nCottonMediator 만 본다면 facade pattern과 똑같다.\nmediator pattern이 facade와 다른점은 컴포넌트가 setMediator 메서드를 제공하는 하나의 인터페이스로 묶여있다는 점이다.\n\nfacade는 facade에서만 컴포넌트를 호출할 수 있었다면,\nmediator는 mediator, 컴포넌트에서 서로를 호출할 수 있다.","slug":"univ_design-pattern/final_08","readingMinutes":3,"wordCount":300},{"title":"Chain of Responsibility","description":"Chain of Responsibility 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Chain of Responsibility Pattern"],"draft":false,"date":"2023-12-07 / 18:33","content":"\n## 필요성\n\n에러를 핸들링하는 로직을 구현해야 하는 경우, 연쇄적인 try-catch문을 쓰면 코드가 길어질 뿐더러 유지 보수도 어려워진다.\n에러 뿐만 아니라 특정 요청만을 처리해야 하는 핸들러를 달아줄 때, if-else를 사용하면 위와 동일한 문제가 생길 뿐더러, 런타임에서 처리 순서를 변경할 수도 없어진다.\n\n위의 모든 문제를 해결하는 방법이 Chain of Responsibility Pattern 이다.\n\n## Chain of Responsibility\n\n파일의 포멧과 상관없는 파일을 읽는 로직을 개발해보자.\n\n```java:File.java\npublic class File {\n  private final String fileName;\n  private final String fileType;\n  private final String filePath;\n\n  public File(String fileName, String fileType, String filePath) {\n    this.fileName = fileName;\n    this.fileType = fileType;\n    this.filePath = filePath;\n  }\n  // getter...\n}\n```\n\n우선 모든 파일을 하나의 인터페이스로 다루기 위해 File 상위 클래스를 만든다.\n\n```java:Handler.java\npublic interface Handler {\n  public void setHandler(Handler handler);\n  public void process(File file);\n  public String getHandlerName();\n}\n```\n\n그리고, 핸들링을 연쇄적으로 하기 위해 하나의 인터페이스로 묶어줘야 한다.\n따라서 핸들러 인터페이스를 만들어준다.\n\n```java:TextFileHandler.java {16-19}\npublic class TextFileHandler implements Handler {\n  private Handler handler;\n  private String handlerName;\n\n  public TextFileHandler(String handlerName) {\n    this.handlerName = handlerName;\n  }\n\n  @override\n  public void setHandler(Handler handler) {\n    this.handler = handler;\n  }\n\n  @override\n  public void process(File file) {\n    if (file.getFileName().equals(\"text\")) {\n      // process\n    } else if (handler != null) {\n      handler .process(file);\n    } else {\n      throw Exception(\"Not supported file format\");\n    }\n  }\n}\n```\n\n그리고 인터페이스 규격에 맞게 각 파일 포멧에 해당하는 핸들러를 구현한다.\n만약, 포멧이 맞다면, 이 핸들러에서 파일이 처리될 것이고,\n포멧이 맞지 않다면, setHandler로 등록된 다음 핸들러에게 파일의 처리를 인가할 것이다.\n\n```java:ReadFile.java {10-12}\npublic class ReadFile {\n  public static void main(String[] args) {\n    File file = new File(\"asd.mp4\", \"mp4\", \"~\");\n\n    Handler textHandler = new TextHandler(\"Text Handler\");\n    Handler excelHandler = new ExcelHandler(\"Excel Handler\");\n    Handler audioHandler = new AudioHandler(\"Audio Handler\");\n    Handler videoHandler = new VideoHandler(\"Video Handler\");\n\n    textHandler.setHandler(excelHandler);\n    excelHandler.setHandler(audioHandler);\n    audioHandler.setHandler(videoHandler);\n\n    textHandler.process(file);\n  }\n}\n```\n\n필요에 따라 런타임에 처리 순서를 바꿔줄 수도 있다.","slug":"univ_design-pattern/final_07","readingMinutes":3,"wordCount":294},{"title":"Builder Pattern","description":"Builder 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Builder Pattern"],"draft":false,"date":"2023-12-07 / 17:57","content":"\n## 필요성\n\n인스턴스를 생성함에 있어, 주입해야할 인자의 개수가 너무 많을 경우 그 순서를 외우는 것은 쉽지 않다.\n또한, 클래스가 has-a관계로 depth가 깊은 경우에도 이를 인스턴스로 초기화 하는과정은 매우 복잡할 것이다.\n\n예를 들어 회원정보를 받는 클래스를 만들어보자.\n\n```java:Form.java\npublic class Form {\n  private String firstName;\n  private String lastName;\n  private String userName;\n  private String email;\n  private String password;\n  private String address;\n  private Date dayOfBirth;\n  // etc...\n\n  public Form(String firstName, String lastName, ...) {\n    //...\n  }\n}\n```\n\n하지만, 위에처럼 인스턴스의 생성을 복잡하게 하지 않도록 하는 방법이 있다.\n인스턴스의 생성(초기화)를 유연하고, 보기 편하게 하기 위해 Builder Pattern을 사용한다.\n\n## Builder Pattern\n\n```diff-java:Form.java {18, 28-36, 40-42}\n  public class Form {\n    private String firstName;\n    private String lastName;\n    private String userName;\n    private String email;\n    private String password;\n    private String address;\n    private Date dayOfBirth;\n    // etc...\n\n+   private Form(FormBuilder builder) {\n-   public Form(String firstName, String lastName, ...) {\n      this.firstName = builder.firstName;\n      this.lastName = builder.lastName;\n      //...\n    }\n\n    public static class FormBuilder {\n      private String firstName;\n      private String lastName;\n      // etc...\n\n      public FormBuilder(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n      }\n\n      public FormBuilder userName(String userName) {\n        this.userName = userName;\n        return this;\n      }\n\n      public FormBuilder email(String email) {\n        this.email = email;\n        return this;\n      }\n\n      // etc...\n\n      public Form build() {\n        return new Form(this);\n      }\n    }\n  }\n```\n\nbuilder 클래스를 외부에도 만들 수 있지만, 여기선 이렇게도 할 수 있다는 것을 보여주기 위해 클래스 내부에 넣었다.\n\n특이한 점은 Form 클래스의 생성자가 private 라는 점이다.\n즉, 일반적인 방법으로 Form 클래스를 인스턴스화 할 수 없다.\n반드시 FormBuilder 클래스를 이용해서 인스턴스화 해야한다.\n\n```java:LoginForm.java\npublic class LoginForm {\n  public static void main(String[] args) {\n    FormBuilder builder = new Form.FormBuilder(\"Woong\", \"dev\");\n    builder = builder.email(\"wjlee611@gmail.com\").password(\"asdasd\").userName(\"dev.Woong\");\n    Form myForm = builder.build();\n  }\n}\n```\n\nFormBuilder의 생성자에 인자를 집어넣으면 필수로 기입해야 하는 항목을 지정할 수 있고,\nemail, password, userName과 같은 요소는 순서와 시점에 상관없이 입력을 받을 수 있다.\n또한, 인스턴스는 반드시 FormBuilder의 build 메서드를 이용해서만 만들 수 있다.\n\nBuilder pattern을 사용하면 마치 클래스의 Iterator를 만들듯이 Builder를 만들어서 생성과정을 은닉할 수 있다.","slug":"univ_design-pattern/final_06","readingMinutes":3,"wordCount":325},{"title":"Bridge Pattern","description":"Bridge 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Bridge Pattern"],"draft":false,"date":"2023-12-07 / 11:17","content":"\n## 필요성\n\n자동차를 만든다고 가정해보자.\n자동차에는 셀 수 없는 여러 부품들이 종합적으로 들어가서 만들어질텐데, 만약 그 부품이 모두 종속적으로 연결되어 있다면?\n부품 교체는 물론이고, 개발하는 것도 여러 사람이 분산해서 개발하지 못할 것이다.\n\n각 부분을 독립적으로 개발하고, 확장을 유연하게 하기 위해 Bridge pattern을 사용한다.\n\n## Bridge Pattern\n\n```java:Product.java\npublic interface Product {\n  public String productName();\n  public void produce();\n}\n```\n\n유연한 확장을 위해 인터페이스를 정의한다.\n자동차의 부품에 해당하는 부분이다.\n\n```java:CentralLocking.java\npublic class CentralLocking implements Product {\n  private final String productName;\n\n  public CentralLocking(String productName) {\n    this.productName = productName;\n  }\n  // override methods\n}\n```\n```java:GearLocking.java\npublic class GearLocking implements Product {\n  private final String productName;\n\n  public GearLocking(String productName) {\n    this.productName = productName;\n  }\n  // override methods\n}\n```\n\n그리고, 여러 사람이 인터페이스에 맞게 부품을 개발한다.\n\n```java:Car.java {2}\npublic abstract class Car {\n  private final Product product;\n  private final String carType;\n\n  public Car(Product product, String carType) {\n    this.product = product;\n    this.carType = carType;\n  }\n\n  public abstract void assemble();\n  public abstract void produceProduct();\n}\n```\n\n그리고 자동차의 뼈대를 만들어준다.\n\n이 때, product를 인터페이스로 만들었기에 유연한 확장과, Car과 독립적으로 product를 개발할 수 있게되는데, 이것이 Bridge pattern 이다.\n\n```java:Motoren.java {8}\npublic class Motoren extends Car {\n  public Motoren(Product product, Strint carType) {\n    super(product, carType);\n  }\n\n  @override\n  public void produceProduct() {\n    product .produce();\n    // ...\n  }\n}\n```\n\n그럼 자동차를 조립하는 입장에서는 produce의 내부 구조는 알 필요없이 인터페이스만을 가지고 독립적으로 개발할 수 있게 된다.","slug":"univ_design-pattern/final_05","readingMinutes":3,"wordCount":228},{"title":"Factory Pattern","description":"Factory 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Factory Pattern","Abstract Factory Pattern"],"draft":false,"date":"2023-11-19 / 21:52","content":"\n## 필요성\n\n이번엔 피자가게로 예시를 들어보자.\n피자 가게에서 피자의 주문을 처리하기 위해서는 아래와 같은 형식으로 코드를 작성해야 할 것이다.\n\n```java:PizzaStore.java\npublic class PizzaStore {\n  ...\n  Pizza orderPizza(String tpye) {\n    Pizza pizza;\n\n    if (type.equals(\"cheese\")) {\n      pizza = new CheesePizza();\n    } else if (type.equals(\"greek\")) {\n      pizza = new GreekPizza();\n    }\n\n    pizza.prepare();\n    pizza.bake();\n    pizza.cut();\n    pizza.box();\n    return pizza;\n  }\n}\n```\n\n느낌만 보면 피자의 종류가 추가되거나 변경될 경우 orderPizza 메서드의 수정이 이루어져야 한다.\n예시가 적절하지 않은 느낌이 없지않아 있지만, orderPizza의 직접적인 수정이 부담스러울 수 있다.\n그 이유는 객체의 생성과 반복되는 메서드 호출 부분이 같은 함수 내에 위치하고 있기 때문이다.\n\n따라서 피자의 생성부(constructor)를 별도의 factory로 관리하는 기법에 대해 알아보자.\n\n## Factory Pattern\n\n이제 객체의 생성부를 factory로 캡슐화를 해보자.\n\n```java:PizzaFactory.java\npublic class PizzaFactory {\n  public Pizza createPizza(String type) {\n    Pizza pizza;\n\n    if (type.equals(\"cheese\")) {\n      pizza = new CheesePizza();\n    } else if (type.equals(\"greek\")) {\n      pizza = new GreekPizza();\n    }\n\n    return pizza;\n  }\n}\n```\n\n이제 이를 위의 피자가게에 적용한다면 코드는 다음과 같이 수정된다.\n\n```diff-java:PizzaStore.java\n  public class PizzaStore {\n+   PizzaFactory factory;\n\n    public PizzaStore(Pizzafactory factory) {\n+     this.factory = factory;\n    }\n\n    public Pizza orderPizza(String type) {\n      Pizza pizza;\n\n+     pizza = factory.createPizza(type);\n-     if (type.equals(\"cheese\")) {\n-       pizza = new CheesePizza();\n-     } else if (type.equals(\"greek\")) {\n-       pizza = new GreekPizza();\n-     }\n\n      pizza.prepare();\n      pizza.bake();\n      pizza.cut();\n      pizza.box();\n      return pizza;\n    }\n  }\n```\n\n이제 코드가 객체의 생성부와 반복되는 메서드의 호출 부분이 분리가 되었다.\n따라서 피자의 종류를 추가하거나 변경할 때에는 PizzaStore의 코드를 수정해야할 필요가 없어졌다.\n\n이렇게 하면 또 장점이 PizzaFactory를 교체하는 것 만으로도 생성할 수 있는 객체의 종류를 런타임에 다르게 결정할 수도 있다.\n\nfactory 패턴을 이렇게 외부 클래스로 구현할 수도 있지만, 내부의 메서드 형식으로도 구현할 수 있다.\n아래 코드를 살펴보자.\n\n```java:PizzaStore.java {11}\npublic abstract class PizzaStore {\n  public Pizza orderPizza(String type) {\n    Pizza pizza;\n\n    pizza = createPizza(type);\n\n    ...\n    return pizza;\n  }\n\n  abstract Pizza createPizza(String type);\n}\n```\n\n위에서는 PizzaFactory를 교체하는 방식으로 생성하는 객체를 다르게 할 수 있었다.\n이제는 이 abstract class를 구현하는 방식으로 생성하는 객체를 다르게 할 수 있다.\n\n```java:NYPizzaStore.java\npublic class NYPizzaStore extends PizzaStore {\n  Pizza createPizza(String type) {\n    if (type.equals(\"cheese\")) {\n      return new NYStyleCheesePizza();\n    } else if (type.equals(\"greek\")) {\n      new NYStyleGreekPizza();\n    }\n    return null;\n  }\n}\n```\n\n참고로 모든 blahPizza는 Pizza 클래스를 상속받는 식으로 구현해야 하고, Pizza 클래스는 abstract로 만들어서 인스턴스로 만들 수 없게 해야한다.\n\n![231125-111929](/posts/final_04/231125-111929.png)\n\n정리하자면, Factory pattern은 객체를 생성하는 인터페이스(createPizza)를 정의할 때\n어떤 클래스(blahPizza)를 만들어야 하는지는 상위 클래스(PizzaStore)가 결정하는 것이 아닌,\n하위 클래스(NYPizzaStore)에게 일임하는 방식의 디자인 패턴을 의미한다.\n\n\u003ctip\u003e\n  참고로 위의 코드는 종속 역전 원칙을 준수한 코드인데, 이게 뭐냐하면\n  가능하면 추상 클래스에 대해 종속성을 갖고, 구현 클래스에 대해서는 종속성을 피해야 한다는 디자인 원칙이다.\n  \u003cbr /\u003e\n  즉, PizzaStore에서는 객체를 CheesePizza, GreekPizza 로 관리하는 것이 아닌, 오직 Pizza 인터페이스로만 관리하는 것이 좋다.\n\u003c/tip\u003e\n\n---\n\n## Abstract Factory Pattern\n\n그렇다면 NYPizza와 ChicagoPizza 모두 같은 종류의 피자를 판매한다면?\n사실살 들어가는 재료가 다를 뿐, 모두 CheesePizza, PepperoniPizza 등 같은 종류의 파지를 판매할 뿐인데,\n각각 다른 종류의 피자 클래스로 구현해야 한다는 문제점이 생길 것이다.\n\n생각해보면, 각 피자는 제조 방식은 같지만, 들어가는 재료가 다를 뿐이다.\n따라서 재료의 생성도 factory pattern으로 만든다면?\n\n```java:PizzaIngredientFactory.java\npublic interface PizzaIngredientFactory {\n  public Dough createDough();\n  public Sauce createSauce();\n  public Cheese createCheese();\n  public Veggies[] createVeggies();\n  public Pepperoni createPepperoni();\n  public Clame createClame();\n}\n```\n\n우선 각 지역의 피자에 들어갈 재료를 factory pattern으로 만들기에 앞서,\n하나의 인터페이스로 묶어주기 위해 인터페이스 클래스를 만들어준다.\n\n```java:NYPizzaIngredientFactory.java\npublic class NYPizzaIngredientFactory implements PizzaIngredientFactory {\n  public Dough createDough() {\n    return new ThinCrustDough();\n  }\n\n  public Sauce createSauce() {\n    return new MarinaraSauce();\n  }\n  ...\n}\n```\n\n이후에 각 지역에 맞는 재료 클래스를 반환하는 클래스를 구현해준다.\n따라서 각 지역에 피자 매장에 그 지역에 맞는 재료 factory를 종속시켜 준다면,\n같은 종류의 피자를 만든다고 할지라도, 재료가 다르게 들어가기 떄문에 지역 특색에 맞는 피자가 만들어 질 것이다.\n\n```java:Pizza.java\npublic abstract class Pizza { \n    String name;\n    Dough dough;\n    Sauce sauce;\n    Veggies veggies[]; \n    Cheese cheese; \n    Pepperoni pepperoni; \n    Clams clam;\n\n    abstract void prepare(); \n\n    void bake() {\n        System.out.println(“Bake for 25 minutes at 350”); \n    }\n    ...\n}\n```\n\n```java:CheesePizza.java\npublic class CheesePizza extends Pizza { \n    PizzaIngredientFactory ingredientFactory;\n\n    public CheesePizza(PizzaIngredientFactory ingredientFactory) { \n        this.ingredientFactory = ingredientFactory;\n    }\n\n    void prepare() {\n        System.out.println(“Preparing “ + name); \n        dough = ingredientFactory.createDough(); \n        sauce = ingredientFactory.createSauce(); \n        cheese = ingredientFactory.createCheese(); \n    }\n}\n```\n\n그렇기에 피자를 만들 때는 각 재료를 factory로 부터 가져오도록 구현해야 한다.\n\n```java:NYPizzaStore.java\npublic class NYPizzaStore extends PizzaStore { \n    ...\n    protected Pizza createPizza(String item) {\n        Pizza pizza = null;\n\n        PizzaIngredientFactory ingredientFactory = \n            new NYPizzaIngredientFactory();\n\n        if (item.equals(“cheese”)) {\n            pizza = new CheesePizza(ingredientFactory); \n            pizza.setName(“New York Style Cheese Pizza”);\n        } else if (item.equals(“veggie”)) {\n            pizza = new VeggiePizza(ingredientFactory); \n            pizza.setName(“New York Style Veggie Pizza”);\n        } else if (item.equals(“clam”)) {\n            pizza = new ClamPizza(ingredientFactory); \n            pizza.setName(“New York Style Clam Pizza”);\n        } else if (item.equals(“pepperoni”)) {\n            pizza = new PepperoniPizza(ingredientFactory); \n            pizza.setName(“New York Style Pepperoni Pizza”);\n        } \n\n        return pizza; \n    }\n}\n```\n\n마지막으로 각 지역에 피자 매장에 그 지역에 맞는 재료 factory를 종속시켜 주면,\n같은 종류의 피자를 만든다고 할지라도, 재료가 다르게 들어가기 떄문에 지역 특색에 맞는 피자가 만들어 질 것이다.\n\n![231125-111610](/posts/final_04/231125-111610.png)\n\n이렇게 구현 클래스(PizzaFactory)를 반환하는 것이 아닌, 클래스 생성 후 인터페이스(NYPizzaIngredientFactory)를 반환하는 디자인 패턴을 Abstract Factory Pattern 라고 한다.\n간단하게 말하면 factory(NYPizzaStore)의 factory(NYPizzaIngredientFactory) 인 것이다.","slug":"univ_design-pattern/final_04","readingMinutes":8,"wordCount":813},{"title":"Proxy Pattern","description":"Proxy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Proxy Pattern","Proxy","Remote Proxy"],"draft":false,"date":"2023-11-06 / 15:26","content":"\n\u003ctip\u003e\n  `Proxy`\n  다른 기능, 서버를 사용하기 전에 본인선에서 처리해버릴 때, 그 본인을 proxy 라고 한다.\n  즉, 중계기로서 대리로 처리하는 것을 의미한다.\n\u003c/tip\u003e\n\n## Remote Proxy Pattern\n\n![231106-155200](/posts/final_02/231106-155200.png)\n\n프로그램이 서로 다른 머신 혹은 프로세스에서 동작 중일 때, 한 프로그램에서 다른 프로그램의 메서드를 직접 사용하기 위해 서로 상대 프로그램의 proxy를 두어 통신한다.\n이렇게 구성하면 각 프로그램은 다른 프로그램의 메서드를 직접 호출한다고 착각하게 되는데, 실제로 통신은 프록시 사이에서 일어나게 되는 것이다.\n\n### 필요성\n\n저번에 만들었던 GumballMachine의 상태를 원격으로 확인하는 서비스를 만들어보자.\napi 통신하는 방법으로도 구현할 수 있겠지만, 이번엔 Java에서 지원하는 Remote 기능을 이용해서 구현해보자.\n\n\u003ctip\u003e\n  `Java RMI`\n  Java Remote Method Invocation은 분산되어 존재하는 객체 간의 메세지 전송을 가능케 하는 프로토콜로, CORBA의 Java 버전이라고 봐도 무방하다.\n  \u003cbr /\u003e\n  CORBA는 여러 언어로 구현된 분산 객체간 통신을 가능케 하기 위한 표준으로 이 기술도 함께 알아보면 좋을 듯 하다.\n\u003c/tip\u003e\n\n### Remote\n\nRemote는 Java에서 제공하는 인터페이스로 내부에 어떠한 메서드도 없다.\n즉, Marker interface로서 JVM에게 이 클래스는 RMI 기능을 내포하고 있음을 알려주는 역할로 사용하게 된다.\n\n```java:GumballMachineRemote.java\npublic interface GumballMachineRemote extends Remote {\n  public int getConut() throws RemoteException;\n  public String getLocation() throws RemoteException;\n  public State getState() throws RemoteException;\n}\n```\n\n여기서 눈여겨 봐야 할 점은 Remote 메서드들이 모두 RemoteException 에러를 던질 수 있도록 해야한다는 점이다.\n그 이유는, 네트워크가 끊기는 경우 프로그램이 정상동작 하지 않을 수 있기 때문이다.\n\n### Examples\n\n그에 따라 상태 클래스도 약간의 변경이 필요하다.\n\n```diff-java:State.java\n- public interface State {\n+ public interface State extends Serializable {\n    public void insertQuarter();\n    public void ejectQuarter();\n    public void turnCrank();\n    public void dispense();\n}\n```\n\nSerializable 하는 이유는, 네트워크 통신을 할 때 객체를 직렬화해서 전송해야 하기 때문이다.\n\n```diff-java:GumballMachine.java\n\n- public class GumballMachine {\n+ public class GumballMachine extends UnicastRemoteObject implements GumballMachineRemote {\n    ...\n\n-   public GumballMachine(int gums) {\n+   public GumballMachine(int gums, String location) throws RemoteException\n      ...\n    }\n\n    public int getConut() {\n      return count;\n    }\n    public String getLocation() {\n      return location;\n    }\n    public State getState() {\n      return state;\n    }\n\n    ...\n  }\n```\n\n여기까지 코드를 수정하고 나면, 이제 원격에서 머신을 실행시키며 RMI 레지스트리에 등록을 해줘야 한다.\n따라서 우선 RMI 레지스트리를 활성화 시켜준다.\n\n```bash:shall\n$ rmiregistry\n```\n\n그다음 원격 머신을 실행시켜준다.\n\n```java:RemoteMain.java\npublic class RemoteMain {\n  public static void main(String args[]) {\n    GumballMachineRemote gumballMachine = new GumballMachine(10, \"my-location\");\n    Naming.rebind(\"//my-location/gumballMachine\", gumballMachine);\n  }\n}\n```\n\n여기서 rebind 메서드를 통해 레지스트리에 stub을 등록시켜 주는 것이다.\n하지만, stub을 생성 시켜주기위해 아래의 rmic (RMI Compliler) 명령어를 실행하여 만들고 난 뒤 해당 코드를 실행해야 한다.\n\n```bash:shall\n$ rmic RemoteMain\n$ java RemoteMain\n```\n\n이렇게 하면 원격 저장소에 GumballMachineRemote의 stub가 레지스트리에 등록이 되었다!\n이제 클라이언트(모니터)에서 데이터를 받아보자.\n\n```java:GumballMonitor.java\npublic class GumballMonitor {\n  GumballMachineRemote machine;\n\n  public GumballMonitor(GumballMachineRemote machine) {\n    this.machine = machine;\n  }\n\n  public void report() {\n    machine.getLocation();\n    machine.getConut();\n    machine.getState();\n    ...\n  }\n}\n```\n\n```java:MonitorMain.java\npublic class MonitorMain {\n  public static void main(String args[]) {\n    GumballMachineRemote machine = Naming.lookup(\"rmi://my-location/gumballMachine\");\n    GumballMonitor monitor = new GumballMonitor(machine);\n    monitor.report();\n  }\n}\n```\n\n여기서 lookup 메서드를 통해 원격 레지스트리에 등록된 stub을 다운로드 받아 사용하는 것이다.\n\n위 과정을 그림으로 표현하면 다음과 같으니 참고하자.\n\n![231119-214628](/posts/final_03/231119-214628.png)","slug":"univ_design-pattern/final_03","readingMinutes":5,"wordCount":478},{"title":"State Pattern","description":"State 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["State Pattern"],"draft":false,"date":"2023-11-06 / 14:46","content":"\n## 필요성\n\n우리가 Gumball machine을 개발한다고 가정해보자.\nGumball machine은 다음과 같은 동작을 수행해야 할 것이다.\n\n![231106-144938](/posts/final_02/231106-144938.png)\n\n개발 경험이 많이 없다면, 해당 동작을 함수 기반으로 작성할 것이다.\n\n```java:GumballMachine.java {9, 12-14}\npublic class GumballMachine {\n  final static int SOLD_OUT = 0;\n  final static int NO_QUARTER = 1;\n  final static int HAS_QUARTER = 2;\n  final static int SOLD = 3;\n\n  private int state = SOLD_OUT;\n\n  public void insertQuarter() {\n    if (state == SOLD_OUT) {\n      // 껌이 비었기에 동전을 넣게 못하도록 처리\n    } else if (state == NO_QUARTER) {\n      // 동전을 받았기에 state를 변경\n      state = HAS_QUARTER;\n    } else if\n    ...\n  }\n}\n```\n\n이런식으로 작성한다면 미래의 발견할 문제점이 많다는 것은 둘째치고, 그냥 뭔가 딱 보기에도 불-편하지 않은가?\n실제로 다음과 같은 문제점도 발생할 가능성이 높다.\n\n- 상태가 많을수록 조건문이 많아짐\n- 상태 상수를 변경하거나, 추가, 삭제시 모든 함수에 대한 수정이 필요함\n\n한 마디로, `유지보수`하기에 너무나도 좋지 못한 방법이다.\n\n## State Pattern\n\n앞의 방식은 상태의 변화, **Transition을 중심**으로 한 코드 작성 방식이었다.\n\n하지만, 상태별로 취해야 할 행동을 다르게 정의하고, 그렇게 정의된 상태를 갖도록 하는 디자인 패턴을 `State Pattern` 라고 하는데,\n말로 하면 이해가 어려우니 이번엔 상태, **State를 중심**으로한 코드 작성 방식을 살펴보자.\n\n```java:State.java\npublic interface State {\n  public void insertQuarter();\n  public void ejectQuarter();\n  public void turnCrank();\n  public void dispense();\n}\n```\n\n우선 각 상태에서 수행해야 할 함수를 모아 State 인터페이스를 만들어주고, 각 상태는 State 인터페이스를 구현하는 방식으로 구현한다.\n\n```java:NoQuarterState.java {8-11}\npublic class NoQuarterState implements State {\n  GumballMachine machine;\n\n  public NoQuarterState(GumballMachine machine) {\n    this.machine = machine;\n  }\n\n  public void insertQuarter() {\n    // 동전을 받았기에 state를 변경\n    machine.setState(machine.getHasQuarterState());\n  }\n  ...\n}\n```\n\n이런식으로 상태에 따라 수행 가능한 기능을 구현하는 것이다.\n\n```diff-java:GumballMachine.java\n  public class GumballMachine {\n-   final static int SOLD_OUT = 0;\n-   final static int NO_QUARTER = 1;\n-   final static int HAS_QUARTER = 2;\n-   final static int SOLD = 3;\n    // getter 구현\n+   State soldOutState;\n+   State noQuarterState;\n+   State hasQuarterState;\n+   State soldState;\n\n-   private int state = SOLD_OUT;\n+   private State state = soldOutState;\n    int count = 0;\n\n    public GumballMachine(int gums) {\n      this.count = gums;\n      soldOutState = new SoldOutState(this);\n      noQuarterState = new NoQuarterState(this);\n      ...\n      if (gums \u003e 0) {\n        state = noQuarterState;\n      }\n    }\n\n    public void setState(State state) {\n      this.state = state;\n    }\n\n    public void insertQuarter() {\n-     if (state == SOLD_OUT) {\n-       // 껌이 비었기에 동전을 넣게 못하도록 처리\n-     } else if (state == NO_QUARTER) {\n-       // 동전을 받았기에 state를 변경\n-       state = HAS_QUARTER;\n-     } else if\n-     ...\n+     state.insertQuarter();\n    }\n  }\n```\n\n이제 GumballMachine은 상태를 상수로 관리하는 것이 아닌, 클래스로 관리하게 되고, 현재 상태에 따라 호출되는 함수의 기능이 달라지게 된다.\n\n이렇게 구현하면 유지보수도 간편해지는게, 상태를 변경한다고 하면, 해당 상태의 클래스만 수정하면 되고,\n상태를 추가한다고 하면 상태 클래스를 추가하고 GumballMachine의 상단에 상태를 보관할 수 있게만 추가하면 된다.","slug":"univ_design-pattern/final_02","readingMinutes":5,"wordCount":454},{"title":"Composite Pattern","description":"Composite 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Composite Pattern"],"draft":false,"date":"2023-11-06 / 12:26","content":"\n## 필요성\n\n트리구조와 같은 데이터에 순차 접근해야 하는 상황을 가정해보자.\nIterator pattern으로 구현된 자료구조에 접근할 때의 문제점은, Iterator로 반환되는 객체의 타입이 동일해야 한다는 것이다.\n무슨 말이냐면, i번째 접근하는 자료형과 k번째 접근하는 자료형(인터페이스)이 동일해야 한다는 것이다.\n\n이 때 만약, leaf node와 inner node가 다른 방식으로 동작한다고 해서 다른 자료형으로 구현한다면?\n노드 타입을 검사하고, 타입에 맞는 순차탐색 과정을 거치는 등 순차탐색하는 과정이 매우 복잡해질 것이다.\n\n## Composite Pattern\n\n이런 순차탐색에서의 불편함을 없애고자, leaf, inner node **모두 동일한 `component class`를 구현**하는 방식을 Composite Pattern 이라고 한다.\n예시 코드를 살펴보자.\n\n```java:MenuComponent.java\npublic abstract class MenuComponent {\n  // For inner node\n  public void add(MenuComponent c) {\n    throw new UnsupportedOperationException();\n  }\n  public void remove(MenuComponent c) {\n    throw new UnsupportedOperationException();\n  }\n  public MenuComponent getChild(int i) {\n    throw new UnsupportedOperationException();\n  }\n  // For all node\n  public void print() {\n    throw new UnsupportedOperationException();\n  }\n  public String getName() {\n    throw new UnsupportedOperationException();\n  }\n  ...\n}\n```\n\n이제 leaf, inner node에서 위 클래스를 extends 하여 구현하면 모두 동일한 인터페이스(메서드)를 갖게되어 Iterator를 이용한 순차탐색이 가능해진다.\n(Iterator\\\u003cMenuComponent\\\u003e 이런 느낌)\n\n```java:MenuItem.java\n// leaf node\npublic class MenuItem extends MenuComponent {\n  String name;\n  ...\n  public MenuItem(String name, ...) {\n    this.name = name;\n    ...\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void print() {\n    System.out.println(getName());\n  }\n  ...\n}\n```\n\n이런식으로 필요한 메서드만 override 해서 사용하면 된다.\n만약, override하지 않은 메서드를 호출한다면 UnsupportedOperationException이 발생하는 것이다.\n\n```java:Menu.java\npublic class Menu extends MenuComponent {\n  ArrayList menuComponents = new ArrayList();\n  String name;\n  ...\n  public Menu(String name, ...) {\n    this.name = name;\n    ...\n  }\n\n  public void add(MenuComponent c) {\n    menuComponents.add(c);\n  }\n  public void remove(MenuComponent c) {\n    menuComponents.remove(c);\n  }\n  public void getChild(int i) {\n    return (MenuComponent)menuComponents.get(i);\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void print() {\n    System.out.println(getName());\n    System.out.println(\"===========\");\n\n    Iterator iter = menuComponents.iterator();\n    while(iter.hasNext()) {\n      MenuComponent menuComp = (MenuComponent)iter.next();\n      menuComp.print();\n    }\n  }\n  ...\n}\n```\n\n이런식으로 MenuItem(leaf), Menu(inner) 모두 동일한 print 라는 메서드를 호출할 수 있지만,\n구현을 다르게 했기 때문에 동작이 달라진다.\n\n이제 메뉴를 출력하든, 메뉴의 각 음식을 출력하든, 나아가 모든 메뉴를 출력(`클라이언트`가 하는 일)하든 상관없이\nMenuComponent 클래스를 상속하여 만든 객체는 print를 호출하여 출력할 수 있다.\n\n### vs. Decorator\n\nMenu 클래스를 보면 뭔가 느낌이 Decorator Pattern을 보는 것과 비슷한 느낌을 받을 수 있다.\n자식 클래스에서 부모 클래스를 멤버 변수로 가지며, override 한다는 점에서 비슷하다.\n\n하지만, 사용 목적에 차이점이 있음을 알고가면 좋을 거 같다.\n\n`Decorator Pattern`은 leaf node에 해당하는 부분의 **변화를 가하지 않고 추가 기능 구현**을 위해 override 한다는 데 목적이 있다면,\n\n`Composite Pattern`은 계층 구조의 모든 노드가 **같은 인터페이스로 클라이언트에서 접근**할 수 있도록 하는데에 목적이 있다.","slug":"univ_design-pattern/final_01","readingMinutes":5,"wordCount":408},{"title":"Iterator Pattern","description":"Iterator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Iterator Pattern"],"draft":false,"date":"2023-10-21 / 20:22","content":"\n## 필요성\n\n사람마다 개발 스타일이 다르다.\n하물며 List, ArrayList 등, 어떤 자료구조가 익숙하냐에 따라 사용하는 데이터 타입 역시 다르다.\n\n만약 분업을 하는데 있어 사람 A는 List, B는 ArrayList를 사용했다고 해보자.\n이렇게 자료구조가 다를 경우, 순차탐색에 있어 코드의 구현이 달라진다.\n\n```java:.java\n// List\nfor (int i=0; i\u003cmyList.length; i++) {\n  myList[i];\n}\n\n// ArrayList\nfor (int i=0; i\u003cmyArrayList.size(); i++) {\n  myArrayList.get(i);\n}\n```\n\n만약 위의 순차탐색에서 동작하는 기능이 동알하다면?\n자료구조가 다르다는 이유로 같은 기능을 수행하는 동작을 중복해서 작성해야 하는 이슈가 생긴다.\n\n더 심각한건, list를 arrayList와 같이 자료구조를 바꾸기라도 하는 날에는 클라이언트가 코드를 수정해야 한다는 치명적인 문제도 있다.\n\n## Iterator Pattern\n\nData Collection을 순차적 접근이 필요할 때 그 방식을 Iterator와 같이 제공하는 디자인 패턴을 Iterator Pattern이라고 한다.\n위의 코드를 이 디자인 패턴을 적용해 개선해보자.\n\n```java:MyListIterator.java {5, 11}\npublic class MyListIterator implements Iterator {\n  Object[] data;\n  int position = 0;\n\n  public MyListIterator(Object[] data) {\n    this.data = data;\n  }\n\n  public Object next() {\n    Object obj = data[position];\n    position += 1;\n    return obj;\n  }\n\n  public boolean hasNext() {\n    if (position \u003e= data.length || data[position] == null) {\n      return false;\n    }\n    return true;\n  }\n}\n```\n\n```java:MyList.java {5, 11}\npublic class MyList {\n  ...\n\n  public Iterator createIterator() {\n    return new MyListIterator(data);\n  }\n}\n```\n\n이런식으로 나만의 클래스나 Iterator를 제공하지 않는 클래스의 경우 Iterator를 생성하기 위한 클래스를 생성하여 이를 createIterator 에서 반환해주면,\n순차 탐색은 createIterator에서 반환된 Iterator를 이용해서 하면 인터페이스를 통일할 수 있다.\n\n\u003ctip\u003e\n  MyArrayListIterator는 왜 안 만드는지?\n  \u003cbr /\u003e\n  기본적으로 Java에서 `Collection`을 implement 하는 자료구조는 Iterator를 제공하기 때문.\n  따라서 얘는 Iterator 클래스를 별도로 구현하지 않아도, 바로 createIterator 메서드 내부에서 `myArrayList.iterator()` 와 같은 방식으로 Iterator를 생성할 수 있음.\n  \u003cbr /\u003e\n  예로 들어 Hashtable 자료구조는 values() 라는 메서드를 제공하는데, 해당 메서드는 Collection 객체(아마 ArrayList)를 반환한다.\n  즉, Hashtable 자료구조는 myHashtable.values().iterator() 형식으로 Iterator를 얻을 수 있음.\n\u003c/tip\u003e\n\n```java:.java\n// List, ArrayList\nwhile (myIterator.hasNext()) {\n  Object obj = myIterator.next();\n}\n```\n\n한 단계 더 나아가 MyList, MyArrayList를 인터페이스로 묶어 createIterator를 강제할 수 있다.\n공통 메서드로 createIterator를 만들어 순차 탐색시에는 Iterator를 사용하도록 유도하는 것이다.\n\n### Single Responsibility\n\n그런데 MyListIterator 클래스를 따로 만들지 않고, 그냥 MyList에서 Iterator를 바로 implements 해서 구현하면 안되는 걸까?\n\n그래도 상관없긴 하다.\n하지만, 하나의 클래스는 하나의 역할만 수행한다는 디자인 원칙을 준수하는 것이 코드를 깔끔하게 관리할 수 있도록 도와줄 것이다.\n\n하나의 클래스가 데이터도 관리하고, Iterator도 관리하면... 기능이 너무 복잡해지기 때문이다.","slug":"univ_design-pattern/mid_09","readingMinutes":5,"wordCount":370},{"title":"Template Method Pattern","description":"Template Method 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Template Method Pattern"],"draft":false,"date":"2023-10-21 / 18:52","content":"\n## 필요성\n\n아래와 같은 음료 제조법이 있다고 가정해보자.\n\n\u003e Coffee Recipe\n\u003e 1. **Boil some water**\n\u003e 2. Brew coffee in Boiling water\n\u003e 3. **Pour beverage in cup**\n\u003e 4. Add sugar and milk\n\u003e\n\u003e Tea Recipe\n\u003e 1. **Boil some water**\n\u003e 2. Steep tea in Boiling water\n\u003e 3. **Pour beverage in cup**\n\u003e 4. Add lemon\n\n1, 3번 과정은 동일하다.\n하지만 음료가 다르다고 같은 제조 과정을 중복해서 적으면 시간도 낭비되고, 수정할 때도 둘 다 수정해야 하는 불편함이 있다.\n\n따라서 **동일한 부분은 함수**로 빼버리고, **다른 부분만 abstract**로 처리하는 기법을 사용하면 이런 불편함을 줄일 수 있을 것이다.\n\n## Template Method Pattern\n\n알고리즘의 뼈대를 정의하고, 서로 다른 부분은 subclass에 미루어 처리하는 디자인 패턴을 Template Method Pattern 이라고 한다.\n\n위의 상황을 코드로 구현하며 알아보자.\n\n```java:Beverage.java {9-10}\npublic class Beverage {\n  final void prepareRecipe() {\n    boilWater();\n    brew();\n    pourInCup();\n    addCondiments();\n  }\n\n  abstract void brew();\n  abstract void addCondiments();\n\n  void boilWater() {\n    // boil water\n  }\n\n  void pourInCup() {\n    // pouring in cup\n  }\n}\n```\n\n```java:Cafe.java\npublic class Coffee extends Beverage {\n  public void brew() {\n    // Brew coffee in Boiling water\n  }\n\n  public void addCondiments() {\n    // Add sugar and milk\n  }\n}\n\npublic class Tea extends Beverage {\n  public void brew() {\n    // Steep tea in Boiling water\n  }\n\n  public void addCondiments() {\n    // Add lemon\n  }\n}\n```\n\n이런식으로 하면 두 음료 모두 boilWater, pourInCup 과정은 동일한 코드를 사용할 수 있고,\n음료에 따라 다른 brew, addCondiments 과정을 갖게 된다.\n\n또한, 두 음료 모두 Beverage 클래스로 다형성을 유지할 수 있고, 음료 제작 과정은 둘 다 prepareRecipe를 호출하여 실행할 수 있다.\n\n\u003ctip\u003e\n  이 방식은 **Hollywood 디자인 원칙** 역시 준수하는데, 이게 뭐냐하면,\n  **상위 컴포넌트(클래스)만 호출**하고, **하위 컴포넌트는 호출하지 않고 등록**만 하는 원칙이다.\n  \u003cbr /\u003e\n  위의 예시에선 Coffee, tea에서 기능을 수행하지 않고, brew, addCondiments만 등록을 했다.\n  실제 호출은 Beverage에서 prepareRecipe에서만 수행했다.\n\u003c/tip\u003e\n\n## IRL\n\nsort에서도 이와 비슷한 기능이 있다.\n\n```java:MergeSort.java {5}\nprivate static void mergeSort(Object src[], Object dest[],\n                    int low, int high, int off) {\n  for (int i=low; i\u003chigh; i++) {\n    for (int j=i; j\u003elow \n         \u0026\u0026 ((Comparable)dest[j-i]).compareTo((Comparable)dest[j])\u003e0; j--) {\n      swap(dest, j, j-1);\n    }\n  }\n}\n```\n\nComparable의 compareTo 메서드에서 객체의 비교하는 방법을 정의하게 되는데, 객체간 비교를 하고싶을 때 Comparable 인터페이스의 compareTo 메서드를 구현하면,\n이에 따라 객체의 비교 방법이 달라져 mergeSort가 객체간 비교를 가능케 하는 것이다.","slug":"univ_design-pattern/mid_08","readingMinutes":4,"wordCount":373},{"title":"Facade Pattern","description":"Facade 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Facade Pattern"],"draft":false,"date":"2023-10-21 / 18:18","content":"\n## 필요성\n\n집에서 나만의 영화관을 만든다고 가정해보자.\n편-안하게 영화를 보고싶지만, 영화 보기 전 선행되어야 할 일들이 많다.\n\n```java:HomeTheater.java\npublic class HomeTheater {\n  public static void main(String[] args) {\n    ...\n    // 팝콘을 튀기고\n    popper.on(); \n    popper.pop();\n    // 조명을 낮추고\n    lights.dim(10); \n    // 스크린을 내리고\n    screen.down();\n    // 빔 프로젝터를 설정하고\n    projector.on();\n    projector.setInput(dvd);\n    projector.wideScreenMode();\n    // 앱프에 영화를 넣고\n    amp.on();\n    amp.setDvd(dvd);\n    amp.setSurroundSound();\n    amp.setVolume(5);\n    // 영화 실행...\n    dvd.on();\n    dvd.play(movie);\n  }\n}\n```\n\n이런 일련의 과정을 클라이언트에게 할당하면, 개발자 입장에선 피곤할 뿐만 아니라, 장치의 메서드에 변화가 생기면 클라이언트가 해당 부분을 수정해야 한다는 단점이 있다.\n\n## Facade Pattern\n\nFacade 디자인 패턴은 **단일화된 인터페이스로 서브 시스템을 다루는 패턴**으로, 위의 일련의 과정을 클라이언트에게 맡기는 것이 아닌, 하나의 인터페이스로 묶고, 그 인터페이스만 클라이언트에게 제공하는 것이다.\n\n```java:HomeTheaterFacade.java\npublic class HomeTheaterFacade {\n  Amplifire amp;\n  DvdPlayer dvd;\n  Projector projector;\n  ...\n\n  public HomeTheaterFacade (Amplifire amp, ...) {\n    this.amp = amp;\n    ...  \n  }\n\n  public void watchMovie(String movie) {\n    // 팝콘을 튀기고\n    popper.on(); \n    popper.pop();\n    // 조명을 낮추고\n    lights.dim(10); \n    // 스크린을 내리고\n    screen.down();\n    // 빔 프로젝터를 설정하고\n    projector.on();\n    projector.setInput(dvd);\n    projector.wideScreenMode();\n    // 앱프에 영화를 넣고\n    amp.on();\n    amp.setDvd(dvd);\n    amp.setSurroundSound();\n    amp.setVolume(5);\n    // 영화 실행...\n    dvd.on();\n    dvd.play(movie);\n  }\n}\n```\n\n```java:HomeTheater.java\npublic class HomeTheater {\n  public static void main(String[] args) {\n    ...\n\n    HomeTheaterFacade homeTheater = new HomeTheaterFacade(...);\n\n    homeTheater.watchMovie(\"movie\");\n  }\n}\n```\n\n일련의 모든 과정을 Facade에게 일임하여 클라이언트는 Facade를 이용해 나름 매크로 기능을 이용할 수 있다.\n\n\u003ctip\u003e\n  눈여겨 봐야 할 디자인 원칙: **직접적인 친구와만 대화하라**\n  \u003cbr /\u003e\n  객체의 메서드는 다음과 같은 경우에만 호출하는 것이 바람직하다.\n  1. 객체 자신의 멤버 메서드를 호출\n  2. 인자로서 넘어온 객체의 메서드를 호출\n  3. 메서드 내부에서 생성된 객체의 메서드를 호출\n  4. 객체의 멤버변수로 저장된 객체의 메서드 호출\n\n  예를 들어보자.\n  아래와 같은 경우는 부적절한 경우이다.\n\n  ```java:.java\n  public float getTemp() {\n    Thermometer thermometer = station.getThermometer();\n    return thermometer.getTemperature();\n  }\n  ```\n\n  thermometer가 getTemp() **메서드 내부에서 생성되지 않았**는데, 해당 객체의 getTemperature() 메서드를 호출했기 때문이다.\n  \u003cbr /\u003e\n  대신에 아래와 같이 하는 것이 바람직하다.\n\n  ```java:.java\n  public float getTemp() {\n    return station.getTemperature();\n  }\n  ```\n\n  \u003cbr /\u003e\n  정리하면, 객체의 메서드를 호출할 때에는 객체간의 인과관계가 명확한 상황에서만 호출하라는 뜻이다.\n\u003c/tip\u003e","slug":"univ_design-pattern/mid_07","readingMinutes":4,"wordCount":321},{"title":"Adapter Pattern","description":"Adapter 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Adapter Pattern"],"draft":false,"date":"2023-10-11 / 17:13","content":"\n## 필요성\n\n개발하다 보면, 이전에 개발했던 코드가 있는데, 새로 개발된 코드 사양에 맞게 변경시켜야 하는 상황이 많을 것이다.\n마음같아선 새로 짜고 싶지만, dependency가 높은 코드나 배포가 진행된 코드의 경우 수정하는데 부담이 클 수 밖에 없다.\n이런 경우에 오래된 코드를 새로운 코드 사양에 맞게 변형시켜줘야 할 필요성이 생기는데, 이 때 `Adapter Pattern`을 사용하게 된다.\n\n## Adapter Pattern\n\n예를 들어보기 위해 우리의 오랜 친구(?) Duck 시뮬레이터를 다시 불러와보자.\n\n```java:Duck.java\npublic interface Duck {\n  public void quack();\n  public void fly();\n}\n```\n\n이제 새로운 동물을 시뮬레이터에 추가해보자. 바로 Turkey!\n\n```java:Turkey.java\npublic interface Turkey {\n  public void gobble();\n  public void fly();\n}\n```\n\n인터페이스를 보면 알겠지만, 울음 소리가 다르다.\n따라서 기존에 많은 곳에서 사용되었던 quack() 메서드를 사용하는 곳에선 Turkey 인터페이스를 구현한 클래스의 인스턴스를 사용할 수가 없게된다.\n이 경우 **코드의 재사용성**을 높이기 위해 `Adapter`를 구현해서 사용하게 된다!\n\n```java:TurkeyAdapter.java {1 8-10}\npublic class TurkeyAdapter implements Duck {\n  Turkey turkey;\n\n  public TurkeyAdapter(Turkey turkey) {\n    this.turkey = turkey;\n  }\n\n  public void quack() {\n    turkey.gobble();\n  }\n\n  public void fly() {\n    turkey.fly();\n  }\n}\n```\n\n이렇게 TurkeyAdapter를 만들어주면 이 어댑터의 인스턴스는 Duck 취급을 받기에 quack() 메서드를 사용하는 부분에 이 인스턴스를 넣을 수 있다.\n즉, Turkey를 Duck 처럼 사용할 수 있다는 뜻이다!\n\n```java:DuckSimulator.java {6}\npublic class DuckSimulator {\n  public static void main(String[] args) {\n    MallardDuck duck = new MallardDuck(); // implement Duck\n    WildTurkey turkey = new WildTurkey(); // inplement Turkey\n\n    Duck turkeyAdapter = new TurkeyAdapter(turkey);\n\n    // 둘 다 가능.\n    duck.quack();\n    turkeyAdapter.quack(); // 내부적으로 turkey.gobble() 호출\n  }\n}\n```\n\n## IRL\n\n실제로 Adapter Pattern이 적용되는 사례를 살펴보자.\n\njava에서 일련의 객체를 나타낼 때 `Iterator`를 많이들 사용하는데, 예전에 Iterator가 없을 때는 `Enumerators`을 사용했다고 한다.\n버전업이 되고 Iterator를 사용하는게 권장됐는데, legacy system에서는 아직도 Enumerators를 사용했기에 이를 강제할 수는 없었다.\n따라서 이를 위해 EnumerationAdapter를 만들었다고 한다.\n\n```java:Enumerators.java\npublic interface Enumerators {\n  public boolean hasMoreElements();\n  public T nextElement();\n}\n```\n\n```java:Iterator.java\npublic interface Iterator {\n  public boolean hasNext();\n  public T next();\n  public void remove();\n}\n```\n\n```java:EnumerationAdapter.java\npublic class EnumerationAdapter implements Iterator {\n  Enumerators enumerators;\n\n  public EnumerationAdapter(Enumerators enumerators) {\n    this.enumerators = enumerators;\n  }\n\n  public boolean hasNext() {\n    return enumerators.hasMoreElements();\n  }\n\n  public T next() {\n    return enumerators.nextElement();\n  }\n\n  public void remove() {\n    throw new UnsupportedOperationException();\n  }\n}\n```\n\n","slug":"univ_design-pattern/mid_06","readingMinutes":4,"wordCount":352},{"title":"Command Pattern","description":"Command 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Command Pattern"],"draft":false,"date":"2023-10-10 / 14:45","content":"\n## 필요성\n\n개발하다보면, 특정 버튼을 누르면 이벤트가 발생하도록 처리하는 패턴을 구현해야 하는 경우가 생길 것이다.\n예로들어 만능 리모컨을 만든다고 가정해보자.\n\n버튼 1 - ON을 누르면 tv가 켜지고 OFF를 누르면 꺼지고,\n\n```java:TV.java\npublic class TV {\n  private boolean isOn;\n  private int channel;\n\n  public TV() {\n    this.isOn = false;\n    this.channel = 1;\n  }\n\n  public void on() {\n    this.isOn = true\n  }\n\n  public void off() {\n    this.isOn = false;\n  }\n\n  public void changeChannel(int channel) {\n    this.channel = channel;\n  }\n}\n```\n\n버튼 2는 전등, 3은 선풍기 등등...\n\n이런 경우에 보통의 경우 `if - else`로 처리하는 경우가 많을 것이다.\n\n```java:Example\nif (버튼 1 - ON) {\n  tv.on();\n} else if (버튼 2 - OFF) {\n  tv.off();\n}\n```\n\n하지만 이런 경우에는 새로운 기능을 추가하거나, 기존에 있는 기능을 수정하려면 그 유지보수가 매우 불편하다.\n\n따라서 이를 해결하기 위한 디자인 패턴을 소개한다.\n\n## Command Pattern\n\nCommand Pattern의 기본적인 아이디어는 모든 기능 요청들을 `하나의 명령어(Command)`로서 관리하여 은닉화 하는데에 있다.\n바로 코드를 보며 이해해보자.\n\n```java:Command.java\npublic interface Command {\n  public void execute();\n}\n```\n\n```java:TVOnCommand.java {1, 8-10}\npublic class TVOnCommand implements Command {\n  TV tv;\n\n  public TVOnCommand(TV tv) {\n    this.tv = tv;\n  }\n\n  public void execute() {\n    tv.on();\n  }\n}\n```\n\n모든 명령어는 무조건 `execute()`로 실행하고, 각 명령어의 실행 방법은 그 명령어가 어떤 장치를 조작하는지에 따라 다르게 구현한다.\n따라서 이렇게 구현한다면 TV를 켜든 끄든 전등을 제어하든 모든 명령은 `execute()`를 호출하면 되는 것이다.\n\n```java:RemoteController.java {2-3}\npublic class RemoteController {\n  Command[] onCommands;\n  Command[] offCommands;\n\n  public RemoteController() {\n    onCommands = new Command[7];\n    offCommands = new Command[7];\n\n    Command empty = new Command();\n    for (int i=0; i\u003conCommands.length; i++) {\n      onCommands[i] = empty;\n      offCommands[i] = empty;\n    }\n  }\n\n  public void setCommand(int slot, Command onCom, Command offCom) {\n    onCommands[slot] = onCom;\n    offCommands[slot] = offCom;\n  }\n\n  public void onBtnPushed(int slot) {\n    onCommands[slot].execute();\n  }\n\n  public void offBtnPushed(int slot) {\n    offCommands[slot].execute();\n  }\n}\n```\n\n그리고 만능 리모컨을 이렇게 구현한다면, 사용자 입장에서는 원하는 기능을 `Command interface`로 구현하고, 원하는 slot에 `setCommand()`를 이용해 넣어주기만 하면 된다.\n\n### 추가 기능\n\n명령어 인터페이스를 이용해 하나로 구현하면 다른 기능을 추가하고 싶을 때도 용이하다.\n예로 들어 undo 기능을 구현해보자.\n\n```diff-java:Command.java\n  public interface Command {\n    public void execute();\n+   public void undo();\n  }\n```\n\n그럼 각 명령어에서 수행할 undo 기능을 추가만 하면 된다.\n\n```diff-java:TVOnCommand.java\n  public class TVOnCommand implements Command {\n    TV tv;\n\n    public TVOnCommand(TV tv) {\n      this.tv = tv;\n    }\n\n    public void execute() {\n      tv.on();\n    }\n\n+   public void undo() {\n+     tv.off(); // on의 반대는 off\n+   }\n  }\n```\n\n그렇다면 컨드롤러의 구현은 이렇게만 수정되면 undo 기능을 쉽게 구현할 수 있게된다!\n\n```diff-java:RemoteController.java\n  public class RemoteController {\n    Command[] onCommands;\n    Command[] offCommands;\n+   Command undoCommand;\n\n    ...\n\n    public void onBtnPushed(int slot) {\n      onCommands[slot].execute();\n+     undoCommand = onCommands[slot];\n    }\n\n    public void offBtnPushed(int slot) {\n      offCommands[slot].execute();\n+     undoCommand = offCommands[slot];\n    }\n\n+   public void undoBtnPushed() {\n+     undoCommand.undo();\n+   }\n  }\n```\n\nundo 뿐만 아니라, 매크로 기능과 같은 서드파티 기능도 쉽게 구현할 수 있을 것이다.\n\n```java:MacroCommand.java\npublic class MacroCommand implements Command {\n  Command[] commands;\n\n  public MacroCommand(Command[] commands) {\n    this.commands = commands;\n  }\n\n  public void execute() {\n    for (int i=0; i\u003ccommands.length; i++) {\n      commands[i].execute();\n    }\n  }\n\n  public void undo() {\n    for (int i=commands.length-1; i\u003e=0 i--) {\n      commands[i].undo();\n    }\n  }\n}\n```\n\n### IRL\n\nIn Real Life에서는 Command Pattern이 어떻게 쓰이고 있을까?\n\n1. 명령어 queuing\n**Command queue**를 만들어 `enqueue`, `dequeue`를 구현하여, 각각의 명령어를 순차처리, 스레드에 할당하는 방식으로 사용하는 경우가 있다.\n\n2. logging\n**Command**에 `store`, `load` 따위의 메서드를 추가하여 명령어가 실행되면 disk에 로깅 및 불러올 수 있도록 기능을 추가하여 에러 및 데이터 분석을 용이하게 하는 경우도 있다.\n\n\n## 결론\n\n클라이언트 별로 다른 요청을 처리하는 경우나, 요청 queue, 로깅이 필요한 경우에는\n명령어, 요청을 `은닉화(encapsulates)`하는 Command Pattern을 활용해보자.","slug":"univ_design-pattern/mid_05","readingMinutes":6,"wordCount":583},{"title":"Singleton Pattern","description":"Singleton 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Singleton Pattern"],"draft":false,"date":"2023-10-08 / 21:31","content":"\n## 필요성\n\n시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용한다.\n\n## Singleton Pattern\n\n```java:Singleton.java {2, 4} showLineNumbers\n  public class Singleton {\n    private static Singleton _instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      if (_instance == null) {\n        _instance = new Singleton();\n      }\n      return _instance;\n    }\n  }\n```\n\n기존에 봐오던 클래스들과 많이 다르게 클래스 내부에 본인의 인스턴스를 저장하는 공간이 있으며,\n**생성자가 외부로 노출되지 않는다**.\n\n인스턴스 생성은 오직 `getInstance()` 메서드 호출을 통해서만 이루어지며,\n내부적으로 null값인 경우에만 인스턴스를 생성하기 때문에 `1개의 인스턴스만 생성`이 된다.\n\n### Multithreading\n\n하지만 멀티스레딩 환경에서는 인스턴스가 2개 이상 생성되는 경우가 발생할 수 있다.\n`Line 7`과 `Line 8` 사이에서 `Context switching`이 일어나는 경우가 그러하다.\n\n이런 경우를 막기 위해서 getInstance()는 `동기화 처리`를 해주는 편이 좋다.\n\n```java:Singleton.java {2}\npublic class Singleton {\n  private static Singleton _instance = new Singleton();\n  ...\n}\n```\n\n이렇게 하면 프로그램 실행시점에 인스턴스가 생성되어 반드시 1개의 인스턴스만 생성할 수 있다.\n하지만, 해당 클래스의 생성시점을 제어할 수 없기에 프로그램 성능이 저하되는 문제가 발생할 수 있다.\n\n```java:Singleton.java {6}\n  public class Singleton {\n    private static Singleton _instance;\n\n    private Singleton() {}\n\n    public static synchronized Singleton getInstance() {\n      if (_instance == null) {\n        _instance = new Singleton();\n      }\n      return _instance;\n    }\n  }\n```\n\njava처럼 동기화 키워드를 제공하는 경우 인스턴스를 생성하는 함수를 동기화 걸어주면 된다.\n하지만 이 경우에도 해당 함수가 매우 무거운 기능을 수행하는 경우에는 동기화 시간이 매우 길어져 성능 저하의 원인이 될 수 있다.\n\n\n```java:Singleton.java {6}\n  public class Singleton {\n    private volatile static Singleton _instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      if (_instance == null) {\n        synchronized (Singleton.class) {\n          if (_instance == null) {\n            _instance = new Singleton();\n          }\n        }\n      }\n      return _instance;\n    }\n  }\n```\n\n위의 코드는 인스턴스 생성 함수 내부에서 정확히 인스턴스를 생성하는 부분만 동기화되기 때문에\n성능상의 이슈도 없앨 수 있다.\n\n## 결론\n\n필요성과 같다.\n시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용하자.","slug":"univ_design-pattern/mid_04","readingMinutes":4,"wordCount":300},{"title":"Decorator Pattern","description":"Decorator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Decorator Pattern","OCP","Java I/O"],"draft":false,"date":"2023-10-08 / 14:49","content":"\n## 필요성\n\n키오스크 개발자라고 가정하고 음료를 정의할 인터페이스를 만들어보자.\n\n```java:Beverage.java\npublic abstract class Beverage {\n  private String description;\n\n  public Beverage(String des) {\n    this.description = des;\n  }\n\n  public String getDescription() {\n      return description;\n  }\n  public abstract double cost();\n}\n```\n\n그렇다면 음료들은 이 클래스를 상속받아서 구현하면 될 것이다.\n하지만 이 경우에 다음과 같은 문제점이 발생할 수 있다.\n\n아아, 아아 샷추가, 아아 우유추가 등 여러 `베리에이션 음료`에 대해 모두 **각각** 클래스로 구현해야 한다는 점이다.\n단순히 샷추가나 우유추가의 경우에는 가격만 좀 더 받으면 될터인데 이를 각각 따로 구현하는거는 코드의 중복 뿐만 아니라, 유지보수도 어렵게 만든다.\n\n### OCP\n\n그렇다면 Beverage에서 옵션도 관리하게 하면 되지 않을까?\n\n```diff-java:Beverage.java\n  public abstract class Beverage {\n    private String description;\n+   private boolean milk;\n+   private boolean soy;\n\n    public Beverage(String des) {\n      this.description = des;\n    }\n\n    public abstract String getDescription() {\n      return description;\n    }\n    public abstract double cost();\n\n+   setMilk();\n+   hasMilk();\n+   setSoy();\n+   hasSoy();\n  }\n```\n\n처음 생각해볼 수 있는 간단한 해결법이지만, 좋은 방법은 아니다.\n다른 옵션을 추가하거나 옵션에 따른 가격 변동을 수정하려는 경우에는 Beverage 클래스에 대한 전면적인 수정이 필요해지기 때문이다.\n\n`새로운 옵션`에 대해서는 **변수 추가 및 get, set을 추가**해야 하고,\n`가격 변동`의 경우에는 **cost 함수가 전면적으로 수정**되어야 한다.\n이 과정에 Beverage를 상속받은 `모든 클래스`에서 일어나야 한다.\n\n이런 경우를 방지하기 위해 `OCP` 방법론을 준수하여 코딩하는게 좋다.\n\nOCP는 Open-Closed Principle의 약어로, 확장엔 유연하게, 변경엔 엄격하게 디자인 해야함을 추구하는 원칙이다.\n\n## Decorator Pattern\n\n이를 해결하기 위해 `Decorator Pattern`을 사용할 수 있다.\n\n우선 Beverage는 다시 원상복구를 시키고, 옵션에 대한 클래스를 구현하자.\n\n```java:CondimentDecorator.java\npublic abstract class CondimentDecorator extends Beverage {\n  public abstract String getDescription();\n}\n```\n\n이제 음료는 Beverage를 상속받아 구현하고, 옵션은 CondimentDecorator를 상속받아 구현하면 된다.\n계속 예시를 살펴보며 이해하자.\n\n```java:Espresso.java\npublic class Espresso extends Beverage {\n  public Espresso() {\n    description = 'Espresso';\n  }\n\n  public double cost() {\n    return 0.89;\n  }\n}\n```\n\n```java:Milk.java\npublic class Milk extends CondimentDecorator {\n  Beverage beverage;\n\n  public Milk(Beverage beverage) {\n    this.beverage = beverage;\n  }\n\n  public String getDescription() {\n    return beverage.getDescription() + ', Milk';\n  }\n\n  public double cost() {\n    return beverage.cost() + 0.20;\n  }\n}\n```\n\n이런식으로 구현한다면 사용할 때는 Espresso를 Milk가 감싸는 방식으로 옵션을 추가할 수 있게된다.\n\n```java:Kiosk.java\npublic class Kiosk {\n  public static void main(String args[]) {\n    Beverage espressoWithMilk = new Milk(new Espresso());\n    System.out.println(espressoWithMilk.getDescription() + “ $” + espressoWithMilk.cost());\n    ...\n  }\n}\n```\n\n\u003e Espresso, Milk $1.09\n\n실제로 Java의 I/O를 사용하다보면 이런 코드를 많이 본 적이 있을 것이다.\n\n```java:FileIO.java\nInputStream in = new LineNumberInputStream(\n                    new BufferedInputStream(\n                       new FileInputStream('text.txt')));\n```\n\n이런 Stream도 모두 Decorator Pattern이 적용된 것이다.\n\n## 결론\n\nDecorator Pattern은 `새로운 기능이 추가`되거나, `적용 순서를 자유롭게` 해야하는 경우에 사용하는 것이 좋다.","slug":"univ_design-pattern/mid_03","readingMinutes":5,"wordCount":417},{"title":"Observer Pattern","description":"Observer 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Observer Pattern","interface"],"draft":false,"date":"2023-09-11 / 10:33","content":"\n## Strategy Pattern\n\n[**저번 포스트**](https://wjlee611.github.io/blog/univ_design-pattern/mid_01)에서 배운 `Strategy 디자인 패턴`을 이용해서 한 가지 예를 살펴보자.\n\n```java:WeatherData.java {7} showLineNumbers\npublic class WeatherData {\n  public void measurementsChanged() {\n    float temp = getTemperature();\n    float humidity = getHumidity();\n    float pressure = getPressure();\n\n     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n    currentConditionsDisplay.update(temp, humidity, pressure);\n    statisticsDisplay.update(temp, humidity, pressure);\n    forecastDisplay.update(temp, humidity, pressure);\n  }\n}\n```\n\n이 코드는 `Display`장치들이 `WeatherData`에서 제공하는 데이터를 이용하려는 코드이다.\n\n예로 들어 `forecastDisplay`에서 날씨 정보를 출력하기 위해서는\n`WeatherData`에서 `forecastDisplay.update()` 메서드를 호출해야\n날씨 정보가 비로소 `forecastDisplay`로 전달되는 것이다.\n\n### 문제점\n\n여기서 문제가 발생한다.\n만약 새로운 장치 futureDisplay를 구현하려면 Strategy Pattern을 사용하는 코드는 아래와 같은 코드수정이 필요해진다.\n\n1. update() 전략을 갖고있는 인터페이스로 구현한 전략(Display) 클래스를 만든다.\n2. `Line 7`에 새로운 장치를 등록한다.\n\n지금 당장은 문제될게 없어 보이지만, 만약 당신이 WeatherData를 `라이브러리화 해서 배포`하는 입장일 경우를 고려해보자.\n`사용자`는 단지 새로운 Display를 추가하여 바로 날씨 정보를 받아오고 싶을 것이다.\n하지만, 위와 같은 코드라면 사용자는 라이브러리 파일을 뜯어서 WeatherData 클래스 내부에\n직접적으로 `새로운 Display를 의존성 주입`을 해줘야만 할 것이다.\n\n이 경우는 꽤나 치명적이다.\n생각해보면 우리가 사용하는 대부분의 라이브러리는 이런 과정을 겪지 않으니 말이다.\n\n따라서 이런 문제를 해결하기 위한 디자인 패턴이 필요하다.\n\n## Observer Pattern\n\nObserver Pattern의 정의는 다음과 같다.\n\n\u003e 객체들이 1:N의 관계를 갖을 때, 한 객체의 상태가 변하면 다른 모든 객체들에 업데이트 통지가 떨어지는 관계로,\n\u003e `객체(Subject)`와 `객체들(Observers)`간의 `종속성이 없는 관계`를 의미한다.\n\n코드로 살펴보며 이해해보자.\n\n### interface\n\n```java:IObserverPattern.java {1-5, 7-9}\npublic interface Subject {\n    public void registerObserver(Observer o);\n    public void removeObserver(Observer o);\n    public void notifyObservers();\n}\n\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\n\npublic interface DisplayElement {\n    public void display();\n}\n```\n\n위 코드는 Observer Pattern에서 사용하는 인터페이스이다.\n`1`의 입장인 클래스(Subject)는 `Subject 인터페이스`를 구현해야 하고,\n`N`의 입장인 클래스(Observers)는 `Observer 인터페이스`를 구현해야 한다.\n\n### Subject class\n\n```diff-java:WeatherData.java {24, 35}\n  public class WeatherData implements Subject {\n+   private ArrayList\u003cObserver\u003e observers;\n\n    public WeatherData() {\n      observers = new ArrayList\u003cObserver\u003e();\n    }\n\n+   @implements\n+   public void registerObserver(Observer o) {\n+     observers.add(o);\n+   }\n+\n+   @implements\n+   public void removeObserver(Observer o) {\n+     int i = observers.indexOf(o);\n+     if (i \u003c 0) return;\n+     observers.remove(i);\n+   }\n+\n+   @implements\n+   public void notifyObservers() {\n+     for (int i=0; i\u003cobservers.length; i++) {\n+       Observer o = observers.get(i);\n+       o.update(temp, humidity, pressure);\n+     }\n+   }\n\n    public void setMeasurements(float temp, float humidity, float pressure) {\n      this.temp = temp;\n      this.humidity = humidity;\n      this.pressure = pressure;\n      measurementsChanged();\n    }\n\n    // 더이상 WeatherData 클래스는 수정할 일이 없어진다.\n    public void measurementsChanged() {\n+     notifyObservers()\n-     float temp = getTemperature();\n-     float humidity = getHumidity();\n-     float pressure = getPressure();\n-\n-     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n-     currentConditionsDisplay.update(temp, humidity, pressure);\n-     statisticsDisplay.update(temp, humidity, pressure);\n-     forecastDisplay.update(temp, humidity, pressure);\n    }\n  }\n```\n\nSubject class의 역할은 Observer의 `구독과 해지`하는 역할을 담당하고,\n구독된 Observers에게 `본인의 변경사항을 알려`주는 역할을 한다.\n\n본인의 변경사항을 알려주기 위해 `Observer는 update 전략`을 포함하고 있어야 한다.\n\n이제 Subject 클래스는 `구독된 Observer를 배열로 관리`하고, `관리되고 있는 Observer를 대상`으로 `변경사항을 emit(update)`하기 때문에\n**더이상 Subject 클래스를 수정할 필요가 없어진다.**\n\n### Observer class\n\n```java:FutureDisplay.java {6-8}\npublic class FutureDisplay implements Observer, DisplayElement {\n  private Subject weatherData;\n\n  public FutureDisplay(Subject weatherData) {\n    this.weatherData = weatherData;\n    // Observer가 Subject를 구독한다.\n    // 비로소 Subject가 update를 쏴줄 수 있다.\n    weatherData .registerObserver(this);\n  }\n\n  public void update(float temp, float humidity, float pressure) {\n    this.temp = temp;\n    this.humidity = humidity;\n    this.pressure = pressure;\n    display();\n  }\n\n  @implements\n  public void display() {\n    // ...\n  }\n}\n```\n\nObserver는 생성시 자동으로 `Subject를 구독`하게 되고,\n구독했기에 Subject의 상태 변경시 자동으로 Observer를 업데이트 할 수 있다.\n_Subject의 observers 배열에 추가되어 관리됨_\n\n\u003e 여기서 눈여겨 봐야 할 점은 `Observer의 update` 전략 메서드는 `Subject`에서,\n\u003e `Subject의 register, remove` 전략 메서드는 `Observer`에서 호출된다는 점이다.\n\u003e 서로 `크로스`되어 메서드를 호출한다는 점을 주목하자.\n\n### main (사용자 입장)\n\n```diff-java:WeatherStation.java {5-6}\n  public class WeatherStation {\n    public static void main(String[] args) {\n      WeatherData weatherData = new WeatherData();\n\n      // another displays\n+     FutureDisplay futureDisplay = new FutureDisplay(weatherData);\n\n      weatherData.setMeasurements(80, 65, 30.4f);\n      weatherData.setMeasurements(82, 70, 29.2f);\n      weatherData.setMeasurements(78, 90, 29.3f);\n    }\n  }\n```\n\n사용자 입장에서는 새로운 Display객체 생성시 WeatherData를 의존성 주입만 해주면,\n그 뒤의 모든 과정은 Observer Pattern에 의해 자동으로 업데이트가 가능해진다.\n\n## 결론\n\n`의존성이 없어`야 하지만 `여러 클래스와 관계`를 가져야하고,\n동시에 `코드가 수정되는 일이 적어`야만 하는 클래스는\nObserver Pattern을 그 클리스와 관계를 갖는 여러 클래스에 적용하는 것이 좋다.\n","slug":"univ_design-pattern/mid_02","readingMinutes":7,"wordCount":693},{"title":"Strategy Pattern","description":"Strategy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Strategy Pattern","extends","implements"],"draft":false,"date":"2023-09-11 / 09:09","content":"\n## 상속\n\n### extends\n\n오리 시뮬레이터를 만든다고 가정해보자.\n그렇다면 일단 오리 객체를 만들어야 할 것이다.\n\n```java:Duck.java {5}\nclass Duck() {\n  quack() {};\n  swim() {};\n  fly() {};\n  display() {};\n  // other duck-like methods\n}\n```\n\n그리고 여러 종류의 오리는 이 `Duck` 클래스를 상속받아서 사용하면 될 것이다.\n\n```java:Ducks.java {2-3, 7-8}\nclass MallardDuck extends Duck {\n  @override\n  display() {};\n}\n\nclass RedheadDuck extends Duck {\n  @override\n  display() {};\n}\n```\n\n물론 생김새는 다르기에 일부 메서드는 `override`해서 사용해야 할 것이다.\n이 때 자식 클래스와 부모 클래스는 `is a` 관계를 갖는다고 말한다.\n_e.g. MallardDuck is a Duck_\n\n### implements (interface)\n\n이제 고무 오리를 만들어보자.\n\n```java:Ducks.java {4-7}\nclass RubberDuck extends Duck {\n  @override\n  display() {}\n  @override\n  quack() {}\n  @override\n  fly() {}\n}\n```\n\n고무 오리는 `꽥` 소리를 내지 않고 `삑`소리를 내기 때문에 `quack()` 메서드 역시 override 해야한다.\n또한, 날지도 않기에 `fly()` 메서드 역시 override 해야한다.\n\nDecoyDuck을 또 만든다면?\n이 역시 quack, fly 메서드를 override 해야한다.\n\n이렇게 모든 Duck들이 공유하지 않는 속성은 매번 override 해야하는 문제점이 있다.\n\n이 때, `interface`를 사용하면 이 문제를 해결할 수 있다.\n\n```diff-java:DucksWithInterfece.java {12, 18}\n  class Duck() {\n    swim() {};\n    display() {};\n  }\n+ interface Flyable() {\n+   fly();\n+ }\n+ interface Quackable() {\n+   quack();\n+ }\n\n  class MallardDuck extends Duck implements Flyable, Quackable {\n+   fly() {};\n+   quack() {};\n    @override\n    display() {};\n  }\n  class RubberDuck extends Duck implements Quackable {\n+   quack() {};\n    @override\n    display() {};\n  }\n```\n\n이렇게 변할 수 있는 부분은 interface로 띄어내면 쓸데없이 메서드를 override할 일이 줄어든다.\n이 때 구현 클래스와 인터페이스는 `has a` 관계를 갖는다고 한다.\n_e.g. RubberDuck has a Quackable_\n\n_참고:_\n_class, interfece의 차이는 사실 거의 없다._\n\n### interface 다형성\n\n하지만 위 방식 역시 문제가 존재한다.\nMallardDuck, RedheadDuck 두 오리 모두 같은 quack 메서드로 동작해야 하지만,\n이를 implements 하는 과정에서 두 메서드를 중복해서 구현해야 한다는 문제점이 발생한다.\n\n이를 해결하기 위해서는 인터페이스의 다형성의 원리를 이용하는게 좋다.\n\n```diff-java:DucksWithPolymorphism.java {18, 20-24}\n  interface QuackBehavior {\n    quack();\n  }\n+ class Quack implements QuackBehavior {\n    @override\n    quack() {'꽥'};\n  }\n+ class Squack implements QuackBehavior {\n    @override\n    quack() {'삑'};\n  }\n+ class MuteQuack implements QuackBehavior {\n    @override\n    quack() {};\n  }\n\n  class Duck {\n    QuackBehavior quackBehavior;\n\n    performQuack() {\n      // delegate to the behavior class\n      // 한 마디로 짬때리기...\n      quackBehavior.quack();\n    }\n    // ...\n  }\n\n  class MallardDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Quack 객체를 지정할 수 있다.\n+     quackBehavior = new Quack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(꽥)를 사용할 수 있음.\n    // ...\n  }\n  class RubberDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Squack 객체를 지정할 수 있다.\n+     quackBehavior = new Squack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(삑)를 사용할 수 있음.\n    // ...\n  }\n```\n\n이렇게 하면 필요한 부분에만 기능을 추가할 수 있고, 코드의 재사용성도 올라간다.\n뿐만 아니라 새로운 기능 (예로 들어 새로운 울음 소리)의 추가도 쉬워진다.\n\n## Strategy Pattern\n\n위에서 알아본 적절한 상속관계를 준수한 패턴을 `Strategy Pattern` 라고 한다.\n정확한 정의는 다음과 같다.\n\n\u003e 객체들이 할 수 있는 행위 각각에 대해 `전략 클래스 (Quack, Squack)`를 생성하고,\n\u003e `유사한 행위들을 캡슐화` 하는 `인터페이스 (QuackBehavior)`를 정의하여,\n\u003e 객체의 행위를 동적으로 바꾸고 싶은 경우 `직접 행위를 수정하지 않고 (performQuack())`\n\u003e 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.\n\n간단히 말해서 객체가 할 수 있는 행위들을 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것만으로 행위의 수정이 가능하도록 만든 패턴이다.\n\n## 결론\n\n`has a (구현)`관계가 `is a (상속)`관계보다 낫다.\n\n상속은 뭘 상속해야 하는지 일일이 파악해야 하는 귀찮음이 있기 때문이다.\n하지만, 구현은 필요한 기능만 가져다 쓰면 되기에 사용및 개발적 측면에서 좋고,\n새로운 기능은 인터페이스를 추가로 구현하면 끝이기에 유지보수 측면에서도 좋다.\n\n따라서 단순히 상속을 이용한 객체지향 프로그래밍 보단,\n전략 패턴을 적용한 코딩 습관을 기르도록 하자.\n","slug":"univ_design-pattern/mid_01","readingMinutes":6,"wordCount":594},{"title":"대학 - 프로그래밍 언어론","description":"3학년 2학기 프로그래밍 언어론 수업 아카이브","icon":"","image":"","tags":[],"draft":false,"date":"2023-09-11 / 09:04","content":"","slug":"univ_design-pattern/index","readingMinutes":0,"wordCount":1}],"mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    span: \"span\",\n    p: \"p\",\n    br: \"br\",\n    div: \"div\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"필요성\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#필요성\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"필요성\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"자동차를 만든다고 가정해보자.\", _jsx(_components.br, {}), \"\\n\", \"자동차에는 셀 수 없는 여러 부품들이 종합적으로 들어가서 만들어질텐데, 만약 그 부품이 모두 종속적으로 연결되어 있다면?\", _jsx(_components.br, {}), \"\\n\", \"부품 교체는 물론이고, 개발하는 것도 여러 사람이 분산해서 개발하지 못할 것이다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 부분을 독립적으로 개발하고, 확장을 유연하게 하기 위해 Bridge pattern을 사용한다.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"bridge-pattern\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#bridge-pattern\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Bridge Pattern\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \"Product.java\"\n    }), _jsx(_components.pre, {\n      className: \"language-java\",\n      children: _jsxs(_components.code, {\n        className: \"language-java code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"interface\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Product\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"String\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"productName\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"produce\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"유연한 확장을 위해 인터페이스를 정의한다.\", _jsx(_components.br, {}), \"\\n\", \"자동차의 부품에 해당하는 부분이다.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \"CentralLocking.java\"\n    }), _jsx(_components.pre, {\n      className: \"language-java\",\n      children: _jsxs(_components.code, {\n        className: \"language-java code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"class\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"CentralLocking\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"implements\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Product\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"String\"\n          }), \" productName\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"CentralLocking\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"String\"\n          }), \" productName\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"this\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), \"productName \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), \" productName\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token comment\",\n            children: \"// override methods\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \"GearLocking.java\"\n    }), _jsx(_components.pre, {\n      className: \"language-java\",\n      children: _jsxs(_components.code, {\n        className: \"language-java code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"class\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"GearLocking\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"implements\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Product\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"String\"\n          }), \" productName\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"GearLocking\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"String\"\n          }), \" productName\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"this\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), \"productName \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), \" productName\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token comment\",\n            children: \"// override methods\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고, 여러 사람이 인터페이스에 맞게 부품을 개발한다.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \"Car.java\"\n    }), _jsx(_components.pre, {\n      className: \"language-java\",\n      children: _jsxs(_components.code, {\n        className: \"language-java code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"abstract\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"class\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Car\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line highlight-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Product\"\n          }), \" product\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"String\"\n          }), \" carType\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Car\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Product\"\n          }), \" product\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"String\"\n          }), \" carType\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"this\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), \"product \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), \" product\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"this\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), \"carType \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), \" carType\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"abstract\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"assemble\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"abstract\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"produceProduct\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 자동차의 뼈대를 만들어준다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 때, product를 인터페이스로 만들었기에 유연한 확장과, Car과 독립적으로 product를 개발할 수 있게되는데, 이것이 Bridge pattern 이다.\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \"Motoren.java\"\n    }), _jsx(_components.pre, {\n      className: \"language-java\",\n      children: _jsxs(_components.code, {\n        className: \"language-java code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"class\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Motoren\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"extends\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Car\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Motoren\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Product\"\n          }), \" product\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Strint\"\n          }), \" carType\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"super\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"product\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \" carType\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token annotation punctuation\",\n            children: \"@override\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"produceProduct\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line highlight-line\",\n          children: [\"    product \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), _jsx(_components.span, {\n            className: \"token function\",\n            children: \"produce\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token comment\",\n            children: \"// ...\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그럼 자동차를 조립하는 입장에서는 produce의 내부 구조는 알 필요없이 인터페이스만을 가지고 독립적으로 개발할 수 있게 된다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"toc":[{"slug":"필요성","text":"필요성","subSections":[]},{"slug":"bridge-pattern","text":"Bridge Pattern","subSections":[]}]},"__N_SSG":true},"page":"/blog/[...slugs]","query":{"slugs":["univ_design-pattern","final_05"]},"buildId":"zjlLyPj8az7Fp8gQlOqTr","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>