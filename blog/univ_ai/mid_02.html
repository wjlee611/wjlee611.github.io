<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>웅덩이</title><link rel="canonical" href="https://wjlee611.github.io/blog/univ_ai/mid_02"/><meta name="next-head-count" content="4"/><link rel="icon" href="/images/icon_circle.png"/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" rel="stylesheet"/><meta name="description" content="웅덩이"/><meta name="apple-mobile-web-app-title" content="웅덩이"/><meta name="application-name" content="웅덩이"/><meta name="theme-color" content="#009c39"/><meta name="google-site-verification" content="vhQ9DaDdUJcSBHKI_U6tAtE61zwz2i2pLQXyZ62GRLk"/><meta name="naver-site-verification" content="07764cc1a8eda55b4bdf78cf846d6811d042b9ee"/><link rel="preload" href="/_next/static/media/a37cf3809adb2c63-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/dd50543ba70be8e9-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/c372a630cbda84f2-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/c244cd6be2a69a75.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c244cd6be2a69a75.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-401a9806b070f31a.js" defer=""></script><script src="/_next/static/chunks/main-6b74302918225334.js" defer=""></script><script src="/_next/static/chunks/pages/_app-01dc60c7ef7ccbd8.js" defer=""></script><script src="/_next/static/chunks/95b64a6e-5c1c80ce1af5e491.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5B...slugs%5D-d30256c1e19801d0.js" defer=""></script><script src="/_next/static/jxN_3xkEGn7F8-if3KEMa/_buildManifest.js" defer=""></script><script src="/_next/static/jxN_3xkEGn7F8-if3KEMa/_ssgManifest.js" defer=""></script></head><body class="text-primary transition-[background] bg-white dark:bg-[#1A1C23]"><script>
            const theme = localStorage.getItem("theme");
            const getUserTheme = () => {
             if(theme){
              return theme
             } 
             return window.matchMedia('(prefers-color-scheme: dark)').matches
             ? 'dark'
             : 'light'
          }
          document.body.dataset.theme = getUserTheme();
          </script><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="__className_e7b8b0 text-center transition-all "><header class="fixed top-0 left-0 right-0 mx-anuo w-screen h-12 md:h-16 flex justify-between items-center px-2 md:px-10 backdrop-blur bg-blue-200 bg-opacity-20 z-50"><div class="h-full flex items-center"><a class="h-full aspect-square flex justify-center items-center text-3xl select-none cursor-pointer" href="/">🫧</a><nav class="h-full hidden md:flex space-x-8 overflow-hidden ml-10"><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-black dark:text-white " href="/">Portfolio</a></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-blue-500 " href="/blog">Blog</a><div class="hidden md:flex w-full h-[2px] bg-blue-500 absolute bottom-0 left-0 blur-[2px]"></div></li><li class="h-full flex items-center list-none relative select-none"><a class="h-full w-full md:w-auto flex items-center transition-colors py-2 md:my-0 font-bold text-black dark:text-white " href="/arkhive">Arkhive</a></li></nav></div><div class="flex items-center h-full"><button aria-label="Toggle Dark Mode" type="button" class="flex h-9 w-9 items-center justify-center rounded-lg transition-all text-secondary hover:bg-secondary "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="h-6 w-6 text-yellow-400 drop-shadow-base"></svg></button><button class="flex md:hidden items-center justify-center w-16 h-full text-2xl text-black dark:text-white"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.5 11.5A.5.5 0 0 1 5 11h10a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 3 7h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm-2-4A.5.5 0 0 1 1 3h10a.5.5 0 0 1 0 1H1a.5.5 0 0 1-.5-.5z"></path></svg></button></div></header><main class="inline-block w-full relative pt-16 px-8 max-w-5xl 2xl:max-w-7xl" style="opacity:1;transform:none"><div class="flex flex-col items-start pb-16"><header class="flex w-full flex-col items-center my-10"><h1 class="bg-gradient-to-br from-blue-600 to-blue-400 bg-clip-text text-transparent text-3xl font-bold mb-5 drop-shadow">게임에서의 탐색 및 최적화</h1><span class="text-blue-500 text-lg">게임 트리를 탐색하는 기법과 최적화에 대해 알아봅니다.</span><span class="space-x-10 mt-5 text-blue-400 text-sm">읽는데<span class="text-blue-500 text-xl font-semibold"> <!-- -->11</span>분 정도 걸려요.</span></header><section class="w-full flex justify-between space-x-5"><div class="w-full flex flex-col items-start prose dark:prose-dark max-w-full lg:max-w-2xl 2xl:max-w-4xl"><h2 id="게임-트리"><a class="anchor" href="#게임-트리"><span class="icon icon-link"></span></a>게임 트리</h2>
<p><code>상대가 있는 게임</code>에서 자신과 상대방의 가능한 게임 상태를 나타낸 트리.<br/>
<!-- -->자신의 턴인지, 상대의 턴인지에 따라 탐색하는 방식이 다르게 적용됨.<br/>
<!-- -->(나에겐 유리하게, 상대에겐 불리하게)</p>
<p>정해진 시간 내에 최대한 많은 수를 보는 것이 유리하기 때문에 탐색 효율을 높이는 것이 중요하다.</p>
<h3 id="mini-max-algorithm"><a class="anchor" href="#mini-max-algorithm"><span class="icon icon-link"></span></a>Mini-max Algorithm</h3>
<p>특이하게 단말 노드로부터 위로 올라가면서 최소-최대 연산을 반복하여 자신이 선택할 수 있는 방법 중 가장 좋은 값을 선택하는 방법이다.</p>
<p>자신의 턴인 Max 노드에서는 자신에게 유리한 값을 선택하고,<br/>
<!-- -->상대의 턴인 Min 노드에서는 상대에게 불리한 값을 선택하는 방식을 취한다.</p>
<p><img src="/posts/mid_02/231021-230224.png" alt="231021-230224"/></p>
<p>하지만 트리가 넓을 수록 모든 상태공간을 탐색하는건 시간상 너무 오래 걸리기 때문에 최적화 기법이 들어가야 한다.<br/>
<!-- -->바로 <strong><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>−</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha - \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05278em">β</span></span></span></span></span> 가지치기(prunning)</strong> 기법이다.</p>
<p>검토해 볼 필요가 없는 부분을 탐색하지 않도록 하는 기법인데, 어떻게 해야 검토할 필요가 없다는 걸 알 수 있을까?</p>
<p>깊이 우선 탐색(DFS)로 제한 깊이까지 탐색을 하면서 Min, Max 노드의 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05278em">β</span></span></span></span></span>값을 업데이트 하는데, 각 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05278em">β</span></span></span></span></span>값은 다음과 같은 값을 저장한다.</p>
<ul>
<li>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span></span><br/>
<!-- -->Max 노드에서만 값이 업데이트되며, 현재까지 확보한 자식의 값 중 최댓값을 저장함</p>
</li>
<li>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05278em">β</span></span></span></span></span><br/>
<!-- -->Min 노드에서만 값이 업데이트되며, 현재까지 확보한 자식의 값 중 최솟값을 저장함</p>
</li>
</ul>
<p>이 때, 탐색 후 값을 업데이트 하다가 <strong><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>≥</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \geq \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05278em">β</span></span></span></span></span></strong> 되는 순간이 오는데, 그 때부터 나머지 자식노드는 탐색할 필요가 없어진다.<br/>
<!-- -->그 이유는, 상한선(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span></span>)과 하한선(<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05278em">β</span></span></span></span></span>)이 정해질 때, 그 부모노드의 상한선과 하한선을 넘지 못하면 부모노드를 업데이트 할 수 없기에, 업데이트를 할 가능성이 없다면 가지치기를 해버리는 것이다.</p>
<p>알고리즘의 이해가 안된다면 아래 영상을 참고하면 좋을 거 같다.</p>
<iframe width="100%" height="auto" class="aspect-video" src="https://www.youtube.com/embed/_i-lZcbWkps" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
<p>속성으로 빠르게 탐색하고 싶다면 이런 방식으로 탐색해도 된다.</p>
<iframe width="100%" height="auto" class="aspect-video" src="https://www.youtube.com/embed/6qN5ReC2SUA" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
<p>빠르게 업데이트 가능한 조건을 적어놓고, 그 조건이 업데이트가 절대로 불가능하다면 나머지 노드를 가지치기 하는 방식이다.</p>
<h3 id="몬테카를로-트리-탐색-기법-monte-carlo-simulation"><a class="anchor" href="#몬테카를로-트리-탐색-기법-monte-carlo-simulation"><span class="icon icon-link"></span></a>몬테카를로 트리 탐색 기법 (Monte Carlo Simulation)</h3>
<p><img src="/posts/mid_02/231022-003000.png" alt="231022-003000"/></p>
<p>탐색 공간을 무작위 표본추출을 하면서 탐색 트리를 확장하여 가장 좋아보이는 것을 선택하는 휴리스틱 탐색 방법으로,<br/>
<!-- -->시간이 허용되는 동안 위의 4단계를 반복하여 시뮬레이션 및 트리를 확장한다.</p>
<ol>
<li>
<p>선택<br/>
<!-- -->선택은 <strong>트리 정책</strong>을 적용하여 선택한다.<br/>
<!-- -->정책은 개발자 마음대로 정하는 거지만, 보통 승률과 노드 방문횟수를 고려하여 선택한다.<br/>
<!-- -->일반적으로 <code>승률이 높으며</code>, <code>방문횟수가 적은</code> 노드에 우선권을 부여한다 (UCB, Upper Confidence Bound 정책).</p>
</li>
<li>
<p>확장<br/>
<!-- -->단말 노드에서 트리 정책에 따라 노드를 추가한다.</p>
</li>
<li>
<p>시뮬레이션<br/>
<!-- -->기본 정책에 의한 <code>몬테카를로 시뮬레이션</code>을 적용한다.<br/>
<!-- -->무작위 선택, 또는 약간 똑똑한 방법으로 게임이 끝날 때 까지 진행한다.</p>
</li>
</ol>
<tip><p><code>몬테카를로 시뮬레이션</code></p><br/><p>특정 확률 분포로 부터 무작위 표본(또는 약간 똑똑한 방법으로)을 생성하고, 이 표본에 따라 행동을 하는 과정을 반복하여 결과를 확인하고 이 과정을 반복해 최정 결정을 하는 것.</p><br/><p>특정 상태의 유불리를 상태판단함수로 판단하는 것이 아닌, 시뮬레이션으로 판단하게 된다.</p></tip>
<ol start="4">
<li>역전파<br/>
<!-- -->게임의 결과를 단말 노드에서 루트 노드까지 올라가면서 반영한다.</li>
</ol>
<hr/>
<h2 id="제약조건-만족-문제"><a class="anchor" href="#제약조건-만족-문제"><span class="icon icon-link"></span></a>제약조건 만족 문제</h2>
<p>주어진 제약조건을 만족하는 조합 해(combination solution)을 찾는 문제로 N-Queens problem과 같은 문제가 이에 해당한다.</p>
<h3 id="백-트래킹-탐색-backtracking-search"><a class="anchor" href="#백-트래킹-탐색-backtracking-search"><span class="icon icon-link"></span></a>백 트래킹 탐색 (Backtracking search)</h3>
<p>깊이 우선 탐색(DFS)을 하는 것처럼 변수에 허용되는 값을 하나씩 대입해보고, 가능한 모든 값을 대입했는데도 만족하는 것이 없으면 이전 단계로 돌아가서 이전 단계의 변수에 다른 값을 대입하는 전형적인 백 트래킹 방식이다.</p>
<h3 id="제약조건-전파-constraint-propagation"><a class="anchor" href="#제약조건-전파-constraint-propagation"><span class="icon icon-link"></span></a>제약조건 전파 (Constraint propagation)</h3>
<p>인접 변수 간의 제약 조건에 따라 각 변수에 허용될 수 없는 값들을 제거하는 방식으로, 이름 그대로 주변에 제약조건을 전파하여 선택 가능한 가지수를 줄여가는 방식이다.</p>
<p><img src="/posts/mid_02/231022-004410.png" alt="231022-004410"/></p>
<p>A에 1을 선택하는 순간 B~D에 각각 제약사항이 전파되어 B~D에서 선택할 수 있는 가지수가 제한된다.<br/>
<!-- -->여기서 B가 3을 선택하는 순간 C, D에 각각 제약사항이 또 전파되는데, 이 때 C는 더이상 아무것도 선택할 수 없기에 이전 스탭에서 다른 제약사항을 걸어야 한다.</p>
<hr/>
<h2 id="최적화"><a class="anchor" href="#최적화"><span class="icon icon-link"></span></a>최적화</h2>
<p>여러가지 가능, 혀용되는 값들 중에서 주어진 기준을 가장 잘 만족하는 것을 선택하는 것으로, 크게 <code>조합 최적화</code>와 <code>함수 최적화</code>로 나뉜다.</p>
<h3 id="조합-최적화"><a class="anchor" href="#조합-최적화"><span class="icon icon-link"></span></a>조합 최적화</h3>
<p>TSP와 같이 주어진 항목들의 조합으로 해가 표현되는 최적화 문제로, 이 경우에는 경로의 길이를 최소화 하는 문제이다.</p>
<p><img src="/posts/mid_02/231022-005505.png" alt="231022-005505"/></p>
<p>이를 달성하기 위해 생물의 진화를 모방한 집단 기반 확률적 탐색 기법인 <code>유전 알고리즘</code>을 사용하기도 한다.</p>
<p>개체는 염색체로 표현되며 다음과 같이 기술된다.</p>
<p><img src="/posts/mid_02/231022-005704.png" alt="231022-005704"/></p>
<p>이런 염색체들의 집합을 <code>모집단</code>이라고 하는데, 이런 모집단(후보해)가 문제의 해로서 적합한 정도를 <code>적합도 함수</code>가 판단하게 되고, 적합하다면 최적 개체로서 알고리즘이 종료되지만, 적합하지 않다면 <strong>진화의 과정</strong>을 거치게 된다.</p>
<p>모집단이 진화를 할 때는 우선 <code>부모 모집단</code> 중 개체를 선택하게 되는데, <strong>가능한 높은 적합도의 개체가 선택되도록 확률을 높게</strong> 조정한다.<br/>
<!-- -->자연선택과 같이 <strong>랜덤</strong>한 요소가 있어야 하기에 반드시 적합한 녀석이 선택되지는 않는다.</p>
<p>이후에는 선택된 부모 개체가 <code>유전 연산</code>을 거쳐 자식 개체를 양산하게 되는데, 유전 연산에는 다음과 같은 연산을 고려할 수 있다.</p>
<p><img src="/posts/mid_02/231022-010201.png" alt="231022-010201"/></p>
<p>이후에는 생성된 여러 자식 개체를 이용해서 <code>세대를 교체</code>하게 되는데, <strong>최대한 많은 우수한 계체가 다음 세대에 유지</strong>될 수 있도록 <code>엘리트주의</code>를 적용한다.</p>
<h3 id="목적-최적화"><a class="anchor" href="#목적-최적화"><span class="icon icon-link"></span></a>목적 최적화</h3>
<p>어떤 목적 함수(Objective function)가 있을 때, 이 함수를 최대로 하거나 최소로 하는 변수 값을 찾는 최적화 문제이다.</p>
<p><img src="/posts/mid_02/231022-010440.png" alt="231022-010440"/></p>
<p><code>최소 평균제곱법</code>을 사용해서 회귀(Regression) 문제의 최적함수를 찾거나,</p>
<p><img src="/posts/mid_02/231022-010602.png" alt="231022-010602"/></p>
<p>함수의 최소값 위치를 찾는 문제에서 <code>경사 하강법</code>과 같은 방법을 사용할 수 있다.</p></div><div class="w-72 hidden h-fit max-h-[calc(100vh-10rem)] lg:flex flex-col overflow-x-hidden overflow-y-scroll scrollbar-hide rounded-xl transition-all sticky top-32 bg-gradient-to-br from-blue-400 to-blue-950"><div class=""><p id="toc-header" class="py-3 font-extrabold leading-6 bg-black bg-opacity-20 text-white">🫧 한 눈에 보기</p><ul id="toc-content" class="px-4 pb-2 mt-2 flex flex-col items-start justify-start text-sm text-start"><li><a href="#게임-트리" class="group block py-1  text-white hover:text-blue-200 hover:drop-shadow-base-bold">게임 트리</a></li><li class="ml-4"><a href="#mini-max-algorithm" class="group flex items-start py-[2px] text-white hover:text-blue-200 hover:drop-shadow-base"><svg width="3" height="24" viewBox="0 -9 3 24" class="mr-2 overflow-visible text-white"><path d="M0 0L3 3L0 6" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path></svg>Mini-max Algorithm</a></li><li class="ml-4"><a href="#몬테카를로-트리-탐색-기법-monte-carlo-simulation" class="group flex items-start py-[2px] text-white hover:text-blue-200 hover:drop-shadow-base"><svg width="3" height="24" viewBox="0 -9 3 24" class="mr-2 overflow-visible text-white"><path d="M0 0L3 3L0 6" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path></svg>몬테카를로 트리 탐색 기법 (Monte Carlo Simulation)</a></li><li><a href="#제약조건-만족-문제" class="group block py-1  text-white hover:text-blue-200 hover:drop-shadow-base-bold">제약조건 만족 문제</a></li><li class="ml-4"><a href="#백-트래킹-탐색-backtracking-search" class="group flex items-start py-[2px] text-white hover:text-blue-200 hover:drop-shadow-base"><svg width="3" height="24" viewBox="0 -9 3 24" class="mr-2 overflow-visible text-white"><path d="M0 0L3 3L0 6" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path></svg>백 트래킹 탐색 (Backtracking search)</a></li><li class="ml-4"><a href="#제약조건-전파-constraint-propagation" class="group flex items-start py-[2px] text-white hover:text-blue-200 hover:drop-shadow-base"><svg width="3" height="24" viewBox="0 -9 3 24" class="mr-2 overflow-visible text-white"><path d="M0 0L3 3L0 6" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path></svg>제약조건 전파 (Constraint propagation)</a></li><li><a href="#최적화" class="group block py-1  text-white hover:text-blue-200 hover:drop-shadow-base-bold">최적화</a></li><li class="ml-4"><a href="#조합-최적화" class="group flex items-start py-[2px] text-white hover:text-blue-200 hover:drop-shadow-base"><svg width="3" height="24" viewBox="0 -9 3 24" class="mr-2 overflow-visible text-white"><path d="M0 0L3 3L0 6" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path></svg>조합 최적화</a></li><li class="ml-4"><a href="#목적-최적화" class="group flex items-start py-[2px] text-white hover:text-blue-200 hover:drop-shadow-base"><svg width="3" height="24" viewBox="0 -9 3 24" class="mr-2 overflow-visible text-white"><path d="M0 0L3 3L0 6" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path></svg>목적 최적화</a></li></ul></div></div></section><footer class="w-full flex flex-col mt-10"><span class="text-blue-400 italic text-start">2023-10-21 / 22:53<!-- --> 에 작성을 시작했어요.</span><div class="w-full flex items-start mt-5 mb-10 space-x-5"><span>Tag</span><ul class="w-full flex list-none m-0 flex-wrap gap-1"><li class="bg-gradient-to-br from-blue-500 to-blue-400 px-3 text-white rounded-md shadow-md whitespace-nowrap"># <!-- -->Mini-Max algorithm</li><li class="bg-gradient-to-br from-blue-500 to-blue-400 px-3 text-white rounded-md shadow-md whitespace-nowrap"># <!-- -->Alpha-Beta prunning</li><li class="bg-gradient-to-br from-blue-500 to-blue-400 px-3 text-white rounded-md shadow-md whitespace-nowrap"># <!-- -->Monte Carlo</li><li class="bg-gradient-to-br from-blue-500 to-blue-400 px-3 text-white rounded-md shadow-md whitespace-nowrap"># <!-- -->Backtracking search</li><li class="bg-gradient-to-br from-blue-500 to-blue-400 px-3 text-white rounded-md shadow-md whitespace-nowrap"># <!-- -->Constraint propagation</li><li class="bg-gradient-to-br from-blue-500 to-blue-400 px-3 text-white rounded-md shadow-md whitespace-nowrap"># <!-- -->Genetic algorithm</li><li class="bg-gradient-to-br from-blue-500 to-blue-400 px-3 text-white rounded-md shadow-md whitespace-nowrap"># <!-- -->Regression</li></ul></div><div class="flex flex-col items-center mb-5"><div class="w-full bg-gradient-to-br from-blue-400 to-blue-950 mt-5 rounded-md overflow-hidden"><h3 class="bg-black bg-opacity-50 px-1 py-3"><span class="bg-gradient-to-br from-blue-600 to-blue-400 bg-clip-text text-transparent font-bold drop-shadow">대학 - 인공지능</span><span class="text-white">의 다른 글</span></h3><ol class="w-full p-1 space-y-1"><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_ai/mid_08">기계학습 - 비지도 &amp; 반지도학습</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_ai/mid_07">기계학습 - 지도학습</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_ai/mid_06">규칙 기반 시스템</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_ai/mid_05">불확실한 지식 표현</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_ai/mid_04">명제 논리 &amp; 술어 논리</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_ai/mid_03">프레임 &amp; 의미망 &amp; 스크립트</a></li><li class="w-full bg-black bg-opacity-20 rounded-md"><a class="w-full flex justify-center text-white before:content-[&#x27;🫧&#x27;] before:mr-2 after:content-[&#x27;🫧&#x27;] after:ml-2" href="/blog/univ_ai/mid_02">게임에서의 탐색 및 최적화</a></li><li class="w-full "><a class="w-full flex justify-center text-white " href="/blog/univ_ai/mid_01">상태공간 &amp; 탐색</a></li></ol></div></div><section class="w-full self-center"></section></footer></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"게임에서의 탐색 및 최적화","description":"게임 트리를 탐색하는 기법과 최적화에 대해 알아봅니다.","icon":"","image":"","tags":["Mini-Max algorithm","Alpha-Beta prunning","Monte Carlo","Backtracking search","Constraint propagation","Genetic algorithm","Regression"],"draft":false,"date":"2023-10-21 / 22:53","content":"\n## 게임 트리\n\n`상대가 있는 게임`에서 자신과 상대방의 가능한 게임 상태를 나타낸 트리.\n자신의 턴인지, 상대의 턴인지에 따라 탐색하는 방식이 다르게 적용됨.\n(나에겐 유리하게, 상대에겐 불리하게)\n\n정해진 시간 내에 최대한 많은 수를 보는 것이 유리하기 때문에 탐색 효율을 높이는 것이 중요하다.\n\n### Mini-max Algorithm\n\n특이하게 단말 노드로부터 위로 올라가면서 최소-최대 연산을 반복하여 자신이 선택할 수 있는 방법 중 가장 좋은 값을 선택하는 방법이다.\n\n자신의 턴인 Max 노드에서는 자신에게 유리한 값을 선택하고,\n상대의 턴인 Min 노드에서는 상대에게 불리한 값을 선택하는 방식을 취한다.\n\n![231021-230224](/posts/mid_02/231021-230224.png)\n\n하지만 트리가 넓을 수록 모든 상태공간을 탐색하는건 시간상 너무 오래 걸리기 때문에 최적화 기법이 들어가야 한다.\n바로 **$\\alpha - \\beta$ 가지치기(prunning)** 기법이다.\n\n검토해 볼 필요가 없는 부분을 탐색하지 않도록 하는 기법인데, 어떻게 해야 검토할 필요가 없다는 걸 알 수 있을까?\n\n깊이 우선 탐색(DFS)로 제한 깊이까지 탐색을 하면서 Min, Max 노드의 $\\alpha$, $\\beta$값을 업데이트 하는데, 각 $\\alpha$, $\\beta$값은 다음과 같은 값을 저장한다.\n\n- $\\alpha$\n  Max 노드에서만 값이 업데이트되며, 현재까지 확보한 자식의 값 중 최댓값을 저장함\n\n- $\\beta$\n  Min 노드에서만 값이 업데이트되며, 현재까지 확보한 자식의 값 중 최솟값을 저장함\n\n이 때, 탐색 후 값을 업데이트 하다가 **$\\alpha \\geq \\beta$** 되는 순간이 오는데, 그 때부터 나머지 자식노드는 탐색할 필요가 없어진다.\n그 이유는, 상한선($\\alpha$)과 하한선($\\beta$)이 정해질 때, 그 부모노드의 상한선과 하한선을 넘지 못하면 부모노드를 업데이트 할 수 없기에, 업데이트를 할 가능성이 없다면 가지치기를 해버리는 것이다.\n\n알고리즘의 이해가 안된다면 아래 영상을 참고하면 좋을 거 같다.\n\n\u003cYT id=\"_i-lZcbWkps\" /\u003e\n\n속성으로 빠르게 탐색하고 싶다면 이런 방식으로 탐색해도 된다.\n\n\u003cYT id=\"6qN5ReC2SUA\" /\u003e\n\n빠르게 업데이트 가능한 조건을 적어놓고, 그 조건이 업데이트가 절대로 불가능하다면 나머지 노드를 가지치기 하는 방식이다.\n\n### 몬테카를로 트리 탐색 기법 (Monte Carlo Simulation)\n\n![231022-003000](/posts/mid_02/231022-003000.png)\n\n탐색 공간을 무작위 표본추출을 하면서 탐색 트리를 확장하여 가장 좋아보이는 것을 선택하는 휴리스틱 탐색 방법으로,\n시간이 허용되는 동안 위의 4단계를 반복하여 시뮬레이션 및 트리를 확장한다.\n\n1. 선택\n  선택은 **트리 정책**을 적용하여 선택한다.\n  정책은 개발자 마음대로 정하는 거지만, 보통 승률과 노드 방문횟수를 고려하여 선택한다.\n  일반적으로 `승률이 높으며`, `방문횟수가 적은` 노드에 우선권을 부여한다 (UCB, Upper Confidence Bound 정책).\n\n2. 확장\n  단말 노드에서 트리 정책에 따라 노드를 추가한다.\n\n3. 시뮬레이션\n  기본 정책에 의한 `몬테카를로 시뮬레이션`을 적용한다.\n  무작위 선택, 또는 약간 똑똑한 방법으로 게임이 끝날 때 까지 진행한다.\n\n  \u003ctip\u003e\n  `몬테카를로 시뮬레이션`\n  \u003cbr /\u003e\n  특정 확률 분포로 부터 무작위 표본(또는 약간 똑똑한 방법으로)을 생성하고, 이 표본에 따라 행동을 하는 과정을 반복하여 결과를 확인하고 이 과정을 반복해 최정 결정을 하는 것.\n  \u003cbr /\u003e\n  특정 상태의 유불리를 상태판단함수로 판단하는 것이 아닌, 시뮬레이션으로 판단하게 된다.\n  \u003c/tip\u003e\n\n4. 역전파\n  게임의 결과를 단말 노드에서 루트 노드까지 올라가면서 반영한다.\n\n---\n\n## 제약조건 만족 문제\n\n주어진 제약조건을 만족하는 조합 해(combination solution)을 찾는 문제로 N-Queens problem과 같은 문제가 이에 해당한다.\n\n### 백 트래킹 탐색 (Backtracking search)\n\n깊이 우선 탐색(DFS)을 하는 것처럼 변수에 허용되는 값을 하나씩 대입해보고, 가능한 모든 값을 대입했는데도 만족하는 것이 없으면 이전 단계로 돌아가서 이전 단계의 변수에 다른 값을 대입하는 전형적인 백 트래킹 방식이다.\n\n### 제약조건 전파 (Constraint propagation)\n\n인접 변수 간의 제약 조건에 따라 각 변수에 허용될 수 없는 값들을 제거하는 방식으로, 이름 그대로 주변에 제약조건을 전파하여 선택 가능한 가지수를 줄여가는 방식이다.\n\n![231022-004410](/posts/mid_02/231022-004410.png)\n\nA에 1을 선택하는 순간 B\\~D에 각각 제약사항이 전파되어 B\\~D에서 선택할 수 있는 가지수가 제한된다.\n여기서 B가 3을 선택하는 순간 C, D에 각각 제약사항이 또 전파되는데, 이 때 C는 더이상 아무것도 선택할 수 없기에 이전 스탭에서 다른 제약사항을 걸어야 한다.\n\n---\n\n## 최적화\n\n여러가지 가능, 혀용되는 값들 중에서 주어진 기준을 가장 잘 만족하는 것을 선택하는 것으로, 크게 `조합 최적화`와 `함수 최적화`로 나뉜다.\n\n### 조합 최적화\n\nTSP와 같이 주어진 항목들의 조합으로 해가 표현되는 최적화 문제로, 이 경우에는 경로의 길이를 최소화 하는 문제이다.\n\n![231022-005505](/posts/mid_02/231022-005505.png)\n\n이를 달성하기 위해 생물의 진화를 모방한 집단 기반 확률적 탐색 기법인 `유전 알고리즘`을 사용하기도 한다.\n\n개체는 염색체로 표현되며 다음과 같이 기술된다.\n\n![231022-005704](/posts/mid_02/231022-005704.png)\n\n이런 염색체들의 집합을 `모집단`이라고 하는데, 이런 모집단(후보해)가 문제의 해로서 적합한 정도를 `적합도 함수`가 판단하게 되고, 적합하다면 최적 개체로서 알고리즘이 종료되지만, 적합하지 않다면 **진화의 과정**을 거치게 된다.\n\n모집단이 진화를 할 때는 우선 `부모 모집단` 중 개체를 선택하게 되는데, **가능한 높은 적합도의 개체가 선택되도록 확률을 높게** 조정한다.\n자연선택과 같이 **랜덤**한 요소가 있어야 하기에 반드시 적합한 녀석이 선택되지는 않는다.\n\n이후에는 선택된 부모 개체가 `유전 연산`을 거쳐 자식 개체를 양산하게 되는데, 유전 연산에는 다음과 같은 연산을 고려할 수 있다.\n\n![231022-010201](/posts/mid_02/231022-010201.png)\n\n이후에는 생성된 여러 자식 개체를 이용해서 `세대를 교체`하게 되는데, **최대한 많은 우수한 계체가 다음 세대에 유지**될 수 있도록 `엘리트주의`를 적용한다.\n\n### 목적 최적화\n\n어떤 목적 함수(Objective function)가 있을 때, 이 함수를 최대로 하거나 최소로 하는 변수 값을 찾는 최적화 문제이다.\n\n![231022-010440](/posts/mid_02/231022-010440.png)\n\n`최소 평균제곱법`을 사용해서 회귀(Regression) 문제의 최적함수를 찾거나,\n\n![231022-010602](/posts/mid_02/231022-010602.png)\n\n함수의 최소값 위치를 찾는 문제에서 `경사 하강법`과 같은 방법을 사용할 수 있다.","slug":"univ_ai/mid_02","readingMinutes":11,"wordCount":724},"posts":[{"title":"기계학습 - 비지도 \u0026 반지도학습","description":"비지도 \u0026 반지도학습에서 사용되는 개념에 대해 알아봅니다.","icon":"","image":"","tags":["Unsupervised learning","Clustering","Semi-supervised learning"],"draft":false,"date":"2023-10-22 / 22:58","content":"\n## 비지도학습\n\n지도학습은 학습 데이터에 입력-출력이 명시되어 있었는데, 비지도학습은 학습 데이터에 어떠한 레이블도 붙지 않은 데이터를 이용한 학습 방법을 의미한다.\n\n비지도학습을 통해 데이터에 대한 잠재적인 구조나 계층 구조를 찾을 수 있고, 문서들을 주제에 따라 구조화 하거나, 로그를 분석한 사용 패턴을 알아내는데 적용할 수 있다.\n\n---\n\n## 군집화\n\n유사성에 따라 데이터를 분할하는 것으로, 데이터가 하나의 군집에만 소속되는 일반 군집화(Hard clustering)와 퍼지 군집화(Fuzzy clustering)으로 나뉜다.\n\n군집화는 보통 아래와 같은 용도로 사용된다.\n\n- 데이터에 내제된/일반적 구조 추정/통찰\n- 가설 설정\n- 이상 감지\n- 데이터 압축\n- 데이터 전처리 (부류(class)를 부여하는 방식)\n\n성능은 군집 내의 분산은 작을수록, 군집간의 거리는 멀수록 좋다고 평가한다.\n\n### 밀도 추정\n\n![231022-230608](/posts/mid_08/231022-230608.png)\n\n부류(class)별로 데이터를 만들어 냈을 것으로 추정되는 확률 분포를 찾는 과정으로, 각 부류 별로 주어진 데이터를 발생시키는 확률을 계산하여 가장 확률이 높은 부류로 데이터를 분류한다.\n\n분포가 수학적인 형태를 갖고있을 것을 가정하여 데이터의 분포를 가장 잘 수학적으로 표현하려고 하는 추정 방식을 `모수적 밀도 추정` 이라고 하며, 전형적으로 **Gaussian 함수의 혼합**으로 표현한다.\n\n또는, 분포에 대한 수학적 함수를 가정하지 않고, 주어진 데이터를 사용하여 밀도함수의 형태로 표현하는 방식을 `비모수적 밀도 추정` 이라고 하며, 전형적으로 **히스토그램**과 같은 방식으로 표현한다.\n\n### 차원 축소\n\n고차원의 데이터를 정보의 손실을 최소화 하면서 저차원으로 변환하는 것으로, 시각화를 직관적으로 하기 위해, 그리고 `차원의 저주 문제`를 완화하기 위해 사용한다.\n\n\u003ctip\u003e\n  `차원의 저주 문제`\n  \u003cbr /\u003e\n  ![231022-231121](/posts/mid_08/231022-231121.png)\n  차원이 커질수록 거리분포가 일정해지는 경향\n\u003c/tip\u003e\n\n![231022-231254](/posts/mid_08/231022-231254.png)\n\n이를 위해 주성분을 분석하여 분산이 큰 축을 기준으로 데이터를 projection하는 방식을 사용해서 저차원으로 변환한다.\n\n### 이상치 탐지\n\n다른 데이터와 크게 달라서 관심 대상으로 봐야하는 데이터를 탐지하기 위해 사용한다.\n이런 관심대상의 데이터는 `노이즈`일 확률이 높으나, `신규성 탐지`의 경우도 항상 염두해야 한다.\n\n이상치는 아래와 같은 방식으로 탐지할 수 있다.\n\n- 점 이상치\n  다른 데이터와 비교하여 차이가 큰 데이터\n\n- 상황적 이상치\n  상황에 맞지 않는 데이터\n\n- 집단적 이상치\n  여러 데이터를 모아서 보면 비정상으로 보이는 데이터\n\n이러한 이상치 탐지는 **부정사용감지 시스템**이나 **침임감지 시스템** 등에 사용할 수 있다.\n\n---\n\n## 반지도학습\n\n비지도학습과 마찬가지로 미분류 데이터를 이용하는데, 이를 지도학습에 사용하는 방법이다.\n\n![231022-231828](/posts/mid_08/231022-231828.png)\n\n이런 식으로 같은 군집에 속하는 것은 가능한 동일한 부류에 소속하도록 학습하는 방식이다.\n미분류 데이터는 획득 비용이 낮기 때문에 이러한 지도학습 방식도 고려하면 좋다.\n\n단, 반지도학습을 위해서는 데이터가 아래와 같은 경향을 보인다는 가정하에 이루어져야 한다.\n\n- 평활성 가정\n  가까이 있는 점들은 서로 같은 부류에 속할 가능성이 높음\n\n- 군집 가정\n  같은 군집에 속하는 데이터는 서로 같은 부류에 속할 가능성이 높음\n\n- 매니폴드(Manifold) 가정\n  원래 차원보다 낮은 차원의 매니폴드에 데이터가 분포할 가능성이 높음","slug":"univ_ai/mid_08","readingMinutes":6,"wordCount":382},{"title":"기계학습 - 지도학습","description":"지도학습에서 사용되는 개념에 대해 알아봅니다.","icon":"","image":"","tags":["Supervised learning","Classification","Regression"],"draft":false,"date":"2023-10-22 / 22:02","content":"\n## 기계학습\n\n사례들(examples)을 일반화하여 패턴 또는 모델을 추출하는 과정으로 학습 데이터를 잘 설명할 수 있는 패턴을 기계 스스로 학습하는 것을 유도하는 것이다.\n\n![231022-220530](/posts/mid_07/231022-220530.png)\n\n단, 오컴의 면도날(Occam's razor) 원리에 따라 가능하면 학습 결과가 간단한 형태로 표현되면 좋다.\n\n기계학습의 종류에는 지도학습, 비지도학습, 반지도학습, 강화학습과 같은 방법이 있는데, 이번에는 지도학습에 대해서만 알아보자.\n\n### 지도학습\n\n주어진 학습 데이터 - **(입력, 출력)** 과 같은 데이터를 이용해서 학습하는 과정.\n학습이 완료된 모델은 새로운 **(입력)** 이 있을 때 **(출력)** 을 유추할 수 있어야 한다.\n\n출력이 불 연속적인 값이어야 한다면 데이터를 `분류`하는 방향으로 학습을 해야하고,\n출력이 연속적인 값이어야 한다면 `회귀`하는 방향으로 학습을 해야한다.\n\n---\n\n## 분류 (Classification)\n\n이상적인 분류기는 학습에 사용되지 않은 데이터에 대해서 분류를 잘 해야한다.\n즉, 일반화의 능력이 좋은것이 이상적인 분류기이다.\n\n\u003ctip\u003e\n  데이터의 종류\n  1. 학습 데이터\n    분류기를 학습하는데 사용하는 데이터 집합.\n  2. 테스트 데이터\n    학습된 모델의 성능을 평가하는데 사용하는 데이터 집합.\n    학습에 사용되지 않은 데이터여야 함.\n  3. 검증 데이터\n    학습 과정에서 학습을 중단할 시점을 결정하기 위해 사용하는 데이터 집합.\n\u003c/tip\u003e\n\n![231022-221446](/posts/mid_07/231022-221446.png)\n\n학습 데이터를 충분히 학습하지 않은 상태를 `부적합` 이라고 한다.\n\n반대로학습 데이터에 대해 지나치게 잘 학습된 상태를 `과적합` 이라고 하는데, 학습되지 않은 데이터에 대해 좋지 못할 성능을 보일 가능성이 크다.\n과적합을 회피하기 위해서 검증 데이터를 사용하게 된다.\n\n![231022-221636](/posts/mid_07/231022-221636.png)\n\n검증 데이터에 대한 오류가 증가하기 시작하면 학습 데이터에 대해 과적합이 일어나는 시점이기 때문에 이 때 학습을 중지하는 것이 좋다.\n\n### 불균형 데이터 문제\n\n특정 부류에 속하는 학습 데이터의 개수가 **다른 부류에 비해 지나치게 많은 경우** 정확도에 의한 성능 평가가 무의미해진다.\n이게 무슨 의미냐면, A 부류의 데이터가 전체 데이터의 99%를 차지한다면, 분류기의 출력을 항상 A로 설정하는 경우 해당 학습 데이터에 대해 99%의 정확도를 보일 것이다.\n하지만, 테스트 데이터에선 A/B가 각각 50% 비율로 들어있다면, 분류기의 정확도는 50%로 감소할 것이다.\n\n![231022-222326](/posts/mid_07/231022-222326.png)\n\n이런 경우 SMOTE 알고리즘을 이용해 어느정도 해결할 수 있다.\n간단하게 설명하면 빈도가 낮은 학습 데이터의 `k-근접 이웃`을 이용해 새로운 데이터를 생성하여 빈도가 낮은 부류의 데이터 개수를 늘리는 알고리즘이다.\n\n### 이진 분류기 성능 평가\n\n이진 분류기는 두 개의 부류만을 갖는 데이터에 대한 분류기로 A/B 둘 중 하나로 분류하는 분류기이다.\n이 분류기는 아래와 같은 예측-결과 표를 생성하는데,\n\n![231022-222646](/posts/mid_07/231022-222646.png)\n\n이것을 이용한 여러가지 지표로 성능을 평가한다.\n\n- 민감도/재현율/진양성율\n  실제 양성일 때, 양성이라고 예측하는 확률이다.\n  \u003e 민감도 = $\\frac{TP}{TP + FN}$\n  \u003e\n  \u003e e.g. 불이났을 때, 불이 났다고 민감하게 알려주는 화재경보기\n\n- 특이도/진음성률\n  실제 음성일 때, 음성이라고 예측하는 확률이다.\n  \u003e 특이도 = $\\frac{TN}{TN + FP}$\n  \u003e\n  \u003e e.g. 불이 안났을 때, 울리지 않는 화재경보기\n\n- 정밀도\n  양성으로 예측을 했는데, 실제로 양성일 확률.\n  \u003e 정밀도 = $\\frac{TP}{TP + FP}$\n  \u003e\n  \u003e e.g. 화재경보기가 경보를 울렸는데, 실제로 불이 난 상황이었음\n\n- 음성 예측도\n  음성으로 예측을 했는데, 실제로 음성일 확률.\n  \u003e 음성 예측도 = $\\frac{TN}{TN + FN}$\n  \u003e\n  \u003e e.g. 화재경보기가 안울렸는데, 실제로 불도나지 않았음\n\n- 위양성율\n  1에서 특이도를 뺀 값.\n  \u003e 위양성율 = $\\frac{FP}{TN + FP}$ = 1 - 특이도\n\n- 위발견율\n  1에서 정밀도를 뺀 값.\n  \u003e 위발견율 = $\\frac{FP}{TP + FP}$ = 1 - 정밀도\n\n- 정확도\n  예측한대로 결과가 나올 확률.\n  \u003e 정확도 = $\\frac{TP + TN}{TP + FP + TN + FN}$\n\n- F1 측도\n  \u003e F1 = 2$\\frac{정밀도 \\times 재현율}{정밀도 + 재현율}$\n\n### ROC 곡선\n\n위양성률, 민감도 그래프로 ROC 곡선의 아래 면적, AUC(Area Under the Curve)가 클수록 바람직하게 분류한다는 뜻이다.\n\n![231022-224153](/posts/mid_07/231022-224153.png)\n\n---\n\n## 회귀 (Regression)\n\n학습 데이터에 부합되는 출력값이 실수인 함수를 찾는 문제로, 앞에서 언급했 듯, 출력이 연속적이어야 하는 경우에 사용하는 방법이다.\n\n![231022-224546](/posts/mid_07/231022-224546.png)\n\n파란 점과 같은 학습 데이터가 주어졌을 떄, 해당 데이터를 가장 잘 설명하는 모델 **$f$** 를 찾기 위해서는 $f$의 오차를 계산하는 함수 **$f*$** 이 최소가 되도록 인자를 조정해야 한다.\n\n$$\nf*(x) = argmin_f \\sum_{i=1}^{n} (y_i - f(x_i))^2\n$$\n\n### 회귀 성능 평가\n\n학습 방향성과 같다.\n테스트 데이터에 대한 오차값의 평균이 작을수록 좋다.\n\n![231022-225021](/posts/mid_07/231022-225021.png)\n\n하지만 처음에 언급했 듯 과적합되는 현상은 피해야 한다.\n\n이를 위해 모델의 복잡도를 일종의 **패널티**로써 성능 평가(목적함수)에 반영하여, 모델의 복잡도를 최소화 하는 방향으로 학습을 유도해야 한다.\n\n### 로지스틱 회귀 (Logistic regression)\n\n모델의 출력이 [0, 1] 사이의 값을 갖도록 조정해야 하는 경우 sigmoid 함수와 같은 로지스틱 함수를 이용해서 학습 데이터의 출력을 근사하는 방식을 사용할 수도 있다.\n\n![231022-225434](/posts/mid_07/231022-225434.png)\n\n단, 이 때의 목적 함수는 `교차 엔트로피`(오차가 0~1 사이로 조정됨)가 적용된 함수를 사용해야 한다.\n\n로지스틱 회귀는 경사 하강법을 사용하는 학습에서 자주 사용된다.","slug":"univ_ai/mid_07","readingMinutes":9,"wordCount":660},{"title":"규칙 기반 시스템","description":"지식을 규칙의 형태로 표현하는 방법에 대해 알아봅니다.","icon":"","image":"","tags":["전향 추론","후향 추론","규칙 기반 시스템"],"draft":false,"date":"2023-10-22 / 19:59","content":"\n## 추론\n\n구축된 지식과 주어진 데이터, 정보를 이용해 새로운 사실을 생성하는 것으로 전향(순방향) 추론과 후향(역방향) 추론으로 나뉜다.\n\n### 전향 추론\n\n규칙의 조건부와 만족하는 사실이 있을 때 규칙의 결론부를 실행하거나 처리하는 방식으로 아래와 같이 순방향으로 추론하는 방식이다.\n\n![231022-200403](/posts/mid_06/231022-200403.png)\n\n### 후향 추론\n\n어떤 사실을 검증하거나 확인하고 싶은 경우에 관심 대상의 사실을 결론부에 갖고 있는 규칙을 찾아서 조건부가 만족하는지를 확힌하는 방식으로 아래와 같이 역방향으로 추론하는 방식이다.\n\n![231022-200616](/posts/mid_06/231022-200616.png)\n\n---\n\n## 규칙 기반 시스템\n\n지식을 규칙과 사실로 기술하며 아래와 같은 구조로 관리된다.\n\n![231022-200851](/posts/mid_06/231022-200851.png)\n\n**문제 해결을 위한 지식**인 `규칙`은 규칙 베이스에서 관리되며, 생성 메모리 라고도 불린다.\n\n**문제에 대해 알려진 데이터나 정보**인 `사실`은 작업 메모리에서 관리된다.\n참고로, 추론 과정의 중간 결과나 사용자로부터 받은 문제에 대한 정보 역시 여기서 관리된다.\n\n### 추론 엔진\n\n실행할 수 있는 규칙을 찾아 해당 규칙을 실행하는데 아래의 3단계의 과정을 반복한다.\n\n1. 패턴 매칭\n  작업 메모리의 사실과 규칙 메모리에 있는 규칙의 조건부를 대조하여 일치하는 규칙을 찾아냄.\n\n2. 경합 해소\n  찾아낸 규칙 중 경합되는 규칙(경합 집합)에 대해 하나의 규칙을 선택함.\n  경합 해소 전략에는 다음과 같은 전략이 있음.\n\n    \u003e 1. 규칙 우선\n    \u003e 미리 규칙에 우선순위를 부여하고, 경합시 우선순위가 높은 규칙을 우선 선택\n    \u003e 우선순위 태그 기준\n    \u003e ![231022-201805](/posts/mid_06/231022-201805.png)\n    \u003e\n    \u003e 2. 최신 우선\n    \u003e 가장 최근에 입력된 데이터와 매칭된 규칙을 우선 선택\n    \u003e 시간 태그 기준\n    \u003e ![231022-201845](/posts/mid_06/231022-201845.png)\n    \u003e\n    \u003e 3. 최초 우선\n    \u003e 경합 집합에서 가장 먼저 매칭된 규칙을 우선 선택\n    \u003e\n    \u003e 4. 상세 우선\n    \u003e 조건부가 가장 상세하거나 복잡한 규칙을 우선 선택\n    \u003e 태그말고 조건문의 길이 기준\n    \u003e ![231022-201826](/posts/mid_06/231022-201826.png)\n    \n\n3. 규칙 실행","slug":"univ_ai/mid_06","readingMinutes":4,"wordCount":241},{"title":"불확실한 지식 표현","description":"불확실한 지식을 표현하는 방법에 대해 알아봅니다.","icon":"","image":"","tags":["Certainty factor","Probability","Fuzzy"],"draft":false,"date":"2023-10-22 / 19:10","content":"\n인과성이 약하거나, 연관성이 애매하거나, '얼마나?'에 해당하는 정도가 모호한 문장을 정량화 하는 방법에 대해 알아봅니다.\n\n## 확신도 (Certainty factor)\n\n규칙과 사실의 신뢰정도를 [-1, 1] 구간의 값으로 표현합니다.\n\n| 확신도 | 대응되는 단어 |\n|---|---|\n| −1.0 | 절대 아니다 (definitely not)|\n| −0.8 | 거의 확실히 아니다 (almost certainly not) |\n| −0.6 | 아마 아니 것이다 (probably not) |\n| −0.4 | 어쩌면 아닐 것이다 (maybe not) |\n| −0.2 ~ 0.2 | 모르겠다 (unknown) |\n| 0.4 | 어쩌면 그럴 것이다 (maybe) |\n| 0.6 | 아마 그럴 것이다 (probably) |\n| 0.8 | 거의 확실하다 (almost certainly) |\n| 1.0 | 확실하다 (definitely)|\n\n### 추론결과의 확신도\n\n추론에 대한 확신도는 각 명제에 대한 확신도를 계산하여 도출해야 합니다.\n\n- IF A THEN B _($\\{A \\rightarrow B, \\; A\\} \\vdash B$)_\n  기본적으로 정형식들의 확신도를 곱하는 방식으로 구합니다.\n  \u003e **$cf(B) = cf(A) \\times cf(A \\rightarrow B)$**\n\n- IF A and B THEN C _($\\{A \\wedge B \\rightarrow C, \\; A, \\; B\\} \\vdash C$)_\n  **and**의 경우 조건부에 해당하는 정형식의 확신도 중 작은 값을 고릅니다.\n  \u003e **$cf(C) = min\\{cf(A), cf(B)\\} \\times cf(A \\wedge B \\rightarrow C)$**\n\n- IF A or B THEN C _($\\{A \\vee B \\rightarrow C, \\; A, \\; B\\} \\vdash C$)_\n  **or**의 경우 조건부에 해당하는 정형식의 확신도 중 큰 값을 고릅니다.\n  \u003e **$cf(C) = max\\{cf(A), cf(B)\\} \\times cf(A \\vee B \\rightarrow C)$**\n\n아래는 예시입니다.\n\n![231022-192422](/posts/mid_05/231022-192422.png)\n\n만약, 여러 사실에 의해 동일한 사실을 추론하는 경우 추론 결과는 같지만, 확신도는 다르게 계산될 수 있습니다.\n이런 경우, 확신도를 하나로 통합하는게 좋습니다.\n\n![231022-192640](/posts/mid_05/231022-192640.png)\n\n---\n\n## 확률 (Probability)\n\n어떤 사건이 일어날 가능성을 표현할 때 사용합니다.\n\n### 결합 확률\n\n사건 A, B가 동시에 일어날 확률을 가리키며, 아래와 같이 수식화 할 수 있습니다.\n\n\u003e A: 첫 번째 주사위가 짝수\n\u003e B: 두 번째 주사위가 홀수\n\u003e\n\u003e $P(A,B) = P(A \\cap B) = P(AB)$\n\u003e $= 1/2 \\times 1/2 = 0.25$\n\n### 조건부 확률\n\n사건 B가 일어났을 때, 사건 A가 일어날 확률을 가리키며, 아래와 같이 수식화 할 수 있습니다.\n\n\u003e A: 두 주사위의 합이 8\n\u003e B: 첫 번째 주사위가 3\n\u003e\n\u003e $P(A|B) = \\frac{P(A,B)}{P(B)}$\n\u003e $= \\frac{1/36}{1/6} = 1/6$\n\n`베이즈 정리`에 의해 조건부 확률의 조건부를 변형할 수 있습니다.\n\n\u003e $P(A|B) = \\frac{P(B|A)P(A)}{P(B)}$\n\n---\n\n## 퍼지 이론 (Fuzzy theory)\n\n기존 집합론과 다르게 퍼지 이론은 0/1의 이분법적으로 분류하지 않고, 0~1로 모호하게(어느정도 포함되게) 구분함.\n즉, 어느 정도(degree)의 문제는 퍼지 집합을 도입하여 해결.\n\n### 퍼지 집합\n\n원소가 모임(collection)에 어느 정도 속한다는 것을 표현한 것으로, 해당 집합은 부분적으로 참이 됨.\n소속정도는 [0, 1] 범위의 실수값으로 표현함.\n\n작다, 평균이다, 크다의 표현을 아래와 같이 다르게 할 수 있음.\n\n![231022-194330](/posts/mid_05/231022-194330.png)\n\n### 퍼지 규칙\n\n소속함수로 표현된 언어항을 표함하는 규칙.\n\n\u003e IF service = 나쁘다 OR food = 별로이다 THEN tip = 적다\n\u003e IF service = 보통이다 THEN tip = 보통이다\n\u003e IF service = 훌륭하다 OR food = 맛있다 THEN tip = 많다\n\n\u003ctip\u003e\n  `언어항`\n  '나쁘다', '맛있다', '많다'와 같은 자연어에 해당하는 항으로 소속함수로 표현될 수 있다. \n  ![231022-194851](/posts/mid_05/231022-194851.png)\n\u003c/tip\u003e\n\n### 퍼지 추론\n\n소속함수로 표현돤 언어항을 사용하는 퍼지 규칙들의 모음으로 수치적인 추론이 가능해진다.\n\n![231022-195645](/posts/mid_05/231022-195645.png)\n\n추론된 영역의 무게중심을 결과로 사용하면 `비퍼지화`가 가능하다.","slug":"univ_ai/mid_05","readingMinutes":5,"wordCount":496},{"title":"명제 논리 \u0026 술어 논리","description":"지식을 표현하는 방법 - 논리에 대해 알아봅니다.","icon":"","image":"","tags":["Proposition","Predicate"],"draft":false,"date":"2023-10-22 / 15:48","content":"\n말로 표현된 문장을 타당한 추론을 위해 기호를 사용하여 표현하고, 기호의 조작을 통해 참과 거짓을 판정하는 분야이다.\n\n## 명제 논리\n\n### 명제 (Proposition)\n\n`명제`란, 참과 거짓을 분평하게 판정할 수 있는 문장으로 P, Q와 같은 기호로 표현된다.\n\n중요한 점은, 명제 그 자체는 참, 거짓을 결정할 수 없고, 반드시 기호의 진리값을 설정해 줘야 한다는 점이다.\n이게 무슨 말이냐면, 아래의 문장을 예로 들어 설명해보겠다.\n\n\u003e 오징어 다리는 10개 이다.\n\n이 명제는 우리나라에서는 참이다.\n하지만 북한에서는 오징어 라는 명사는 우리나라의 낙지를 가리키는 말 이기 때문에 북한에서는 거짓인 명제이다.\n\n즉, 문장 자체의 내용에 대해서는 관심을 갖지 말고, 문장의 설정된 `진리값에만 관심`을 가져야 한다.\n\n_**용어 설명**_\n| 용어 | 의미 |\n|---|---|\n| 기본 명재 | 하나의 진술로만 이루어진 최소 단위의 명제 |\n| 복합 명제 | 기본 명제들이 결합되어 만들어진 명제 |\n\n### 논리식 (Logical expression)\n\n명제를 기호로 표현한 형식으로 명제기호, T/F, 논리 기호를 사용하여 구성되는데, 가장 기본이 되는 논리 기호는 다음과 같다.\n\n| 논리기호 | 이름 | 논리식 | 의미 |\n|---|---|---|---|\n| $\\neg$ | 부정 (negation) | $\\neg P$ | $P$가 아님 |\n| $\\vee$ | 논리합 (disjunction) | $P \\vee Q$ | $P$ 또는 $Q$ |\n| $\\wedge$ | 논리곱 (conjunction) | $P \\wedge Q$ | $P$ 그리고 $Q$ |\n| $\\rightarrow$ | 함의 (implication) | $P \\rightarrow Q$ | $P$ 이면 $Q$ |\n| $\\equiv$ | 동치 (equivalence) | $P \\equiv Q$ | $(P \\rightarrow Q) \\wedge (Q \\rightarrow P)$ |\n\n_**용어 설명**_\n| 용어 | 의미 |\n|---|---|\n| 리터럴 | 명제 기호 또는 명제 기호의 부정 |\n| 절 | 리터럴들이 논리합이나 논리곱으로만 연결 (논리합 절, 논리곱 절) |\n| 논리곱 정규형 (CNF) | 논리합 절들이 논리곱으로 연결되어 있는 논리식 |\n| 논리합 정규형 (DNF) | 논리곱 절들이 논리합으로 연결되어 있는 논리식 |\n| 정형식 (WFF) | 진리값(T/F)과 명제, 그들과 논리 기호를 사용하여 구성된 논리식을 의미함 |\n\n### 진리표 (Truth table)\n\n논리기호에 따라 T/F를 결합하는 방법을 나타낸 표\n\n| $P$ | $Q$ | $\\neg P$ | $P \\vee Q$ | $P \\wedge Q$ | $P \\rightarrow Q$ | $P \\equiv Q$ |\n|---|---|---|---|---|---|---|\n| F | F | **T** | F | F | **T** | **T** |\n| F | **T** | **T** | **T** | F | **T** | F |\n| **T** | F | F | **T** | F | F | F |\n| **T** | **T** | F | **T** | **T** | **T** | **T** |\n\n- 타당한 논리식 (Valid logical expression), 항진식\n  모든 가능한 해석에 대해 항상 참인 논리식\n  _e.g. $P \\vee \\neg P$_\n\n- 항위식\n  모든 가능한 해석에 대해 항상 거짓인 논리식\n  _e.g. $P \\wedge \\neg P$_\n\n- 츙족가능한 논리식\n  참으로 만들 수 있는 해석이 하나라도 있는 논리식\n\n- 충족불가능한 논리식\n  참으로 만들 수 있는 해석이 하나도 없는 논리식. 즉, 항위식.\n\n### 동치 관계 (Equivalence relation)\n\n어떠한 해석에 대해서도 같은 진리 값을 갖는 두 논리식\n\n- $\\neg(\\neg p) \\equiv p$\n- $p \\vee F \\equiv p$\n  $p \\wedge T \\equiv p$\n- $P \\vee \\neg P \\equiv T$\n  $P \\wedge \\neg P \\equiv F$\n- **$\\neg (p \\wedge q) \\equiv \\neg p \\vee \\neg q$**\n  **$\\neg (p \\vee q) \\equiv \\neg p \\wedge \\neg q$**\n- **$p \\rightarrow q \\equiv \\neg p \\vee q$**\n- $p \\vee (q \\vee r) \\equiv p \\vee q \\vee r$\n  $(p \\wedge q) \\wedge r \\equiv p \\wedge q \\wedge r$\n- **$p \\vee (q \\wedge r) \\equiv (p \\vee q) \\wedge (p \\vee r)$**\n  **$p \\wedge (q \\vee r) \\equiv (p \\wedge q) \\vee (p \\wedge r)$**\n\n### 논리적 귀결 (Logical entailment)\n\n정형식(Well-Formed Formula, WFF)의 집합 $\\Delta$가 다른 정형식 $\\omega$를 참으로 만든다면 두 관계를 아래와 같이 정의한다.\n\n\u003e $\\Delta \\models \\omega$\n\u003e e.g. $\\{P, \\; P \\rightarrow Q\\} \\models Q$\n\u003e\n\u003e $\\Delta$는 $\\omega$를 논리적으로 귀결한다.\n\u003e $\\omega$는 $\\Delta$를 논리적으로 따른다.\n\u003e $\\omega$는 $\\Delta$의 논리적 결론이다.\n\n### 추론 (Inference)\n\n논리적 귀결을 도출하는 과정을 추론이라고 한다.\n\n관측된 복수의 사실들을 일반화하여 일반적인 패턴(명제)를 도출하는 것을 `귀납적 추론` 이라고 하고,\n참인 명제(사실)들로부터 새로운 명제(사실)을 도출하는 것을 `연역적 추론` 이라고 한다.\n\n논리에서의 추론은 보통 **연역적 추론**을 가리키는데, 이걸 도출하는 테크닉에 대해 살펴보자.\n\n- 긍정 논법\n  $\\{p \\rightarrow q, \\; p\\} \\vdash q$\n  _(\\{새이다 \u0026rarr; 날 수 있다, 새이다\\} \u0026rarr; 날 수 있다)_\n\n- 부정 논법\n  $\\{p \\rightarrow q, \\; \\neg q\\} \\vdash \\neg p$\n  _(\\{새이다 \u0026rarr; 날 수 있다, 날 수 없다\\} \u0026rarr; 새가 아니다)_\n\n- 삼단 논법\n  $\\{p \\rightarrow q, \\; q \\rightarrow r\\} \\vdash p \\rightarrow r$\n  _(\\{새이다 \u0026rarr; 날개가 있다, 날개가 있다 \u0026rarr; 날 수 있다\\} \u0026rarr; 새이다 \u0026rarr; 날 수 있다)_\n\n- **논리 융합 (Resolution)**\n  긍정, 부정, 삼단 논법을 포함한 일반화된 추론 규칙으로 \n  두 개의 **논리합 절**이 같은 기호의 긍정-부정 리터럴을 서로 포함하고 있을 때, 해당 리터럴을 제외한 나머지 리터럴의 논리합 절을 만들어 내는 것.\n\n  | 논법 | 변환 | WFF (논리 융합식, Resolvent) |\n  |---|---|---|\n  | $p \\rightarrow q, \\; p$ | **$\\neg p$** $\\vee q$, **$p$** | $q$ |\n  | $p \\rightarrow q, \\; \\neg q$ | $\\neg p \\vee$ **$q$**, **$\\neg q$** | $\\neg p$ |\n  | $p \\rightarrow q, \\; q \\rightarrow r$ | $\\neg p \\vee$ **$q$**, **$\\neg q$** $\\vee r$ | $\\neg p \\vee r$ ($p \\rightarrow r$) |\n\n  즉, 논리 융합을 사용하면 모든 추론 규칙을 일반화 할 수 있다.\n\n- 정당성 (sound)\n  $\\Delta \\vdash \\omega \\; \\rightarrow \\; \\Delta \\models \\omega$ (아야 sound)\n\n- 완전성 (complete)\n  $\\Delta \\models \\omega \\; \\rightarrow \\; \\Delta \\vdash \\omega$ (야아 complete 하네)\n\n  \u003ctip\u003e\n    정당성과 완전성을 동시에 만족하는 추론 규칙은 논리적인 귀결과 동일시 할 수 있다.\n  \u003c/tip\u003e\n\n### 증명 (Proof)\n\n- 구성적 증명 (Constructive proof)\n  공리(참인 논리식)들에 추론 규칙을 적용하여 참을 만들어 보이는 증명.\n  정리하다가 결론이 참으로 끝나면 된다.\n\n- 논리융합 반박 (Resoultion refutation)\n  증명할 정리를 일단 부정하고, 논리융합 방법을 적용해 모순이 발생함으로 보이는 증명.\n  부정된 정리가 모순이니, 원상태의 정리는 참이 된다.\n\n  ![231022-171322](/posts/mid_04/231022-171322.png)\n\n---\n\n## 술어 논리\n\n명제의 내용을 다루기 위해 변수, 함수 등을 도입하고, 이들의 값에따라 T/F가 결정되도록 명제 논리를 확장한 논리.\n\n### 술어 (Predicate)\n\n대상의 속성이나 관계를 기술하는 기호로, 대상에게 T/F를 부여하는 명제의 기본 형식이다.\n\n| 문장 | 명제 논리 | 술어 논리 |\n|---|---|---|\n| 모든 사람은 죽는다 | P | $\\forall x(사람(x) \\rightarrow 죽는다(x))$ |\n| 소크라테스는 사람이다 | Q | $사람(소크라테스)$ |\n| 소크라테스는 죽는다 | R | $죽는다(소크라테스)$ |\n\n\u003ctip\u003e\n  `존재 한정사`\n  Existential quantifier로 존재함을 알려준다. (**$\\exist$**)\n  \u003cbr /\u003e\n  `전칭 한정사`\n  Universal quantifier로 모든 범위를 가리킨다. (**$\\forall$**)\n\u003c/tip\u003e\n\n### 함수 (function) / 항 (term)\n\n주어진 인자에 대해 T/F를 반환하는 것이 아닌, 일반작인 값을 반환하는 것을 `함수`라고 한다.\n즉, 인자를 지칭하기 위해 쓰인다.\n\n함수의 인자가 될 수 있는 것을 `항` 이라고 한다.\n**상수, 변수, 함수**만이 항이 될 수 있다.\n\n\u003ctip\u003e\n  명제 논리식의 정형식(WFF)과 마찬가지로, 술어 논리식의 정형식 역시 비슷한 정의를 갖는다.\n  항, 논리 기호, 한정사로만 이루어진 식을 정형식이라고 부른다.\n\u003c/tip\u003e\n\n### N차 술어 논리 (N-order predicate logic)\n\n**변수에만** 한정사를 사용할 수 있도록 한 술어 논리를 `일차 술어논리(FOL)` 라고 한다.\n엄밀히는, 술어기호의 인자로 사용될 수 있는 객체나 대상만을 변수화 할 수 있고, 이들 변수에만 전칭 한정사와 존재 한정사를 쓸 수 있도록 한 술어논리를 말한다.\n\n**변수, 함수, 술어기호**에 대해 한정사를 쓸 수 있도록 한 술어 논리를 `고차 술어논리(HOL)` 라고 한다.\n엄밀히는, 함수나 술어기호도 변수화 할 수 있고, 이들 변수에만 전칭 한정사와 존재 한정사를 쓸 수 있도록 한 술어논리를 말한다.\n\n인공지능 분야에서는 **연산량의 한계** 때문에 `일차 술어논리`를 주로 사용한다.\n\n### CNF 변환\n\n아래의 변환 과정을 거친면 된다.\n\n1. 한정사를 논리식의 맨 앞으로 끌어내는 변환\n  일반적으로 한정사를 맨 앞으로 끌어내도 의미는 변하지 않지만, 그래도 최다한 할 수 있는 변환을 한 뒤에 끌어내자.\n\n2. 전칭 한정사 제거\n  $\\forall$은 바로 제거해도 상관없다.\n\n3. 존재 한정사 제거\n  우선 아래와 같은 방식으로 전칭 한정사로 변환한 뒤 전칭 한정사를 제거하는 방법을 사용한다.\n  **$\\neg \\exist x P \\equiv \\forall x \\neg P$**\n\n    만일 함수에 변수가 2개 이상 사용된 경우 변환이 어려울 때는 상수를 집어넣거나 스콜렘 함수로 변환한다.\n    $\\forall x \\exist y [P(x) \\wedge$ **$Q(x, y)$**$] \\rightarrow \\forall x [P(x) \\wedge$ **$Q(x, s(x))$**$]$\n\n4. 단일화\n  논리 융합을 적용할 때, 대응되는 리터럴이 같아지도록 상수를 변수화 함.\n  ![231022-175353](/posts/mid_04/231022-175353.png)\n\n변환 과정을 거쳐 논리융합 반박을 통해 증명하는 예시를 살펴보자.\n아래의 예시는 (5)의 모순을 보임으로써 $\\neg$(5)가 참임을 보이는 논리융합 반박이다.\n\n![231022-175534](/posts/mid_04/231022-175534.png)","slug":"univ_ai/mid_04","readingMinutes":13,"wordCount":1309},{"title":"프레임 \u0026 의미망 \u0026 스크립트","description":"지식을 표현하는 방법 - 프레임, 의미망, 스크립트에 대해 알아봅니다.","icon":"","image":"","tags":["Frame"],"draft":false,"date":"2023-10-22 / 15:35","content":"\n## 프레임 (Frame)\n\n특정 객체 또는 개념에 대한 전형적인 지식을 슬롯(slot)의 집합으로 표현하는 것으로, 컴퓨터를 표현한 프레임은 다음과 같이 기술할 수 있다.\n\n![231022-153840](/posts/mid_03/231022-153840.png)\n\n### 슬롯 (slot)\n\n객체의 속성(attribute)를 기술하는 것으로 슬롯 이름과 값으로 구성된다.\n슬롯 값은 복수개의 `패싯`과 `데몬`으로 구성된다.\n\n- 패싯 (facet)\n  속성에 대한 부가적인 정보를 저장하기 위해 사용되며 아래와 같은 패싯 이름들을 사용할 수 있다.\n  - value: 속성 값\n  - data-type: 속성의 자료형\n  - default: 기본 값\n  - require: 슬롯에 들어갈 수 있는 값이 만족해야 할 제약조건\n\n- 데몬 (demon)\n  ![231022-154436](/posts/mid_03/231022-154436.png)\n\n  지정된 조건을 만족할 때 실행할 절차적 지식을 기술하는데 사용되며, 아래와 같은 데몬 이름들을 사용할 수 있다.\n  - if_needed: 슬롯 값을 알아야 할 때(즉, 사용하려고 할 때)\n  - if_added: 슬롯 값이 추가될 때\n  - if_removed: 슬롯 값이 제거될 때\n  - if_modified: 슬롯 값이 수정될 때\n\n### 클래스 프레임\n\n위에서 프레임을 설명할 때 사용한 프레임이 클래스 프레임이다.\n\n\u003ctip\u003e\n  하위 프레임이 상위 프레임을 상속받는 계층구조도 가질 수 있음.\n\u003c/tip\u003e\n\n### 인스턴스 프레임\n\n![231022-154657](/posts/mid_03/231022-154657.png)\n\n클래스 프레임을 특정 객체에 대한 정보로 표현하면 인스턴스 프레임이 된다.\n그냥 OOP와 같은 개념이다.\n\n---\n\n## 의미망 (Semantic network)\n\n![231022-184947](/posts/mid_03/231022-184947.png)\n\n노드와 방향성 간선으로 구성되는 그래프를 이용해 지식을 표현하는 방법으로, 이항 관계만을 표현한다.\n그렇기에 다항 관계도 이항 관계로 전개하여 표현해야 하는데, 그 때문에 관계(relation) 역시 객체로 간주하여 표현한다.\n\n![231022-185755](/posts/mid_03/231022-185755.png)\n\n- `is-a`\n  자식 is-a 부모, 인스턴스 is-a 클래스와 같은 관계의 간선을 표현한다.\n\n- `has-a`\n  전체 has-a 부분, 부분 part-of 전체와 같은 관계의 간선을 표현한다.\n\n\u003ctip\u003e\n  is-a, has-a는 추이적 관계를 만족하는데, 추이적 관계란, 3단논법과 같은 관계를 의미함.\n  \n  \u003e is-a(팽귄, 조류) $\\wedge$ is-a(조류, 동물) \u0026rarr; is-a(팽귄, 동물)\n\u003c/tip\u003e\n\n지식을 시각적으로 표현할 수 있어 직관적으로 이해할 수 있고, 노드 추가 및 변경이 자유롭다는 장점이 있다.\n하지만, 양이 많아지면 관리가 복잡해지고, 개념이나 관계를 임의로 정의하기에 통일성이 떨어진다는 단점이 있다.\n\n### 추론\n\n상속관계를 이용해서 추론한다.\n예로 들어 '바둑기사의 키는?' 이라는 질문은 다음과 같이 추론할 수 있다.\n\n![231022-190024](/posts/mid_03/231022-190024.png)\n\n뿐만 아니라, 주어진 지식으로부터 새로운 사실을 이끌어내는 추론도 가능하다.\n예로 들어 '사람1이 사람2에게 사물1을 준다'는 지식으로부터, '사람2는 사물1을 소유하게 된다'는 사실을 추론한다.\n\n![231022-190213](/posts/mid_03/231022-190213.png)\n\n### 프레임으로 변환\n\n![231022-190324](/posts/mid_03/231022-190324.png)\n\n노드별로 프레임으로 변환할 수 있는데, 노드에서 나가는 간선들을 슬롯으로 구성하면 된다.\n\n---\n\n## 스크립트 (Script)\n\n일반적으로 발생할 수 있는 전형적인 상황에 대한 절차적 지식을 일목요연하게 표현한 것이다.\n\n![231022-190644](/posts/mid_03/231022-190644.png)\n\n- 진입 조건\n  스크립트에 기술된 사건들이 일어나기 전에 만족되어야 하는 전제조건\n\n- 역할자\n  스크립트에 관련된 사람, 대상\n\n- 자산\n  사건 진행 과정에서 사용되는 객체\n\n- 트랙\n  스크립트에서 발생할 수 있는 사건들이 변형된 형태 식별자 (장소)\n\n- 장면\n  실제 일어나는 일련의 사건\n  \n- 결과 조건\n  스크립트의 장면에 있는 사건들이 일어난 후에 만족되는 조건","slug":"univ_ai/mid_03","readingMinutes":6,"wordCount":401},{"title":"게임에서의 탐색 및 최적화","description":"게임 트리를 탐색하는 기법과 최적화에 대해 알아봅니다.","icon":"","image":"","tags":["Mini-Max algorithm","Alpha-Beta prunning","Monte Carlo","Backtracking search","Constraint propagation","Genetic algorithm","Regression"],"draft":false,"date":"2023-10-21 / 22:53","content":"\n## 게임 트리\n\n`상대가 있는 게임`에서 자신과 상대방의 가능한 게임 상태를 나타낸 트리.\n자신의 턴인지, 상대의 턴인지에 따라 탐색하는 방식이 다르게 적용됨.\n(나에겐 유리하게, 상대에겐 불리하게)\n\n정해진 시간 내에 최대한 많은 수를 보는 것이 유리하기 때문에 탐색 효율을 높이는 것이 중요하다.\n\n### Mini-max Algorithm\n\n특이하게 단말 노드로부터 위로 올라가면서 최소-최대 연산을 반복하여 자신이 선택할 수 있는 방법 중 가장 좋은 값을 선택하는 방법이다.\n\n자신의 턴인 Max 노드에서는 자신에게 유리한 값을 선택하고,\n상대의 턴인 Min 노드에서는 상대에게 불리한 값을 선택하는 방식을 취한다.\n\n![231021-230224](/posts/mid_02/231021-230224.png)\n\n하지만 트리가 넓을 수록 모든 상태공간을 탐색하는건 시간상 너무 오래 걸리기 때문에 최적화 기법이 들어가야 한다.\n바로 **$\\alpha - \\beta$ 가지치기(prunning)** 기법이다.\n\n검토해 볼 필요가 없는 부분을 탐색하지 않도록 하는 기법인데, 어떻게 해야 검토할 필요가 없다는 걸 알 수 있을까?\n\n깊이 우선 탐색(DFS)로 제한 깊이까지 탐색을 하면서 Min, Max 노드의 $\\alpha$, $\\beta$값을 업데이트 하는데, 각 $\\alpha$, $\\beta$값은 다음과 같은 값을 저장한다.\n\n- $\\alpha$\n  Max 노드에서만 값이 업데이트되며, 현재까지 확보한 자식의 값 중 최댓값을 저장함\n\n- $\\beta$\n  Min 노드에서만 값이 업데이트되며, 현재까지 확보한 자식의 값 중 최솟값을 저장함\n\n이 때, 탐색 후 값을 업데이트 하다가 **$\\alpha \\geq \\beta$** 되는 순간이 오는데, 그 때부터 나머지 자식노드는 탐색할 필요가 없어진다.\n그 이유는, 상한선($\\alpha$)과 하한선($\\beta$)이 정해질 때, 그 부모노드의 상한선과 하한선을 넘지 못하면 부모노드를 업데이트 할 수 없기에, 업데이트를 할 가능성이 없다면 가지치기를 해버리는 것이다.\n\n알고리즘의 이해가 안된다면 아래 영상을 참고하면 좋을 거 같다.\n\n\u003cYT id=\"_i-lZcbWkps\" /\u003e\n\n속성으로 빠르게 탐색하고 싶다면 이런 방식으로 탐색해도 된다.\n\n\u003cYT id=\"6qN5ReC2SUA\" /\u003e\n\n빠르게 업데이트 가능한 조건을 적어놓고, 그 조건이 업데이트가 절대로 불가능하다면 나머지 노드를 가지치기 하는 방식이다.\n\n### 몬테카를로 트리 탐색 기법 (Monte Carlo Simulation)\n\n![231022-003000](/posts/mid_02/231022-003000.png)\n\n탐색 공간을 무작위 표본추출을 하면서 탐색 트리를 확장하여 가장 좋아보이는 것을 선택하는 휴리스틱 탐색 방법으로,\n시간이 허용되는 동안 위의 4단계를 반복하여 시뮬레이션 및 트리를 확장한다.\n\n1. 선택\n  선택은 **트리 정책**을 적용하여 선택한다.\n  정책은 개발자 마음대로 정하는 거지만, 보통 승률과 노드 방문횟수를 고려하여 선택한다.\n  일반적으로 `승률이 높으며`, `방문횟수가 적은` 노드에 우선권을 부여한다 (UCB, Upper Confidence Bound 정책).\n\n2. 확장\n  단말 노드에서 트리 정책에 따라 노드를 추가한다.\n\n3. 시뮬레이션\n  기본 정책에 의한 `몬테카를로 시뮬레이션`을 적용한다.\n  무작위 선택, 또는 약간 똑똑한 방법으로 게임이 끝날 때 까지 진행한다.\n\n  \u003ctip\u003e\n  `몬테카를로 시뮬레이션`\n  \u003cbr /\u003e\n  특정 확률 분포로 부터 무작위 표본(또는 약간 똑똑한 방법으로)을 생성하고, 이 표본에 따라 행동을 하는 과정을 반복하여 결과를 확인하고 이 과정을 반복해 최정 결정을 하는 것.\n  \u003cbr /\u003e\n  특정 상태의 유불리를 상태판단함수로 판단하는 것이 아닌, 시뮬레이션으로 판단하게 된다.\n  \u003c/tip\u003e\n\n4. 역전파\n  게임의 결과를 단말 노드에서 루트 노드까지 올라가면서 반영한다.\n\n---\n\n## 제약조건 만족 문제\n\n주어진 제약조건을 만족하는 조합 해(combination solution)을 찾는 문제로 N-Queens problem과 같은 문제가 이에 해당한다.\n\n### 백 트래킹 탐색 (Backtracking search)\n\n깊이 우선 탐색(DFS)을 하는 것처럼 변수에 허용되는 값을 하나씩 대입해보고, 가능한 모든 값을 대입했는데도 만족하는 것이 없으면 이전 단계로 돌아가서 이전 단계의 변수에 다른 값을 대입하는 전형적인 백 트래킹 방식이다.\n\n### 제약조건 전파 (Constraint propagation)\n\n인접 변수 간의 제약 조건에 따라 각 변수에 허용될 수 없는 값들을 제거하는 방식으로, 이름 그대로 주변에 제약조건을 전파하여 선택 가능한 가지수를 줄여가는 방식이다.\n\n![231022-004410](/posts/mid_02/231022-004410.png)\n\nA에 1을 선택하는 순간 B\\~D에 각각 제약사항이 전파되어 B\\~D에서 선택할 수 있는 가지수가 제한된다.\n여기서 B가 3을 선택하는 순간 C, D에 각각 제약사항이 또 전파되는데, 이 때 C는 더이상 아무것도 선택할 수 없기에 이전 스탭에서 다른 제약사항을 걸어야 한다.\n\n---\n\n## 최적화\n\n여러가지 가능, 혀용되는 값들 중에서 주어진 기준을 가장 잘 만족하는 것을 선택하는 것으로, 크게 `조합 최적화`와 `함수 최적화`로 나뉜다.\n\n### 조합 최적화\n\nTSP와 같이 주어진 항목들의 조합으로 해가 표현되는 최적화 문제로, 이 경우에는 경로의 길이를 최소화 하는 문제이다.\n\n![231022-005505](/posts/mid_02/231022-005505.png)\n\n이를 달성하기 위해 생물의 진화를 모방한 집단 기반 확률적 탐색 기법인 `유전 알고리즘`을 사용하기도 한다.\n\n개체는 염색체로 표현되며 다음과 같이 기술된다.\n\n![231022-005704](/posts/mid_02/231022-005704.png)\n\n이런 염색체들의 집합을 `모집단`이라고 하는데, 이런 모집단(후보해)가 문제의 해로서 적합한 정도를 `적합도 함수`가 판단하게 되고, 적합하다면 최적 개체로서 알고리즘이 종료되지만, 적합하지 않다면 **진화의 과정**을 거치게 된다.\n\n모집단이 진화를 할 때는 우선 `부모 모집단` 중 개체를 선택하게 되는데, **가능한 높은 적합도의 개체가 선택되도록 확률을 높게** 조정한다.\n자연선택과 같이 **랜덤**한 요소가 있어야 하기에 반드시 적합한 녀석이 선택되지는 않는다.\n\n이후에는 선택된 부모 개체가 `유전 연산`을 거쳐 자식 개체를 양산하게 되는데, 유전 연산에는 다음과 같은 연산을 고려할 수 있다.\n\n![231022-010201](/posts/mid_02/231022-010201.png)\n\n이후에는 생성된 여러 자식 개체를 이용해서 `세대를 교체`하게 되는데, **최대한 많은 우수한 계체가 다음 세대에 유지**될 수 있도록 `엘리트주의`를 적용한다.\n\n### 목적 최적화\n\n어떤 목적 함수(Objective function)가 있을 때, 이 함수를 최대로 하거나 최소로 하는 변수 값을 찾는 최적화 문제이다.\n\n![231022-010440](/posts/mid_02/231022-010440.png)\n\n`최소 평균제곱법`을 사용해서 회귀(Regression) 문제의 최적함수를 찾거나,\n\n![231022-010602](/posts/mid_02/231022-010602.png)\n\n함수의 최소값 위치를 찾는 문제에서 `경사 하강법`과 같은 방법을 사용할 수 있다.","slug":"univ_ai/mid_02","readingMinutes":11,"wordCount":724},{"title":"상태공간 \u0026 탐색","description":"상태공간과 탐색의 의미와 예시를 알아봅니다.","icon":"","image":"","tags":["Depth First Search","Breadth First Search","Depth Limited Search","Best First Search","Beam Search","A* Algorithm"],"draft":false,"date":"2023-09-12 / 15:44","content":"\n## 상태공간\n\n문제 해결 과정에서 초기 상태로부터 도달할 수 있는 모든 상태들의 집합을 의미한다.\n한 마디로 `문제의 해가 될 가능성`이 있는 모든 상태들의 집합을 의미한다.\n\n## 탐색\n\n상태공간에서 최적의 해를 찾기위해 공간을 체계적으로 찾아보는 것을 의미한다.\n탐색은 아래와 같은 방식으로 크게 구분지을 수 있다.\n\n1. 맹목적 탐색\n2. 정보이용 탐색\n\n이렇게 구분짓는 이유는 탐색의 방식에 따라 달라지는데,\n탐색 방식이 다양해 질 수 밖에 없는 이유는 일반적인 문제에서는 상태공간이 매우 크기 때문에\n미리 공간 그래프를 그릴 수 없어 탐색 과정에서 그래프를 생성할 수 밖에 없기 때문이다.\n\n---\n\n## 맹목적 탐색\n\n정해진 순서에 따라 상태공간 그래프를 점차 생성해 가면서 해를 탐색하는 방법을 의미한다.\n\n### 깊이 우선 탐색 (Depth-first search)\n\n![231021-223045](/posts/mid_01/231021-223045.png)\n\n초기 노드부터 깊이가 깊어지는 방향으로 우선 탐색하는 기법.\n더이상 진행할 수 없다면 백 트리킹으로 돌아와 다음 노드 탐색.\n\n루트 노드에서 현재 노드까지의 경로 하나만 유지한다는 특징이 있기에 메모리 공간 사용이 효율적이라는 장점이 있다.\n하지만, 깊이가 무한히 깊어지는 무한루프의 가능성 때문에 항상 최단 경로의 해를 보장할 수 없다는 단점이 있다.\n\n### 너비 우선 탐색 (Breadth-first search)\n\n![231021-223311](/posts/mid_01/231021-223311.png)\n\n초기 노드부터 시작하여 모든 자식 노드를 확장하여 탐색하는 기법.\n목표 노드가 없다면 단말 노드에서 다시 자식노드 확장 탐색.\n\n최단 경로의 해를 보장하지만, 메모리 효율적이지 못하다.\n\n### 깊이 제한 탐색 (Depth-limited search)\n\n![231021-223510](/posts/mid_01/231021-223510.png)\n\n기본적인 탐색 방식은 깊이 우선 탐색 방식임.\n단, 깊이에 제한을 둬서 특정 깊이 이하로는 탐색을 진행하지 않고 백 트래킹 하는 것이 특징임.\n특정 깊이에서 목표를 찾지 못한 경우 깊이를 늘려가며 처음부터 다시 탐색을 진행함.\n\n최단 경로의 해를 보장하며, 메모리 사용도 효율적이다.\n상위 노드는 반복해서 탐색하기에 약간의 비효율성이 있으나, 무시할만한 수준임.\n\n즉 맹목적 탐색시에는 이 방식을 우선적으로 고려하는 것이 좋음.\n\n---\n\n## 정보이용 탐색\n\n휴리스틱한 방법으로 목표까지의 예상 비용을 구하고, 그 값에 의거해 순간순간 최선의 선택을 해가며 탐색하는 방법을 의미한다.\n\n\u003ctip\u003e\n  `휴리스틱 (heuristic)`\n  신속하게 어림짐작 하는 것.\n\u003c/tip\u003e\n\n### 언덕 오르기 방법 (Hill climbing method)\n\n![231021-224206](/posts/mid_01/231021-224206.png)\n\n현재 노드에서 휴리스틱에 의한 평가값이 가장 좋은 이웃 노드 하나를 확장해가는 탐색기법.\n단, 국소 최적해에 빠질 가능성이 있다.\n(경사 하강법과 유사)\n\n### 최상 우선 탐색 (Best-first search)\n\n확장 중인 노드들 중에서 목표 노드까지 남은 거리가 가장 짧은 노드를 확장하여 탐색하는 기법.\n일종의 그리디한 방식임.\n\n![231021-224403](/posts/mid_01/231021-224403.png)\n\n예시로 휴리스틱 함수를 제자리가 아닌 타일의 개수라고 할 때, 다음과 같은 순서로 탐색을 진행하게 된다.\n\n\u003e a \u0026rarr; c \u0026rarr; e/f \u0026rarr; h \u0026rarr; j\n\n### 빔 탐색 (Beam search)\n\n최상 우선 탐색(BFS) 의 확장판으로, 휴리스틱에 의한 평가값이 우수한 일정 개수(K개)의 확장 가능한 노드만을 메모리에서 관리하면서 탐색.\n\n![231021-224723](/posts/mid_01/231021-224723.png)\n\n예시로 K=2일 때, A~E를 일단 탐색하고, 평가값이 우수한 B, E를 제외한 노드는 메모리에서 제거하며 B, E에서 그 자식노드에 대해 같은 방식을 적용하며 탐색한다.\n\n### A* 알고리즘 (A-star algorithm)\n\n최상 우선 탐색(BFS) 의 개선판으로, 휴리스틱에 의한 평가값 + 현재까지의 코스트의 결과인 휴리스틱한 전체 비용을 기준으로 탐색하는 기법.\n\n![231021-225028](/posts/mid_01/231021-225028.png)\n\n최초 상태를 탐색한 후, 그 자식 노드 3개의 휴리스틱한 전체 비용을 계산하면 `1(현재까지의 코스트)+3(휴리스틱 평가값)`의 값을 갖는 가운데 자식 노드가 비용이 가장 작기에 다음 탐색 대상으로 한다.\n\n이런 식으로 **탐색한 모든 노드를 메모리 상에서 관리**하며, 그 순간 휴리스틱 전체 비용이 가장 낮은 노드를 다음 탐색 대상으로 삼는다.","slug":"univ_ai/mid_01","readingMinutes":7,"wordCount":479},{"title":"대학 - 인공지능","description":"3학년 2학기 인공지능 수업 아카이브","icon":"","image":"","tags":[],"draft":false,"date":"2023-09-05 / 16:11","content":"","slug":"univ_ai/index","readingMinutes":0,"wordCount":1}],"mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    span: \"span\",\n    p: \"p\",\n    code: \"code\",\n    br: \"br\",\n    h3: \"h3\",\n    img: \"img\",\n    strong: \"strong\",\n    math: \"math\",\n    semantics: \"semantics\",\n    mrow: \"mrow\",\n    mi: \"mi\",\n    mo: \"mo\",\n    annotation: \"annotation\",\n    ul: \"ul\",\n    li: \"li\",\n    ol: \"ol\",\n    hr: \"hr\"\n  }, _provideComponents(), props.components), {YT} = _components;\n  if (!YT) _missingMdxReference(\"YT\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"게임-트리\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#게임-트리\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"게임 트리\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"상대가 있는 게임\"\n      }), \"에서 자신과 상대방의 가능한 게임 상태를 나타낸 트리.\", _jsx(_components.br, {}), \"\\n\", \"자신의 턴인지, 상대의 턴인지에 따라 탐색하는 방식이 다르게 적용됨.\", _jsx(_components.br, {}), \"\\n\", \"(나에겐 유리하게, 상대에겐 불리하게)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정해진 시간 내에 최대한 많은 수를 보는 것이 유리하기 때문에 탐색 효율을 높이는 것이 중요하다.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"mini-max-algorithm\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#mini-max-algorithm\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Mini-max Algorithm\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"특이하게 단말 노드로부터 위로 올라가면서 최소-최대 연산을 반복하여 자신이 선택할 수 있는 방법 중 가장 좋은 값을 선택하는 방법이다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"자신의 턴인 Max 노드에서는 자신에게 유리한 값을 선택하고,\", _jsx(_components.br, {}), \"\\n\", \"상대의 턴인 Min 노드에서는 상대에게 불리한 값을 선택하는 방식을 취한다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/posts/mid_02/231021-230224.png\",\n        alt: \"231021-230224\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"하지만 트리가 넓을 수록 모든 상태공간을 탐색하는건 시간상 너무 오래 걸리기 때문에 최적화 기법이 들어가야 한다.\", _jsx(_components.br, {}), \"\\n\", \"바로 \", _jsxs(_components.strong, {\n        children: [_jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsx(_components.mi, {\n                      children: \"α\"\n                    }), _jsx(_components.mo, {\n                      children: \"−\"\n                    }), _jsx(_components.mi, {\n                      children: \"β\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"\\\\alpha - \\\\beta\"\n                  })]\n                })\n              })\n            }), _jsxs(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: [_jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.6667em\",\n                    verticalAlign: \"-0.0833em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.0037em\"\n                  },\n                  children: \"α\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2222em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mbin\",\n                  children: \"−\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2222em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.8889em\",\n                    verticalAlign: \"-0.1944em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.05278em\"\n                  },\n                  children: \"β\"\n                })]\n              })]\n            })]\n          })\n        }), \" 가지치기(prunning)\"]\n      }), \" 기법이다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"검토해 볼 필요가 없는 부분을 탐색하지 않도록 하는 기법인데, 어떻게 해야 검토할 필요가 없다는 걸 알 수 있을까?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"깊이 우선 탐색(DFS)로 제한 깊이까지 탐색을 하면서 Min, Max 노드의 \", _jsx(_components.span, {\n        className: \"math math-inline\",\n        children: _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsx(_components.mrow, {\n                  children: _jsx(_components.mi, {\n                    children: \"α\"\n                  })\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"\\\\alpha\"\n                })]\n              })\n            })\n          }), _jsx(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.4306em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                style: {\n                  marginRight: \"0.0037em\"\n                },\n                children: \"α\"\n              })]\n            })\n          })]\n        })\n      }), \", \", _jsx(_components.span, {\n        className: \"math math-inline\",\n        children: _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsx(_components.mrow, {\n                  children: _jsx(_components.mi, {\n                    children: \"β\"\n                  })\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"\\\\beta\"\n                })]\n              })\n            })\n          }), _jsx(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.8889em\",\n                  verticalAlign: \"-0.1944em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                style: {\n                  marginRight: \"0.05278em\"\n                },\n                children: \"β\"\n              })]\n            })\n          })]\n        })\n      }), \"값을 업데이트 하는데, 각 \", _jsx(_components.span, {\n        className: \"math math-inline\",\n        children: _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsx(_components.mrow, {\n                  children: _jsx(_components.mi, {\n                    children: \"α\"\n                  })\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"\\\\alpha\"\n                })]\n              })\n            })\n          }), _jsx(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.4306em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                style: {\n                  marginRight: \"0.0037em\"\n                },\n                children: \"α\"\n              })]\n            })\n          })]\n        })\n      }), \", \", _jsx(_components.span, {\n        className: \"math math-inline\",\n        children: _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsx(_components.mrow, {\n                  children: _jsx(_components.mi, {\n                    children: \"β\"\n                  })\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"\\\\beta\"\n                })]\n              })\n            })\n          }), _jsx(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.8889em\",\n                  verticalAlign: \"-0.1944em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                style: {\n                  marginRight: \"0.05278em\"\n                },\n                children: \"β\"\n              })]\n            })\n          })]\n        })\n      }), \"값은 다음과 같은 값을 저장한다.\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.span, {\n            className: \"math math-inline\",\n            children: _jsxs(_components.span, {\n              className: \"katex\",\n              children: [_jsx(_components.span, {\n                className: \"katex-mathml\",\n                children: _jsx(_components.math, {\n                  xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                  children: _jsxs(_components.semantics, {\n                    children: [_jsx(_components.mrow, {\n                      children: _jsx(_components.mi, {\n                        children: \"α\"\n                      })\n                    }), _jsx(_components.annotation, {\n                      encoding: \"application/x-tex\",\n                      children: \"\\\\alpha\"\n                    })]\n                  })\n                })\n              }), _jsx(_components.span, {\n                className: \"katex-html\",\n                \"aria-hidden\": \"true\",\n                children: _jsxs(_components.span, {\n                  className: \"base\",\n                  children: [_jsx(_components.span, {\n                    className: \"strut\",\n                    style: {\n                      height: \"0.4306em\"\n                    }\n                  }), _jsx(_components.span, {\n                    className: \"mord mathnormal\",\n                    style: {\n                      marginRight: \"0.0037em\"\n                    },\n                    children: \"α\"\n                  })]\n                })\n              })]\n            })\n          }), _jsx(_components.br, {}), \"\\n\", \"Max 노드에서만 값이 업데이트되며, 현재까지 확보한 자식의 값 중 최댓값을 저장함\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.span, {\n            className: \"math math-inline\",\n            children: _jsxs(_components.span, {\n              className: \"katex\",\n              children: [_jsx(_components.span, {\n                className: \"katex-mathml\",\n                children: _jsx(_components.math, {\n                  xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                  children: _jsxs(_components.semantics, {\n                    children: [_jsx(_components.mrow, {\n                      children: _jsx(_components.mi, {\n                        children: \"β\"\n                      })\n                    }), _jsx(_components.annotation, {\n                      encoding: \"application/x-tex\",\n                      children: \"\\\\beta\"\n                    })]\n                  })\n                })\n              }), _jsx(_components.span, {\n                className: \"katex-html\",\n                \"aria-hidden\": \"true\",\n                children: _jsxs(_components.span, {\n                  className: \"base\",\n                  children: [_jsx(_components.span, {\n                    className: \"strut\",\n                    style: {\n                      height: \"0.8889em\",\n                      verticalAlign: \"-0.1944em\"\n                    }\n                  }), _jsx(_components.span, {\n                    className: \"mord mathnormal\",\n                    style: {\n                      marginRight: \"0.05278em\"\n                    },\n                    children: \"β\"\n                  })]\n                })\n              })]\n            })\n          }), _jsx(_components.br, {}), \"\\n\", \"Min 노드에서만 값이 업데이트되며, 현재까지 확보한 자식의 값 중 최솟값을 저장함\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이 때, 탐색 후 값을 업데이트 하다가 \", _jsx(_components.strong, {\n        children: _jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsx(_components.mi, {\n                      children: \"α\"\n                    }), _jsx(_components.mo, {\n                      children: \"≥\"\n                    }), _jsx(_components.mi, {\n                      children: \"β\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"\\\\alpha \\\\geq \\\\beta\"\n                  })]\n                })\n              })\n            }), _jsxs(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: [_jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.7719em\",\n                    verticalAlign: \"-0.136em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.0037em\"\n                  },\n                  children: \"α\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mrel\",\n                  children: \"≥\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.8889em\",\n                    verticalAlign: \"-0.1944em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.05278em\"\n                  },\n                  children: \"β\"\n                })]\n              })]\n            })]\n          })\n        })\n      }), \" 되는 순간이 오는데, 그 때부터 나머지 자식노드는 탐색할 필요가 없어진다.\", _jsx(_components.br, {}), \"\\n\", \"그 이유는, 상한선(\", _jsx(_components.span, {\n        className: \"math math-inline\",\n        children: _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsx(_components.mrow, {\n                  children: _jsx(_components.mi, {\n                    children: \"α\"\n                  })\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"\\\\alpha\"\n                })]\n              })\n            })\n          }), _jsx(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.4306em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                style: {\n                  marginRight: \"0.0037em\"\n                },\n                children: \"α\"\n              })]\n            })\n          })]\n        })\n      }), \")과 하한선(\", _jsx(_components.span, {\n        className: \"math math-inline\",\n        children: _jsxs(_components.span, {\n          className: \"katex\",\n          children: [_jsx(_components.span, {\n            className: \"katex-mathml\",\n            children: _jsx(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: _jsxs(_components.semantics, {\n                children: [_jsx(_components.mrow, {\n                  children: _jsx(_components.mi, {\n                    children: \"β\"\n                  })\n                }), _jsx(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"\\\\beta\"\n                })]\n              })\n            })\n          }), _jsx(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: _jsxs(_components.span, {\n              className: \"base\",\n              children: [_jsx(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.8889em\",\n                  verticalAlign: \"-0.1944em\"\n                }\n              }), _jsx(_components.span, {\n                className: \"mord mathnormal\",\n                style: {\n                  marginRight: \"0.05278em\"\n                },\n                children: \"β\"\n              })]\n            })\n          })]\n        })\n      }), \")이 정해질 때, 그 부모노드의 상한선과 하한선을 넘지 못하면 부모노드를 업데이트 할 수 없기에, 업데이트를 할 가능성이 없다면 가지치기를 해버리는 것이다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"알고리즘의 이해가 안된다면 아래 영상을 참고하면 좋을 거 같다.\"\n    }), \"\\n\", _jsx(YT, {\n      id: \"_i-lZcbWkps\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"속성으로 빠르게 탐색하고 싶다면 이런 방식으로 탐색해도 된다.\"\n    }), \"\\n\", _jsx(YT, {\n      id: \"6qN5ReC2SUA\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"빠르게 업데이트 가능한 조건을 적어놓고, 그 조건이 업데이트가 절대로 불가능하다면 나머지 노드를 가지치기 하는 방식이다.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"몬테카를로-트리-탐색-기법-monte-carlo-simulation\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#몬테카를로-트리-탐색-기법-monte-carlo-simulation\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"몬테카를로 트리 탐색 기법 (Monte Carlo Simulation)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/posts/mid_02/231022-003000.png\",\n        alt: \"231022-003000\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"탐색 공간을 무작위 표본추출을 하면서 탐색 트리를 확장하여 가장 좋아보이는 것을 선택하는 휴리스틱 탐색 방법으로,\", _jsx(_components.br, {}), \"\\n\", \"시간이 허용되는 동안 위의 4단계를 반복하여 시뮬레이션 및 트리를 확장한다.\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"선택\", _jsx(_components.br, {}), \"\\n\", \"선택은 \", _jsx(_components.strong, {\n            children: \"트리 정책\"\n          }), \"을 적용하여 선택한다.\", _jsx(_components.br, {}), \"\\n\", \"정책은 개발자 마음대로 정하는 거지만, 보통 승률과 노드 방문횟수를 고려하여 선택한다.\", _jsx(_components.br, {}), \"\\n\", \"일반적으로 \", _jsx(_components.code, {\n            children: \"승률이 높으며\"\n          }), \", \", _jsx(_components.code, {\n            children: \"방문횟수가 적은\"\n          }), \" 노드에 우선권을 부여한다 (UCB, Upper Confidence Bound 정책).\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"확장\", _jsx(_components.br, {}), \"\\n\", \"단말 노드에서 트리 정책에 따라 노드를 추가한다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"시뮬레이션\", _jsx(_components.br, {}), \"\\n\", \"기본 정책에 의한 \", _jsx(_components.code, {\n            children: \"몬테카를로 시뮬레이션\"\n          }), \"을 적용한다.\", _jsx(_components.br, {}), \"\\n\", \"무작위 선택, 또는 약간 똑똑한 방법으로 게임이 끝날 때 까지 진행한다.\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(\"tip\", {\n      children: [_jsx(_components.p, {\n        children: _jsx(_components.code, {\n          children: \"몬테카를로 시뮬레이션\"\n        })\n      }), _jsx(\"br\", {}), _jsx(_components.p, {\n        children: \"특정 확률 분포로 부터 무작위 표본(또는 약간 똑똑한 방법으로)을 생성하고, 이 표본에 따라 행동을 하는 과정을 반복하여 결과를 확인하고 이 과정을 반복해 최정 결정을 하는 것.\"\n      }), _jsx(\"br\", {}), _jsx(_components.p, {\n        children: \"특정 상태의 유불리를 상태판단함수로 판단하는 것이 아닌, 시뮬레이션으로 판단하게 된다.\"\n      })]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"역전파\", _jsx(_components.br, {}), \"\\n\", \"게임의 결과를 단말 노드에서 루트 노드까지 올라가면서 반영한다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h2, {\n      id: \"제약조건-만족-문제\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#제약조건-만족-문제\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"제약조건 만족 문제\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"주어진 제약조건을 만족하는 조합 해(combination solution)을 찾는 문제로 N-Queens problem과 같은 문제가 이에 해당한다.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"백-트래킹-탐색-backtracking-search\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#백-트래킹-탐색-backtracking-search\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"백 트래킹 탐색 (Backtracking search)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"깊이 우선 탐색(DFS)을 하는 것처럼 변수에 허용되는 값을 하나씩 대입해보고, 가능한 모든 값을 대입했는데도 만족하는 것이 없으면 이전 단계로 돌아가서 이전 단계의 변수에 다른 값을 대입하는 전형적인 백 트래킹 방식이다.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"제약조건-전파-constraint-propagation\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#제약조건-전파-constraint-propagation\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"제약조건 전파 (Constraint propagation)\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"인접 변수 간의 제약 조건에 따라 각 변수에 허용될 수 없는 값들을 제거하는 방식으로, 이름 그대로 주변에 제약조건을 전파하여 선택 가능한 가지수를 줄여가는 방식이다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/posts/mid_02/231022-004410.png\",\n        alt: \"231022-004410\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A에 1을 선택하는 순간 B~D에 각각 제약사항이 전파되어 B~D에서 선택할 수 있는 가지수가 제한된다.\", _jsx(_components.br, {}), \"\\n\", \"여기서 B가 3을 선택하는 순간 C, D에 각각 제약사항이 또 전파되는데, 이 때 C는 더이상 아무것도 선택할 수 없기에 이전 스탭에서 다른 제약사항을 걸어야 한다.\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h2, {\n      id: \"최적화\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#최적화\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"최적화\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"여러가지 가능, 혀용되는 값들 중에서 주어진 기준을 가장 잘 만족하는 것을 선택하는 것으로, 크게 \", _jsx(_components.code, {\n        children: \"조합 최적화\"\n      }), \"와 \", _jsx(_components.code, {\n        children: \"함수 최적화\"\n      }), \"로 나뉜다.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"조합-최적화\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#조합-최적화\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"조합 최적화\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TSP와 같이 주어진 항목들의 조합으로 해가 표현되는 최적화 문제로, 이 경우에는 경로의 길이를 최소화 하는 문제이다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/posts/mid_02/231022-005505.png\",\n        alt: \"231022-005505\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이를 달성하기 위해 생물의 진화를 모방한 집단 기반 확률적 탐색 기법인 \", _jsx(_components.code, {\n        children: \"유전 알고리즘\"\n      }), \"을 사용하기도 한다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"개체는 염색체로 표현되며 다음과 같이 기술된다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/posts/mid_02/231022-005704.png\",\n        alt: \"231022-005704\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이런 염색체들의 집합을 \", _jsx(_components.code, {\n        children: \"모집단\"\n      }), \"이라고 하는데, 이런 모집단(후보해)가 문제의 해로서 적합한 정도를 \", _jsx(_components.code, {\n        children: \"적합도 함수\"\n      }), \"가 판단하게 되고, 적합하다면 최적 개체로서 알고리즘이 종료되지만, 적합하지 않다면 \", _jsx(_components.strong, {\n        children: \"진화의 과정\"\n      }), \"을 거치게 된다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"모집단이 진화를 할 때는 우선 \", _jsx(_components.code, {\n        children: \"부모 모집단\"\n      }), \" 중 개체를 선택하게 되는데, \", _jsx(_components.strong, {\n        children: \"가능한 높은 적합도의 개체가 선택되도록 확률을 높게\"\n      }), \" 조정한다.\", _jsx(_components.br, {}), \"\\n\", \"자연선택과 같이 \", _jsx(_components.strong, {\n        children: \"랜덤\"\n      }), \"한 요소가 있어야 하기에 반드시 적합한 녀석이 선택되지는 않는다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이후에는 선택된 부모 개체가 \", _jsx(_components.code, {\n        children: \"유전 연산\"\n      }), \"을 거쳐 자식 개체를 양산하게 되는데, 유전 연산에는 다음과 같은 연산을 고려할 수 있다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/posts/mid_02/231022-010201.png\",\n        alt: \"231022-010201\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이후에는 생성된 여러 자식 개체를 이용해서 \", _jsx(_components.code, {\n        children: \"세대를 교체\"\n      }), \"하게 되는데, \", _jsx(_components.strong, {\n        children: \"최대한 많은 우수한 계체가 다음 세대에 유지\"\n      }), \"될 수 있도록 \", _jsx(_components.code, {\n        children: \"엘리트주의\"\n      }), \"를 적용한다.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"목적-최적화\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#목적-최적화\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"목적 최적화\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"어떤 목적 함수(Objective function)가 있을 때, 이 함수를 최대로 하거나 최소로 하는 변수 값을 찾는 최적화 문제이다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/posts/mid_02/231022-010440.png\",\n        alt: \"231022-010440\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"최소 평균제곱법\"\n      }), \"을 사용해서 회귀(Regression) 문제의 최적함수를 찾거나,\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/posts/mid_02/231022-010602.png\",\n        alt: \"231022-010602\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"함수의 최소값 위치를 찾는 문제에서 \", _jsx(_components.code, {\n        children: \"경사 하강법\"\n      }), \"과 같은 방법을 사용할 수 있다.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"toc":[{"slug":"게임-트리","text":"게임 트리","subSections":[{"slug":"mini-max-algorithm","text":"Mini-max Algorithm"},{"slug":"몬테카를로-트리-탐색-기법-monte-carlo-simulation","text":"몬테카를로 트리 탐색 기법 (Monte Carlo Simulation)"}]},{"slug":"제약조건-만족-문제","text":"제약조건 만족 문제","subSections":[{"slug":"백-트래킹-탐색-backtracking-search","text":"백 트래킹 탐색 (Backtracking search)"},{"slug":"제약조건-전파-constraint-propagation","text":"제약조건 전파 (Constraint propagation)"}]},{"slug":"최적화","text":"최적화","subSections":[{"slug":"조합-최적화","text":"조합 최적화"},{"slug":"목적-최적화","text":"목적 최적화"}]}]},"__N_SSG":true},"page":"/blog/[...slugs]","query":{"slugs":["univ_ai","mid_02"]},"buildId":"jxN_3xkEGn7F8-if3KEMa","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>