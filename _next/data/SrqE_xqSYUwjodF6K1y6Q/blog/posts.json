{"pageProps":{"posts":[{"title":"Edge Detection","description":"영상에서 경계를 검출하는 방법을 알아봅니다.","icon":"","image":"","tags":[],"draft":false,"date":"2023-11-25 / 17:05","content":"\n## Edge Detector\n\n이전에 [**`라플라시안 커널`**](https://wjlee611.github.io/blog/univ_com-vision/mid_05#laplacian) 에서 다뤘던 내용의 연장입니다.\n\n![231125-171834](/posts/final_02/231125-171834.png)\n\n값은 상관없지만, 방향성이 있어야 하며, 합이 0인 커널을 구현하면 해당 방향으로의 line edge를 검출할 수 있습니다.\n\n![231125-172028](/posts/final_02/231125-172028.png)\n\n하지만, 위 영상 I 처럼 극명하게 경계가 정해지는 영상은 드뭅니다.\n대부분의 영상은 아래의 가운데 영상처럼 경계가 명확하게 구분되는 편은 아닙니다.\n\n![231125-172325](/posts/final_02/231125-172325.png)\n\n따라서 이런 경우까지 고려하기 위해 2중 미분을 통해 edge를 검출하는 것이 좋습니다.\n\n![231125-172357](/posts/final_02/231125-172357.png)\n\n하지만, 영상에 노이즈가 낀 경우에는 2중 미분을 한다고 해서 edge를 검출할 수 없습니다.\n\n![231125-173158](/posts/final_02/231125-173158.png)\n\n따라서 우선 미분을 하기 전에 smoothing filter를 적용해서 노이즈를 줄인 후 edge를 검출하면 검출 성능이 올라갈 수 있습니다.\n\n물론, smoothing filter를 적용하면 경계 역시 블러될 수 있습니다.\n그럼에도 불구하고, 경계는 찾을 수 있습니다.\n\n![231125-173502](/posts/final_02/231125-173502.png)\n\n참고로 미분 역시 컨볼루전으로 간단하게 처리될 수 있기 때문에 아래와 같이 연산 과정을 간략하게 할 수 있습니다.\n(e.g. \\[1, 0\\]을 컨볼루전 하면 미분된 효과를 얻을 수 있습니다.)\n\n![231125-173638](/posts/final_02/231125-173638.png)\n\n이런식으로 경계를 강조한 뒤에 threshold를 하면 edge를 검출할 수 있습니다.\n\n---\n\n## Canny edge detector\n\nCanny edge detector은 위에서 살펴본 기본적인 edge 검출 방식을 개선시킨 방식입니다.\n\n| Edge detector | Canny edge detector |\n|---|---|\n| 1. smoothing filter (가우시안의 미분) 적용 | 1. smoothing filter (가우시안의 미분) 적용 |\n| 2. gradient의 크기만 구함 | 2. gradient의 크기와 뱡향을 구함 |\n| | 3. Non-maximum suppression |\n| | 4. Hysteresis thresholding |\n\n1, 2번 까지 진행하고 threshold 하는 경우에는 차이가 없습니다.\n하지만 3, 4 번의 과정을 추가로 진행하여 더 나은 edge를 검출할 수 있습니다.\n\n### Non-maximum suppression\n\n![231125-181229](/posts/final_02/231125-181229.png)\n\n기존의 방식대로 검출할 경우 gradient의 크기만을 구하기 때문에 검출하는 edge의 두께가 두꺼워지는 문제가 발생합니다.\n\n![231125-181445](/posts/final_02/231125-181445.png)\n\n하지만, Canny 방식은 방향 역시 구하기 때문에 선의 두께를 얇게 만들어주면서 edge를 결정할 수 있습니다.\n\n![231125-182005](/posts/final_02/231125-182005.png)\n\n그러나, 여전히 약한 edge가 존재하는 문제가 있습니다.\n\n### Hysteresis thresholding\n\n약한 edge는 주면의 edge와 linking 하는 방식으로 해결하게 됩니다.\n\n![231125-182203](/posts/final_02/231125-182203.png)\n\n그렇게 하기 위해 일단 Low, High threshold를 우선 정합니다.\n이후에 threshold시 아래와 같은 판단을 거쳐 edge를 확정합니다.\n\n- threshold 값이 Low 보다 낮다?\n  edge가 아님.\n\n- threshold 값이 high 보다 크다?\n  edge임.\n\n- threshold 값이 Low, High 사이이다?\n  약한 edge임. 따라서 양 쪽에 edge가 있을 경우에만 edge로 판단.\n\n이렇게 진행된 Canny 방식은 확실히 이전보다 나은 성능을 보입니다.\n\n![231125-182457](/posts/final_02/231125-182457.png)\n\n참고로, 처음의 가우시안 필터의 세기를 크게 한다면 강한 에지만 살아남게 됩니다.\n\n---\n\n## Hough transform\n\nHough transform은 line detector 중 하나인데, 그 방식이 피팅(투표)하는 방식으로 좀 특이하다.\n\n![231125-210610](/posts/final_02/231125-210610.png)\n\n우선 영상에서 edge points를 찾아내고, 이후에는 무수히 많은 직선을 그었을 때,\n가장 많은 edge points를 지나는 직선이 선택되는 방식이다.\n\n이 때 드는 의문점이 있다.\n무수히 많은 직선을 긋는다는게 시간복잡도 상으로 간단하게 구현 가능한걸까?\n일반적인 방식으로 영상에 긋는 방식으로는 불가능 할것이다.\n하지만, 영상을 변환하는 과정을 거치면 가능해지는데, 그 방식을 살펴보자.\n\n### Hough space\n\n![231125-210859](/posts/final_02/231125-210859.png)\n\nHough space는 직선의 방정식의 파라미터를 축으로 하는 공간이다.\n따라서 영상 공간에서의 직선은 Hough 공간에서는 점으로 표시된다.\n\n![231125-211018](/posts/final_02/231125-211018.png)\n\n반대로 영상 공간에서의 점은?\n해당 점을 지나는 직선은 무수히 많을 것이다.\n따라서 그 무수히 많은 직선을 Hough 공간상에서 무수히 많은 점으로 찍으면 하나의 직선 형태로 표현될 것이다.\n\n![231125-211151](/posts/final_02/231125-211151.png)\n\n이를 응용해서 무수히 많은 점을 지나는 직선을 찾는 방식은 위 그림과 같다.\n\n영상 공간의 점은 Hough 공간에서 직선으로 표현되기 때문에,\nHough 공간에서의 교점은 영상 공간에서의 모든 점을 지나는 직선이 된다.\n\n하지만, Hough 공간을 확대해보면 실제로 한 점에서 만나는 경우는 드물기 때문에 약간의 근사를 해야하며 거기서 약간의 오차가 발생할 수 있다.\n\n![231125-211441](/posts/final_02/231125-211441.png)","slug":"univ_com-vision/final_02","readingMinutes":7,"wordCount":525},{"title":"Image Restoration","description":"훼손된 영상을 최대한 복원해보는 방식에 대해 알아봅니다.","icon":"","image":"","tags":["Image Restoration","Noise","Mean filter","Median filter","Inverse filter"],"draft":false,"date":"2023-11-25 / 15:07","content":"\n<notice>\n  이미지 훼손은 아래와 같은 공식에 의해 이루어졌다는 가정하에 진행됩니다.\n  따라서 현실 세계의 훼손을 복원할 때는 제대로 동작하지 않습니다.\n\n  $$\n  g(x,y) = h(x,y) * f(x,y) + \\eta(x,y)\n  $$\n\n  $h$: 훼손 함수\n  $\\eta$: 노이즈\n  <br />\n  즉, 이미지를 복원시킨다는 것은 훼손된 영상 $g$에 대해 $h$ 와 $\\eta$를 알고 있을 때, 그 영향을 제거하는 방향으로 진행합니다.\n</notice>\n\n## Noise Restoration\n\n우선 영상의 노이즈를 줄이는 방식을 알아보겠습니다.\n\n### Noise Model\n\n노이즈를 줄이기 위해서는 노이즈가 어떻게 생겼는지 분석할 필요가 있습니다.\n100%는 아니지만, 자연계에서 노이즈가 발생하는 방식은 여러 방식으로 모델링하여 추상화 할 수 있지만, 그 중에 대표적인 노이즈 모델에 대해서만 알아보겠습니다.\n\n1. `Gaussian Noise`\n\n    ![231125-152000](/posts/final_01/231125-152000.png)\n    ![231125-152908](/posts/final_01/231125-152908.png)\n\n    Gaussian Noise는 말 그대로 가우시안 분포를 따르는 노이즈 패턴으로 자연계에서 발견할 수 있는 형태를 갖습니다.\n\n2. `Uniform Noise`\n\n    ![231125-153500](/posts/final_01/231125-153500.png)\n    ![231125-153644](/posts/final_01/231125-153644.png)\n\n    Uniform Noise는 동일한 확률 분포로 노이즈 패턴을 갖는 형태입니다.\n\n2. `Impulse (Salt-and-Pepper) Noise`\n  \n    ![231125-154000](/posts/final_01/231125-154000.png)\n    $$\n    p(z) = \\left\\{\\begin{matrix}\n    P_a \\; for \\; z=a \\\\\n    P_b \\; for \\; z=b \\\\\n    0 \\; otherwise\\end{matrix}\\right. \n    $$\n\n    Salt-and-Pepper Noise는 일정 확률로 0 또는 255로 노이즈가 생기는 형태입니다.\n\n### Mean filter\n\nMean filter는 간단하게 말해서 기존에 많이 써왔던 smoothing filter와 동일합니다.\n직역하면 평균값 필터 입니다.\n\n$$\n\\hat{f}(x,y) = \\frac{1}{mn} \\sum_{(s,t)\\in S_{xy}}^{} g(s,t)\n$$\n\n즉, 전체적인 노이즈를 뿌옇게 만듦으로서 노이즈를 줄이는 것이기에 가우시안 노이즈에 효과적 입니다.\n하지만, 영상의 디테일이 뭉게진다는 한계가 존재합니다.\n\n### Median filter\n\nMedian filter는 간단하게 말하면 특정 윈도우 $S$ 내부의 값을 일렬로 정렬했을 때 가운데 값으로 대체하는 필터입니다.\n직역하면 중앙값 필터 입니다.\n\n$$\n\\hat{f}(x,y) = \\underset{(s,t)\\in S_{xy}}{median} \\{g(s,t)\\}\n$$\n\n즉, 0, 255와 같은 특이값을 중앙값으로 대체할 수 있기 때문에 Salt-and-Pepper 노이즈에 효과적 입니다.\n하지만, 특정 윈도우 영역에 노이즈가 우연히 많이 분포하게 될 경우 복원이 불가능 합니다.\n\n### Adaptive Mean filter\n\nAdaptive filter는 기존 필터와 다르게 영상의 특징을 반영하여 영역별로 다르게 필터링을 한다는 특징이 있습니다.\n\n$$\n\\hat{f}(x,y) = g(x,y) - \\frac{\\sigma_\\eta^2}{\\sigma_L^2} (g(x,y) - m_L)\n$$\n\n이 수식을 자세히 분석해봅시다.\n\n$\\sigma_\\eta^2$가 0 이라는 뜻은 노이즈의 분산이 0이라는 뜻입니다. 즉, 노이즈가 없다는 뜻입니다.\n이 때의 위 수식의 좌변은 $g(x,y)$만 남게 됩니다.\n즉, 노이즈가 없는 영상은 별 다른 변환 없이 통과하게 됩니다.\n\n$\\sigma_L^2$가 $\\sigma_\\eta^2$에 비해 매우 높은 경우는?\n노이즈의 분산에 비해 영상 자체의 분산이 매우 크다는 의미입니다.\n즉, 영상의 변화율이 크기 때문에 디테일을 살리기 위해 필터($m_L$)의 강도를 매우 약하게 설정해야 한다는 의미입니다.\n실제로 $\\sigma_\\eta^2$/$\\sigma_L^2$를 0.1과 같은 작은 값을 넣고 계산하면 필터의 영향력이 10%만 발휘된 변환 영상을 얻을 수 있습니다.\n\n$\\sigma_L^2$가 $\\sigma_\\eta^2$와 같은 경우는?\n노이즈의 분산이 원본영상 + 노이즈의 분산과 같다는 의미입니다.\n즉, 영상의 변화율이 없다는 의미이므로, 필터를 강하게 해서 디테일을 뭉게도 영향이 없는 상태입니다.\n실제로 $\\sigma_\\eta^2$/$\\sigma_L^2$에 1을 넣고 계산하면 100% 필터링된 변환 영상을 얻을 수 있습니다.\n\n이렇듯, 노이즈의 분산($\\sigma_\\eta^2$)과 원본영상 + 노이즈의 분산($\\sigma_L^2$)을 비교하여 필터($m_L$)링 강도를 결정하면, 디테일이 필요한 부분은 필터링을 약하게, 디테일이 필요없는 부분은 필터링을 강하게 하여 노이즈를 줄일 수 있습니다.\n\n### Adaptive Median filter\n\n이 경우엔 수식이 아닌, 일련의 명령어 집합으로 소개가 되어있기에 일단 소개하고 한 줄 한 줄 분석해보도록 하겠습니다.\n\n![231125-163400](/posts/final_01/231125-163400.png)\n\n`Line 1~3`\nmedian이 min, max가 아닌 값이 있다?\n&rarr; 주변에 salt, pepper도 있고, 원본 영상도 섞여있다.\n&rarr; B에서 후 처리.\n\n`Line 4~6`\nmedian이 min, max값 중 하나라면 해당 부분이 salt, pepper인지, 아니면 원본 영상 자체가 0, 255 값을 갖는건지 알 수 없다.\n&rarr; 윈도우 사이즈($S_{xy}$)를 키워서 A 재시도.\n\n`Line 7~9`\n픽셀 값이 min, max가 아니다?\n&rarr; 노이즈가 아니고 원본 값이다.\n&rarr; 원본 영상 그대로 리턴.\n\n`Line 10`\n픽셀 값이 min, max값 중 하나라면 해당 부분은 salt, pepper 노이즈일 것.\n&rarr; 중앙값 리턴.\n\n---\n\n## Degradation Restoration\n\n### Estimating the Degradation Function\n\n이제 노이즈는 어느정도 제거했다고 가정하고, 훼손 함수 $h$를 추정하는 법을 알아봅시다.\n추정만 해낼 수 있다면 이를 역으로 연산하는 과정을 통해서 제거할 수 있기 때문에 추정하는 대표적인 3가지 방식에 대해 알아봅시다.\n\n- Observation\n\n    부분의 H는 전체의 H와 같기 때문에 부분을 잘 선택하고, 노가다(?)를 통한 원본 영상을 만들어내어 그 변환과정(H)을 얻을 수 있다면, 전체 영상에 대한 복원이 가능해집니다.\n\n- Experimentation\n\n    impulse에 대한 H의 response를 보면 그 변환과정(H)을 얻을 수 있습니다.\n\n- Mathematical modeling\n\n### Inverse filter\n\n이제 찾아낸 훼손 함수 H를 기반으로 복원을 해봅시다.\n그 전에 앞서 가정했던 이미지 훼손 공식을 푸리에 변환한 식을 살펴봅시다.\n\n$$\nG(u,v) = F(u,v)H(u,v) + N(u,v)\n$$\n\n노이즈(N)는 앞에서 많이 줄였기에 없다고 가정했을 때 우리가 복원해야 하는 원본 영상 F는 다음과 같이 정의할 수 있습니다.\n\n$$\n\\hat{F}(u,v) = \\frac{G(u,v)}{H(u,v)} = F(u,v) + \\frac{N(u,v)}{H(u,v)}\n$$\n\n복원이 완벽하게 이뤄질 수는 없기에 $\\hat{F}$의 형태로 표현하였습니다.\n이 식에서 $\\frac{N(u,v)}{H(u,v)}$ 부분을 유심히 살펴봅시다.\n\n![231125-165953](/posts/final_01/231125-165953.png)\n\n보통 노이즈는 모든 주파수 구간에서 동일하게 일어납니다.\n하지만, 훼손은 보통 저주파수 영역에서 크게 일어나는 특징이 있습니다. (그렇다네요)\n\n따라서 고주파수 영역에서는 $\\frac{N(u,v)}{H(u,v)}$ 값이 매우 커지는,\n즉, 노이즈가 부스트되는 현상이 발생하게 됩니다.\n\n![231125-170139](/posts/final_01/231125-170139.png)\n\n따라서 훼손을 줄이는 과정에서 적당히 lowpass 를 해주는 것이 영상 품질을 높이는데 도움이 될 수 있습니다.","slug":"univ_com-vision/final_01","readingMinutes":9,"wordCount":740},{"title":"Factory Pattern","description":"Factory 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Factory Pattern","Abstract Factory Pattern"],"draft":false,"date":"2023-11-19 / 21:52","content":"\n## 필요성\n\n이번엔 피자가게로 예시를 들어보자.\n피자 가게에서 피자의 주문을 처리하기 위해서는 아래와 같은 형식으로 코드를 작성해야 할 것이다.\n\n```java:PizzaStore.java\npublic class PizzaStore {\n  ...\n  Pizza orderPizza(String tpye) {\n    Pizza pizza;\n\n    if (type.equals(\"cheese\")) {\n      pizza = new CheesePizza();\n    } else if (type.equals(\"greek\")) {\n      pizza = new GreekPizza();\n    }\n\n    pizza.prepare();\n    pizza.bake();\n    pizza.cut();\n    pizza.box();\n    return pizza;\n  }\n}\n```\n\n느낌만 보면 피자의 종류가 추가되거나 변경될 경우 orderPizza 메서드의 수정이 이루어져야 한다.\n예시가 적절하지 않은 느낌이 없지않아 있지만, orderPizza의 직접적인 수정이 부담스러울 수 있다.\n그 이유는 객체의 생성과 반복되는 메서드 호출 부분이 같은 함수 내에 위치하고 있기 때문이다.\n\n따라서 피자의 생성부(constructor)를 별도의 factory로 관리하는 기법에 대해 알아보자.\n\n## Factory Pattern\n\n이제 객체의 생성부를 factory로 캡슐화를 해보자.\n\n```java:PizzaFactory.java\npublic class PizzaFactory {\n  public Pizza createPizza(String type) {\n    Pizza pizza;\n\n    if (type.equals(\"cheese\")) {\n      pizza = new CheesePizza();\n    } else if (type.equals(\"greek\")) {\n      pizza = new GreekPizza();\n    }\n\n    return pizza;\n  }\n}\n```\n\n이제 이를 위의 피자가게에 적용한다면 코드는 다음과 같이 수정된다.\n\n```diff-java:PizzaStore.java\n  public class PizzaStore {\n+   PizzaFactory factory;\n\n    public PizzaStore(Pizzafactory factory) {\n+     this.factory = factory;\n    }\n\n    public Pizza orderPizza(String type) {\n      Pizza pizza;\n\n+     pizza = factory.createPizza(type);\n-     if (type.equals(\"cheese\")) {\n-       pizza = new CheesePizza();\n-     } else if (type.equals(\"greek\")) {\n-       pizza = new GreekPizza();\n-     }\n\n      pizza.prepare();\n      pizza.bake();\n      pizza.cut();\n      pizza.box();\n      return pizza;\n    }\n  }\n```\n\n이제 코드가 객체의 생성부와 반복되는 메서드의 호출 부분이 분리가 되었다.\n따라서 피자의 종류를 추가하거나 변경할 때에는 PizzaStore의 코드를 수정해야할 필요가 없어졌다.\n\n이렇게 하면 또 장점이 PizzaFactory를 교체하는 것 만으로도 생성할 수 있는 객체의 종류를 런타임에 다르게 결정할 수도 있다.\n\nfactory 패턴을 이렇게 외부 클래스로 구현할 수도 있지만, 내부의 메서드 형식으로도 구현할 수 있다.\n아래 코드를 살펴보자.\n\n```java:PizzaStore.java {11}\npublic abstract class PizzaStore {\n  public Pizza orderPizza(String type) {\n    Pizza pizza;\n\n    pizza = createPizza(type);\n\n    ...\n    return pizza;\n  }\n\n  abstract Pizza createPizza(String type);\n}\n```\n\n위에서는 PizzaFactory를 교체하는 방식으로 생성하는 객체를 다르게 할 수 있었다.\n이제는 이 abstract class를 구현하는 방식으로 생성하는 객체를 다르게 할 수 있다.\n\n```java:NYPizzaStore.java\npublic class NYPizzaStore extends PizzaStore {\n  Pizza createPizza(String type) {\n    if (type.equals(\"cheese\")) {\n      return new NYStyleCheesePizza();\n    } else if (type.equals(\"greek\")) {\n      new NYStyleGreekPizza();\n    }\n    return null;\n  }\n}\n```\n\n참고로 모든 blahPizza는 Pizza 클래스를 상속받는 식으로 구현해야 하고, Pizza 클래스는 abstract로 만들어서 인스턴스로 만들 수 없게 해야한다.\n\n![231125-111929](/posts/final_04/231125-111929.png)\n\n정리하자면, Factory pattern은 객체를 생성하는 인터페이스(createPizza)를 정의할 때\n어떤 클래스(blahPizza)를 만들어야 하는지는 상위 클래스(PizzaStore)가 결정하는 것이 아닌,\n하위 클래스(NYPizzaStore)에게 일임하는 방식의 디자인 패턴을 의미한다.\n\n<tip>\n  참고로 위의 코드는 종속 역전 원칙을 준수한 코드인데, 이게 뭐냐하면\n  가능하면 추상 클래스에 대해 종속성을 갖고, 구현 클래스에 대해서는 종속성을 피해야 한다는 디자인 원칙이다.\n  <br />\n  즉, PizzaStore에서는 객체를 CheesePizza, GreekPizza 로 관리하는 것이 아닌, 오직 Pizza 인터페이스로만 관리하는 것이 좋다.\n</tip>\n\n---\n\n## Abstract Factory Pattern\n\n그렇다면 NYPizza와 ChicagoPizza 모두 같은 종류의 피자를 판매한다면?\n사실살 들어가는 재료가 다를 뿐, 모두 CheesePizza, PepperoniPizza 등 같은 종류의 파지를 판매할 뿐인데,\n각각 다른 종류의 피자 클래스로 구현해야 한다는 문제점이 생길 것이다.\n\n생각해보면, 각 피자는 제조 방식은 같지만, 들어가는 재료가 다를 뿐이다.\n따라서 재료의 생성도 factory pattern으로 만든다면?\n\n```java:PizzaIngredientFactory.java\npublic interface PizzaIngredientFactory {\n  public Dough createDough();\n  public Sauce createSauce();\n  public Cheese createCheese();\n  public Veggies[] createVeggies();\n  public Pepperoni createPepperoni();\n  public Clame createClame();\n}\n```\n\n우선 각 지역의 피자에 들어갈 재료를 factory pattern으로 만들기에 앞서,\n하나의 인터페이스로 묶어주기 위해 인터페이스 클래스를 만들어준다.\n\n```java:NYPizzaIngredientFactory.java\npublic class NYPizzaIngredientFactory implements PizzaIngredientFactory {\n  public Dough createDough() {\n    return new ThinCrustDough();\n  }\n\n  public Sauce createSauce() {\n    return new MarinaraSauce();\n  }\n  ...\n}\n```\n\n이후에 각 지역에 맞는 재료 클래스를 반환하는 클래스를 구현해준다.\n따라서 각 지역에 피자 매장에 그 지역에 맞는 재료 factory를 종속시켜 준다면,\n같은 종류의 피자를 만든다고 할지라도, 재료가 다르게 들어가기 떄문에 지역 특색에 맞는 피자가 만들어 질 것이다.\n\n```java:Pizza.java\npublic abstract class Pizza { \n    String name;\n    Dough dough;\n    Sauce sauce;\n    Veggies veggies[]; \n    Cheese cheese; \n    Pepperoni pepperoni; \n    Clams clam;\n\n    abstract void prepare(); \n\n    void bake() {\n        System.out.println(“Bake for 25 minutes at 350”); \n    }\n    ...\n}\n```\n\n```java:CheesePizza.java\npublic class CheesePizza extends Pizza { \n    PizzaIngredientFactory ingredientFactory;\n\n    public CheesePizza(PizzaIngredientFactory ingredientFactory) { \n        this.ingredientFactory = ingredientFactory;\n    }\n\n    void prepare() {\n        System.out.println(“Preparing “ + name); \n        dough = ingredientFactory.createDough(); \n        sauce = ingredientFactory.createSauce(); \n        cheese = ingredientFactory.createCheese(); \n    }\n}\n```\n\n그렇기에 피자를 만들 때는 각 재료를 factory로 부터 가져오도록 구현해야 한다.\n\n```java:NYPizzaStore.java\npublic class NYPizzaStore extends PizzaStore { \n    ...\n    protected Pizza createPizza(String item) {\n        Pizza pizza = null;\n\n        PizzaIngredientFactory ingredientFactory = \n            new NYPizzaIngredientFactory();\n\n        if (item.equals(“cheese”)) {\n            pizza = new CheesePizza(ingredientFactory); \n            pizza.setName(“New York Style Cheese Pizza”);\n        } else if (item.equals(“veggie”)) {\n            pizza = new VeggiePizza(ingredientFactory); \n            pizza.setName(“New York Style Veggie Pizza”);\n        } else if (item.equals(“clam”)) {\n            pizza = new ClamPizza(ingredientFactory); \n            pizza.setName(“New York Style Clam Pizza”);\n        } else if (item.equals(“pepperoni”)) {\n            pizza = new PepperoniPizza(ingredientFactory); \n            pizza.setName(“New York Style Pepperoni Pizza”);\n        } \n\n        return pizza; \n    }\n}\n```\n\n마지막으로 각 지역에 피자 매장에 그 지역에 맞는 재료 factory를 종속시켜 주면,\n같은 종류의 피자를 만든다고 할지라도, 재료가 다르게 들어가기 떄문에 지역 특색에 맞는 피자가 만들어 질 것이다.\n\n![231125-111610](/posts/final_04/231125-111610.png)\n\n이렇게 구현 클래스(PizzaFactory)를 반환하는 것이 아닌, 클래스 생성 후 인터페이스(NYPizzaIngredientFactory)를 반환하는 디자인 패턴을 Abstract Factory Pattern 라고 한다.\n간단하게 말하면 factory(NYPizzaStore)의 factory(NYPizzaIngredientFactory) 인 것이다.","slug":"univ_design-pattern/final_04","readingMinutes":8,"wordCount":813},{"title":"Proxy Pattern","description":"Proxy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Proxy Pattern","Proxy","Remote Proxy"],"draft":false,"date":"2023-11-06 / 15:26","content":"\n<tip>\n  `Proxy`\n  다른 기능, 서버를 사용하기 전에 본인선에서 처리해버릴 때, 그 본인을 proxy 라고 한다.\n  즉, 중계기로서 대리로 처리하는 것을 의미한다.\n</tip>\n\n## Remote Proxy Pattern\n\n![231106-155200](/posts/final_02/231106-155200.png)\n\n프로그램이 서로 다른 머신 혹은 프로세스에서 동작 중일 때, 한 프로그램에서 다른 프로그램의 메서드를 직접 사용하기 위해 서로 상대 프로그램의 proxy를 두어 통신한다.\n이렇게 구성하면 각 프로그램은 다른 프로그램의 메서드를 직접 호출한다고 착각하게 되는데, 실제로 통신은 프록시 사이에서 일어나게 되는 것이다.\n\n### 필요성\n\n저번에 만들었던 GumballMachine의 상태를 원격으로 확인하는 서비스를 만들어보자.\napi 통신하는 방법으로도 구현할 수 있겠지만, 이번엔 Java에서 지원하는 Remote 기능을 이용해서 구현해보자.\n\n<tip>\n  `Java RMI`\n  Java Remote Method Invocation은 분산되어 존재하는 객체 간의 메세지 전송을 가능케 하는 프로토콜로, CORBA의 Java 버전이라고 봐도 무방하다.\n  <br />\n  CORBA는 여러 언어로 구현된 분산 객체간 통신을 가능케 하기 위한 표준으로 이 기술도 함께 알아보면 좋을 듯 하다.\n</tip>\n\n### Remote\n\nRemote는 Java에서 제공하는 인터페이스로 내부에 어떠한 메서드도 없다.\n즉, Marker interface로서 JVM에게 이 클래스는 RMI 기능을 내포하고 있음을 알려주는 역할로 사용하게 된다.\n\n```java:GumballMachineRemote.java\npublic interface GumballMachineRemote extends Remote {\n  public int getConut() throws RemoteException;\n  public String getLocation() throws RemoteException;\n  public State getState() throws RemoteException;\n}\n```\n\n여기서 눈여겨 봐야 할 점은 Remote 메서드들이 모두 RemoteException 에러를 던질 수 있도록 해야한다는 점이다.\n그 이유는, 네트워크가 끊기는 경우 프로그램이 정상동작 하지 않을 수 있기 때문이다.\n\n### Examples\n\n그에 따라 상태 클래스도 약간의 변경이 필요하다.\n\n```diff-java:State.java\n- public interface State {\n+ public interface State extends Serializable {\n    public void insertQuarter();\n    public void ejectQuarter();\n    public void turnCrank();\n    public void dispense();\n}\n```\n\nSerializable 하는 이유는, 네트워크 통신을 할 때 객체를 직렬화해서 전송해야 하기 때문이다.\n\n```diff-java:GumballMachine.java\n\n- public class GumballMachine {\n+ public class GumballMachine extends UnicastRemoteObject implements GumballMachineRemote {\n    ...\n\n-   public GumballMachine(int gums) {\n+   public GumballMachine(int gums, String location) throws RemoteException\n      ...\n    }\n\n    public int getConut() {\n      return count;\n    }\n    public String getLocation() {\n      return location;\n    }\n    public State getState() {\n      return state;\n    }\n\n    ...\n  }\n```\n\n여기까지 코드를 수정하고 나면, 이제 원격에서 머신을 실행시키며 RMI 레지스트리에 등록을 해줘야 한다.\n따라서 우선 RMI 레지스트리를 활성화 시켜준다.\n\n```bash:shall\n$ rmiregistry\n```\n\n그다음 원격 머신을 실행시켜준다.\n\n```java:RemoteMain.java\npublic class RemoteMain {\n  public static void main(String args[]) {\n    GumballMachineRemote gumballMachine = new GumballMachine(10, \"my-location\");\n    Naming.rebind(\"//my-location/gumballMachine\", gumballMachine);\n  }\n}\n```\n\n여기서 rebind 메서드를 통해 레지스트리에 stub을 등록시켜 주는 것이다.\n하지만, stub을 생성 시켜주기위해 아래의 rmic (RMI Compliler) 명령어를 실행하여 만들고 난 뒤 해당 코드를 실행해야 한다.\n\n```bash:shall\n$ rmic RemoteMain\n$ java RemoteMain\n```\n\n이렇게 하면 원격 저장소에 GumballMachineRemote의 stub가 레지스트리에 등록이 되었다!\n이제 클라이언트(모니터)에서 데이터를 받아보자.\n\n```java:GumballMonitor.java\npublic class GumballMonitor {\n  GumballMachineRemote machine;\n\n  public GumballMonitor(GumballMachineRemote machine) {\n    this.machine = machine;\n  }\n\n  public void report() {\n    machine.getLocation();\n    machine.getConut();\n    machine.getState();\n    ...\n  }\n}\n```\n\n```java:MonitorMain.java\npublic class MonitorMain {\n  public static void main(String args[]) {\n    GumballMachineRemote machine = Naming.lookup(\"rmi://my-location/gumballMachine\");\n    GumballMonitor monitor = new GumballMonitor(machine);\n    monitor.report();\n  }\n}\n```\n\n여기서 lookup 메서드를 통해 원격 레지스트리에 등록된 stub을 다운로드 받아 사용하는 것이다.\n\n위 과정을 그림으로 표현하면 다음과 같으니 참고하자.\n\n![231119-214628](/posts/final_03/231119-214628.png)","slug":"univ_design-pattern/final_03","readingMinutes":5,"wordCount":478},{"title":"State Pattern","description":"State 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["State Pattern"],"draft":false,"date":"2023-11-06 / 14:46","content":"\n## 필요성\n\n우리가 Gumball machine을 개발한다고 가정해보자.\nGumball machine은 다음과 같은 동작을 수행해야 할 것이다.\n\n![231106-144938](/posts/final_02/231106-144938.png)\n\n개발 경험이 많이 없다면, 해당 동작을 함수 기반으로 작성할 것이다.\n\n```java:GumballMachine.java {9, 12-14}\npublic class GumballMachine {\n  final static int SOLD_OUT = 0;\n  final static int NO_QUARTER = 1;\n  final static int HAS_QUARTER = 2;\n  final static int SOLD = 3;\n\n  private int state = SOLD_OUT;\n\n  public void insertQuarter() {\n    if (state == SOLD_OUT) {\n      // 껌이 비었기에 동전을 넣게 못하도록 처리\n    } else if (state == NO_QUARTER) {\n      // 동전을 받았기에 state를 변경\n      state = HAS_QUARTER;\n    } else if\n    ...\n  }\n}\n```\n\n이런식으로 작성한다면 미래의 발견할 문제점이 많다는 것은 둘째치고, 그냥 뭔가 딱 보기에도 불-편하지 않은가?\n실제로 다음과 같은 문제점도 발생할 가능성이 높다.\n\n- 상태가 많을수록 조건문이 많아짐\n- 상태 상수를 변경하거나, 추가, 삭제시 모든 함수에 대한 수정이 필요함\n\n한 마디로, `유지보수`하기에 너무나도 좋지 못한 방법이다.\n\n## State Pattern\n\n앞의 방식은 상태의 변화, **Transition을 중심**으로 한 코드 작성 방식이었다.\n\n하지만, 상태별로 취해야 할 행동을 다르게 정의하고, 그렇게 정의된 상태를 갖도록 하는 디자인 패턴을 `State Pattern` 라고 하는데,\n말로 하면 이해가 어려우니 이번엔 상태, **State를 중심**으로한 코드 작성 방식을 살펴보자.\n\n```java:State.java\npublic interface State {\n  public void insertQuarter();\n  public void ejectQuarter();\n  public void turnCrank();\n  public void dispense();\n}\n```\n\n우선 각 상태에서 수행해야 할 함수를 모아 State 인터페이스를 만들어주고, 각 상태는 State 인터페이스를 구현하는 방식으로 구현한다.\n\n```java:NoQuarterState.java {8-11}\npublic class NoQuarterState implements State {\n  GumballMachine machine;\n\n  public NoQuarterState(GumballMachine machine) {\n    this.machine = machine;\n  }\n\n  public void insertQuarter() {\n    // 동전을 받았기에 state를 변경\n    machine.setState(machine.getHasQuarterState());\n  }\n  ...\n}\n```\n\n이런식으로 상태에 따라 수행 가능한 기능을 구현하는 것이다.\n\n```diff-java:GumballMachine.java\n  public class GumballMachine {\n-   final static int SOLD_OUT = 0;\n-   final static int NO_QUARTER = 1;\n-   final static int HAS_QUARTER = 2;\n-   final static int SOLD = 3;\n    // getter 구현\n+   State soldOutState;\n+   State noQuarterState;\n+   State hasQuarterState;\n+   State soldState;\n\n-   private int state = SOLD_OUT;\n+   private State state = soldOutState;\n    int count = 0;\n\n    public GumballMachine(int gums) {\n      this.count = gums;\n      soldOutState = new SoldOutState(this);\n      noQuarterState = new NoQuarterState(this);\n      ...\n      if (gums > 0) {\n        state = noQuarterState;\n      }\n    }\n\n    public void setState(State state) {\n      this.state = state;\n    }\n\n    public void insertQuarter() {\n-     if (state == SOLD_OUT) {\n-       // 껌이 비었기에 동전을 넣게 못하도록 처리\n-     } else if (state == NO_QUARTER) {\n-       // 동전을 받았기에 state를 변경\n-       state = HAS_QUARTER;\n-     } else if\n-     ...\n+     state.insertQuarter();\n    }\n  }\n```\n\n이제 GumballMachine은 상태를 상수로 관리하는 것이 아닌, 클래스로 관리하게 되고, 현재 상태에 따라 호출되는 함수의 기능이 달라지게 된다.\n\n이렇게 구현하면 유지보수도 간편해지는게, 상태를 변경한다고 하면, 해당 상태의 클래스만 수정하면 되고,\n상태를 추가한다고 하면 상태 클래스를 추가하고 GumballMachine의 상단에 상태를 보관할 수 있게만 추가하면 된다.","slug":"univ_design-pattern/final_02","readingMinutes":5,"wordCount":454},{"title":"Composite Pattern","description":"Composite 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Composite Pattern"],"draft":false,"date":"2023-11-06 / 12:26","content":"\n## 필요성\n\n트리구조와 같은 데이터에 순차 접근해야 하는 상황을 가정해보자.\nIterator pattern으로 구현된 자료구조에 접근할 때의 문제점은, Iterator로 반환되는 객체의 타입이 동일해야 한다는 것이다.\n무슨 말이냐면, i번째 접근하는 자료형과 k번째 접근하는 자료형(인터페이스)이 동일해야 한다는 것이다.\n\n이 때 만약, leaf node와 inner node가 다른 방식으로 동작한다고 해서 다른 자료형으로 구현한다면?\n노드 타입을 검사하고, 타입에 맞는 순차탐색 과정을 거치는 등 순차탐색하는 과정이 매우 복잡해질 것이다.\n\n## Composite Pattern\n\n이런 순차탐색에서의 불편함을 없애고자, leaf, inner node **모두 동일한 `component class`를 구현**하는 방식을 Composite Pattern 이라고 한다.\n예시 코드를 살펴보자.\n\n```java:MenuComponent.java\npublic abstract class MenuComponent {\n  // For inner node\n  public void add(MenuComponent c) {\n    throw new UnsupportedOperationException();\n  }\n  public void remove(MenuComponent c) {\n    throw new UnsupportedOperationException();\n  }\n  public MenuComponent getChild(int i) {\n    throw new UnsupportedOperationException();\n  }\n  // For all node\n  public void print() {\n    throw new UnsupportedOperationException();\n  }\n  public String getName() {\n    throw new UnsupportedOperationException();\n  }\n  ...\n}\n```\n\n이제 leaf, inner node에서 위 클래스를 extends 하여 구현하면 모두 동일한 인터페이스(메서드)를 갖게되어 Iterator를 이용한 순차탐색이 가능해진다.\n(Iterator\\<MenuComponent\\> 이런 느낌)\n\n```java:MenuItem.java\n// leaf node\npublic class MenuItem extends MenuComponent {\n  String name;\n  ...\n  public MenuItem(String name, ...) {\n    this.name = name;\n    ...\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void print() {\n    System.out.println(getName());\n  }\n  ...\n}\n```\n\n이런식으로 필요한 메서드만 override 해서 사용하면 된다.\n만약, override하지 않은 메서드를 호출한다면 UnsupportedOperationException이 발생하는 것이다.\n\n```java:Menu.java\npublic class Menu extends MenuComponent {\n  ArrayList menuComponents = new ArrayList();\n  String name;\n  ...\n  public Menu(String name, ...) {\n    this.name = name;\n    ...\n  }\n\n  public void add(MenuComponent c) {\n    menuComponents.add(c);\n  }\n  public void remove(MenuComponent c) {\n    menuComponents.remove(c);\n  }\n  public void getChild(int i) {\n    return (MenuComponent)menuComponents.get(i);\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void print() {\n    System.out.println(getName());\n    System.out.println(\"===========\");\n\n    Iterator iter = menuComponents.iterator();\n    while(iter.hasNext()) {\n      MenuComponent menuComp = (MenuComponent)iter.next();\n      menuComp.print();\n    }\n  }\n  ...\n}\n```\n\n이런식으로 MenuItem(leaf), Menu(inner) 모두 동일한 print 라는 메서드를 호출할 수 있지만,\n구현을 다르게 했기 때문에 동작이 달라진다.\n\n이제 메뉴를 출력하든, 메뉴의 각 음식을 출력하든, 나아가 모든 메뉴를 출력(`클라이언트`가 하는 일)하든 상관없이\nMenuComponent 클래스를 상속하여 만든 객체는 print를 호출하여 출력할 수 있다.\n\n### vs. Decorator\n\nMenu 클래스를 보면 뭔가 느낌이 Decorator Pattern을 보는 것과 비슷한 느낌을 받을 수 있다.\n자식 클래스에서 부모 클래스를 멤버 변수로 가지며, override 한다는 점에서 비슷하다.\n\n하지만, 사용 목적에 차이점이 있음을 알고가면 좋을 거 같다.\n\n`Decorator Pattern`은 leaf node에 해당하는 부분의 **변화를 가하지 않고 추가 기능 구현**을 위해 override 한다는 데 목적이 있다면,\n\n`Composite Pattern`은 계층 구조의 모든 노드가 **같은 인터페이스로 클라이언트에서 접근**할 수 있도록 하는데에 목적이 있다.","slug":"univ_design-pattern/final_01","readingMinutes":5,"wordCount":408},{"title":"Matrix and Transformations","description":"행렬에 대한 기본적인 내용과 이를 이용한 공간상에서의 변환에 대해 다뤄봅니다.","icon":"","image":"","tags":["Matrix","Transform","Translate","Basis","Linear Map","Homogeneous Coordinates"],"draft":false,"date":"2023-10-23 / 22:09","content":"\n## Matrix\n\n$$\n\\begin{pmatrix}\na_{11} & a_{12} & ... & a_{1n} \\\\\na_{21} & a_{22} & ... & a_{2n} \\\\\n... & ... & ... & ... \\\\\na_{m1} & a_{m2} & ... & a_{mn} \\\\\n\\end{pmatrix}\n$$\n\nm-by-n matrix, 또는 **m행(Row) n열(Column)** 의 행렬이라고 부른다.\n\n여기서 하나의 **행** 만으로 이루어진 행렬을 `Row vectors`, \n한 **열**로만 이루어진 행렬을 `Column vectors` 라고 부른다.\n\n### Transpose\n\n$$\n(A^T)_{ij} = A_{ji}\n$$\n\n각 행과 열을 뒤집은 행렬을 전치행렬 이라고 부른다.\n\n### Square Matrix\n\n행과 열의 개수가 같은 행렬을 의미한다.\n\n### Identity Matrix\n\n$$\n\\begin{pmatrix}\n1 & 0 \\\\\n0 & 1 \\\\\n\\end{pmatrix}\n, \\;\n\\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n\\end{pmatrix}\n$$\n\n위와 같이 Square Matrix인데 대각선만 1이고, 나머지는 0으로 채워진 행렬을 의미한다.\n\n> AI = IA = A\n\n이 행렬의 가장 큰 특징은 행렬 A에 Identity Matrix를 곱하면 다시 행렬 A가 나온다는 것이다.\n\n### Scalar Multiplication & Addition\n\n백터에 스칼라 곱을 하거나, 백터간 합이나 차를 구할 때는 [**이전 포스트**](https://wjlee611.github.io/blog/univ_virtual-worlds/mid_03)에서 벡터의 연산을 했을 때와 동일하게 **각 원소에 대해 연산**을 진행하면 된다.\n\n### Matrix Multiplication\n\n![231023-222141](/posts/mid_04/231023-222141.png)\n\n행렬간 곱 연산은 위의 이미지와 같이 계산된다.\n여기서 주의할 점은 **앞의 행렬의 `열`** 의 개수와 **뒤의 행렬의 `행`** 의 개수가 일치해야 한다는 점이다.\n\n---\n\n## Transformations\n\n### Basis\n\n변환에 앞서 기저에 대해 알 필요가 있다.\n선형 독립인 벡터들이 공간을 생성(span)할 때, 그 벡터의 집합을 기저(basis)라고 한다.\n\n<tip>\n`선형 독립 (Linear Independent)`\n<br />\nN차원에서 어떤 하나의 벡터가 나머지 N-1개의 벡터의 **선형 결합으로 표현할 수 없는 경우**, N개의 벡터들이 선형 독립이라고 한다.\n즉, 벡터간 의존성이 없어야 한다.\n</tip>\n\n벡터가 공간을 생성한다는 의미를 잘 모를 수 있는데, 예로 들어보자.\n\n![231023-230449](/posts/mid_04/231023-230449.png)\n\nv는 한 평면위의 벡터이다.\n이 상태에서 $v_1, \\; v_2$의 값을 [-$\\infty$, $\\infty$] 범위로 임의 조정한다고 가정해보자.\n그럼 v는 어떤 범위의 종점 좌표를 가질 수 있을까?\n바로 벡터 a, b가 속한 평면의 모든 좌표를 가질 수 있을 것이다.\n\n즉, **평행하지 않은 벡터의 선형 결합으로 공간을 생성**할 수 있는 것이다.\n\n그렇다면 두 벡터가 평행하지 않는다는 조건도 이해가 될 것이다.\n만약 두 벡터가 **평행**하다, 즉, **하나의 벡터로 다른 벡터를 표현**할 수 있다, 다른 말로 두 벡터가 **선형 의존**이라면, v는 직선상에만 존재할 수 있기 때문이다.\n\n그럼 다시 basis 얘기로 돌아와서, basis의 선형 결합으로 basis가 span하는 공간의 모든 벡터를 표현할 수 있다는 것을 이해했다.\n이 때 성립하는 증명이 있다.\n\n> 같은 basis의 선형결합으로 표현되는 벡터는 표현 방법이 1개로 유일하다.\n\n위의 증명된 내용 덕분에, basis의 선형 결합 시 사용하는 weight를 좌표로써 활용할 수 있는 것이다.\n그렇기에 basis를 바꾼다는 건 좌표값을 바꾸는 것일 뿐, 벡터 그 자체를 바꾸는게 아니다.\n\n### Linear Map\n\n선형 사상이란 벡터의 기저를 바꿀 때, 즉 **벡터 공간이 바뀔 때 변형시에 선형성이 유지되는 변환 함수($F$)** 를 말한다.\n\n예로 들어 아래는 선형 사상이다.\n![231023-232038](/posts/mid_04/231023-232038.png)\n\n하지만, 이 경우는 선형 사상이 아니다.\n![231023-232104](/posts/mid_04/231023-232104.png)\n\n음? 그런데 이게 기저가 바뀌는거랑 무슨 상관이냐고?\n이제 기저를 선형 사상(변환 함수)에 대입해보며 알아보자.\n\n$$\n\\widehat{\\textrm{v}} = F\\textrm{v} \\\\\n{} \\\\\n\\begin{pmatrix}\n\\widehat{v_1} \\\\\n\\widehat{v_2} \\\\\n\\widehat{v_3}\n\\end{pmatrix} =\n\\begin{bmatrix}\nf_{11} & f_{12} & f_{13} \\\\\nf_{21} & f_{22} & f_{23} \\\\\nf_{31} & f_{32} & f_{33} \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\nv_1 \\\\\nv_2 \\\\\nv_3\n\\end{pmatrix} \n$$\n\n이해를 돕기 위해 $v_1$, $v_2$, $v_3$을 $x$, $y$, $z$ 라고 생각해보자.\n\n이제 ($v_1$, $v_2$, $v_3$) 대신에 (1, 0, 0) 을 대입해보자.\n이 때, (1, 0, 0)은 x축을 가리키는 기저의 원소이다.\n\n\n$$\n\\begin{pmatrix}\n\\widehat{v_1} \\\\\n\\widehat{v_2} \\\\\n\\widehat{v_3}\n\\end{pmatrix} =\n\\begin{bmatrix}\nf_{11} & f_{12} & f_{13} \\\\\nf_{21} & f_{22} & f_{23} \\\\\nf_{31} & f_{32} & f_{33} \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{pmatrix} =\n\\begin{pmatrix}\nf_{11} \\\\\nf_{21} \\\\\nf_{31}\n\\end{pmatrix} \n$$\n\n즉, 선형 사상($F$) 로 인해 기저 x(1, 0, 0)는 $(f_{11}, \\; f_{21}, \\; f_{31})^T$로 변환되었다.\n\n여기서 알 수 있는 것은 선형 사상, **Linear Function $F$의 i번째 열 벡터는 i번째 축의 기저벡터가 어디로 대응**되는가를 알려준다.\n또한, 위의 변환 과정은 선형성이 유지된다.\n\n참고로 선형성이 유지되는 특성 덕분에 여러 선형 사상을 한 번에 처리하는 것 또한 가능해진다.\n\n> A(B(C(D(x)))) = ABCDx = $\\textrm{x}^TD^TC^TB^TA^T$\n\n### 2D Linear Transformations\n\n우선 회전을 살펴보자.\n\n![231023-234010](/posts/mid_04/231023-234010.png)\n\n선형 사상을 이용한 기저의 변환을 어느정도 이해했다면 이제 변형식이 왜 이렇게 생겼는지도 이해할 수 있을 것이다.\n\n예로 들어 (1,0) 즉 x축의 기저벡터를 $\\theta$ 만큼 회전시킨 좌표는 ($cos \\theta$, $sin \\theta$)가 되는데, 이는 위에서 언급한 \"선형 사상, **Linear Function $F$의 i번째 열 벡터는 i번째 축의 기저벡터가 어디로 대응**되는가를 알려준다\" 와 완벽히 일치한다.\n\n<tip>\n  즉, 앞으로의 변환은 각 축의 기저 벡터가 어떻게 변하는지를 파악하고, 해당 **변화 후의 값을 이용**해서 선형 사상 함수를 작성하면 된다.\n</tip>\n\n이런 내용을 염두하고 다른 변환들도 살펴보자.\n\n![231023-235906](/posts/mid_04/231023-235906.png)\n\n![231024-000043](/posts/mid_04/231024-000043.png)\n\n![231024-000102](/posts/mid_04/231024-000102.png)\n\n### Affine Maps\n\n2D Translation을 가능케하는 Transformations 이 있을까?\n\n![231024-000319](/posts/mid_04/231024-000319.png)\n\n없다.\n그 이유는 **이동은 선형 변환이 아니**라서 이를 표현할 선형 사상 함수가 없기 때문이다.\n\n즉, Affine Map은 Linear map + Translation 으로 표현할 수 밖에 없다.\n왜냐면 Affine은 Linear하지 않기 때문이다.\n\n### Homogeneous Coordinates\n\n그렇다면 Transform과 Translate를 동시에 처리할 수 있는 방법이 없을까?\n바로 Homogeneous Coordinates를 이용하면 된다.\n\n이게 뭐냐면, 2차원의 Homogeneous Coordinates는 3차원의 벡터가 된다는 건데, 예시를 들어보자.\n\n$$\n\\begin{pmatrix}\nwx' \\\\\nwy' \\\\\nw\n\\end{pmatrix} =\n\\begin{bmatrix}\n1 & 0 & t_x \\\\\n0 & 1 & t_y \\\\\n0 & 0 & 1 \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\nwx \\\\\nwy \\\\\nw\n\\end{pmatrix}\n$$\n\n적당하게 w 기저를 하나 더 만들어서 차원을 높였다.\n이 때, ($wx$, $wy$, $w$)를 Homogeneous Coordinates 라고 하는데, 이제 여기에 계산의 편의를 위해 $w$에 1을 대입해보자.\n\n$$\n\\begin{pmatrix}\nx' \\\\\ny' \\\\\n1\n\\end{pmatrix} =\n\\begin{bmatrix}\n1 & 0 & t_x \\\\\n0 & 1 & t_y \\\\\n0 & 0 & 1 \\\\\n\\end{bmatrix}\n\\begin{pmatrix}\nx \\\\\ny \\\\\n1\n\\end{pmatrix} = \n\\begin{pmatrix}\nx + t_x \\\\\ny + t_y \\\\\n1\n\\end{pmatrix}\n$$\n\n결과는?\n놀랍게도 Transformations 한 방식과 동일하게 진행되었는데 결과는 Translate 한 결과가 나왔다.\n이를 이용하면 2D 에서의 모든 변형은 다음과 같은 4개의 행렬의 곱으로 표현이 가능해진다.\n\n![231024-002119](/posts/mid_04/231024-002119.png)\n\n즉, 좌상단의 2x2 행렬은 Transform을 위한 부분이고, 우상단의 2x1 행렬은 Translate를 위한 부분이다.\n\n참고용으로 3D에 대한 Homogeneous Coordinates도 남겨놓겠다.\n![231024-002347](/posts/mid_04/231024-002347.png)\n\n### Compound Transformations\n\nLinear Map의 마지막에 언급한 사실에 근거해 이제 모든 변환은 합성 변환으로 치환할 수 있다.\n\n> A(B(C(D(x)))) = ABCDx = $\\textrm{x}^TD^TC^TB^TA^T$\n\n그렇게 하면 ABCDx 이 행렬곱을 정리하기만 하면 A~D 까지의 모든 변환을 한 번에 수행하는 결과를 얻을 수 있으니 연산량이 매우 감소하게 된다.\n\n<notice>\n  단, 연산 순서에 주의해야 한다.\n  <br />\n  ![231024-002828](/posts/mid_04/231024-002828.png)\n</notice>\n\n이제 연산량이 어떻게 변하는지 예시를 살펴보자.\n\n![231024-003050](/posts/mid_04/231024-003050.png)\n\n이를 응용하면 특정 방향으로만 스케일링 하는 것도 구현할 수 있다.\n\n![231024-003225](/posts/mid_04/231024-003225.png)","slug":"univ_virtual-worlds/mid_04","readingMinutes":11,"wordCount":1032},{"title":"Vector","description":"벡터에 대한 기본적인 내용에 대해 다뤄봅니다.","icon":"","image":"","tags":["Vector","Points"],"draft":false,"date":"2023-10-23 / 20:12","content":"\n<notice>\n  Vector와 Points는 (1, 2, 3) 과 같이 숫자로된 좌표로 표현된다는 점에서는 비슷하다.\n  <br />\n  하지만, `Points`는 **공간의 위치**를 나타내지만, `Vector`은 **방향과 크기**를 나타낸다는 점이서 다르다.\n  (벡터는 위치 개념이 없음. 상대적인 방향과 크기만을 가질 뿐) \n</notice>\n\n## Vector Algebra\n\n### Scalar Multiplication\n\n![231023-204033](/posts/mid_03/231023-204033.png)\n\n해당 방향으로 크기만 증가하는 연산이다.\n**벡터의 각 성분에 크기 c만큼 각각 곱해주면** 된다.\n\n### Addition\n\n![231023-204232](/posts/mid_03/231023-204232.png)\n\nA 벡터의 종점에 B 벡터의 시점을 이어붙이는 연산으로, 그 값은 A 벡터의 시점 &rarr; B 벡터의 종점이 된다.\n평행 사변형법으로도 계산할 수 있으며, **벡터의 각 성분끼리 더하면** 된다.\n\n### Substraction\n\n![231023-204432](/posts/mid_03/231023-204432.png)\n\n벡터에 -1을 스칼라 곱을 한 후, Addition을 한 결과와 같은 연산이다.\n**벡터의 각 성분을 빼주면** 된다.\n\n### Length & Direction\n\n![231023-204636](/posts/mid_03/231023-204636.png)\n\n벡터의 크기($L$)와 x축에 대한 방향($\\theta$)는 다음과 같다.\n\n> $L = \\sqrt{x^2 + y^2}$\n>\n> $\\theta = tan^{-1}\\frac{y}{x}$\n\n<tip>\n  크기가 1인 벡터를 `단위벡터` 라고 하며, 벡터를 단위벡터로 변환하는 것을 **Normalization** 이라고 한다.\n  백터를 Normalization 하는 법은 **벡터의 각 성분을 $L$로 나눠주면** 된다.\n</tip>\n\n### Linear Combination\n\n벡터들을 선형결합 하는 것을 의미한다.\n\n> $b = c_1v_1 + c_2v_2 + ... + c_kv_k$\n\n이는 $v_1$, $v_2$, ..., $v_k$의 선형 결합이며, 상수 c를 weight라고 부른다.\n\n이 weight 값에 따라 다른 명칭으로 불리기도 한다.\n\n- `Affine Combination`\n  weight의 합이 반드시 1이 되는 선형결합.\n\n- `Convex Combination`\n  weight이 모두 양수이고, 합이 반드시 1이 되는 선형결합.\n\n### Dot product (내적)\n\n![231023-211310](/posts/mid_03/231023-211310.png)\n\n내적의 연산 결과는 스칼라가 되는데 우선 식부터 살펴보자.\n\n> $\\overrightarrow{a} \\cdot \\overrightarrow{b} = a_1b_1 + a_2b_2 = \\begin{Vmatrix} \\overrightarrow{a} \\end{Vmatrix} \\begin{Vmatrix} \\overrightarrow{b} \\end{Vmatrix} cos \\theta$\n\n내적은 사잇각을 알아내는데 사용할 수 있는데, 그런데 내적 그 자체는 무슨 의미를 가질까?\n유닛벡터에 대해 다음과 같은 내적값은 다음과 같은 의미를 갖는다.\n\n- `1`\n  두 벡터가 **같은 방향으로 평행**하다\n\n- `-1`\n  두 벡터가 **정 반대 방향으로 평행**하다\n\n- `0`\n  두 벡터가 **수직**한다\n\n- `>0`\n  두 벡터가 **같은 방향**이다\n\n- `<0`\n  두 벡터가 **다른 방향**이다\n\n### Projection\n\n내적을 응용하면 한 벡터를 다른 벡터에 사상한 벡터를 얻을 수 있다.\n\n![231023-212348](/posts/mid_03/231023-212348.png)\n\n$\\overrightarrow{a'}$ 벡터의 길이는 **$\\begin{Vmatrix} \\overrightarrow{a} \\end{Vmatrix} cos \\theta$** 와 같다.\n또한 $\\overrightarrow{a'}$ 벡터의 단위벡터는 **$\\frac{1}{||\\overrightarrow{b}||} \\overrightarrow{b}$** 이다.\n\n따라서 둘을 곱한 다음의 식이 벡터 a를 벡터 b에 사상한 벡터가 된다.\n\n![231023-213605](/posts/mid_03/231023-213605.png)\n\n### Cross produce (외적)\n\n![231023-213718](/posts/mid_03/231023-213718.png)\n\n> $\\overrightarrow{a} \\times \\overrightarrow{b} = \\begin{Vmatrix} \\overrightarrow{a} \\end{Vmatrix} \\begin{Vmatrix} \\overrightarrow{b} \\end{Vmatrix} sin \\theta \\cdot \\overrightarrow{n}$\n>\n> 여기서 $\\overrightarrow{n}$은 벡터 a, b에 수직한 유닛 벡터\n\n외적 두 벡터의 수직인 벡터로, 그 크기는 두 벡터가 이루는 평행사변형의 넓이이다.\n\n계산은 아래와 같이 하면 된다.\n\n$$\n\\begin{pmatrix}\na_1 \\\\\na_2 \\\\\na_3\n\\end{pmatrix} \\times\n\\begin{pmatrix}\nb_1 \\\\\nb_2 \\\\\nb_3\n\\end{pmatrix} =\n\\begin{pmatrix}\na_2b_3 - a_3b_2 \\\\\na_3b_1 - a_1b_3 \\\\\na_1b_2 - a_2b_1\n\\end{pmatrix}\n$$\n\n### Normal Vector\n\n한 평면에 대한 수직 단위벡터로 외적을 이용하면 구할 수 있다.\n\n![231023-214703](/posts/mid_03/231023-214703.png)\n\n---\n\n## Points Algebra\n\nPoints 는 더하거나, 스칼라곱에 대한 정의가 없다.\n하지만, 특수 상황에서는 의미를 갖는데, 그것들에 대해 알아보자.\n\n### Point - Point\n\n![231023-210346](/posts/mid_03/231023-210346.png)\n\nPoint B에서 Point A를 뺴면, 그 결과는 A&rarr;B `Vector`가 된다.\n\n### Point + Vector\n\n![231023-210527](/posts/mid_03/231023-210527.png)\n\nPoint에 Vector를 더하거나 빼면 다른 `Point`가 된다.\n\n### Affine Combination\n\n위에서 언급했 듯, Points 는 더하거나, 스칼라곱에 대한 정의가 없다.\n하지만, 스칼라 곱 중에서 그 weight의 합이 1이 되는 경우 내분, 또는 외분의 의미를 갖게된다.","slug":"univ_virtual-worlds/mid_03","readingMinutes":6,"wordCount":506},{"title":"Modeling","description":"모델을 저장하는 방법에 대해 알아봅나디.","icon":"","image":"","tags":["Coordinate Systems","Polygonal Meshes"],"draft":false,"date":"2023-10-23 / 19:47","content":"\n## Coordinate Systems\n\n어떤 데이터든 간에 3D 공간상에 표현하기 위해서는 좌표 시스템을 먼저 구현해야 한다.\n그래야 공간상의 좌표의 조합으로 모델을 생성할 수 있기 때문이다.\n\n![231023-195004](/posts/mid_02/231023-195004.png)\n\n개발 환경에 따라 왼손 좌표계를 쓰거나 오른손 좌표계를 쓰는데, 참고로 유니티는 왼손 좌표계를 사용한다.\n따라서 유니티 관련 포스트는 모두 왼손 좌표계 기준으로 기술될 예정이다.\n\n---\n\n## Polygonal Meshes\n\n![231023-195154](/posts/mid_02/231023-195154.png)\n\n모든 3D 오브젝트를 삼각형 평면을 이어붙힌 형태로 표현하는 기법으로, 가장 많이 사용되는 방식이다.\n이런 데이터를 저장하는 방식에는 크게 3가지로 나뉘는데 각각 어떤식으로 데이터를 관리하는지 살펴보자.\n\n<tip>\n  mesh들은 OBJ, 3DS, POV 등의 확장자로 관리되는데,\n  OBJ의 경우 아래와 같은 정보를 저장한다.\n  - vertex의 좌표\n  - 각 vertex의 택스쳐 좌표\n  - 각 vertex의 수직 vertex\n  - 위의 vertex들로 표현돤 face\n</tip>\n\n### Vertex-Vertex\n\n![231023-195357](/posts/mid_02/231023-195357.png)\n\n오직 점들만 데이터로 관리하는 자료구조를 사용한다.\n각 vertex의 **좌표**와 인접한(연결된) **vertex**를 저장한다.\n\n면에 대한 정보는 저장하지 않기에 추가적인 연산을 통해 얻어낼 수 밖에 없다.\n그렇기에 용량은 가장 작지만, 연산에 대한 부담이 있는 모델이다.\n\n### Face-Vertex\n\n![231023-195627](/posts/mid_02/231023-195627.png)\n\n점과 면을 데이터로 관리하는 자료구조를 사용하며, 가장 많이 사용되는 방식이다.\n`face`는 face를 구성하고 있는 **vertex**들의 집합으로 관리되고,\n`vertex`는 vertex의 **좌표**와 인접한 **faces**들의 집합으로 관리된다.\n\n### Winged Edge\n\n![231023-195936](/posts/mid_02/231023-195936.png)\n\n점과 면, 추가로 모서리의 데이터로 관리하는 자료구조를 사용하며, mesh를 변화시켜야 할 상황에 유용하게 사용할 수 있다.\n`face`는 face를 구성하고 있는 **edge**들의 집합으로 관리되고,\n`vertex`는 vertex에 연결된 **edge**들의 집합으로 관리된다.\n마지막으로 `edge`는 **시점, 종점의 좌표**와 **분할하는 면**, 그리고 연결된 edge 중 4개의 edge로 관리되는데,\n4개의 edge는 **시점에 연결된 back CCW, back CW, 종점에 연결된 front CCW, front CW** 순으로 관리된다. (그림 참고)","slug":"univ_virtual-worlds/mid_02","readingMinutes":4,"wordCount":241},{"title":"Unity Engine","description":"유니티 게임 엔진에 대한 기초적인 이론을 알아봅니다.","icon":"","image":"","tags":["Unity","Resource Management","Game Loop","Delta Time"],"draft":false,"date":"2023-10-23 / 17:46","content":"\n## Engine Architecture\n\n정말 말도안되게 깊고 넓은 레이어가 있는데, 간략하게 무슨 역할만을 하는지 살펴보자.\n~~(괜히 게임이 종합 예술이 아닌...)~~\n\n- Platform Independence Layer\n  디바이스에 상관없이 구동시키기 위한 레이어\n\n- Core systems\n  각종 코어 유틸리티들의 집합.\n  메모리 관리, 수학 라이브러리, 자체 자료구조 알고리즘 등.\n\n- Resource Manager\n  각종 에셋글의 생성과 관리, 배치 등의 총괄적인 관리를 담당.\n  **생성은 개발단계**에서, **배치는 런타임**에 관리된다.\n\n- Rendering Engine\n  에셋 등 데이터를 픽셀로 랜더링.\n  Projection, Shading, Texture sampling 등이 여기서 처리됨.\n\n- Scene Graph/Culling Optimization\n  시야에 안보이는 부분을 잘라내여 보이는 부분만 랜더링하도록 최적화.\n\n- Visual Effects\n  광원, 명암 등, 이미지(비주얼) 향상을 위한 후처리 과정.\n\n- Collision and Physics\n  충돌 및 물리 계산.\n\n- Animation\n  에셋들의 물리법칙을 에외한 움직임.\n\n- Human Interface Devices (HID)\n  사용자 입력, 움직임 등의 장치 관리.\n\n- Gameplay Foundation systems\n  게임 개발 환경 제공.\n\n---\n\n## Resource Management\n\n리소스에는 Meshes, audio, animation 등등 여러 raw resources 가 존재하는데, 각 리소스가 어떻게 처리되어야 하는지는 각 리소스의 Metadata를 참고하면 알 수 있다.\n\n리소스 생성과정은 다음과 같다.\n1. Maya, Photoshop 등과 같은 서드파티 앱에서 Export 한다.\n2. 이후 유니티가 game-ready 에셋인 `prefeb`으로 변환하기 위해 리소스 컴파일러가 구동된다.\n3. 추가로 여러 리소스를 하나의 패키지로 합치기 위해 링커도 제공한다.\n\n### Runtime\n\n유니티가 런타임에 어떻게 리소스를 관리하는지 개념적으로 알아보자.\n\n우선 유니티는 동일한 리소스는 특정 시각에 반드시 **1개**만 메모리에 올라오도록 보장한다.\n무슨 말이냐면 원할 때 리소스가 불러와지고, 이게 중복되어 불러와져 메모리 낭비를 하지 않게끔 해준다는 뜻인데, 이는 유니티의 **로딩 정책** 덕분에 가능해졌다.\n\n![231023-181333](/posts/mid_01/231023-181333.png)\n\n유니티는 리소스를 `비동기 로드`하기 때문에 로드해야 할 시점보다 미리 로딩한다.\n예로 들어 Level 1 에서는 A, B, C 리소스가 필요한데, 레벨 실행 전에 먼저 필요한 리소스의 목록을 파악해서 로딩하고, 로딩이 완료된 후에 레벨을 진행하는 방식으로 진행된다.\n\n이 때, 각 리소스별로 `Reference count`를 둬서 쓸데없는 중복 로딩이나, 필요 없는 리소스를 메모리에서 제거하기도 한다.\nref count가 0보다 큰데 로딩되지 않은 리소스는 로딩하고, ref count가 0인데 로딩된 리소스는 언로드 하도록 하는 것이다.\n\n메모리에서 제거하는 원리는, GC(Garbage Collector)가 일정 주기로 ref count가 0인 리소스를 제거한다.\n`System.GC.Collect()` 를 이용하면 수동적으로 GC를 호출할 수 있지만, 가능하면 그러지 말자.\n\n정리하면 런타임에 리소스 매니저는 아래의 역할을 수행할 수 있어야 한다.\n1. 동일한 리소스는 특정 시각에 메모리에 1개만 올라오도록 보장\n2. 각 리소스의 생명주기를 관리\n3. prefeb과 같은 여러군데 흩어진 리소스의 묶음을 관리할 수 있어야 한다\n4. 리소스간 참조의 무결성을 보장해야 한다\n5. 이미 로드된 리소스의 메모리 사용량도 관리해야 한다\n\n### Location\n\n리소스가 어디에 존재하는지에 따라 런타임시 로드 방식이 달라진다.\n\n- AssetBundles\n  유니티 플레이어 외부의 리소스로, 보통 웹서버 상에 존재하는 리소스이다.\n  `AssetBundle.LoadAsset()` 으로 불러올 수 있다.\n\n- Resource folders\n  유니티 플레이어 내부의 리소스로, Project view의 Resources 폴더에 존재하는 리소스이다.\n  `Resources.Load()` 로 불러올 수 있다.\n\n---\n\n## Game Loop\n\n매 프레임 상태 변경을 하거나, 사용자 입력을 받거나, 화면 랜더링을 위한 무한 루프를 의미한다.\n1초에 얼마나 루프가 돌아가는지를 나타내는 척도가 FPS인데, 엄밀히 말하면 화면이 그려지는 횟수지만, 한 루프에 한 번 화면이 업데이트되니 거의 같이 사용할 수 있다.\n\n유니티에선 거의 대부분의 클래스가 `MonoBehavior`를 상속하여 정의하는데, 여기에서 `Update()` 함수가 프레임당 한 번 호출이 이루어진다.\n\n그 외에도 override할 수 있는 다른 함수 몇 개 더 알아보자.\n\n- `Start()`\n  첫 프레임 업데이트시 호출되는 함수.\n\n- `LateUpdate()`\n  Update() 함수가 종료되고나서 호출되는 함수.\n\n- `OnDestory()`\n  소멸자 비스무리한 함수.\n  마지막 프레임의 업데이트가 완료되고 나서 호출되는 함수.\n\n### Delta Time\n\n두 인접한 프레임 사이의 시간이 얼마나 흘렀는가를 나타내는 값으로, 보통 그 값은 FPS의 역수이다.\n즉, 30FPS 게임에서의 $\\Delta t$는 1/30 seconds, 즉, 3.33ms이다.\n\n두 프레임 사이의 시간이므로 물리 시뮬레이션시 시간 변화율로서 동작하게 되는데, 물리량을 수식화 하면 다음과 같다.\n\n| 의미 | 수식 |\n|---|---|\n| Position | $p_{t+\\Delta t} = p_t + v_t \\cdot \\Delta t$ |\n| Velocity | $v_{t+\\Delta t} = v_t + a_t \\cdot \\Delta t$ |\n| Acceleration | $a_{t+\\Delta t} = f_{ext}/m$ |\n\n즉, $\\Delta t$가 너무 크거나 일정하지 않으면 물리량에 오차가 커질 수 밖에 없다.\n만약 델타값을 고정시키고, 이를 게임 루프에 의존해서 증가시킨다면 컴퓨터 사양에 따라 다르게 동작하는 현상이 발생할 수 있다.\n\n따라서, 유니티는 **CPU**의 `high-resolution timer`를 이용해서 델타값을 구하기 때문에 현실세계와 유사한 플레이 경험을 얻을 수 있도록 합니다.","slug":"univ_virtual-worlds/mid_01","readingMinutes":8,"wordCount":640},{"title":"기계학습 - 비지도 & 반지도학습","description":"비지도 & 반지도학습에서 사용되는 개념에 대해 알아봅니다.","icon":"","image":"","tags":["Unsupervised learning","Clustering","Semi-supervised learning"],"draft":false,"date":"2023-10-22 / 22:58","content":"\n## 비지도학습\n\n지도학습은 학습 데이터에 입력-출력이 명시되어 있었는데, 비지도학습은 학습 데이터에 어떠한 레이블도 붙지 않은 데이터를 이용한 학습 방법을 의미한다.\n\n비지도학습을 통해 데이터에 대한 잠재적인 구조나 계층 구조를 찾을 수 있고, 문서들을 주제에 따라 구조화 하거나, 로그를 분석한 사용 패턴을 알아내는데 적용할 수 있다.\n\n---\n\n## 군집화\n\n유사성에 따라 데이터를 분할하는 것으로, 데이터가 하나의 군집에만 소속되는 일반 군집화(Hard clustering)와 퍼지 군집화(Fuzzy clustering)으로 나뉜다.\n\n군집화는 보통 아래와 같은 용도로 사용된다.\n\n- 데이터에 내제된/일반적 구조 추정/통찰\n- 가설 설정\n- 이상 감지\n- 데이터 압축\n- 데이터 전처리 (부류(class)를 부여하는 방식)\n\n성능은 군집 내의 분산은 작을수록, 군집간의 거리는 멀수록 좋다고 평가한다.\n\n### 밀도 추정\n\n![231022-230608](/posts/mid_08/231022-230608.png)\n\n부류(class)별로 데이터를 만들어 냈을 것으로 추정되는 확률 분포를 찾는 과정으로, 각 부류 별로 주어진 데이터를 발생시키는 확률을 계산하여 가장 확률이 높은 부류로 데이터를 분류한다.\n\n분포가 수학적인 형태를 갖고있을 것을 가정하여 데이터의 분포를 가장 잘 수학적으로 표현하려고 하는 추정 방식을 `모수적 밀도 추정` 이라고 하며, 전형적으로 **Gaussian 함수의 혼합**으로 표현한다.\n\n또는, 분포에 대한 수학적 함수를 가정하지 않고, 주어진 데이터를 사용하여 밀도함수의 형태로 표현하는 방식을 `비모수적 밀도 추정` 이라고 하며, 전형적으로 **히스토그램**과 같은 방식으로 표현한다.\n\n### 차원 축소\n\n고차원의 데이터를 정보의 손실을 최소화 하면서 저차원으로 변환하는 것으로, 시각화를 직관적으로 하기 위해, 그리고 `차원의 저주 문제`를 완화하기 위해 사용한다.\n\n<tip>\n  `차원의 저주 문제`\n  <br />\n  ![231022-231121](/posts/mid_08/231022-231121.png)\n  차원이 커질수록 거리분포가 일정해지는 경향\n</tip>\n\n![231022-231254](/posts/mid_08/231022-231254.png)\n\n이를 위해 주성분을 분석하여 분산이 큰 축을 기준으로 데이터를 projection하는 방식을 사용해서 저차원으로 변환한다.\n\n### 이상치 탐지\n\n다른 데이터와 크게 달라서 관심 대상으로 봐야하는 데이터를 탐지하기 위해 사용한다.\n이런 관심대상의 데이터는 `노이즈`일 확률이 높으나, `신규성 탐지`의 경우도 항상 염두해야 한다.\n\n이상치는 아래와 같은 방식으로 탐지할 수 있다.\n\n- 점 이상치\n  다른 데이터와 비교하여 차이가 큰 데이터\n\n- 상황적 이상치\n  상황에 맞지 않는 데이터\n\n- 집단적 이상치\n  여러 데이터를 모아서 보면 비정상으로 보이는 데이터\n\n이러한 이상치 탐지는 **부정사용감지 시스템**이나 **침임감지 시스템** 등에 사용할 수 있다.\n\n---\n\n## 반지도학습\n\n비지도학습과 마찬가지로 미분류 데이터를 이용하는데, 이를 지도학습에 사용하는 방법이다.\n\n![231022-231828](/posts/mid_08/231022-231828.png)\n\n이런 식으로 같은 군집에 속하는 것은 가능한 동일한 부류에 소속하도록 학습하는 방식이다.\n미분류 데이터는 획득 비용이 낮기 때문에 이러한 지도학습 방식도 고려하면 좋다.\n\n단, 반지도학습을 위해서는 데이터가 아래와 같은 경향을 보인다는 가정하에 이루어져야 한다.\n\n- 평활성 가정\n  가까이 있는 점들은 서로 같은 부류에 속할 가능성이 높음\n\n- 군집 가정\n  같은 군집에 속하는 데이터는 서로 같은 부류에 속할 가능성이 높음\n\n- 매니폴드(Manifold) 가정\n  원래 차원보다 낮은 차원의 매니폴드에 데이터가 분포할 가능성이 높음","slug":"univ_ai/mid_08","readingMinutes":6,"wordCount":382},{"title":"기계학습 - 지도학습","description":"지도학습에서 사용되는 개념에 대해 알아봅니다.","icon":"","image":"","tags":["Supervised learning","Classification","Regression"],"draft":false,"date":"2023-10-22 / 22:02","content":"\n## 기계학습\n\n사례들(examples)을 일반화하여 패턴 또는 모델을 추출하는 과정으로 학습 데이터를 잘 설명할 수 있는 패턴을 기계 스스로 학습하는 것을 유도하는 것이다.\n\n![231022-220530](/posts/mid_07/231022-220530.png)\n\n단, 오컴의 면도날(Occam's razor) 원리에 따라 가능하면 학습 결과가 간단한 형태로 표현되면 좋다.\n\n기계학습의 종류에는 지도학습, 비지도학습, 반지도학습, 강화학습과 같은 방법이 있는데, 이번에는 지도학습에 대해서만 알아보자.\n\n### 지도학습\n\n주어진 학습 데이터 - **(입력, 출력)** 과 같은 데이터를 이용해서 학습하는 과정.\n학습이 완료된 모델은 새로운 **(입력)** 이 있을 때 **(출력)** 을 유추할 수 있어야 한다.\n\n출력이 불 연속적인 값이어야 한다면 데이터를 `분류`하는 방향으로 학습을 해야하고,\n출력이 연속적인 값이어야 한다면 `회귀`하는 방향으로 학습을 해야한다.\n\n---\n\n## 분류 (Classification)\n\n이상적인 분류기는 학습에 사용되지 않은 데이터에 대해서 분류를 잘 해야한다.\n즉, 일반화의 능력이 좋은것이 이상적인 분류기이다.\n\n<tip>\n  데이터의 종류\n  1. 학습 데이터\n    분류기를 학습하는데 사용하는 데이터 집합.\n  2. 테스트 데이터\n    학습된 모델의 성능을 평가하는데 사용하는 데이터 집합.\n    학습에 사용되지 않은 데이터여야 함.\n  3. 검증 데이터\n    학습 과정에서 학습을 중단할 시점을 결정하기 위해 사용하는 데이터 집합.\n</tip>\n\n![231022-221446](/posts/mid_07/231022-221446.png)\n\n학습 데이터를 충분히 학습하지 않은 상태를 `부적합` 이라고 한다.\n\n반대로학습 데이터에 대해 지나치게 잘 학습된 상태를 `과적합` 이라고 하는데, 학습되지 않은 데이터에 대해 좋지 못할 성능을 보일 가능성이 크다.\n과적합을 회피하기 위해서 검증 데이터를 사용하게 된다.\n\n![231022-221636](/posts/mid_07/231022-221636.png)\n\n검증 데이터에 대한 오류가 증가하기 시작하면 학습 데이터에 대해 과적합이 일어나는 시점이기 때문에 이 때 학습을 중지하는 것이 좋다.\n\n### 불균형 데이터 문제\n\n특정 부류에 속하는 학습 데이터의 개수가 **다른 부류에 비해 지나치게 많은 경우** 정확도에 의한 성능 평가가 무의미해진다.\n이게 무슨 의미냐면, A 부류의 데이터가 전체 데이터의 99%를 차지한다면, 분류기의 출력을 항상 A로 설정하는 경우 해당 학습 데이터에 대해 99%의 정확도를 보일 것이다.\n하지만, 테스트 데이터에선 A/B가 각각 50% 비율로 들어있다면, 분류기의 정확도는 50%로 감소할 것이다.\n\n![231022-222326](/posts/mid_07/231022-222326.png)\n\n이런 경우 SMOTE 알고리즘을 이용해 어느정도 해결할 수 있다.\n간단하게 설명하면 빈도가 낮은 학습 데이터의 `k-근접 이웃`을 이용해 새로운 데이터를 생성하여 빈도가 낮은 부류의 데이터 개수를 늘리는 알고리즘이다.\n\n### 이진 분류기 성능 평가\n\n이진 분류기는 두 개의 부류만을 갖는 데이터에 대한 분류기로 A/B 둘 중 하나로 분류하는 분류기이다.\n이 분류기는 아래와 같은 예측-결과 표를 생성하는데,\n\n![231022-222646](/posts/mid_07/231022-222646.png)\n\n이것을 이용한 여러가지 지표로 성능을 평가한다.\n\n- 민감도/재현율/진양성율\n  실제 양성일 때, 양성이라고 예측하는 확률이다.\n  > 민감도 = $\\frac{TP}{TP + FN}$\n  >\n  > e.g. 불이났을 때, 불이 났다고 민감하게 알려주는 화재경보기\n\n- 특이도/진음성률\n  실제 음성일 때, 음성이라고 예측하는 확률이다.\n  > 특이도 = $\\frac{TN}{TN + FP}$\n  >\n  > e.g. 불이 안났을 때, 울리지 않는 화재경보기\n\n- 정밀도\n  양성으로 예측을 했는데, 실제로 양성일 확률.\n  > 정밀도 = $\\frac{TP}{TP + FP}$\n  >\n  > e.g. 화재경보기가 경보를 울렸는데, 실제로 불이 난 상황이었음\n\n- 음성 예측도\n  음성으로 예측을 했는데, 실제로 음성일 확률.\n  > 음성 예측도 = $\\frac{TN}{TN + FN}$\n  >\n  > e.g. 화재경보기가 안울렸는데, 실제로 불도나지 않았음\n\n- 위양성율\n  1에서 특이도를 뺀 값.\n  > 위양성율 = $\\frac{FP}{TN + FP}$ = 1 - 특이도\n\n- 위발견율\n  1에서 정밀도를 뺀 값.\n  > 위발견율 = $\\frac{FP}{TP + FP}$ = 1 - 정밀도\n\n- 정확도\n  예측한대로 결과가 나올 확률.\n  > 정확도 = $\\frac{TP + TN}{TP + FP + TN + FN}$\n\n- F1 측도\n  > F1 = 2$\\frac{정밀도 \\times 재현율}{정밀도 + 재현율}$\n\n### ROC 곡선\n\n위양성률, 민감도 그래프로 ROC 곡선의 아래 면적, AUC(Area Under the Curve)가 클수록 바람직하게 분류한다는 뜻이다.\n\n![231022-224153](/posts/mid_07/231022-224153.png)\n\n---\n\n## 회귀 (Regression)\n\n학습 데이터에 부합되는 출력값이 실수인 함수를 찾는 문제로, 앞에서 언급했 듯, 출력이 연속적이어야 하는 경우에 사용하는 방법이다.\n\n![231022-224546](/posts/mid_07/231022-224546.png)\n\n파란 점과 같은 학습 데이터가 주어졌을 떄, 해당 데이터를 가장 잘 설명하는 모델 **$f$** 를 찾기 위해서는 $f$의 오차를 계산하는 함수 **$f*$** 이 최소가 되도록 인자를 조정해야 한다.\n\n$$\nf*(x) = argmin_f \\sum_{i=1}^{n} (y_i - f(x_i))^2\n$$\n\n### 회귀 성능 평가\n\n학습 방향성과 같다.\n테스트 데이터에 대한 오차값의 평균이 작을수록 좋다.\n\n![231022-225021](/posts/mid_07/231022-225021.png)\n\n하지만 처음에 언급했 듯 과적합되는 현상은 피해야 한다.\n\n이를 위해 모델의 복잡도를 일종의 **패널티**로써 성능 평가(목적함수)에 반영하여, 모델의 복잡도를 최소화 하는 방향으로 학습을 유도해야 한다.\n\n### 로지스틱 회귀 (Logistic regression)\n\n모델의 출력이 [0, 1] 사이의 값을 갖도록 조정해야 하는 경우 sigmoid 함수와 같은 로지스틱 함수를 이용해서 학습 데이터의 출력을 근사하는 방식을 사용할 수도 있다.\n\n![231022-225434](/posts/mid_07/231022-225434.png)\n\n단, 이 때의 목적 함수는 `교차 엔트로피`(오차가 0~1 사이로 조정됨)가 적용된 함수를 사용해야 한다.\n\n로지스틱 회귀는 경사 하강법을 사용하는 학습에서 자주 사용된다.","slug":"univ_ai/mid_07","readingMinutes":9,"wordCount":660},{"title":"규칙 기반 시스템","description":"지식을 규칙의 형태로 표현하는 방법에 대해 알아봅니다.","icon":"","image":"","tags":["전향 추론","후향 추론","규칙 기반 시스템"],"draft":false,"date":"2023-10-22 / 19:59","content":"\n## 추론\n\n구축된 지식과 주어진 데이터, 정보를 이용해 새로운 사실을 생성하는 것으로 전향(순방향) 추론과 후향(역방향) 추론으로 나뉜다.\n\n### 전향 추론\n\n규칙의 조건부와 만족하는 사실이 있을 때 규칙의 결론부를 실행하거나 처리하는 방식으로 아래와 같이 순방향으로 추론하는 방식이다.\n\n![231022-200403](/posts/mid_06/231022-200403.png)\n\n### 후향 추론\n\n어떤 사실을 검증하거나 확인하고 싶은 경우에 관심 대상의 사실을 결론부에 갖고 있는 규칙을 찾아서 조건부가 만족하는지를 확힌하는 방식으로 아래와 같이 역방향으로 추론하는 방식이다.\n\n![231022-200616](/posts/mid_06/231022-200616.png)\n\n---\n\n## 규칙 기반 시스템\n\n지식을 규칙과 사실로 기술하며 아래와 같은 구조로 관리된다.\n\n![231022-200851](/posts/mid_06/231022-200851.png)\n\n**문제 해결을 위한 지식**인 `규칙`은 규칙 베이스에서 관리되며, 생성 메모리 라고도 불린다.\n\n**문제에 대해 알려진 데이터나 정보**인 `사실`은 작업 메모리에서 관리된다.\n참고로, 추론 과정의 중간 결과나 사용자로부터 받은 문제에 대한 정보 역시 여기서 관리된다.\n\n### 추론 엔진\n\n실행할 수 있는 규칙을 찾아 해당 규칙을 실행하는데 아래의 3단계의 과정을 반복한다.\n\n1. 패턴 매칭\n  작업 메모리의 사실과 규칙 메모리에 있는 규칙의 조건부를 대조하여 일치하는 규칙을 찾아냄.\n\n2. 경합 해소\n  찾아낸 규칙 중 경합되는 규칙(경합 집합)에 대해 하나의 규칙을 선택함.\n  경합 해소 전략에는 다음과 같은 전략이 있음.\n\n    > 1. 규칙 우선\n    > 미리 규칙에 우선순위를 부여하고, 경합시 우선순위가 높은 규칙을 우선 선택\n    > 우선순위 태그 기준\n    > ![231022-201805](/posts/mid_06/231022-201805.png)\n    >\n    > 2. 최신 우선\n    > 가장 최근에 입력된 데이터와 매칭된 규칙을 우선 선택\n    > 시간 태그 기준\n    > ![231022-201845](/posts/mid_06/231022-201845.png)\n    >\n    > 3. 최초 우선\n    > 경합 집합에서 가장 먼저 매칭된 규칙을 우선 선택\n    >\n    > 4. 상세 우선\n    > 조건부가 가장 상세하거나 복잡한 규칙을 우선 선택\n    > 태그말고 조건문의 길이 기준\n    > ![231022-201826](/posts/mid_06/231022-201826.png)\n    \n\n3. 규칙 실행","slug":"univ_ai/mid_06","readingMinutes":4,"wordCount":241},{"title":"불확실한 지식 표현","description":"불확실한 지식을 표현하는 방법에 대해 알아봅니다.","icon":"","image":"","tags":["Certainty factor","Probability","Fuzzy"],"draft":false,"date":"2023-10-22 / 19:10","content":"\n인과성이 약하거나, 연관성이 애매하거나, '얼마나?'에 해당하는 정도가 모호한 문장을 정량화 하는 방법에 대해 알아봅니다.\n\n## 확신도 (Certainty factor)\n\n규칙과 사실의 신뢰정도를 [-1, 1] 구간의 값으로 표현합니다.\n\n| 확신도 | 대응되는 단어 |\n|---|---|\n| −1.0 | 절대 아니다 (definitely not)|\n| −0.8 | 거의 확실히 아니다 (almost certainly not) |\n| −0.6 | 아마 아니 것이다 (probably not) |\n| −0.4 | 어쩌면 아닐 것이다 (maybe not) |\n| −0.2 ~ 0.2 | 모르겠다 (unknown) |\n| 0.4 | 어쩌면 그럴 것이다 (maybe) |\n| 0.6 | 아마 그럴 것이다 (probably) |\n| 0.8 | 거의 확실하다 (almost certainly) |\n| 1.0 | 확실하다 (definitely)|\n\n### 추론결과의 확신도\n\n추론에 대한 확신도는 각 명제에 대한 확신도를 계산하여 도출해야 합니다.\n\n- IF A THEN B _($\\{A \\rightarrow B, \\; A\\} \\vdash B$)_\n  기본적으로 정형식들의 확신도를 곱하는 방식으로 구합니다.\n  > **$cf(B) = cf(A) \\times cf(A \\rightarrow B)$**\n\n- IF A and B THEN C _($\\{A \\wedge B \\rightarrow C, \\; A, \\; B\\} \\vdash C$)_\n  **and**의 경우 조건부에 해당하는 정형식의 확신도 중 작은 값을 고릅니다.\n  > **$cf(C) = min\\{cf(A), cf(B)\\} \\times cf(A \\wedge B \\rightarrow C)$**\n\n- IF A or B THEN C _($\\{A \\vee B \\rightarrow C, \\; A, \\; B\\} \\vdash C$)_\n  **or**의 경우 조건부에 해당하는 정형식의 확신도 중 큰 값을 고릅니다.\n  > **$cf(C) = max\\{cf(A), cf(B)\\} \\times cf(A \\vee B \\rightarrow C)$**\n\n아래는 예시입니다.\n\n![231022-192422](/posts/mid_05/231022-192422.png)\n\n만약, 여러 사실에 의해 동일한 사실을 추론하는 경우 추론 결과는 같지만, 확신도는 다르게 계산될 수 있습니다.\n이런 경우, 확신도를 하나로 통합하는게 좋습니다.\n\n![231022-192640](/posts/mid_05/231022-192640.png)\n\n---\n\n## 확률 (Probability)\n\n어떤 사건이 일어날 가능성을 표현할 때 사용합니다.\n\n### 결합 확률\n\n사건 A, B가 동시에 일어날 확률을 가리키며, 아래와 같이 수식화 할 수 있습니다.\n\n> A: 첫 번째 주사위가 짝수\n> B: 두 번째 주사위가 홀수\n>\n> $P(A,B) = P(A \\cap B) = P(AB)$\n> $= 1/2 \\times 1/2 = 0.25$\n\n### 조건부 확률\n\n사건 B가 일어났을 때, 사건 A가 일어날 확률을 가리키며, 아래와 같이 수식화 할 수 있습니다.\n\n> A: 두 주사위의 합이 8\n> B: 첫 번째 주사위가 3\n>\n> $P(A|B) = \\frac{P(A,B)}{P(B)}$\n> $= \\frac{1/36}{1/6} = 1/6$\n\n`베이즈 정리`에 의해 조건부 확률의 조건부를 변형할 수 있습니다.\n\n> $P(A|B) = \\frac{P(B|A)P(A)}{P(B)}$\n\n---\n\n## 퍼지 이론 (Fuzzy theory)\n\n기존 집합론과 다르게 퍼지 이론은 0/1의 이분법적으로 분류하지 않고, 0~1로 모호하게(어느정도 포함되게) 구분함.\n즉, 어느 정도(degree)의 문제는 퍼지 집합을 도입하여 해결.\n\n### 퍼지 집합\n\n원소가 모임(collection)에 어느 정도 속한다는 것을 표현한 것으로, 해당 집합은 부분적으로 참이 됨.\n소속정도는 [0, 1] 범위의 실수값으로 표현함.\n\n작다, 평균이다, 크다의 표현을 아래와 같이 다르게 할 수 있음.\n\n![231022-194330](/posts/mid_05/231022-194330.png)\n\n### 퍼지 규칙\n\n소속함수로 표현된 언어항을 표함하는 규칙.\n\n> IF service = 나쁘다 OR food = 별로이다 THEN tip = 적다\n> IF service = 보통이다 THEN tip = 보통이다\n> IF service = 훌륭하다 OR food = 맛있다 THEN tip = 많다\n\n<tip>\n  `언어항`\n  '나쁘다', '맛있다', '많다'와 같은 자연어에 해당하는 항으로 소속함수로 표현될 수 있다. \n  ![231022-194851](/posts/mid_05/231022-194851.png)\n</tip>\n\n### 퍼지 추론\n\n소속함수로 표현돤 언어항을 사용하는 퍼지 규칙들의 모음으로 수치적인 추론이 가능해진다.\n\n![231022-195645](/posts/mid_05/231022-195645.png)\n\n추론된 영역의 무게중심을 결과로 사용하면 `비퍼지화`가 가능하다.","slug":"univ_ai/mid_05","readingMinutes":5,"wordCount":496},{"title":"명제 논리 & 술어 논리","description":"지식을 표현하는 방법 - 논리에 대해 알아봅니다.","icon":"","image":"","tags":["Proposition","Predicate"],"draft":false,"date":"2023-10-22 / 15:48","content":"\n말로 표현된 문장을 타당한 추론을 위해 기호를 사용하여 표현하고, 기호의 조작을 통해 참과 거짓을 판정하는 분야이다.\n\n## 명제 논리\n\n### 명제 (Proposition)\n\n`명제`란, 참과 거짓을 분평하게 판정할 수 있는 문장으로 P, Q와 같은 기호로 표현된다.\n\n중요한 점은, 명제 그 자체는 참, 거짓을 결정할 수 없고, 반드시 기호의 진리값을 설정해 줘야 한다는 점이다.\n이게 무슨 말이냐면, 아래의 문장을 예로 들어 설명해보겠다.\n\n> 오징어 다리는 10개 이다.\n\n이 명제는 우리나라에서는 참이다.\n하지만 북한에서는 오징어 라는 명사는 우리나라의 낙지를 가리키는 말 이기 때문에 북한에서는 거짓인 명제이다.\n\n즉, 문장 자체의 내용에 대해서는 관심을 갖지 말고, 문장의 설정된 `진리값에만 관심`을 가져야 한다.\n\n_**용어 설명**_\n| 용어 | 의미 |\n|---|---|\n| 기본 명재 | 하나의 진술로만 이루어진 최소 단위의 명제 |\n| 복합 명제 | 기본 명제들이 결합되어 만들어진 명제 |\n\n### 논리식 (Logical expression)\n\n명제를 기호로 표현한 형식으로 명제기호, T/F, 논리 기호를 사용하여 구성되는데, 가장 기본이 되는 논리 기호는 다음과 같다.\n\n| 논리기호 | 이름 | 논리식 | 의미 |\n|---|---|---|---|\n| $\\neg$ | 부정 (negation) | $\\neg P$ | $P$가 아님 |\n| $\\vee$ | 논리합 (disjunction) | $P \\vee Q$ | $P$ 또는 $Q$ |\n| $\\wedge$ | 논리곱 (conjunction) | $P \\wedge Q$ | $P$ 그리고 $Q$ |\n| $\\rightarrow$ | 함의 (implication) | $P \\rightarrow Q$ | $P$ 이면 $Q$ |\n| $\\equiv$ | 동치 (equivalence) | $P \\equiv Q$ | $(P \\rightarrow Q) \\wedge (Q \\rightarrow P)$ |\n\n_**용어 설명**_\n| 용어 | 의미 |\n|---|---|\n| 리터럴 | 명제 기호 또는 명제 기호의 부정 |\n| 절 | 리터럴들이 논리합이나 논리곱으로만 연결 (논리합 절, 논리곱 절) |\n| 논리곱 정규형 (CNF) | 논리합 절들이 논리곱으로 연결되어 있는 논리식 |\n| 논리합 정규형 (DNF) | 논리곱 절들이 논리합으로 연결되어 있는 논리식 |\n| 정형식 (WFF) | 진리값(T/F)과 명제, 그들과 논리 기호를 사용하여 구성된 논리식을 의미함 |\n\n### 진리표 (Truth table)\n\n논리기호에 따라 T/F를 결합하는 방법을 나타낸 표\n\n| $P$ | $Q$ | $\\neg P$ | $P \\vee Q$ | $P \\wedge Q$ | $P \\rightarrow Q$ | $P \\equiv Q$ |\n|---|---|---|---|---|---|---|\n| F | F | **T** | F | F | **T** | **T** |\n| F | **T** | **T** | **T** | F | **T** | F |\n| **T** | F | F | **T** | F | F | F |\n| **T** | **T** | F | **T** | **T** | **T** | **T** |\n\n- 타당한 논리식 (Valid logical expression), 항진식\n  모든 가능한 해석에 대해 항상 참인 논리식\n  _e.g. $P \\vee \\neg P$_\n\n- 항위식\n  모든 가능한 해석에 대해 항상 거짓인 논리식\n  _e.g. $P \\wedge \\neg P$_\n\n- 츙족가능한 논리식\n  참으로 만들 수 있는 해석이 하나라도 있는 논리식\n\n- 충족불가능한 논리식\n  참으로 만들 수 있는 해석이 하나도 없는 논리식. 즉, 항위식.\n\n### 동치 관계 (Equivalence relation)\n\n어떠한 해석에 대해서도 같은 진리 값을 갖는 두 논리식\n\n- $\\neg(\\neg p) \\equiv p$\n- $p \\vee F \\equiv p$\n  $p \\wedge T \\equiv p$\n- $P \\vee \\neg P \\equiv T$\n  $P \\wedge \\neg P \\equiv F$\n- **$\\neg (p \\wedge q) \\equiv \\neg p \\vee \\neg q$**\n  **$\\neg (p \\vee q) \\equiv \\neg p \\wedge \\neg q$**\n- **$p \\rightarrow q \\equiv \\neg p \\vee q$**\n- $p \\vee (q \\vee r) \\equiv p \\vee q \\vee r$\n  $(p \\wedge q) \\wedge r \\equiv p \\wedge q \\wedge r$\n- **$p \\vee (q \\wedge r) \\equiv (p \\vee q) \\wedge (p \\vee r)$**\n  **$p \\wedge (q \\vee r) \\equiv (p \\wedge q) \\vee (p \\wedge r)$**\n\n### 논리적 귀결 (Logical entailment)\n\n정형식(Well-Formed Formula, WFF)의 집합 $\\Delta$가 다른 정형식 $\\omega$를 참으로 만든다면 두 관계를 아래와 같이 정의한다.\n\n> $\\Delta \\models \\omega$\n> e.g. $\\{P, \\; P \\rightarrow Q\\} \\models Q$\n>\n> $\\Delta$는 $\\omega$를 논리적으로 귀결한다.\n> $\\omega$는 $\\Delta$를 논리적으로 따른다.\n> $\\omega$는 $\\Delta$의 논리적 결론이다.\n\n### 추론 (Inference)\n\n논리적 귀결을 도출하는 과정을 추론이라고 한다.\n\n관측된 복수의 사실들을 일반화하여 일반적인 패턴(명제)를 도출하는 것을 `귀납적 추론` 이라고 하고,\n참인 명제(사실)들로부터 새로운 명제(사실)을 도출하는 것을 `연역적 추론` 이라고 한다.\n\n논리에서의 추론은 보통 **연역적 추론**을 가리키는데, 이걸 도출하는 테크닉에 대해 살펴보자.\n\n- 긍정 논법\n  $\\{p \\rightarrow q, \\; p\\} \\vdash q$\n  _(\\{새이다 &rarr; 날 수 있다, 새이다\\} &rarr; 날 수 있다)_\n\n- 부정 논법\n  $\\{p \\rightarrow q, \\; \\neg q\\} \\vdash \\neg p$\n  _(\\{새이다 &rarr; 날 수 있다, 날 수 없다\\} &rarr; 새가 아니다)_\n\n- 삼단 논법\n  $\\{p \\rightarrow q, \\; q \\rightarrow r\\} \\vdash p \\rightarrow r$\n  _(\\{새이다 &rarr; 날개가 있다, 날개가 있다 &rarr; 날 수 있다\\} &rarr; 새이다 &rarr; 날 수 있다)_\n\n- **논리 융합 (Resolution)**\n  긍정, 부정, 삼단 논법을 포함한 일반화된 추론 규칙으로 \n  두 개의 **논리합 절**이 같은 기호의 긍정-부정 리터럴을 서로 포함하고 있을 때, 해당 리터럴을 제외한 나머지 리터럴의 논리합 절을 만들어 내는 것.\n\n  | 논법 | 변환 | WFF (논리 융합식, Resolvent) |\n  |---|---|---|\n  | $p \\rightarrow q, \\; p$ | **$\\neg p$** $\\vee q$, **$p$** | $q$ |\n  | $p \\rightarrow q, \\; \\neg q$ | $\\neg p \\vee$ **$q$**, **$\\neg q$** | $\\neg p$ |\n  | $p \\rightarrow q, \\; q \\rightarrow r$ | $\\neg p \\vee$ **$q$**, **$\\neg q$** $\\vee r$ | $\\neg p \\vee r$ ($p \\rightarrow r$) |\n\n  즉, 논리 융합을 사용하면 모든 추론 규칙을 일반화 할 수 있다.\n\n- 정당성 (sound)\n  $\\Delta \\vdash \\omega \\; \\rightarrow \\; \\Delta \\models \\omega$ (아야 sound)\n\n- 완전성 (complete)\n  $\\Delta \\models \\omega \\; \\rightarrow \\; \\Delta \\vdash \\omega$ (야아 complete 하네)\n\n  <tip>\n    정당성과 완전성을 동시에 만족하는 추론 규칙은 논리적인 귀결과 동일시 할 수 있다.\n  </tip>\n\n### 증명 (Proof)\n\n- 구성적 증명 (Constructive proof)\n  공리(참인 논리식)들에 추론 규칙을 적용하여 참을 만들어 보이는 증명.\n  정리하다가 결론이 참으로 끝나면 된다.\n\n- 논리융합 반박 (Resoultion refutation)\n  증명할 정리를 일단 부정하고, 논리융합 방법을 적용해 모순이 발생함으로 보이는 증명.\n  부정된 정리가 모순이니, 원상태의 정리는 참이 된다.\n\n  ![231022-171322](/posts/mid_04/231022-171322.png)\n\n---\n\n## 술어 논리\n\n명제의 내용을 다루기 위해 변수, 함수 등을 도입하고, 이들의 값에따라 T/F가 결정되도록 명제 논리를 확장한 논리.\n\n### 술어 (Predicate)\n\n대상의 속성이나 관계를 기술하는 기호로, 대상에게 T/F를 부여하는 명제의 기본 형식이다.\n\n| 문장 | 명제 논리 | 술어 논리 |\n|---|---|---|\n| 모든 사람은 죽는다 | P | $\\forall x(사람(x) \\rightarrow 죽는다(x))$ |\n| 소크라테스는 사람이다 | Q | $사람(소크라테스)$ |\n| 소크라테스는 죽는다 | R | $죽는다(소크라테스)$ |\n\n<tip>\n  `존재 한정사`\n  Existential quantifier로 존재함을 알려준다. (**$\\exist$**)\n  <br />\n  `전칭 한정사`\n  Universal quantifier로 모든 범위를 가리킨다. (**$\\forall$**)\n</tip>\n\n### 함수 (function) / 항 (term)\n\n주어진 인자에 대해 T/F를 반환하는 것이 아닌, 일반작인 값을 반환하는 것을 `함수`라고 한다.\n즉, 인자를 지칭하기 위해 쓰인다.\n\n함수의 인자가 될 수 있는 것을 `항` 이라고 한다.\n**상수, 변수, 함수**만이 항이 될 수 있다.\n\n<tip>\n  명제 논리식의 정형식(WFF)과 마찬가지로, 술어 논리식의 정형식 역시 비슷한 정의를 갖는다.\n  항, 논리 기호, 한정사로만 이루어진 식을 정형식이라고 부른다.\n</tip>\n\n### N차 술어 논리 (N-order predicate logic)\n\n**변수에만** 한정사를 사용할 수 있도록 한 술어 논리를 `일차 술어논리(FOL)` 라고 한다.\n엄밀히는, 술어기호의 인자로 사용될 수 있는 객체나 대상만을 변수화 할 수 있고, 이들 변수에만 전칭 한정사와 존재 한정사를 쓸 수 있도록 한 술어논리를 말한다.\n\n**변수, 함수, 술어기호**에 대해 한정사를 쓸 수 있도록 한 술어 논리를 `고차 술어논리(HOL)` 라고 한다.\n엄밀히는, 함수나 술어기호도 변수화 할 수 있고, 이들 변수에만 전칭 한정사와 존재 한정사를 쓸 수 있도록 한 술어논리를 말한다.\n\n인공지능 분야에서는 **연산량의 한계** 때문에 `일차 술어논리`를 주로 사용한다.\n\n### CNF 변환\n\n아래의 변환 과정을 거친면 된다.\n\n1. 한정사를 논리식의 맨 앞으로 끌어내는 변환\n  일반적으로 한정사를 맨 앞으로 끌어내도 의미는 변하지 않지만, 그래도 최다한 할 수 있는 변환을 한 뒤에 끌어내자.\n\n2. 전칭 한정사 제거\n  $\\forall$은 바로 제거해도 상관없다.\n\n3. 존재 한정사 제거\n  우선 아래와 같은 방식으로 전칭 한정사로 변환한 뒤 전칭 한정사를 제거하는 방법을 사용한다.\n  **$\\neg \\exist x P \\equiv \\forall x \\neg P$**\n\n    만일 함수에 변수가 2개 이상 사용된 경우 변환이 어려울 때는 상수를 집어넣거나 스콜렘 함수로 변환한다.\n    $\\forall x \\exist y [P(x) \\wedge$ **$Q(x, y)$**$] \\rightarrow \\forall x [P(x) \\wedge$ **$Q(x, s(x))$**$]$\n\n4. 단일화\n  논리 융합을 적용할 때, 대응되는 리터럴이 같아지도록 상수를 변수화 함.\n  ![231022-175353](/posts/mid_04/231022-175353.png)\n\n변환 과정을 거쳐 논리융합 반박을 통해 증명하는 예시를 살펴보자.\n아래의 예시는 (5)의 모순을 보임으로써 $\\neg$(5)가 참임을 보이는 논리융합 반박이다.\n\n![231022-175534](/posts/mid_04/231022-175534.png)","slug":"univ_ai/mid_04","readingMinutes":13,"wordCount":1309},{"title":"프레임 & 의미망 & 스크립트","description":"지식을 표현하는 방법 - 프레임, 의미망, 스크립트에 대해 알아봅니다.","icon":"","image":"","tags":["Frame"],"draft":false,"date":"2023-10-22 / 15:35","content":"\n## 프레임 (Frame)\n\n특정 객체 또는 개념에 대한 전형적인 지식을 슬롯(slot)의 집합으로 표현하는 것으로, 컴퓨터를 표현한 프레임은 다음과 같이 기술할 수 있다.\n\n![231022-153840](/posts/mid_03/231022-153840.png)\n\n### 슬롯 (slot)\n\n객체의 속성(attribute)를 기술하는 것으로 슬롯 이름과 값으로 구성된다.\n슬롯 값은 복수개의 `패싯`과 `데몬`으로 구성된다.\n\n- 패싯 (facet)\n  속성에 대한 부가적인 정보를 저장하기 위해 사용되며 아래와 같은 패싯 이름들을 사용할 수 있다.\n  - value: 속성 값\n  - data-type: 속성의 자료형\n  - default: 기본 값\n  - require: 슬롯에 들어갈 수 있는 값이 만족해야 할 제약조건\n\n- 데몬 (demon)\n  ![231022-154436](/posts/mid_03/231022-154436.png)\n\n  지정된 조건을 만족할 때 실행할 절차적 지식을 기술하는데 사용되며, 아래와 같은 데몬 이름들을 사용할 수 있다.\n  - if_needed: 슬롯 값을 알아야 할 때(즉, 사용하려고 할 때)\n  - if_added: 슬롯 값이 추가될 때\n  - if_removed: 슬롯 값이 제거될 때\n  - if_modified: 슬롯 값이 수정될 때\n\n### 클래스 프레임\n\n위에서 프레임을 설명할 때 사용한 프레임이 클래스 프레임이다.\n\n<tip>\n  하위 프레임이 상위 프레임을 상속받는 계층구조도 가질 수 있음.\n</tip>\n\n### 인스턴스 프레임\n\n![231022-154657](/posts/mid_03/231022-154657.png)\n\n클래스 프레임을 특정 객체에 대한 정보로 표현하면 인스턴스 프레임이 된다.\n그냥 OOP와 같은 개념이다.\n\n---\n\n## 의미망 (Semantic network)\n\n![231022-184947](/posts/mid_03/231022-184947.png)\n\n노드와 방향성 간선으로 구성되는 그래프를 이용해 지식을 표현하는 방법으로, 이항 관계만을 표현한다.\n그렇기에 다항 관계도 이항 관계로 전개하여 표현해야 하는데, 그 때문에 관계(relation) 역시 객체로 간주하여 표현한다.\n\n![231022-185755](/posts/mid_03/231022-185755.png)\n\n- `is-a`\n  자식 is-a 부모, 인스턴스 is-a 클래스와 같은 관계의 간선을 표현한다.\n\n- `has-a`\n  전체 has-a 부분, 부분 part-of 전체와 같은 관계의 간선을 표현한다.\n\n<tip>\n  is-a, has-a는 추이적 관계를 만족하는데, 추이적 관계란, 3단논법과 같은 관계를 의미함.\n  \n  > is-a(팽귄, 조류) $\\wedge$ is-a(조류, 동물) &rarr; is-a(팽귄, 동물)\n</tip>\n\n지식을 시각적으로 표현할 수 있어 직관적으로 이해할 수 있고, 노드 추가 및 변경이 자유롭다는 장점이 있다.\n하지만, 양이 많아지면 관리가 복잡해지고, 개념이나 관계를 임의로 정의하기에 통일성이 떨어진다는 단점이 있다.\n\n### 추론\n\n상속관계를 이용해서 추론한다.\n예로 들어 '바둑기사의 키는?' 이라는 질문은 다음과 같이 추론할 수 있다.\n\n![231022-190024](/posts/mid_03/231022-190024.png)\n\n뿐만 아니라, 주어진 지식으로부터 새로운 사실을 이끌어내는 추론도 가능하다.\n예로 들어 '사람1이 사람2에게 사물1을 준다'는 지식으로부터, '사람2는 사물1을 소유하게 된다'는 사실을 추론한다.\n\n![231022-190213](/posts/mid_03/231022-190213.png)\n\n### 프레임으로 변환\n\n![231022-190324](/posts/mid_03/231022-190324.png)\n\n노드별로 프레임으로 변환할 수 있는데, 노드에서 나가는 간선들을 슬롯으로 구성하면 된다.\n\n---\n\n## 스크립트 (Script)\n\n일반적으로 발생할 수 있는 전형적인 상황에 대한 절차적 지식을 일목요연하게 표현한 것이다.\n\n![231022-190644](/posts/mid_03/231022-190644.png)\n\n- 진입 조건\n  스크립트에 기술된 사건들이 일어나기 전에 만족되어야 하는 전제조건\n\n- 역할자\n  스크립트에 관련된 사람, 대상\n\n- 자산\n  사건 진행 과정에서 사용되는 객체\n\n- 트랙\n  스크립트에서 발생할 수 있는 사건들이 변형된 형태 식별자 (장소)\n\n- 장면\n  실제 일어나는 일련의 사건\n  \n- 결과 조건\n  스크립트의 장면에 있는 사건들이 일어난 후에 만족되는 조건","slug":"univ_ai/mid_03","readingMinutes":6,"wordCount":401},{"title":"게임에서의 탐색 및 최적화","description":"게임 트리를 탐색하는 기법과 최적화에 대해 알아봅니다.","icon":"","image":"","tags":["Mini-Max algorithm","Alpha-Beta prunning","Monte Carlo","Backtracking search","Constraint propagation","Genetic algorithm","Regression"],"draft":false,"date":"2023-10-21 / 22:53","content":"\n## 게임 트리\n\n`상대가 있는 게임`에서 자신과 상대방의 가능한 게임 상태를 나타낸 트리.\n자신의 턴인지, 상대의 턴인지에 따라 탐색하는 방식이 다르게 적용됨.\n(나에겐 유리하게, 상대에겐 불리하게)\n\n정해진 시간 내에 최대한 많은 수를 보는 것이 유리하기 때문에 탐색 효율을 높이는 것이 중요하다.\n\n### Mini-max Algorithm\n\n특이하게 단말 노드로부터 위로 올라가면서 최소-최대 연산을 반복하여 자신이 선택할 수 있는 방법 중 가장 좋은 값을 선택하는 방법이다.\n\n자신의 턴인 Max 노드에서는 자신에게 유리한 값을 선택하고,\n상대의 턴인 Min 노드에서는 상대에게 불리한 값을 선택하는 방식을 취한다.\n\n![231021-230224](/posts/mid_02/231021-230224.png)\n\n하지만 트리가 넓을 수록 모든 상태공간을 탐색하는건 시간상 너무 오래 걸리기 때문에 최적화 기법이 들어가야 한다.\n바로 **$\\alpha - \\beta$ 가지치기(prunning)** 기법이다.\n\n검토해 볼 필요가 없는 부분을 탐색하지 않도록 하는 기법인데, 어떻게 해야 검토할 필요가 없다는 걸 알 수 있을까?\n\n깊이 우선 탐색(DFS)로 제한 깊이까지 탐색을 하면서 Min, Max 노드의 $\\alpha$, $\\beta$값을 업데이트 하는데, 각 $\\alpha$, $\\beta$값은 다음과 같은 값을 저장한다.\n\n- $\\alpha$\n  Max 노드에서만 값이 업데이트되며, 현재까지 확보한 자식의 값 중 최댓값을 저장함\n\n- $\\beta$\n  Min 노드에서만 값이 업데이트되며, 현재까지 확보한 자식의 값 중 최솟값을 저장함\n\n이 때, 탐색 후 값을 업데이트 하다가 **$\\alpha \\geq \\beta$** 되는 순간이 오는데, 그 때부터 나머지 자식노드는 탐색할 필요가 없어진다.\n그 이유는, 상한선($\\alpha$)과 하한선($\\beta$)이 정해질 때, 그 부모노드의 상한선과 하한선을 넘지 못하면 부모노드를 업데이트 할 수 없기에, 업데이트를 할 가능성이 없다면 가지치기를 해버리는 것이다.\n\n알고리즘의 이해가 안된다면 아래 영상을 참고하면 좋을 거 같다.\n\n<YT id=\"_i-lZcbWkps\" />\n\n속성으로 빠르게 탐색하고 싶다면 이런 방식으로 탐색해도 된다.\n\n<YT id=\"6qN5ReC2SUA\" />\n\n빠르게 업데이트 가능한 조건을 적어놓고, 그 조건이 업데이트가 절대로 불가능하다면 나머지 노드를 가지치기 하는 방식이다.\n\n### 몬테카를로 트리 탐색 기법 (Monte Carlo Simulation)\n\n![231022-003000](/posts/mid_02/231022-003000.png)\n\n탐색 공간을 무작위 표본추출을 하면서 탐색 트리를 확장하여 가장 좋아보이는 것을 선택하는 휴리스틱 탐색 방법으로,\n시간이 허용되는 동안 위의 4단계를 반복하여 시뮬레이션 및 트리를 확장한다.\n\n1. 선택\n  선택은 **트리 정책**을 적용하여 선택한다.\n  정책은 개발자 마음대로 정하는 거지만, 보통 승률과 노드 방문횟수를 고려하여 선택한다.\n  일반적으로 `승률이 높으며`, `방문횟수가 적은` 노드에 우선권을 부여한다 (UCB, Upper Confidence Bound 정책).\n\n2. 확장\n  단말 노드에서 트리 정책에 따라 노드를 추가한다.\n\n3. 시뮬레이션\n  기본 정책에 의한 `몬테카를로 시뮬레이션`을 적용한다.\n  무작위 선택, 또는 약간 똑똑한 방법으로 게임이 끝날 때 까지 진행한다.\n\n  <tip>\n  `몬테카를로 시뮬레이션`\n  <br />\n  특정 확률 분포로 부터 무작위 표본(또는 약간 똑똑한 방법으로)을 생성하고, 이 표본에 따라 행동을 하는 과정을 반복하여 결과를 확인하고 이 과정을 반복해 최정 결정을 하는 것.\n  <br />\n  특정 상태의 유불리를 상태판단함수로 판단하는 것이 아닌, 시뮬레이션으로 판단하게 된다.\n  </tip>\n\n4. 역전파\n  게임의 결과를 단말 노드에서 루트 노드까지 올라가면서 반영한다.\n\n---\n\n## 제약조건 만족 문제\n\n주어진 제약조건을 만족하는 조합 해(combination solution)을 찾는 문제로 N-Queens problem과 같은 문제가 이에 해당한다.\n\n### 백 트래킹 탐색 (Backtracking search)\n\n깊이 우선 탐색(DFS)을 하는 것처럼 변수에 허용되는 값을 하나씩 대입해보고, 가능한 모든 값을 대입했는데도 만족하는 것이 없으면 이전 단계로 돌아가서 이전 단계의 변수에 다른 값을 대입하는 전형적인 백 트래킹 방식이다.\n\n### 제약조건 전파 (Constraint propagation)\n\n인접 변수 간의 제약 조건에 따라 각 변수에 허용될 수 없는 값들을 제거하는 방식으로, 이름 그대로 주변에 제약조건을 전파하여 선택 가능한 가지수를 줄여가는 방식이다.\n\n![231022-004410](/posts/mid_02/231022-004410.png)\n\nA에 1을 선택하는 순간 B\\~D에 각각 제약사항이 전파되어 B\\~D에서 선택할 수 있는 가지수가 제한된다.\n여기서 B가 3을 선택하는 순간 C, D에 각각 제약사항이 또 전파되는데, 이 때 C는 더이상 아무것도 선택할 수 없기에 이전 스탭에서 다른 제약사항을 걸어야 한다.\n\n---\n\n## 최적화\n\n여러가지 가능, 혀용되는 값들 중에서 주어진 기준을 가장 잘 만족하는 것을 선택하는 것으로, 크게 `조합 최적화`와 `함수 최적화`로 나뉜다.\n\n### 조합 최적화\n\nTSP와 같이 주어진 항목들의 조합으로 해가 표현되는 최적화 문제로, 이 경우에는 경로의 길이를 최소화 하는 문제이다.\n\n![231022-005505](/posts/mid_02/231022-005505.png)\n\n이를 달성하기 위해 생물의 진화를 모방한 집단 기반 확률적 탐색 기법인 `유전 알고리즘`을 사용하기도 한다.\n\n개체는 염색체로 표현되며 다음과 같이 기술된다.\n\n![231022-005704](/posts/mid_02/231022-005704.png)\n\n이런 염색체들의 집합을 `모집단`이라고 하는데, 이런 모집단(후보해)가 문제의 해로서 적합한 정도를 `적합도 함수`가 판단하게 되고, 적합하다면 최적 개체로서 알고리즘이 종료되지만, 적합하지 않다면 **진화의 과정**을 거치게 된다.\n\n모집단이 진화를 할 때는 우선 `부모 모집단` 중 개체를 선택하게 되는데, **가능한 높은 적합도의 개체가 선택되도록 확률을 높게** 조정한다.\n자연선택과 같이 **랜덤**한 요소가 있어야 하기에 반드시 적합한 녀석이 선택되지는 않는다.\n\n이후에는 선택된 부모 개체가 `유전 연산`을 거쳐 자식 개체를 양산하게 되는데, 유전 연산에는 다음과 같은 연산을 고려할 수 있다.\n\n![231022-010201](/posts/mid_02/231022-010201.png)\n\n이후에는 생성된 여러 자식 개체를 이용해서 `세대를 교체`하게 되는데, **최대한 많은 우수한 계체가 다음 세대에 유지**될 수 있도록 `엘리트주의`를 적용한다.\n\n### 목적 최적화\n\n어떤 목적 함수(Objective function)가 있을 때, 이 함수를 최대로 하거나 최소로 하는 변수 값을 찾는 최적화 문제이다.\n\n![231022-010440](/posts/mid_02/231022-010440.png)\n\n`최소 평균제곱법`을 사용해서 회귀(Regression) 문제의 최적함수를 찾거나,\n\n![231022-010602](/posts/mid_02/231022-010602.png)\n\n함수의 최소값 위치를 찾는 문제에서 `경사 하강법`과 같은 방법을 사용할 수 있다.","slug":"univ_ai/mid_02","readingMinutes":11,"wordCount":724},{"title":"Iterator Pattern","description":"Iterator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Iterator Pattern"],"draft":false,"date":"2023-10-21 / 20:22","content":"\n## 필요성\n\n사람마다 개발 스타일이 다르다.\n하물며 List, ArrayList 등, 어떤 자료구조가 익숙하냐에 따라 사용하는 데이터 타입 역시 다르다.\n\n만약 분업을 하는데 있어 사람 A는 List, B는 ArrayList를 사용했다고 해보자.\n이렇게 자료구조가 다를 경우, 순차탐색에 있어 코드의 구현이 달라진다.\n\n```java:.java\n// List\nfor (int i=0; i<myList.length; i++) {\n  myList[i];\n}\n\n// ArrayList\nfor (int i=0; i<myArrayList.size(); i++) {\n  myArrayList.get(i);\n}\n```\n\n만약 위의 순차탐색에서 동작하는 기능이 동알하다면?\n자료구조가 다르다는 이유로 같은 기능을 수행하는 동작을 중복해서 작성해야 하는 이슈가 생긴다.\n\n더 심각한건, list를 arrayList와 같이 자료구조를 바꾸기라도 하는 날에는 클라이언트가 코드를 수정해야 한다는 치명적인 문제도 있다.\n\n## Iterator Pattern\n\nData Collection을 순차적 접근이 필요할 때 그 방식을 Iterator와 같이 제공하는 디자인 패턴을 Iterator Pattern이라고 한다.\n위의 코드를 이 디자인 패턴을 적용해 개선해보자.\n\n```java:MyListIterator.java {5, 11}\npublic class MyListIterator implements Iterator {\n  Object[] data;\n  int position = 0;\n\n  public MyListIterator(Object[] data) {\n    this.data = data;\n  }\n\n  public Object next() {\n    Object obj = data[position];\n    position += 1;\n    return obj;\n  }\n\n  public boolean hasNext() {\n    if (position >= data.length || data[position] == null) {\n      return false;\n    }\n    return true;\n  }\n}\n```\n\n```java:MyList.java {5, 11}\npublic class MyList {\n  ...\n\n  public Iterator createIterator() {\n    return new MyListIterator(data);\n  }\n}\n```\n\n이런식으로 나만의 클래스나 Iterator를 제공하지 않는 클래스의 경우 Iterator를 생성하기 위한 클래스를 생성하여 이를 createIterator 에서 반환해주면,\n순차 탐색은 createIterator에서 반환된 Iterator를 이용해서 하면 인터페이스를 통일할 수 있다.\n\n<tip>\n  MyArrayListIterator는 왜 안 만드는지?\n  <br />\n  기본적으로 Java에서 `Collection`을 implement 하는 자료구조는 Iterator를 제공하기 때문.\n  따라서 얘는 Iterator 클래스를 별도로 구현하지 않아도, 바로 createIterator 메서드 내부에서 `myArrayList.iterator()` 와 같은 방식으로 Iterator를 생성할 수 있음.\n  <br />\n  예로 들어 Hashtable 자료구조는 values() 라는 메서드를 제공하는데, 해당 메서드는 Collection 객체(아마 ArrayList)를 반환한다.\n  즉, Hashtable 자료구조는 myHashtable.values().iterator() 형식으로 Iterator를 얻을 수 있음.\n</tip>\n\n```java:.java\n// List, ArrayList\nwhile (myIterator.hasNext()) {\n  Object obj = myIterator.next();\n}\n```\n\n한 단계 더 나아가 MyList, MyArrayList를 인터페이스로 묶어 createIterator를 강제할 수 있다.\n공통 메서드로 createIterator를 만들어 순차 탐색시에는 Iterator를 사용하도록 유도하는 것이다.\n\n### Single Responsibility\n\n그런데 MyListIterator 클래스를 따로 만들지 않고, 그냥 MyList에서 Iterator를 바로 implements 해서 구현하면 안되는 걸까?\n\n그래도 상관없긴 하다.\n하지만, 하나의 클래스는 하나의 역할만 수행한다는 디자인 원칙을 준수하는 것이 코드를 깔끔하게 관리할 수 있도록 도와줄 것이다.\n\n하나의 클래스가 데이터도 관리하고, Iterator도 관리하면... 기능이 너무 복잡해지기 때문이다.","slug":"univ_design-pattern/mid_09","readingMinutes":5,"wordCount":370},{"title":"Template Method Pattern","description":"Template Method 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Template Method Pattern"],"draft":false,"date":"2023-10-21 / 18:52","content":"\n## 필요성\n\n아래와 같은 음료 제조법이 있다고 가정해보자.\n\n> Coffee Recipe\n> 1. **Boil some water**\n> 2. Brew coffee in Boiling water\n> 3. **Pour beverage in cup**\n> 4. Add sugar and milk\n>\n> Tea Recipe\n> 1. **Boil some water**\n> 2. Steep tea in Boiling water\n> 3. **Pour beverage in cup**\n> 4. Add lemon\n\n1, 3번 과정은 동일하다.\n하지만 음료가 다르다고 같은 제조 과정을 중복해서 적으면 시간도 낭비되고, 수정할 때도 둘 다 수정해야 하는 불편함이 있다.\n\n따라서 **동일한 부분은 함수**로 빼버리고, **다른 부분만 abstract**로 처리하는 기법을 사용하면 이런 불편함을 줄일 수 있을 것이다.\n\n## Template Method Pattern\n\n알고리즘의 뼈대를 정의하고, 서로 다른 부분은 subclass에 미루어 처리하는 디자인 패턴을 Template Method Pattern 이라고 한다.\n\n위의 상황을 코드로 구현하며 알아보자.\n\n```java:Beverage.java {9-10}\npublic class Beverage {\n  final void prepareRecipe() {\n    boilWater();\n    brew();\n    pourInCup();\n    addCondiments();\n  }\n\n  abstract void brew();\n  abstract void addCondiments();\n\n  void boilWater() {\n    // boil water\n  }\n\n  void pourInCup() {\n    // pouring in cup\n  }\n}\n```\n\n```java:Cafe.java\npublic class Coffee extends Beverage {\n  public void brew() {\n    // Brew coffee in Boiling water\n  }\n\n  public void addCondiments() {\n    // Add sugar and milk\n  }\n}\n\npublic class Tea extends Beverage {\n  public void brew() {\n    // Steep tea in Boiling water\n  }\n\n  public void addCondiments() {\n    // Add lemon\n  }\n}\n```\n\n이런식으로 하면 두 음료 모두 boilWater, pourInCup 과정은 동일한 코드를 사용할 수 있고,\n음료에 따라 다른 brew, addCondiments 과정을 갖게 된다.\n\n또한, 두 음료 모두 Beverage 클래스로 다형성을 유지할 수 있고, 음료 제작 과정은 둘 다 prepareRecipe를 호출하여 실행할 수 있다.\n\n<tip>\n  이 방식은 **Hollywood 디자인 원칙** 역시 준수하는데, 이게 뭐냐하면,\n  **상위 컴포넌트(클래스)만 호출**하고, **하위 컴포넌트는 호출하지 않고 등록**만 하는 원칙이다.\n  <br />\n  위의 예시에선 Coffee, tea에서 기능을 수행하지 않고, brew, addCondiments만 등록을 했다.\n  실제 호출은 Beverage에서 prepareRecipe에서만 수행했다.\n</tip>\n\n## IRL\n\nsort에서도 이와 비슷한 기능이 있다.\n\n```java:MergeSort.java {5}\nprivate static void mergeSort(Object src[], Object dest[],\n                    int low, int high, int off) {\n  for (int i=low; i<high; i++) {\n    for (int j=i; j>low \n         && ((Comparable)dest[j-i]).compareTo((Comparable)dest[j])>0; j--) {\n      swap(dest, j, j-1);\n    }\n  }\n}\n```\n\nComparable의 compareTo 메서드에서 객체의 비교하는 방법을 정의하게 되는데, 객체간 비교를 하고싶을 때 Comparable 인터페이스의 compareTo 메서드를 구현하면,\n이에 따라 객체의 비교 방법이 달라져 mergeSort가 객체간 비교를 가능케 하는 것이다.","slug":"univ_design-pattern/mid_08","readingMinutes":4,"wordCount":373},{"title":"Facade Pattern","description":"Facade 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Facade Pattern"],"draft":false,"date":"2023-10-21 / 18:18","content":"\n## 필요성\n\n집에서 나만의 영화관을 만든다고 가정해보자.\n편-안하게 영화를 보고싶지만, 영화 보기 전 선행되어야 할 일들이 많다.\n\n```java:HomeTheater.java\npublic class HomeTheater {\n  public static void main(String[] args) {\n    ...\n    // 팝콘을 튀기고\n    popper.on(); \n    popper.pop();\n    // 조명을 낮추고\n    lights.dim(10); \n    // 스크린을 내리고\n    screen.down();\n    // 빔 프로젝터를 설정하고\n    projector.on();\n    projector.setInput(dvd);\n    projector.wideScreenMode();\n    // 앱프에 영화를 넣고\n    amp.on();\n    amp.setDvd(dvd);\n    amp.setSurroundSound();\n    amp.setVolume(5);\n    // 영화 실행...\n    dvd.on();\n    dvd.play(movie);\n  }\n}\n```\n\n이런 일련의 과정을 클라이언트에게 할당하면, 개발자 입장에선 피곤할 뿐만 아니라, 장치의 메서드에 변화가 생기면 클라이언트가 해당 부분을 수정해야 한다는 단점이 있다.\n\n## Facade Pattern\n\nFacade 디자인 패턴은 **단일화된 인터페이스로 서브 시스템을 다루는 패턴**으로, 위의 일련의 과정을 클라이언트에게 맡기는 것이 아닌, 하나의 인터페이스로 묶고, 그 인터페이스만 클라이언트에게 제공하는 것이다.\n\n```java:HomeTheaterFacade.java\npublic class HomeTheaterFacade {\n  Amplifire amp;\n  DvdPlayer dvd;\n  Projector projector;\n  ...\n\n  public HomeTheaterFacade (Amplifire amp, ...) {\n    this.amp = amp;\n    ...  \n  }\n\n  public void watchMovie(String movie) {\n    // 팝콘을 튀기고\n    popper.on(); \n    popper.pop();\n    // 조명을 낮추고\n    lights.dim(10); \n    // 스크린을 내리고\n    screen.down();\n    // 빔 프로젝터를 설정하고\n    projector.on();\n    projector.setInput(dvd);\n    projector.wideScreenMode();\n    // 앱프에 영화를 넣고\n    amp.on();\n    amp.setDvd(dvd);\n    amp.setSurroundSound();\n    amp.setVolume(5);\n    // 영화 실행...\n    dvd.on();\n    dvd.play(movie);\n  }\n}\n```\n\n```java:HomeTheater.java\npublic class HomeTheater {\n  public static void main(String[] args) {\n    ...\n\n    HomeTheaterFacade homeTheater = new HomeTheaterFacade(...);\n\n    homeTheater.watchMovie(\"movie\");\n  }\n}\n```\n\n일련의 모든 과정을 Facade에게 일임하여 클라이언트는 Facade를 이용해 나름 매크로 기능을 이용할 수 있다.\n\n<tip>\n  눈여겨 봐야 할 디자인 원칙: **직접적인 친구와만 대화하라**\n  <br />\n  객체의 메서드는 다음과 같은 경우에만 호출하는 것이 바람직하다.\n  1. 객체 자신의 멤버 메서드를 호출\n  2. 인자로서 넘어온 객체의 메서드를 호출\n  3. 메서드 내부에서 생성된 객체의 메서드를 호출\n  4. 객체의 멤버변수로 저장된 객체의 메서드 호출\n\n  예를 들어보자.\n  아래와 같은 경우는 부적절한 경우이다.\n\n  ```java:.java\n  public float getTemp() {\n    Thermometer thermometer = station.getThermometer();\n    return thermometer.getTemperature();\n  }\n  ```\n\n  thermometer가 getTemp() **메서드 내부에서 생성되지 않았**는데, 해당 객체의 getTemperature() 메서드를 호출했기 때문이다.\n  <br />\n  대신에 아래와 같이 하는 것이 바람직하다.\n\n  ```java:.java\n  public float getTemp() {\n    return station.getTemperature();\n  }\n  ```\n\n  <br />\n  정리하면, 객체의 메서드를 호출할 때에는 객체간의 인과관계가 명확한 상황에서만 호출하라는 뜻이다.\n</tip>","slug":"univ_design-pattern/mid_07","readingMinutes":4,"wordCount":321},{"title":"Finding Similar Items","description":"유사도 높은 문서를 찾아내는 방법을 알아봅니다.","icon":"","image":"","tags":["Shingling","Minhashing","Jaccard Similarity"],"draft":false,"date":"2023-10-20 / 22:12","content":"\n생김새가 비슷한 사이트를 묶거나, 표절 검사를 하거나, 비슷한 내용의 뉴스를 클러스터링 하는 등 여러 분야에서 사용될 수 있는 기술에 대해 설명합니다.\n\n<notice>\n  생김새가 비슷한 문서를 찾아내는 기술이지, 비슷한 토픽을 찾아내는 기술은 아닙니다.\n</notice>\n\n아래의 단계를 거쳐 비슷한 문서를 찾게 되는데, 각 단계에 대한 세부적인 내용은 추후에 설명합니다.\n\n1. `Shingling`을 통해 데이터(문서)를 집합으로 변환\n2. `Minhashing`을 통해 큰 집합을 작은 시그니처로 변환\n3. `LSH`를 통해 시그니처를 분류 후 비슷한 집합 찾기\n\n## Jaccard Similarity\n\n세부내용 설명 전 개념 하나만 짚고 넘어가자.\n유사도를 검사할 때, 다음과 같은 경우를 고려해보자.\n\nA, B 모두 메이져한 게임들을 주로 플레이하고, A는 RPG를, B는 FPS를 주로 플레이한다고 가정하자.\n이 때, 마이너한 장르의 게임을 예시로 들며 유사도를 검사하는데, A, B 모두 해당 게임을 보유하지 않는다고 두 사람의 유사도가 높다고 이야기 할 수 있을까?\n두 사람은 그런 마이너한 장르의 게임에 관심이 없어서 갖고있지 않을 뿐인데, 둘 다 갖고있지 않다고 두 사람의 플레이스타일이 유사하다고 판단하는 것은 무리가 있다.\n\n따라서 이런 유사도 파악의 오류를 해결하기 위해 Jaccard 유사도를 사용하여 유사도를 측정하게 된다.\n\n$$\nSim(C_1, C_2) = \\frac{|C_1 \\cap C_2|}{|C_1 \\cup C_2|}\n$$\n\n즉, **두 사람 중 한 사람이라도 해당 게임을 보유하고 있는 경우에만 두 사람이 동시에 해당 게임을 보유하는가**로 유사도를 검사하는 것이다.\n\n---\n\n## Shingling\n\n문서의 유사도를 측정할 때 그 기준이 되는 토큰을 생성하는 방법입니다.\n`k-shingle` 과 같은 용어를 사용하는데, 이는 k개의 문자로 이루어진 shingle을 의미합니다.\n실제로 비슷한 문서를 싱글링 했을 때 집합의 원소도 일치하는 부분이 매우 많습니다.\n\n예로 들어 \\\"The dog which chased the cat\\\" 이라는 문장이 있다고 했을 때, 여기서 2-shingle를 구하면 다음과 같습니다.\n\n> th(보통 소문자로 변환), he, e_, _d, do, og, ...\n\n하지만, 2-shingle로 하면 th, he, do와 같이 문장으로 볼 때는 상당히 유니크한 의미를 갖는 문장이 이렇게 아무데서나 나올법한 shingle이 되어버립니다.\n따라서 보통은 `8~10`-shingle로 하는 것이 적당합니다.\n\n### Tokens\n\n10-shingle을 사용하는 경우에는 최대 $27^{10} \\approx 200조$ 개의 싱글이 생성되게 됩니다.\n이를 메모리상에서 관리하는 것은 현실적으로 불가능한 일입니다.\n\n따라서 싱글을 해싱하여 4bytes의 자료형으로 변환하여 `Token`으로서 사용하게 됩니다.\n4bytes로 최대 약 42억개의 서로 다른 싱글을 표현할 수 있습니다.\n물론 다른 싱글에 대해 같은 토큰이 생성될 수 있지만, 그리 빈번한 경우는 아닐 것이며, 효율상 이 방법이 더 좋습니다.\n\n즉, 같은 토큰을 보유한 문서가 있다면, 그 문서들은 같은 싱글을 갖고있다는 얘기이므로, 유사도가 있다고 판단할 수 있겠습니다.\n\n---\n\n## Minhashing\n\nMinhashing을 알아보기 전, 데이터를 표현하는 행렬을 읽는 법을 알고가자.\n\n| (token) | $C_1$ | $C_2$ |\n|---|---|---|\n| a | 0 | 0 |\n| b | 1 | 0 |\n| c | 0 | 1 |\n| d | 1 | 1 |\n\na 토큰(싱글)은 문서(Column) 1, 2에서 모두 없다는 뜻이고, b는 문서 1에서만 갖고있다는 뜻으로 해석하면 된다.\n참고로 위의 경우 두 문서의 Jaccard 유사도는 **1/3**이다. (a는 둘 다 없기에 비교대상이 아니다)\n\n### Permute the rows\n\n우선 행을 핸덤으로 뒤죽박죽 섞는다.\n섞는다는 것은 실제로 맊 섞는다는 것이 아닌, 탐색 순서를 섞는다는 것을 의미하는데, 구현 관점에서 해싱을 돌리는 것과 같다.\n예시를 보며 이해해보자.\n\n| (row) | $C_1$ | $C_2$ | $C_3$ |\n|---|---|---|---|\n| 1 | 0 | 1 | 1 |\n| 2 | 1 | 0 | 1 |\n| 3 | 0 | 1 | 0 |\n| 4 | 0 | 0 | 0 |\n| 5 | 1 | 0 | 1 |\n\n$h_1(x) = x \\% 5$ 해시함수를 적용하면 탐색 순서는 다음과 같아진다.\n\n> **5**(0) &rarr; **1**(1) &rarr; **2**(2) &rarr; **3**(3) &rarr; **4**(4)\n\n$h_2(x) = (2x+1) \\% 5$ 해시함수를 적용하면 탐색 순서는 다음과 같아진다.\n\n> **2**(0) &rarr; **5**(1) &rarr; **3**(2) &rarr; **1**(3) &rarr; **4**(4)\n\n### Create signature\n\n탐색 순서에 맞게 처음으로 1(토큰 보유)을 만나는 탐색 순서를 기록한다.\n\n> $h_1$를 적용한 탐색시 생성되는 Singature matrix\n> [1, 2, 1]\n>\n> $h_2$를 적용한 탐색시 생성되는 Singature matrix\n> [1, 3, 1]\n\n즉, $C_1$에 대한 시그니처는 11, $C_2$는 23, $C_3$은 11이 된다.\n\n여기서 중요한 특징이 있는데, 시그니처의 길이가 길어질 수록(무작위 순서에 의한 탐색 횟수가 늘어날 수록) 시그니처가 일치할 확률이 Jaccard 유사도와 확률이 같아진다.\n그 이유를 간단한 예시로 이해해보자.\n\n우선, $C_2$과 $C_3$의 Jaccard 유사도는 **1/4**이다.\n그런데 이 때, Singature가 같아지는 경우는 무엇일까? 바로 **최초로 1이 나오는 시점이 같다**는 이야기이다.\n즉, 같은 row에 대해 둘 다 1이 들어가 있는 row를 고를 확률과 같아진다.\n둘 다 0인 경우를 제외하면 4개 중에 둘 다 1인 row는 1개 존재하기에 Jaccard 유사도와 동일한 **1/4** 확률을 갖는다.\n\n![231020-235719](/posts/mid_05/231020-235719.png)\n\n이해를 돕기 위해 다른 예시도 보자.\n\n원래대로라면 생성되는 모든 토큰(42억개)에 대해 유사도를 검사 했어야 했다.\n하지만, 시그니처를 만드는 과정에서 무작위 순서로 탐색을 진핼할 때, 탐색개수를 제한을 걸면 검사 시간을 줄일 수 있다.\n예로 들어 해시함수의 결과를 50까지만 검색한다면 42억개의 항목에 대해 검사를 진행하지 않아도 된다. \n\n이 때 검사 개수를 줄인 만큼 서로다른 해시를 여러 번 진행하면 신뢰도 역시 어느정도 확보할 수 있다.\n예로 들어 서로 다른 해시함수 100개를 적용한다면, 시그니처의 길이가 100으로 결정되는데, 이 길이는 충분히 신뢰도를 확보할 수 있을 것이다.\n즉, 42억개에서 100개로 압축되는 효과가 발생하는 것이다.\n\n위의 사진을 예시로 실제 Jaccard 유사도와 시그니처 유사도를 비교해보며 시그니처 길이가 신뢰도에 어느정도 영향을 주는지 알아보자.\n\n> Column 1, 2\n> Jaccard Similarity: **1/4**\n> Singature Similarity: **1/3**\n>\n> Column 2, 3\n> Jaccard Similarity: **1/5**\n> Singature Similarity: **1/3**\n>\n> Column 3, 4\n> Jaccard Similarity: **1/5**\n> Singature Similarity: **0**\n\n### implement\n\n의사코드로 구현해보고 시그니처 생성과정을 살펴보자.\n\n```cpp:의사코드\n// 처음에 무한대로 초기화\nfor (all i and c) M(i, c) = inf;\n\n// 각 행에 대해 반복하는데, 여기에 탐색개수 50개와 같은 제한을 걸 수 있음\nfor (each row r) {\n  for (each hash function h_i) {\n    compute h_i(r);\n  }\n  for (each column c) {\n    // 탐색지점에 1이 있는 경우\n    if (c has 1 in row r) {\n      for (each hash function h_1) {\n        // 저장된 시그니처보다 새 탐색값이 작은 경우에만 업데이트\n        if (h_i(r) is smaller them M(i, c)) {\n          M(i, c) = h_i(r);\n        }\n      }\n    }\n  }\n}\n```\n\n![231021-001859](/posts/mid_05/231021-001859.png)","slug":"univ_mmds/mid_05","readingMinutes":11,"wordCount":927},{"title":"Association Rules","description":"빅데이터에서 연관 규칙을 찾아내는 방법에 대해 알아봅니다.","icon":"","image":"","tags":["Association Rules","Support","Confidence","Interest"],"draft":false,"date":"2023-10-20 / 20:08","content":"\n## Application\n\n연관 규칙을 응용할 수 있는 분야를 살펴보면서 대략적인 이해와 필요성에 대해 알아보자.\n\n![231020-201233](/posts/mid_04/231020-201233.png)\n\n장을볼 때 각 장바구니에 어떤 물건을 샀는지를 나타내는 표이다.\n이 표를 간단하게 분석해보면, `Milk`를 산 사람은 대체로 `Coke`를 사는 경향이 있고, `Diaper, Milk`를 동시에 산 사람은 대체로 `Beer`를 산 경향이 있는걸로 보인다.\n이렇게 사람들의 구매 경향을 분석할 때 사용하기도 한다.\n\n또한 문서 상에서 **\\{the\\} &rarr; \\{cat\\}** 이라는 규칙이 있다면 the 라는 단어 뒤에는 대체적으로 cat 이라는 단어가 나온다는 뜻으로, 자연어처리시 문법을 파악하고 학습시키는데 도움이 될 수도 있다.\n\n그 외에도 여러 분야에서 활용될 수 있지만, 섣부른 일반화는 안된다.\n예로 들어 **비타민C를 많이 먹는 사람들은 불면증을 겪는 경향이 있다**는 규칙을 발견했다면, **비타민C를 안먹는 경우**에도 불면증 경향이 있는지 검사해봐야 확실해는 것이다.\n\n## Frequent Itemset\n\nFrequent Itemset을 구하는 방법은 [**`저번 포스트`**](https://wjlee611.github.io/blog/univ_mmds/mid_03)에서 알아봤으니, 이젠 용어과 수식을 통해 연관 규칙을 정의하는 것을 알아보자.\n\n### Support\n\n**Support for itemset I** 라고 한다면 itemset I가 등장한 횟수를 의미한다.\n전체 basket에서 itemset I가 등장한 횟수를 카운트 하면 된다.\n이 때, Support threshold S 보다 크다면 빈번하다고 판단하게 되는 것이다.\n\n| Baskets | m(ilk), c(oke), p(epsi), b(read), j(am) |\n| --- | --- |\n| $B_1$ = **\\{m, c, b\\}** | $B_2$ = **\\{m, p, j\\}** |\n| $B_3$ = **\\{m, b\\}** | $B_4$ = **\\{c, j\\}** |\n| $B_5$ = **\\{m, p, b\\}** | $B_6$ = **\\{m, c, b, j\\}** |\n| $B_7$ = **\\{c, b, j\\}** | $B_8$ = **\\{b, c\\}** |\n\n예로 들어 위와 같이 목록들이 존재하고, Support threshold가 `3 baskets` 라고 주어진다면,\nFrequent itemset은 아래와 같이 나오게 된다.\n\n> **\\{m\\}, \\{c\\}, \\{b\\}, \\{j\\}, \\{m, b\\}, \\{b, c\\}, \\{c, j\\}**\n\n## Association Rules\n\n**특정 집합($I$)이 등장할 때 $j$ 하는 경향이 있다** 라는 연관 규칙을 수식화 하면 아래와 같이 표현이 가능하다.\n\n> $\\{i_1, \\; i_2, \\; ,... \\; , i_k\\}$ &rarr; $j$\n\n### Confidence\n\n이 떄, 그 경향에 대한 신뢰도, `Confidence`는 아래와 같이 수식화 할 수 있다.\n\n$$\nconf(I \\rightarrow j) = \\frac{support(I \\cup j)}{support(I)}\n$$\n\n즉 조건부에 해당하는 itemset이 등장할 확률 기반으로 itemset + j 가 동시에 등장할 확률을 구하면 되는 것이다.\n\n### Interest\n\n하지만 신뢰도가 높다고 반드시 의미있는 규칙이 발견된 것은 아니다.\n\n예로 들어 **X &rarr; milk** 라는 규칙을 발견했다고 가정하자.\n그러나, 굳이 X가 아니더라고 그냥 milk는 많이 사기때문에 둘 사이에 연관성이 깊다고 판단하기에는 무리가 있다.\n\n이 떄문에 `Interest`의 개념이 존재한다.\n\n$$\nInterest(I \\rightarrow j) = | conf(I \\rightarrow j) - Pr[j] | \\\\\nPr[j] = \\frac{support(j)}{표본 \\; 수}\n$$\n\n흥미도는 I 신뢰도에서 j가 등장할 확률을 뺀 값의 절댓값과 같다.\n\n보통 해당 값이 `0.5보다 크다`면 해당 규칙이 의존성이 있다는 의미가 된다.\n만약 `-0.5보다 작은` 경우에도 의존성이 있다는 의미가 있는데 이 경우에는 **I, j를 둘 다 사는 경우는 없다**는 뜻으로 해석할 수 있다.\n\n| Baskets | m(ilk), c(oke), p(epsi), b(read), j(am) |\n| --- | --- |\n| $B_1$ = **\\{m, c, b\\}** | $B_2$ = **\\{m, p, j\\}** |\n| $B_3$ = **\\{m, b\\}** | $B_4$ = **\\{c, j\\}** |\n| $B_5$ = **\\{m, p, b\\}** | $B_6$ = **\\{m, c, b, j\\}** |\n| $B_7$ = **\\{c, b, j\\}** | $B_8$ = **\\{b, c\\}** |\n\n위애서 예시로 든 baskets에서 다음과 같은 연관 규칙을 찾았다고 해보자.\n\n> **\\{m, b\\} &rarr; c**\n>\n> $support(\\{m, b\\} \\cup c)$ = **2** (m, b, c 동시 등장 횟수)\n> $support(\\{m, b\\})$ = **4** (m, b 동시 등장 횟수)\n> $conf(\\{m, b\\} \\rightarrow c)$ = 2/4 = **0.5**\n> $Interest(\\{m, b\\} \\rightarrow c)$ = | 0.5 - 5/8 | = **1/8**\n\n즉, 이 경우에는 Interest가 낮기 때문에 그다지 의미 없는 규칙이라는 뜻이다.\n\n### Mining Association Rules\n\n1. 모든 빈발 항목 집합 I를 찾는다.\n  (이건 [**`이전 포스트`**](https://wjlee611.github.io/blog/univ_mmds/mid_03)에서 찾는 법을 다룸)\n\n2. 규칙 생성\n\n이제 규칙을 생성하는 방식을 알아보자.\n\n우선 생성된 빈발 항목 집합 I의 부분집합을 이용해서 생성 가능한 모든 연관 규칙을 만든다.\n예로 들어 **I = \\{a, b, c, d\\}** 라면, **\\{a, b, d\\} &rarr; c, \\{a, b\\} &rarr; \\{c, d\\}** 등등과 같이 모든 조합에 대해 만들어 주는 것이다.\n\n그 다음은 생성된 모든 규칙에 대해 Confidence, Interest를 분석해서 의미있는 규칙만 남도록 걸러내면 된다.\n여기서 특정 규칙을 검사하고 나면 나머지 특정 규칙들은 검사할 필요가 없어지는 최적화가 가능한데, 그 이유를 알아보자.\n\n예로 들어 **\\{a, b, c\\} &rarr; d** 의 confidence가 threshold 이하라면 **\\{a, b, c\\}** 의 부분집합이 조건부가 되는 규칙들(**\\{a, b\\} &rarr; \\{c, d\\}**, **\\{b\\} &rarr; \\{a, c, d\\}**, ...)은 검사를 진행할 필요가 없어진다.\n왜냐하면 아래의 식을 잘 살펴보자.\n\n$$\nconf(I \\rightarrow j) = \\frac{support(I \\cup j)}{support(I)}\n$$\n\n여기서 동일한 빈발 항목 집합에 대해 생성된 규칙이면 분자는 동일하다는 것은 자명하다.\n즉, 분모만 변화하게 되는데, 원소의 개수가 줄어들 수록 분모의 값은 필연적으로 같거나 커질 수 밖에 없다.\n그렇기에, confidence는 반드시 같거나 작아질 수 밖에 없는 것이다. (하물며 threshold와 비교하면? 분명 더 작을거다.)\n\n| Baskets | m(ilk), c(oke), p(epsi), b(read), j(am) |\n| --- | --- |\n| $B_1$ = **\\{m, c, b\\}** | $B_2$ = **\\{m, p, j\\}** |\n| $B_3$ = **\\{m, c, b, n\\}** | $B_4$ = **\\{c, j\\}** |\n| $B_5$ = **\\{m, p, b\\}** | $B_6$ = **\\{m, c, b, j\\}** |\n| $B_7$ = **\\{c, b, j\\}** | $B_8$ = **\\{b, c\\}** |\n\n마지막으로 실제로 연관 규칙을 찾아보며 마무리해보자.\nthreshold = 3, confidence = 0.75 로 제한한다고 가정하자.\n\n> Frequent itemsets: \n> **\\{b, m\\} \\{b, c\\} \\{c, m\\} \\{c, j\\} \\{m, c, b\\}**\n\n| Generate rules | | | |\n| --- | --- | --- | --- |\n| ~~b &rarr; m [c=0.67]~~ | b &rarr; c [c=0.83] | ... | ~~b,c &rarr; m [c=0.6]~~ |\n| m &rarr; b [c=0.8] | c &rarr; b [c=0.83] | | ~~b &rarr; c,m (검사 필요 없음)~~ |\n| | | | ~~c &rarr; b,m (검사 필요 없음)~~ |\n| | | | c,m &rarr; b [c=1] |\n| | | | b,m &rarr; c [c=0.75] |\n| | | | ~~m &rarr; b,c [c=0.6]~~ |\n이후에 interest도 진행\n\n### Compacting the output\n\n생성되는 연관 규칙이 너무 많기에 이를 압축하는 방식도 있다.\n\n1. Maximal frequent itemsets\n  threshold 기준으로 압축한다.\n2. Closed itemsets\n  support 기준으로 압축한다.\n\n다음 표를 보면서 이해해보자.\n(Yes인 경우에만 연관 규칙을 출력한다는 뜻이다)\n\n| Itemset | Support | Maximal | Closed |\n| --- | --- | --- | --- |\n| A | 4 | No | No |\n| B | 5 | No | Yes |\n| C | 3 | No | No |\n| AB | 4 | Yes | Yes |\n| AC | 2 | No | No |\n| BC | 3 | Yes | Yes |\n| ABC | 2 | No | Yes |\n**Threshold = 3**\n\n`Maximal 기준`\n- C를 보면 support가 threshold보다 크지만 출력하지 않는다.\n그 이유는 C의 superset BC가 `frequent 해서` 이미 출력하기 때문에 중복해서 출력하지 않는 것이다.\n- 반대로 AB를 보면 support가 threshold보다 커서 출력한다.\n그 이유는 AB의 superset ABC가 `frequent 하지 않기 때문`에 출력해야하기 때문이다.\n\n\n`Closed 기준`\n- C를 보면 support가 threshold보다 크지만 출력하지 않는다.\n그 이유는 C의 superset BC의 `support와 같기 때문`에 출력하지 않는 것이다.\n- 반대로 AB를 보면 support가 threshold보다 커서 출력한다.\n그 이유는 AB의 superset ABC의 `support가 보다 작기 때문`에 출력하는 것이다.","slug":"univ_mmds/mid_04","readingMinutes":11,"wordCount":1147},{"title":"Frequent Itemset","description":"빈발 항목 집합을 구하는 방법을 알아봅니다.","icon":"","image":"","tags":["Frequent Itemset","A-Priroi","PCY","Random Sampling","SON","Toivonen"],"draft":false,"date":"2023-10-19 / 16:33","content":"\n## Naive Algorithm\n\n우선 나이브한 방법으로 빈발 항목 집합을 찾는 방법부터 알아보자.\n처음에는 frequent pair를 찾는 것을 목표로 하고, 이후에 원소의 개수가 더 많은 집합을 찾는 방식으로 확장하자.\n\n간단하게 요약하면 아래의 두 단계에 걸쳐 모든 pair를 생성한다.\n\n1. 가능한 모든 조합의 쌍 생성\n  n개의 아이템이 들어있는 Basket에서는 `n(n-1)/2` 개의 조합 쌍이 생성된다.\n2. 해당 조합 쌍이 동시에 등장하는 경우 1씩 카운트하며 개수를 센다.\n\n이 방식은 구현이 제일 간단하지만 치명적인 문제가 있다.\n개수를 `4bytes`의 int형으로 저장한다고 가정하면 n개의 아이템이 존재하는 Basket에 대해 `2n(n-1)bytes`의 메모리 공간이 할당되어야 하는데, 이런 크기의 메모리 공간을 할당할 수 없을 뿐더러, 존재하지도 않은 페어의 메모리 공간을 할당해야만 하는 문제점이 있다.\n\n### Triples\n\n이런 한계를 극복하기 위해 원소를 triples로 관리하는 기법도 있다.\n`[i, j, c]` 로 관리하는 기법인데, **\\\"\\{i, j\\} 페어가 c번 등장함\\\"** 이라는 의미로 관리하는 것이다.\n이렇게 하면 하나의 페어당 12bytes가 들어가긴 하지만, 존재하지도 않은 페어에 대한 메모리 공간 할당은 방지할 수 있다.\n\n하지만 메모리 주소 관리를 위해 별도의 `해시 테이블`을 할당해야 하기에 그다지 메리트가 크지는 않다.\nTriples 방식이 더 효율적으로 작동하기 위해서는 가능한 모든 페어 조합 수의 1/3 수준으로 실제로 등장하는 페어수가 존재해야 한다.\n\n---\n\n## A-Priori Algorithm\n\n페어가 메인 메모리에 올라갈 정도로 적다면 나이브한 방식을 사용하는것이 좋다.\nBasket을 한 번만 읽어도 되는, 1pass만에 빈발 항목 집합을 찾을 수 있으니 속도가 빠르기 때문이다.\n\n<tip>\n  `pass`\n  Basket(파일)을 처음부터 끝까지 읽는 횟수로, Disk I/O의 cost가 큰 만큼 pass 횟수에 따라 알고리즘의 성능을 평가하는 요소로 작동한다.\n</tip>\n\n하지만, 그렇지 않은 대다수의 경우에는 다른 방식을 고안해야 한다.\nA-Priori 알고리즘의 경우에는 2pass로 pair를 찾을 수 있지만, 그 대신 메모리 효율성이 극대화되어 매우 큰 파일도 메모리에 적재할 수 있다.\n하지만 이게 어떻게 가능한 것일까?\n\n기본적인 아이디어는 이렇다.\n이 파일에는 아이템이 **a, b, c** 이렇게 존재한다고 해보자.\n만약 **\\{a, b\\}** 가 10번 등장했다면, 진 부분집합 **\\{a\\}, \\{b\\}** 역시 10변 이상 등장했을 것이다.\n반대로 말하면 **\\{a\\}, \\{b\\}** 가 10번도 안나왔다면, **\\{a, b\\}** 역시 10번도 안나올 것이다.\n\n따라서 빈발 항목 집합을 세기 전에 우선 threshold보다 큰 경우에만 빈번하다고 기준을 정의하고 시작한다.\n\n### Pass 1\n\npass 1에서는 우선 파일을 읽어보며 개별적인 아이템 개수부터 세어본다.\n이 때, 아이템 개수가 threshold보다 큰 경우에만 다음 pass에서 고려하게 된다.\n\n![231019-205437](/posts/mid_03/231019-205437.png)\n\n참고로 pass 2에서 빈번하게 등장한 아이템에 접근하기 위해 빈번하게 등장한 아이템들의 주소를 저장하기 위해 메모리 공간을 약간 할당한다.\n\n### Pass 2\n\npass 2에서는 pass 1에서 통과한 아이템들을 이용해서 페어를 생성한다.\n그리고 나이브한 방법과 마찬가지로 파일을 읽으면서 등장 횟수를 카운트한다.\n\n이 방식이 훨씬 효율적인게, 만약 pass 1에서 읽어야 할 아이템의 개수가 1/10 으로 줄었다면,\npass 2에서 생성되는 pair의 개수는 1/100 수준으로 줄어든다.\n따라서 메모리 효율성이 거의 100배 증가하는 것이다.\n\n### Frequent Triples\n\npair에서 확장되어 원소의 개수가 3개, 4개인 경우의 처리 방식도 알아보자.\n근데 사실 별 거 없다. 그냥 앞에서 봤던 방법의 반복이다.\n\n빈번하게 등장한 페어를 이루는 아이템들로 triple을 만든다.\n이후 각 triple의 진 부분집합이 빈번하게 등장한 pair인 경우에만 파일을 읽어보며 세어보면 된다.\n\n예시들 들어 이해해보자.\n\n> $C_1$ = \\{\\{b\\} \\{c\\} \\{j\\} \\{m\\} \\{n\\} \\{p\\}\\}\n> threshold보다 많이 등장한 원소는 아래 4개라고 해보자.\n> $L_1$ = \\{b, c, j, m\\}\n> $L_1$을 이용해서 다름 pass 진행\n> \n> $C_2$ = \\{\\{b, c\\} \\{b, j\\} \\{b, m\\} \\{c, j\\} \\{c, m\\} \\{j, m\\}\\}\n> threshold보다 많이 등장한 원소는 아래 4개라고 해보자.\n> $L_2$ = \\{\\{b, c\\} \\{b, m\\} \\{c, j\\} \\{c, m\\}\\}\n> $L_2$을 이용해서 다름 pass 진행\n>\n> $C_3$ = \\{\\{b, c, m\\} \\{b, c, j\\} \\{b, m, j\\} \\{c, m, j\\}\\}\n> 이 때 \\{b, c, j\\} \\{b, m, j\\} \\{c, m, j\\}의 부분 집합은 $L_2$에 포함되지 않으니 세어볼 필요 없음 (반드시 threshold보다 적게 등장할 것)\n\n즉, A-Priori 알고리즘은 k-pass 단계에서 k-tuple의 집합을 생성하게 되는데,\n일반적으로 k=2일 때, 메모리 사용량이 가장 많다.\n\n---\n\n## PCY Algorithm\n\nPark-Chen-Yu 알고리즘으로 A-Priori 알고리즘의 pass 1에서 메모리의 빈 공간을 활용하여 탐색 효율을 높인 알고리즘이다.\n그 이후의 과정은 A-Priori와 같으니, pass 1에서의 메모리 관리 방법에 대해서만 알아보자.\n\n![231019-211632](/posts/mid_03/231019-211632.png)\n\n### Bucket's Hash Table\npass 1에서 개별적인 아이템 등장 횟수를 카운트 할 때, 동시에 아이템으로 만들 수 있는 pair의 개수도 동시에 카운트 하는 것이다.\n이 때 페어를 해싱하여 버킷으로 만들고, 그 버킷을 Hash table for pairs에 최대한 가득 채운다.\n\n예로 들어 a, b, c의 개수를 세어보면서 \\{a, b\\} \\{b, c\\} \\{a, c\\}를 해싱한 주소에 등장할 때 마다 1씩 카운트 하는 것이다.\n만약 \\{a, b\\} \\{a, c\\} 의 해시 결과가 같은데, 해당 pair을 해시한 곳의 값이 threshold보다 작다면 pass 2에서 \\{a, b\\} \\{a, c\\} 를 셀 필요가 없다는 뜻이된다.\n\n그럼에도 불구하고 pass 2에서는 파일을 한 번 더 탐색을 해야만 하는데, 버킷만으로 pair가 threshold보다 크다고 단정지을 수 없는 이유는 해시의 특성 때문이다.\n다른 입력에 대해 같은 출력이 나올 수 있는 해시는 여러 pair가 하나의 버킷에 카운트 될 수 있음을 시사한다.\n즉, 버킷이 threshold보다 작다면 해싱후 그 버킷을 가리키는 pair는 세어볼 필요가 없지만,\nthreshold보다 큰 경우에는 threshold보다 작은 값이 여러개 모여 threshold보다 커졌을 가능성이 있기 때문에 다시 파일을 읽어보며 확인을 해봐야 하는 것이다.\n\n### Bit-vector (bitmap)\n\n아무튼, pass 1에서 pair의 해싱을 통한 버킷이 저장된 해시 테이블을 만들어 추후 파일 탐색시 검사해야 할 pair의 수를 줄이게 되는데,\n해시 테이블을 암축하지 않으면 pass 2로 넘어갈 수 없다. (메모리에 꽉 차게 할당했기 때문)\n어떻게 압축해야 필요한 정보를 유지할 수 있을까?\n\n우리가 필요한 정보는 n번째 버킷이 threshold보다 많이 등장했는지(1) 아닌지(0) 이다.\n따라서 해시 테이블에 n번째 버킷이 threshold보다 크다면 1, 아니면 0으로 압축할 수 있다.\n4bytes(32bits)에서 1bit로 압축되는 셈이다.\n\n그리고 이제 pass 2에서 \\{b, c\\}를 파일에서 몇 번 등장하는지 세어보기 전에 우선 해싱을 하여 bitmap에 해당 해시의 위치가 1이면 실제로 세어보고 0이면 셀 필요 없이 threshold보다 작다는 뜻이 된다.\n\n---\n\n## Random Sampling\n\n지금까지 알아본 빈번 항목 집합을 찾는 방식은 k-tuple의 개수를 세어보기 위해서는 k-pass를 거쳐야만 했다.\n이번부터 알아볼 알고리즘은 단 2-pass만에 세어볼 수 있는 방식을 알아볼 것이다.\n\n랜덤 샘플링 기법은 파일을 메모리에 올릴 수 있을 만큼만 적당히 샘플링 해와서 모든 카운트 과정을 메모리 내부에서 해결하는 것이다.\n하지만, 샘플링 비율만큼 실제 데이터 양도 줄어들기 때문에 threshold도 샘플링 비율만큼 줄여서 측정한다.\n\n하지만 이 경우에는 False Positive, False Negative 문제가 발생할 수 있다.\n\n<tip>\n  `False Positive`\n  실제로는 빈번하지 않은데 샘플링된 데이터에서는 빈번하다고 나온 경우\n  <br />\n  `False Negative`\n  실제로는 빈번한데 샘플링된 데이터에서는 빈번하지 않다고 나온 경우\n</tip>\n\nFalse Positive의 경우에는 pass 2에서 빈번 집합의 경우 실제로 빈번하게 등장하는지 검사해 봄으로써 해결할 수 있다.\n하지만 False Negative의 경우에는 찾아낼 방법이 없다.\n\nthreshold를 더 작게 설정하는 방식으로 False Negative가 나올 확률을 줄일수는 있겠지만, 해결책은 아니다.\n\n---\n\n## SON Algorithm\n\n기본적인 방식은 랜덤 샘플링과 동일하다.\n차이점은 SON Algorithm음 모든 파일을 다 읽는다는 것이다.\n즉, 한 번 읽을 때 샘플링한 작은 청크를 읽지만, 이 과정을 여러번 반복해서 전체 파일을 읽어온다는 차이점이다.\n\n이 방식은 False Negative도 없다고 확신할 수 있다.\n왜냐하면 실제로 빈번한 집합이라면 읽어오는 모든 청크에 대해 최소 1개의 청크에서는 빈번하게 등장할 것이기 때문이다.\n\n하지만 모든 청크를 결국 메모리에 1번은 올려야 하기 때문에 시간이 오래 걸린다는 단점이 있다.\n\n---\n\n## Toivonen's Algorithm\n\n시작은 랜덤 샘플링과 같다.\n하지만 랜덤 샘플링에서 샘플을 파일의 1/100 수준으로 샘플링 한다면 threshold도 1/100 수준으로 설정할텐데 이 경우에는 좀 넉넉하게 1/125 정도로 설정한다는 차이가 있다.\n\n추가로 pass 1에서 Negative Border 라는 개념을 도입하여 False Negative를 방지한다.\n이 외에는 랜덤 샘플링 방식과 동일하다.\n\n### Negative Border\n\nNegative Border에 포함되는 집합은 본인은 빈번하지 않지만, 본인의 진 부분집합은 빈번하게 등장한 경우 포함된다.\n예시를 들어 알아보자.\n\n> 모든 집합이 **\\{\\} \\{a\\} \\{b\\} \\{c\\} \\{a b\\} \\{b c\\} \\{a c\\} \\{a b c\\}** 만 존재한다고 가정해보자.\n>\n> `Case 1` **\\{a\\} \\{b\\}** 만 빈번하게 등장함 &rarr; **\\{a b\\} \\{c\\}** 를 Negative Border로 추가.\n> **\\{a b\\}** 의 경우에는 본인의 진 부분집합이 빈번하게 등장했으니 본인도 빈번하게 등장했을 가능성이 있다.\n> 따라서 추가 검사를 진행해봐야 하는 것이다.\n> **\\{c\\}** 의 경우에는 진 부분집합이랄게 없기 때문에 추가 검사를 진행해 봐야 하는 것이다.\n>\n> `Case 2` **\\{a\\} \\{b\\} \\{c\\}** 만 빈번하게 등장함 &rarr; **\\{a b\\} \\{b c\\} \\{a c\\}** 를 Negative Border로 추가.\n> 빈번하게 등장한 집합의 다음 스탭만 의심해야지, 나아가서 **\\{a b c\\}** 까지는 검사하지 않는다.\n>\n> `Case 3` **\\{\\}** (아무것도 빈번하지 않음) &rarr; **\\{a\\} \\{b\\} \\{c\\}** 를 Negative Border로 추가.\n> 샘플링을 너무 못했을 가능성이 높기에 일단 원소 1개짜리는 추가 검사를 해봐야 한다.\n\n이후 pass 2에서 빈번 항목 집합과 Negative Border에 대해 검사를 진행한다.\nFalse Positive의 경우에는 랜덤 샘플링과 마찬가지로 여기서 걸린다.\n\nFalse Negative의 경우에는 Negative Border에 포함된 집합을 검사하면서 나오게 될텐데,\n만약 Negative Border에 있는 집합이 실제로는 빈번하게 등장했다면 False Negative가 존재한다는 뜻이 된다.\n이런 경우에는 다른 샘플로 pass 1부터 다시 시도하게 된다.\n따라서 정확히는 2 pass안에 끝나지 않을 수는 있다.","slug":"univ_mmds/mid_03","readingMinutes":17,"wordCount":1340},{"title":"Spark 개념","description":"MapReduce 모델의 확장판, Spark에 대해 알아봅니다.","icon":"","image":"","tags":["Spark","RDD"],"draft":false,"date":"2023-10-19 / 15:04","content":"\n## MapReduce 문제점\n\n기존 MapReduce 모델의 문제점은 데이터 복제, Disk I/O 등의 오버헤드가 크다는 점이었다.\n\n하지만, ranks를 2개(map, reduce)로 나누어 관리하여 한 반향으로 데이터를 흐르게 만들어 \n시스템이 다운될 경우 재시작의 효율성이 올라가는 점도 고려하여 구현되었다.\n(단방향으로 흐르기에 처리 실패가 발생한 지점부터 다시 처리하면 됌)\n\n그러나, rank가 2개라 모든 문제를 map-reduce 패턴으로 묘사하기가 쉽지 않다는 점도 있었다.\n\n## Spark\n\n스파크는 오늘날 가장 많이 쓰이는 Data-Flow system으로 MapReduce에 비해 여러 부분에서 개선이 이루어졌다.\n\n1. rank를 2개로 제한하지 않음.\n  map, reduce 외의 tasks, ranks와 같은 여러 단계를 허용함.\n2. Map, Reduce 외의 별도의 유용한 함수 제공.\n3. 바로 디스크에 중간 결과를 저장하지 않고, 메모리에 캐싱하기도 함.\n  적당한 크기의 중간 결과는 메모리에 캐싱하기에 속도로 보다 빠르다\n4. MapReduce와 마찬가지로 단방향으로 데이터가 흐르는 DAGs 형식을 따른다.\n  (Directed Acycle Graphs)\n5. 여러 언어와 api를 제공하고, 오픈소스이며 호환성도 좋다.\n\n<tip>\n  `vs. Hadoop MapReduce`\n  Spark이 더 빠른대신 메모리 사용량도 더 많다.\n  Spark에서 제공하는 api가 더 많아 사용하기에 더 편하다.\n  둘 다 map-reduce 부분에서는 성능차이는 없다.\n</tip>\n\n### RDD\n\nResilient Distributed Dataset의 약어로 Spark에서는 큰 데이터를 RDD 라는 청크로 쪼개어 key-value 페어로 저장한다.\n즉, RDD가 여러개의 클러스터에 분산 저장되는데, 가장 큰 특징은 RDD는 **읽기 전용**이라는 점이다.\n그렇기에 **파일로부터** RDD를 얻어오기도 하며, **RDD로부터** 새로운 RDD를 만드는 식으로 작업된다.\n또한, RDD는 일반적으로 **메모리에 캐싱**되며, 필요에 따라 디스크에 저장하기도 한다.\n\n<tip>\n  `DataFrame`\n  RDD와는 다르게 데이터들이 테이블 형태로 저장되먀 column별로 이름도 있다.\n  <br />\n  `DataSet`\n  DF의 상위호환으로 타입 세이프, 객체지향 프로그래밍 인터페이스를 지원하며, 컴파일 타임에 에러도 잡아낼 수 있다.\n</tip>\n\n### Transformations\n\nRDD에서 새로운 RDD로의 변환을 Transformations라고 하는데, `map`, filter, join, union, intersection, distinct와 같은 변환이 있다.\n\n중요한 점은 이러한 변환은 `Lazy evaluation` 하게 동작한다는 점인데, 이게 무슨 말이냐면\n뭔가를 지시를 해도 실제로 수행을 하지 않는다는 뜻이다.\n지시를 하면 지시 사항을 기록하다가 사용자가 실제로 값을 요청시 기록된 요청을 최적화 알고리즘을 적용하여 한 번에 실행하기 때문에 효율적으로 동작하게 된다.\n\n### Actions\n\nLazy evaluation 중 실제로 동작을 수행하게 하는 명령이다.\ncount, collect, `reduce`, save 와 같은 명령이 있다.\n\n### Task Scheduler (General DAGs)\n\n![231019-153939](/posts/mid_02/231019-153939.png)\n\nSpark 스케쥴러는 스마트하게 동작하는데 그 특징은 다음과 같다.\n\n1. 파이프라인 함수를 제공한다.\n  Stage 1, Stage 2와 같이 여러 단계를 추상화하여 하나의 단계로 취급해 성능을 최적화 한다.\n2. 감당 가능한 크기의 데이터는 캐싱한다.\n  데이터를 캐싱하여 재사용성을 높이고, 속도도 빠르게 한다.\n3. key값 분포상태를 파악하여 불필요한 shuffle을 피한다.\n  일례로 A &rarr; B로 넘어가며 키 값이 정렬되었으니, B &rarr; F로 넘어갈때는 불필요한 셔플을 하지 않음.\n\n---\n\n## methods (real-code)\n\n<notice>\n  Finding Similar Item까지 본 뒤에 코드를 보는 것이 더 좋습니다.\n</notice>\n\n### (Spark) DataFrame\n\n- `printSchema()`\n  해당 데이터프레임의 스키마를 보여줍니다.\n\n- `take(N)`\n  N개의 행을 보여줍니다.\n\n- `show(n=N, truncate=boolean)`\n  N개의 행을 표 형태로 정리하여 보여줍니다.\n  truncate=False시 ...으로 요약되지 않은 전체 문자열을 출력합니다.\n\n- `select(columnName[])`\n  columnName에 해당하는 column들만 남긴 spark dataframe 객체를 반환합니다.\n\n- `selectExpr(sqlSelect[])`\n  sql select문에서 사용할 수 있는 문법을 이용하여 해당 column을 가져온 뒤 dataframe 객체로 반환합니다.\n\n- `sort(columnName, ascending=boolean)`\n  columnName을 기준으로 오름차순 정렬합니다.\n  ascending=False시 내림차순으로 정렬합니다.\n\n- `join(dataframe, this.column == dataframe.column)`\n  본인(this) dataframe과 인자로 넣은(dataframe) dataframe의 공통 column을 기준으로 natural join을 수행 후 dataframe 객체를 반환합니다.\n  단, 일반 sql과 다르게 공통 column이 하나만 표시되는게 아닌 중복되서 표시됩니다.\n\n- `toPandas()`\n  데이터가 pandas로 옮길 수 있을 만큼 작다면, spark dataframe에서 pandas dataframe으로 변환합니다.\n\n- `groupBy(columnName[])`\n  배열에 들어있는 모든 columnName을 기준으로 그루핑한 후 GroupedData 객체를 반환합니다.\n\n- `rdd`\n  spark dataframe에서 RDD 인스턴스를 생성합니다.\n\n### (spark) GroupedData\n\n- `count()`\n  각 그룹의 행의 개수를 카운트하여 count column을 만들고 dataframe 객체를 반환합니다.\n\n- `agg(column)`\n  column에 대해 집계함수를 수행합니다.\n  아래와 같이 응용하여 사용하면 item을 직렬화할 수 있습니다.\n  alias를 이용해 column의 이름을 변경할 수 있습니다.\n\n  ```python:.py\n  df = orders_joined.groupBy('order_id').agg(collect_set('product_name').alias('items'))\n  df.show()\n  ```\n\n  | order_id | items |\n  |---|---|\n  | 1 | [Bag of Organic B... ] |\n  | 96 | [Roasted Turkey, ... ] |\n  | 112 | [Umcka Elderberry... ] |\n\n### RDD (PipelinedRDD)\n\n- `collect()`\n  RDD를 출력합니다.\n\n- `map(function(row))`\n  RDD에 대해 function를 적용합니다.\n  파라미터로 RDD의 row가 전달됩니다.\n\n  ```python:.py\n  all_locations = jun_29_operations.rdd.map(lambda row: (row.TakeoffLocation, 1))\n  all_locations.take(3) \n  ```\n\n  적용 후 PipelinedRDD 객체를 반환합니다.\n\n  > [('TAKHLI', 1), ('DANANG', 1), ('CONSTELLATION', 1)]\n\n- `flatMap(function)`\n  map과 동일한 기능을 수행합니다.\n  단, 결과가 1차원 배열만을 반환합니다.\n\n  ```python:.py\n  RDDs1 = RDDs1.flatMap(lambda line: line.split(' '))\n  ```\n\n- `reduceByKey(function(number, number))`\n  PipelinedRDD에 대해 function을 적용합니다.\n  파라미터로 2개의 key-value pair에 대해 value가 전달됩니다.\n\n  ```python:.py\n  locations_counts_rdd = all_locations.reduceByKey(lambda a, b: a+b).sortBy(lambda r: -r[1])\n  locations_counts_rdd.take(3)\n  ```\n\n  적용 후 PipelinedRDD 객체를 반환합니다.\n\n  > [('CONSTELLATION', 87), ('TAKHLI', 56), ('KORAT', 55)]\n\n- `sortByKey(ascending=boolean)`\n  RDD key-value pair에 대해 key값을 기준으로 정렬합니다.\n\n- `filter(function)`\n  function이 true를 반환하는 값만 통과시켜 RDD객체를 반환합니다.\n\n### spark instance\n\n- `sql(queryString)`\n  sql문법을 queryString를 실행한 후 spark dataframe 객체를 반환합니다.\n\n- `createDataFrame(RDD)`\n  RDD를 spark dataframe 인스턴스로 변환합니다.\n  단, 인스턴스의 Row에 따라 Column의 이름이 결정됩니다.\n\n  예로 들어 reduceByKey 이후 바로 createDataFrame 생성시 Row의 이름이 작성되지 않아 Column명이 _1, _2와 같은 식으로 초기화됩니다.\n\n  따라서 아래의 코드로 이름을 지정하는 것이 시각화에 도움이 됩니다.\n\n  ```python:.py\n  locations_counts_with_schema = locations_counts_rdd.map(lambda r: Row(TakeoffLocation=r[0], MissionsCount=r[1]))\n  locations_counts = spark.createDataFrame(locations_counts_with_schema)\n  locations_counts.show()\n  ```\n\n- `sparkContext.textFile(path)`\n  path에 해당하는 파일을 읽은 뒤 RDD 인스턴스를 반환합니다.\n\n### FPGrowth\n\n- `FPGrowth(itemsCol=columnName, minSupport=number, minConfidence=number)`\n  dataframe의 columnName에 대해 연관규칙을 생성하는 FPGrowth 인스턴스를 생성합니다.\n  이 때 minSupport, minConfidence를 설정해야 합니다.\n\n- `fit(dataframe)`\n  생성된 FPGrowth 인스턴스에 대해 dataframe을 적용하여 FPGrowthModel을 만듭니다.\n\n- `freqItemsets, associationRules`\n  생성된 FPGrowthModel에 대해 `빈발 항목 집합`과 `연관 규칙`을 생성합니다.\n\n  ```python:.py\n  # grouping with order_id\n  df = orders_joined.groupBy('order_id').agg(collect_set('product_name').alias('items'))\n\n  # change to spark dataframe\n  df = spark.createDataFrame(df.toPandas(), ['id', 'items'])\n\n  # analysis using FP-Growth\n  from pyspark.ml.fpm import FPGrowth\n  fpGrowth = FPGrowth(itemsCol='items', minSupport=0.01, minConfidence=0.5)\n  model = fpGrowth.fit(df)\n\n  num_freqItemsets1 = model.freqItemsets.count()\n  num_associationRules1 = model.associationRules.count()\n  ```","slug":"univ_mmds/mid_02","readingMinutes":10,"wordCount":871},{"title":"분산 파일관리 시스템","description":"분산 파일관리 시스템에 관련한 기초 지식을 배웁니다.","icon":"","image":"","tags":["분산 파일관리","Chunk","Map","Reduce"],"draft":false,"date":"2023-10-19 / 14:13","content":"\n## 분산 파일관리 시스템\n\n방대한 데이터 보관, 또는 백업을 위해 데이터를 분산 저장하는 경우 여러대의 컴퓨터를 연결하여 하나처럼 동작하도록 구성해야 한다.\n\n하지만, 실시간으로 데이터를 처리해야 하는 부분에 대해서는 데이터를 복사하여 네트워크 전송을 통해 처리하는 방식은 네트워크 속도가 상대적으로 매우 느리기 때문에 문제가 있다.\n\n이런 경우에는 데이터를 옮기는 것이 아닌, 필요한 데이터를 보관하는 컴퓨터에게 `연산 작업을 맡기고`, `동기화는 주기적`으로 하는 방식을 사용하는 것이 좋다.\n\n이렇게 데이터를 분산하여 저장하는 시스템을 분산 파일관리 시스템이라 불리고, `Spark`, `MapReduce`와 같은 시스템이 이런 방식을 사용한다.\n하지만, 이런 파일관리 시스템은 1개의 머신만을 사용하는 시스템에 비해 속도가 느리기 때문에 아래의 조건을 만족하는 경우에만 사용하는 것이 바람직하다.\n\n1. 데이터 양이 매우 많은 경우\n2. 데이터의 수정은 왠만하면 일어나지 않는 경우\n3. 읽고 이어쓰기가 빈번하게 일어나는 경우\n\n### Chunk servers\n\n16~64MB 정도의 파일을 하나의 Chunk로 묶어 관리하는데, 이런 청크를 2, 3배 중복으로 다른 물리적 공간에 저장하는 식으로 분산 관리를 하게 되는데,\n이런 다른 물리적 공간을 Chunk server 라고 부른다.\n\n![231019-143146](/posts/mid_01/231019-143146.png)\n\n따라서 여러 청크서버에 동일한 청크가 분산 저장되어 있기 때문에 하나의 청크서버가 다운되더라도 데이터는 온전히 남는다.\n\n또한, 위에서 언급했 듯, 데이터를 움직이는 것이 아닌 연산을 일임한다고 했는데,\n서버의 과부화 방지를 위해 각 청크서버가 특정 청크에 필요한 연산을 전담하여 수행하고 결과를 반환한다.\n\n### Master node\n\n파일이 저장된 위치인 메타데이터를 저장한 서버이다.\n따라서 파일 엑세스 요청이 들어오면, 일단 모든 요청은 마스터 노드로 향하여 요청한 파일이 어느 청크서버에 있는지 알아낸다.\n이후 그 요청에 대한 응답은 청크서버로 직접 엑세스되어 청크서버에서 요청이 처리되게 된다.\n\n여기서 드는 의문점은 **왜 마스터 노드가 직접 데이터를 전달하지 않는가**이다.\n그 이유는 마스터 노드에 엑세스가 제일 많은데 데이터까지 전달하게 되면 과부화가 걸리기 때문에 그렇다.\n\n---\n\n## MapReduce\n\n초창기 분산 컴퓨팅 프로그래밍 모델이다.\n이 기술의 구현체로 Hadoop, Spark, Flink 등이 있는데, 이 모델의 동작 과정을 살펴보자.\n\n### overview\n\n![231019-144045](/posts/mid_01/231019-144045.png)\n\nMap, Group by Key(보통 자동으로 일어남), Reduce의 3단계로 이루어지는데, 각 단계에서 어떻게 일이 처리되는지 알아보자.\n\n참고로 Map, Reduce의 과정은 하나의 머신에서 일어나는 것이 아닌, 다중 머신에서 병렬적으로 일어난다는 점을 기억하자.\n\n### Map\n\n우선 개발자가 Map 함수를 작성한다.\nMap 함수는 읽은 데이터를 처리하기 위해 `key-value pair`로 변환하는 작업을 수행하게 된다.\n\n하지만 MapReduce에서 사용 가능한 규격으로 데이터를 처리해야 하는데 이 과정이 좀 까다로울 수 있다.\n\n추가로 이 이후에 생성된 key값을 이용해서 해싱같은 방식을 이용해 생성된 페어를 Reduce를 수행할 컴퓨터로 보내게 된다.\n\n### Group by Key\n\nMap으로 얻어진 pair을 key값을 중심으로 정렬하고, 중복된 key들에 대해 value 들을 배열로 묶어주는 일을 처리한다.\n대부분의 시스템에서 이 과정은 자동으로 일어나기 때문에 개발자가 개입할 부분이 상대적으로 적다.\n\n하지만 성능적으로 이 단계에서 `병목현상`이 발생할 수 있다.\nMap, Reduce는 파일이나 청크를 한 번만 탐색하면 끝나지만($O(n)$),\nGroup by Key는 정렬 및 그루핑을 해야하기 때문에 상대적으로 느리기 때문이다($O(n log(n))$).\n\n### Reduce\n\n개발자가 개발한 Reduce 함수를 이용해 배열로 되어있는 values들을 하나로 합쳐준다.\n이 과정이 종료되면 유니크한 key-value pairs가 생성될 것이다.\n\n### Dealing with Failures\n\n`Map worker`가 다운된 경우에는 일이 진행 중이든 완료되었든 간에 무조건 다른 worker에게 일을 처음부터 재시작하게 한다.\n왜냐하면 일이 완료된 경우 그 결과를 시간 비용의 문제 때문에 `로컬 디스크`에 데이터를 저장하기 때문이다.\n\n반면에 `Reduce worker`가 다운된 경우에는 일이 진행 중인 경우에만 다른 worker에게 일을 처음부터 재시작하도록 한다.\nReduce일이 완료된 경우, 그 결과는 중요한 데이터이니 `분산 저장`하기 때문에 완료된 경우에 다운되어도 재시작할 필요가 없는 것이다.\n\n### Cost Measure\n\nMapReduce 내부적으로 사용되는 알고리즘의 비용을 측정해보자.\n\n1. Communication cost\n  모든 프로세스의 **I/O bytes**\n> (아래 항목을 모두 더하면 됌)\n> - 입력 파일 사이즈\n> - 2 $\\times$ Map process &rarr; Reduce process 로 이동한 파일 사이즈 (2를 곱한 이유는 Map, Reduce 2개이기 때문)\n> - Reduce process에서 나온 출력 사이즈의 합\n2. Elapsed communication cost\n  Communication cost 중 가장 큰(peak) 비용 (정확히는 파일 사이즈가 가장 큰 입력 파일 기준)\n  &rarr; 이 비용이 작을수록 병렬(분산)화가 잘 되었다는 뜻이다.\n3. (Elapsed) Computation cost\n  1, 2와 동일, 단, 기준이 byte 단위가 아닌 **I/O 시간** 단위 기준임.\n\n<tip>\n  대부분의 클라우드 서비스는 Communication cost 기준으로 비용이 청구됌.\n  (Elapsed는 기준은 아님)\n</tip>\n\n---\n\n## Problems Suited for MapReduce\n\nSpark과 같은 라이브러리 말고 MapReduce만 사용하기에도 충분한 문제들을 알아보자.\n보통 데이터 `순차탐색` 문제나, `비 실시간`으로 처리되어도 상관없는 여유로운 작업에 적합하다.\n\n### Host size\n\nurl로 부터 host를 추출하고, 해당 호스트에서 제공하는 많고 거대한 데이터의 총 크기(용량)을 알고싶을 때 사용할 수 있다.\n\n> (host1, size1)\n> (host2, size2)\n> ...\n\n### Language Model\n\n언어 모델 개발시에도 이용할 수 있다.\n\n> 5개의 단어 뭉치가 문서에서 얼마나 등장하는지\n> (5-word seq, count)\n\n이런 경우도 map, reduce로 간단하게 만들 수 있다.\n\n### join\n\njoin 연산도 MapReduce로 할 수 있다.\n\n![231019-155529](/posts/mid_01/231019-155529.png)\n\n$R(A,B) \\Join S(B,C)$를 `natural join`한다로 해보자.\n\n> `Map`\n> 1. join에 사용될 column을 key로 사용하는 key-value 페어로 만든다.\n>\n>   ($b_1$, ($a_1$, R))\n>   ($b_1$, ($a_2$, R))\n>   ($b_2$, ($a_3$, R))\n>   ($b_3$, ($a_4$, R))\n>   ($b_2$, ($c_1$, S))\n>   ($b_2$, ($c_2$, S))\n>   ($b_3$, ($c_3$, S))\n>\n> 2. 키값을 해싱한 후 Reduce 프로세스로 보낸다.\n\n> `Reduce`\n> 1. Reduce를 진행한다.\n>\n>   ($h(b_1)$, [($a_1$, R), ($a_2$, R)])\n>   ($h(b_2)$, [($a_3$, R), ($c_1$, S), ($c_2$, S)])\n>   ($h(b_3)$, [($a_4$, R), ($c_3$, S)])\n>\n> 2. values에 R-S로 되어있는 value들만 묶어서 (a,b,c)로 출력한다.\n>   (R-R, S-S를 제외하기 위해서 value pair에 R, S를 포함시킨 것이다)\n>\n>   ($a_3$, $b_2$, $c_1$)\n>   ($a_3$, $b_2$, $c_2$)\n>   ($a_4$, $b_3$, $c_3$)\n\n### Not Suited\n\n적합하지 않은 문제상황은 뭐가 있을까?\ngraph 탐색이나, ML에서의 `비 순차탐색` 하는 경우에는 적합치 않다.","slug":"univ_mmds/mid_01","readingMinutes":11,"wordCount":837},{"title":"Filtering in the Frequency Domain","description":"주파수 도메인에서의 필터링에 대해 다뤄봅니다.","icon":"","image":"","tags":["Fourier Transform","Frequency Domain","Highpass","Lowpass"],"draft":false,"date":"2023-10-18 / 21:11","content":"\n## Fourier Transform\n\n푸리에 변환을 간단하게 말하면 시간, 공간 도메인의 주기를 갖는 사인파의 합을 주파수 도메인의 함수로의 변환을 말한다.\n\n<tip>\n  `도메인 간의 관계`\n  <br />\n  ![231018-211849](/posts/mid_06/231018-211849.png)\n  <br />\n  시간 도메인이 길다는 의미는 주파수가 낮다는 뜻이다.\n  따라서 푸리에 변환시 저주파수 영역에서 값이 크게 나타난다.\n  반대의 경우도 마찬가지.\n  <br />\n  [**`전에 헷갈렸던 내용`**](https://wjlee611.github.io/blog/univ_com-vision/mid_02#sampling)으로 다시 돌아가서 보면 이해될 것.\n</tip>\n\n### Property\n\n이제 영상을 푸리에 변환을 통해 주파수 도메인으로 변화를 시킬건데, 그 결과물을 분석하는 법을 알아보자.\n\n![231018-212424](/posts/mid_06/231018-212424.png)\n\nDC, 즉, 원점에 가까워 질 수록 주파수가 낮은 영역, 멀 수록 주파수가 높은 영역을 나타내는데,\n영상에서의 주파수는 변화율이라고 보면 된다.\n즉, 주파수가 크다 라는 의미는 영상이 변화하는 부분이 많다는 뜻이다.\n\n![231018-213206](/posts/mid_06/231018-213206.png)\n\n이 변환결과를 보고 이해해보자.\n\n우선 주파수 데이터를 보면 먼 곳이 어둡다.\n즉 영상 전체적으로 확확 변하는 부분이 적다는 뜻이다.\n\n그런데 X 모양으로는 밝은 것을 볼 수 있다.\n이 뜻은 해당 방향과 수직한 방향으로 변화가 많다는 것을 의미한다.\n실제로 원본 영상을 보면 같은 방향으로 홈도 파져있고, 변화가 많은 모습을 확인할 수 있다.\n\n그리고 미세하게 세로 방향으로 점선과 같은 무늬가 있다.\n이는 원본 영상에서 가로 방향으로 긴 무언가가 변화가 큼을 의미한다.\n실제로 원본 영상에는 가로로 흰 실같은 무언가가 있다.\n\n마지막으로 주파스 데이터 전체적으로 노이즈가 있다.\n이는 원본 영상에서도 노이즈가 있다는 뜻이다.\n\n---\n\n## Frequency Domain Filtering\n\n이제 푸리에 변환을 이용해서 주파수 도메인으로 변환된 영상을 이용한 필터링을 해보자.\n\n이 것이 가능한 이유는 LTI System 이기에 가능한 것이다.\nLTI System과 푸리에 변환을 이용한 연산의 단순화에 대한 내용은 [**`여기`**](https://wjlee611.github.io/blog/univ_com-vision/mid_02)에서 확인하자.\n\n![231018-214840](/posts/mid_06/231018-214840.png)\n\n앞으로 살펴볼 필터링에 대해 이 영상과 주파수 영상을 사용할 예정이다.\n여기서 주파수 영상의 얇은 흰 원 부분은 무시하자.\n일종의 $D_0$로 반지름을 나타내는 것인데, 원본 영상을 푸리에 변환 할 경우에는 나오지 않는다.\n\n### Ideal Lowpass Filter\n\n![231018-214145](/posts/mid_06/231018-214145.png)\n\n원본 영상을 푸리에 변환을 하고, 그 주파수 영상에 대해 위 사진의 흰색 영역만 살리고 나머지는 검게 만든 후 다시 역 푸리에 변환을 해볼 것이다.\n이 때, 위의 흰색 영역을 보면 낮은 주파수 영역만을 통과시킴을 알 수 있다.\n즉, 고주파수 영역, 변화량이 많은 영역을 없앤다는 뜻인데, 변화량이 많은 영역을 없앤다?\n즉, 영상을 뿌옇게 만들어 변화량이 적어지도록 하겠다는 의미이다.\n\n정리하면 Lowpass filter를 통과시키면 영상 전반적으로 Smoothing filter처리를 한 결과를 얻을 수 있다.\n\n해당 주파수 필터는 다음과 같이 정의할 수 있는데,\n\n$$\nH(u,v) = \\left\\{\\begin{matrix}\n1 \\;\\; if \\;\\; D(u,v) \\leq D_0 \\\\\n0 \\;\\; if \\;\\; D(u,v) > D_0 \n\\end{matrix}\\right.\n$$\n\n이렇게 이상적으로 0과 1이 나뉘는 필터를 Ideal Lowpass filter라고 부른다.\n\n![231018-215052](/posts/mid_06/231018-215052.png)\n\n상단부터 지그재그 모양으로 $D_0$가 5, 15, 30, 80, 230 값으로 통과시키는 주파수 대역을 점점 늘린 변환 결과이다.\n\n$D_0$ = 5, 즉 매우 낮은 주파수를 갖는 대역만 통과시킨 영상은 영상이 매우 Smoothing 처리된 것을 확인할 수 있다.\n이게 무슨 의미냐면 그정도의 낮은 변화율로는 원본 영상의 가파른 변화를 표현하지 못하고,\n변환된 영상 정도의 완만한 변화율만 표현 가능하다는 뜻이다.\n\n따라서 $D_0$의 값을 키울수록 높은 변화도 표현 가능해져 점점 영상이 선명해지는 것을 볼 수 있다.\n다르게 말하면 **$D_0$ 값이 클수록 필터링 강도가 약해진다**.\n\n이때 주의깊게 볼 점은 변환된 영상에서 뭔가 일렁이는 듯한 노이즈가 생겼다는 점이다.\n왜 이런게 생긴걸까?\n\n바로 Ideal filter 특성 때문에 고주파수 영역을 깔끔하게 날려버렸기 때문에 세밀한 변화를 묘사하지 못해 화질이 떨어진 것이다.\n이를 개선할 수 없을까?\n\n### Butterworth Lowpass Filter\n\n\\'가능.\\' 당연히 개선할 수 있다.\n주파수 영역을 필터링할 때 적절하게 고주파수 영역을 통과시킨다면 화질 개선이 가능한데, 그 방법이 Butterworth 방식이다.\n\n![231018-215943](/posts/mid_06/231018-215943.png)\n\n약간의 곡률을 추가함으로서 일부 고주파수 영역을 통과시킨다.\n이 그래프를 구현하는 식은 다음과 같이 생겼다.\n\n$$\nH(u,v) = \\frac{1}{1+[D(u,v) / D_0]^{2n}}\n$$\n\n실제로 개선이 되었을까?\n\n![231018-220523](/posts/mid_06/231018-220523.png)\n\nSmoothing 효과는 살짝 약해졌지만, 확실이 울렁이는 듯한 노이즈는 제거되었다.\n약간의 화질 개선이 이루어 진 것이다.\n\n### Gaussian Lowpass Filter\n\n![231018-220657](/posts/mid_06/231018-220657.png)\n\n$$\nH(u,v) = e^{-D^2(u,v)/2D_0^2}\n$$\n\n위에 두 필터보다 성능이 좋은 가우시안 필터도 있다.\n그런데 Butterworth와 육안으로 구별되는 정도는 아니다.\n\n---\n\n### Highpass Filter\n\nLowpass는 영상을 뿌옇게 만들었는데, 반대로 Highpass는?\n그렇다. 영상을 더 샤프하게 만든다.\n정확하게 말하면 변화가 큰 부분만을 남기기에 Laplacian filter와 유사한 기능을 수행한다.\n\n![231018-221102](/posts/mid_06/231018-221102.png)\n\n위에서 부터 차례대로 Ideal, Butterworth, Gaussian Highpass Filter이다.\n함수를 구하는 방법은 그저 1에서 Lowpass 함수를 빼주면 된다.\n(Butterworth의 경우에는 $D$(분모) 와 $D_0$(분자)의 위치를 변환하면 된다)\n\n![231018-221329](/posts/mid_06/231018-221329.png)\n\nIdeal Highpass의 결과이다.\n역시 $D_0$값을 키울수록 필터의 강도가 약해진다.\n그렇기에 노이즈 역시 줄어든다.\n\n![231018-221426](/posts/mid_06/231018-221426.png)\n\n같은 필터 강도의 결과이다. 왼쪽부터 차례대로 Ideal, Butterworth, Gaussian Highpass이다.\n이번엔 Butterworth와 Gaussian도 육안으로 차이가 난다.\n여기서도 마찬가지로 Gaussian filter가 노이즈가 없고 깔끔하다.","slug":"univ_com-vision/mid_06","readingMinutes":9,"wordCount":672},{"title":"Filtering and Convolution","description":"Filtering 과 Convolution 의 동작방식과 차이를 다뤄봅니다.","icon":"","image":"","tags":["Kernel","Filtering","Convolution"],"draft":false,"date":"2023-10-17 / 21:51","content":"\n## Kernel\n\nFiltering과 Convolution에 적용할 데이터를 Kernel 이라고 부른다.\n즉, 원본 영상에 어떤 커널을 Filtering 혹은 Convolution 하느냐에 따라 다른 출력물이 나오는 것이다.\n\n커널에 적용방식은 뒤에 Filtering과 Convolution에서 다룰 예정이니 참고만 하고 나중에 다시오자.\n\n### Moving Average (Smoothing)\n\n가로, 세로가 N인 배열의 원소가 모두 $1/N^2$ 로 채워진 커널이다.\n이 커널을 적용하면 이미지가 뿌옇게 변하게 된다.\n\n### Laplacian\n\n3$\\times$3 배열에 중심이 -4, 상하좌우가 1, 나머지가 0으로 채워진 커널이다.\n이 커널을 적용하면 이미지 주변부가 강조되고, 중심부는 약화된다.\n\nLaplacian을 적용한 필터를 원본 이미지에서 빼는 방식으로 Sharping Filter를 구현할 수 있다.\n\n### Shift\n\n중심으로부터 n만큼 떨어진 거리에 1, 나머지는 0으로 채우면 Filtering의 경우 해당 방향의 반대 방향으로 영상이 이동한다.\n예로 들어 3$\\times$3 배열 중 가운데 왼쪽만 1, 나머지는 0인 커널로 영상을 Filtering시 영상은 오른쪽으로 1픽셀 Shift된다.\n\n---\n\n## Filtering\n\n![231017-225146](/posts/mid_05/231017-225146.png)\n\n영상의 주변부의 값을 이용해 변형시키는 과정을 필터링이라고 한다.\n필터링 과정은 [**`LTI System`**](https://wjlee611.github.io/blog/univ_com-vision/mid_02#lti-system)에서 이루어진다.\n\n이 필터링은 크게 Correlation Filtering (just Filtering)과 Convolution Filtering (just Convolution)으로 나뉘게 되는데,\n두 방식의 차이를 비교해보며 위에서 소개한 두 커널을 적용하면 이미지가 어떤식으로 바뀌는지 알아보자.\n\n### Filtering (Correlation)\n\n$$\ng(m,n) = f(m,n) * h(m,n) \\\\\n= \\sum_{k=m-a}^{m+a}\\sum_{l=n-a}^{n+a}f[k,l]\\times h[m-k,n-l]\n$$\n\n필터링은 `커널의 변형이 없이` 연산된다.\n\n위 수식을 보면 픽셀별로 주변 $a$만큼의 픽셀의 값을 참고하여 연산이 진행됨을 알 수 있는데, 이를 아래 그림으로 살펴보자.\n이 때 사용한 커널은 위에서 언급한 `Moving Average` 커널이다.\n\n![filtering_gif](/posts/mid_05/moving_average_filtering.gif)\n\n위 영상은 커널사이즈가 3$\\times$3 ($a=1$)인 Moving Average Kernel을 Filtering 한 결과이다.\n전반적으로 화면이 뿌옇게 변하는 영상을 얻을 수 있다.  \n\n### Convolution\n\n$$\ng(m,n) = f(m,n) * h(m,n) \\\\\n= \\sum_{k=m-a}^{m+a}\\sum_{l=n-a}^{n+a}f[k,l]\\times h[n-k,m-l]\n$$\n\n자세히 보면 h의 **m, n**의 위치가 Filtering과 `반대`이다.\n즉, 컨볼루전은 `커널이 대각선 반전`되어 연산된다.\n\n![231018-204207](/posts/mid_05/231018-204207.png)\n\n좌상단은 원본 영상, 우상단은 그 원본 영상에 Laplacian 커널을 Convolution한 결과이다.\n좌상단 영상에서 우상단 영상을 빼면 좌하단과 같이 영상의 윤곽선이 선명해지는 Sharping Filter를 구현할 수 있다.\n그런데 이게 어떻게 가능한걸까?\n\n이걸 가능케 하기 위해선 우선 사람이 빛을 인지할 때 그 민감도를 인지하는 법을 알아야 한다.\n\n![231018-204430](/posts/mid_05/231018-204430.png)\n\n사람이 밝은 빛을 보다가 어두운 빛을 보면은 원색보다 더 어둡게 느끼고,\n어두운 빛을 보다가 밝은 빛을 보면은 원색보다 더 밝게 느끼는 현상이 발생하는데, 이를 이용하는 것이다.\n\n구현할 때 빛의 밝기 `변화`에 초점을 맞춰보자.\n변화, 즉, 미분을 이용하는 것이다.\n\n> 밝아진다 &rarr; 기울기가 양의 기울기 &rarr; 기울기가 증가함\n\n그림으로 살펴보자.\n\n![231018-204831](/posts/mid_05/231018-204831.png)\n\n밝기가 감소하기 시작하는 부분의 밝기는 높여주고, 감소가 끝나는 부분의 밝기는 높여주면 선명해지는 효과가 있다.\n그런데 2번 미분한 값을 보자.\n우리가 원하는 변화량과 정확히 반대의 값을 갖는다.\n\n즉, `2차 미분값을 원본 영상에서 빼주면`, 우리가 원하는 Sharping Filter를 구현할 수 있다.\n\n그런데 영상처리에서 미분계산이 너무 코스트가 크지 않을까 걱정이 된다.\n\n$$\nf'(x) = \\frac{df}{dx} = \\frac{f(x + \\Delta x) - f(x)}{x + \\Delta x - x}\n$$\n\n하지만, 실제로 그렇지 않다.\n디지털에서 영상 처리를 할 때는 Quantization를 했기 때문에 $\\Delta x$의 매우 작은 값은 1이 된다.\n따라서 다음과 같은 식으로 정리된다.\n\n$$\n\\frac{df}{dx} = f(x + 1) - f(x) \\\\\n{} \\\\\n\\frac{d^2f}{dx^2} = f(x + 1) - 2f(x) + f(x - 1) \n$$\n\n이 값은 사실 각각 `h[0, -1, 1]` / `h[1, -2, 1]`의 컨볼루전과 같다.\n따라서 1차원 영상의 경우에는 영상에 `h[1, -2, 1]` 커널을 컨볼루전 하면 된다.\n\n2차원은 위 방식을 편미분을 사용하여 비슷한 방식으로 진행하면 된다.\n`x에 대한 편미분` + `y에 대한 편미분` 값을 더하면 다음과 같은 3 $\\times$ 3 배열이 나오는데, 이 배열을 컨볼루전하면 원하는 Laplacian Filter를 구현할 수 있다.\n\n![231018-210553](/posts/mid_05/231018-210553.png)\n\n## Boundary (Edge)\n\nFiltering 부분에서 gif영상으로 봤을 때 가장자리는 데이터를 채워주지 못했다.\n그 이유는 커널 중심을 가장자리 영역으로 잡았을 때, 영상 외부의 값을 참조해야 값을 계산해야 하기 때문이다.\n\n이런 부분에 대한 해결책으로 간단하게 3가지만 알아보자.\n\n![231018-210916](/posts/mid_05/231018-210916.png)\n\n`zero padding` 방식은 없는 영상 영역을 0으로 채우고 하는 간단한 기법이다.\n\n`boundary value repetition`은 최외각 픽셀의 데이터를 반복하여 채우는 간단한 기법이다.\n\n`mirroring`은 마치 거울이 있는것 처럼 픽셀값을 반사하여 채우는 기법이다.","slug":"univ_com-vision/mid_05","readingMinutes":8,"wordCount":594},{"title":"Color Image","description":"색상과 관련된 용어와 변환을 다뤄봅니다.","icon":"","image":"","tags":["RGB","HSI"],"draft":false,"date":"2023-10-16 / 23:05","content":"\n## Color\n\n![231017-141752](/posts/mid_04/231017-141752.png)\n\n하얀색 빛은 RGB 색상의 빛을 모두 합칠 때 나타난다는 건 많이들 알고있을 것이다.\n하지만, 빛의 삼원색과 색상의 합을 두고는 의문이 든다.\n왜 마젠타와 노란색을 섞으면 밝아지는 것이 아닌 어두워지는 걸까.. 하고.\n\n색상이 보인다 라는 것은 사물이 `해당 색상의 빛을 반사`하고 `나머지 색상의 빛을 흡수`하기 때문이다.\n마젠타는 RB의 빛의 혼합이다. 즉 Green 색을 흡수한다는 뜻이다.\n노랑은 RG의 빛의 혼합이다. 즉 Blue 색을 흡수한다는 뜻이다.\n따라서 마젠타와 노랑을 섞은 색은 Green, Blue 색을 흡수한다는 뜻이니 R만 반사할 것이다.\n그렇기에 밝아지는게 아닌 어두워져서 Red 색상을 띄게 되는 것이다.\n\n### RGB Model\n\n![231017-142916](/posts/mid_04/231017-142916.png)\n\nRGB 모델은 아주 익숙한 색상 모델이다.\n빛의 삼원색인 Red, Green, Blue 색상의 빛의 밝기로 색상을 표현한다.\n\n### HSI Model\n\n![231017-143217](/posts/mid_04/231017-143217.png)\n\nHSI 모델은 생소하지만, 활용성이 뛰어난 색상 모델이다.\nHue, Saturation, Intensity의 3요소로 색상을 표현한다.\n\n`Hue`는 색상을 표현하는 각도로 `색조` 라고도 부른다.\n0$\\degree$는 Red, 180$\\degree$는 Cyan 등 각도 하나만으로 모든 색상을 나타내게 된다.\n\n`Saturation`은 색상의 포함 정도로 `채도` 라고도 부른다.\nSaturation값이 클수록 색상을 많이 함유하고 있다는 뜻이다.\n따라서 Saturation이 0이 되면 색상이 존재하지 않는, Gray 색상이 되어버린다.\n\n`Intensity`는 빛의 세기를 표현하는 정도로 `강도` 라도도 부른다.\nIntensity값이 클수록 빛이 강하다는 뜻이니 흰색에 가까워진다.\n\n### RGB vs HSI\n\n두 모델간의 가장 큰 차이라면 '빛의 밝기가 색상에 영향을 주는 가' 이다.\n\nRGB는 각 채널을 같은 비율로 늘리고 줄이는 방식으로 빛의 밝기를 조절한다.\n따라서 빛의 밝기가 변하면 다른 색상이라고 취급된다.\n\n하지만 HSI는 빛의 밝기를 I채널에서 관리한다.\n따라서 빛의 밝기가 변해도 같은 색상으로 취급된다. (정확히는 H, S값이 변하지 않는다)\n\n두 모델간 차이를 확인하기 위한 이미지이니 참고하자.\n\n![231017-211125](/posts/mid_04/231017-211125.png)\n\n---\n\n## Pseudocolor Image Processing\n\n흑백 데이터를 사람이 보기 쉽게 컬러로 대응시키는 과정을 의미한다.\n\n### Intensity Slicing\n\n![231017-211341](/posts/mid_04/231017-211341.png)\n\nIntensity 값을 기준으로 다르게 색상일 입히는 방식이다.\nSlicing plane을 여러개 두면 여러 색상으로 여러 범위의 색상을 입힐 수도 있다.\n\n![231017-211515](/posts/mid_04/231017-211515.png)\n\n---\n\n## Color Transformations\n\n기본적으로 앞서 배웠던 영상 변환과 같은 공식을 사용해서 변환한다.\n\n$$\ng(x,y) = T[f(x,y)]\n$$\n\n하지만 수식적인 부분은 뒤로 미뤄두고 어떤 채널을 어떻게 변화하면 영상이 어떻게 변화하는지를 중점적으로 알아보자.\n\n### Intensity\n\n![231017-212214](/posts/mid_04/231017-212214.png)\n\n위 영상은 Intensity만 30% 줄인 영상이다.\n\n![231017-212235](/posts/mid_04/231017-212235.png)\n\n그 결과 RGB 모델은 모든 채널이 30% 감소했지만,\nHSI 모델은 I 채널만 30% 감소한 모습을 볼 수 있다.\n\n### Color Complements\n\n![231017-212435](/posts/mid_04/231017-212435.png)\n\n위 영상은 보색으로 색상을 반전시킨 영상이다.\n그 결과 RGB 모델은 각 색상 채널이 상하반전된 모습을 취하게 되었다.\n\nHSI 모델은 색상이 반전되었기에,\nHue는 180$\\degree$만큼 shift된 모습의 그래프를 보이게 되었고, Intensity 역시 반전되었다.\n하지만, S는 역시 변화가 없다.\n\n---\n\n## Tone and Color Correction\n\n이번엔 색상과 밝기 등을 수정하면서 어떻게 하면 영상을 보기좋게 만들 수 있는지 알아보자.\n\n![231017-214520](/posts/mid_04/231017-214520.png)\n\nRGB 채널에 ease 커브를 줄 경우 어두운 부분은 더 어둡게, 밝은 부분은 더 밝게 만들 수 있다.\n하지만 역시 밝기만 건드렸기 때문에 H, S값의 변화는 없다.\n\n![231017-214624](/posts/mid_04/231017-214624.png)\n\n전체적으로 너무 밝은 영상의 경우에는 곡률을 아래로 주게 될 경우\n영상 톤을 전체적으로 어둡게 바꿀 수 있다.\n\n![231017-214711](/posts/mid_04/231017-214711.png)\n\n반대의 경우도 가능하다.\n\n![231017-215001](/posts/mid_04/231017-215001.png)\n\n색상별로 톤 변화를 줄 수 있다.\n이 경우 색상도 바뀐다.\n\n본인 기준 특이하다고 생각되었던건 특정 색상을 어둡게 커브를 줬더니 영상에서는 오히려 해당 색이 많이 보이도록 조정되었다는 점이 인상적이었다.\n\n---\n\n## Color Slicing\n\n특정 색상영역을 추출하는 기법이다.\n예로들어 피부색을 추출하고 싶다면, 피부색과 오차범위에 해당하는 색상만을 선택하여 남기는 작업을 수행하게 된다.\n\n특정 영역을 선별하는 공식은 아래 2가지 방법이 있다.\n\n$$\ns_i = \\left\\{\\begin{matrix}\n0.5 \\;\\; if[|r_j-a_j| > \\frac{W}{2}]_{any \\; 1 \\leq j \\leq n} \\\\\nr_i \\;\\; otherwise\n\\end{matrix}\\right.\n$$\n\nRGB 3채널을 기준으로($n=3$) 픽셀의 색상($r_j$)과 기준값($a_j$)의 차이가 오차범위($W/2$)보다 크면 0.5로 세팅하고,\n오차범위 내부, 즉, 추출하고자 하는 색상 영역이면 원색상을 유지한다.\n\n이 때, 허용범위는 RGB 스페이스에서 `정육면체` 모양으로 구성되게 된다.\n따라서 실제 원했던 색상영역보다 약간 더(꼭짓점 부분) 색상을 포함할 수 있다.\n\n<br />\n\n$$\ns_i = \\left\\{\\begin{matrix}\n0.5 \\;\\; if\\sum_{j=1}^{n}(r_j-a_j)^2 > R_0^2, \\\\\nr_i \\;\\; otherwise\n\\end{matrix}\\right.\n$$\n\nRGB 3채널을 기준으로($n=3$) 픽셀의 색상($r_j$)과 기준값($a_j$)의 차이가 오차범위($R_0$)보다 크면 0.5로 세팅하고,\n오차범위 내부, 즉, 추출하고자 하는 색상 영역이면 원색상을 유지한다.\n\n이 때, 허용범위는 RGB 스페이스에서 `구` 모양으로 구성되게 된다.\n따라서 실제 원했던 색상영역을 정확하게 표현할 수 있다.\n\n![231017-214142](/posts/mid_04/231017-214142.png)\n\n왼쪽은 첫번째 방법으로, 오른쪽은 두번째 방법으로 Slicing한 영상이다.\n더 나아보이는 방식으로 취사선택하면 될 거 같다.","slug":"univ_com-vision/mid_04","readingMinutes":9,"wordCount":638},{"title":"Intensity Transformations","description":"이미지 밝기 변환에 대한 내용을 다뤄봅니다.","icon":"","image":"","tags":["Transform Function","Histogram","Equalization"],"draft":false,"date":"2023-10-16 / 21:09","content":"\n## Transform Functions\n\n입력 영상에 대해 밝기값(에너지 레벨)의 변화를 가하고 싶다면 단순히 픽셀값의 데이터에 변화를 가하면 된다.\n\n$$\ns = T(r)\n$$\n\n하지만, 특정 데이터를 어떻게 변화시키는지에 따라 출력 영상이 달라지고, 거기에서 얻을 수 있는 정보도 달라진다.\n그 데이터를 변화시키는 기준인 변환 함수의 종류와, 그 결과를 알아보자.\n\n<notice>\n  얻을 수 있는 정보가 달라진다는 표현을 사용했는데,\n  **강조**하고싶은 정보가 달라진다는 것이지 **실제** 정보량 자체는 변하지 않는다.\n  물론 임의로 특정 밝기 영역을 0으로 만든다면 정보량이 줄어들 수는 있다.\n  하지만 **물리적인 정보량은 절대 늘어나지 않는다**. (사람 눈에 보기 편하게 바꿀 뿐)\n</notice>\n\n### Basic\n\n![231016-212632](/posts/mid_03/231016-212632.png)\n\n이제부터 그래프를 해석하는 능력이 중요해진다.\n예로 들어 `Log` 함수를 변환 함수로 선택한다면 `전반적으로 영상이 밝아짐`을 알 수 있어야 한다.\n$y=-x$ 형태의 `Negative` 함수를 선택한다면 영상 명암이 아래와같이 `반전`될 것이다.\n\n![231016-213010](/posts/mid_03/231016-213010.png)\n\n### Power-Law (Gamma)\n\n위의 기본 함수로는 세부적으로 변화시키기 힘들것이다.\n하지만 아래의 함수를 이용하면 상수값($\\gamma$)를 변화시켜 변환을 세부적으로 처리할 수 있게된다.\n\n$$\ns = cr^\\gamma\n$$\n\n감마값이 커질수록 변환된 영상이 어두워지는 특징이 있다.\n\n![231016-213224](/posts/mid_03/231016-213224.png)\n\n감마 함수는 Gamma correction에 자주 사용되곤 하는데,\n이게 뭐냐면, 출력 장치의 빛의 세기를 조정해 원본 영상과 같은 영상을 디스플레이 할 수 있도록 하는 과정이다.\n\n![231016-213529](/posts/mid_03/231016-213529.png)\n\n### Piecewise-Linear\n\n선형 커브를 여러 범위로 쪼갠 함수로\n특정 범위의 값을 확장하거나, 임의의 값으로 변경할 때 사용한다.\n\n![231016-214238](/posts/mid_03/231016-214238.png)\n\n함수가 좌상단과 같이 주어질 경우 우상단의 이미지가 좌하단의 이미지처럼 변환된다.\n특정 범위의 값을 확장시켜 비슷한 레벨의 빛을 분산시켜 차이를 만든 것이다.\n\n$\\overline{(r_1,s_1)(r_2,s_2)}$의 기울기를 수직으로 만들면 `Threshold` 함수라고 불리우게 되는데,\n그렇게 되면 특정 범위 이하의 빛은 검은색, 이상의 빛은 흰색으로 이분된다.\n\n이러한 처리 기법을 `Contrast Stretching` 라고 부른다.\n\n![231016-214728](/posts/mid_03/231016-214728.png)\n\n이렇게 함수가 주어진 경우에는 영상이 다음과 같이 변환된다.\n\n![231016-214753](/posts/mid_03/231016-214753.png)\n\n특정 부분을 제외한 나머지 영역을 죽이거나, 특정 부분만을 강조할 때 사용하는데,\n이런 처리 기법을 `Intensity-Level Slicing` 라고 부른다.\n\n---\n\n## Histogram Processing\n\n<tip>\n  `Histogram`\n  데이터의 분포를 한 눈에 볼 수 있는 그림 혹은 그래프\n</tip>\n\n영상의 에너지 레벨 분포를 알고싶다면 다음과 같은 과정으로 구할 수 있다.\n\n$$\nh(r_k) = n_k\n$$\n\n여기서 $r_k$는 k번째 gray level(에너지 레벨 0~255)를 나타내고,\n$n_k$는 그 에너리 레벨을 갖는 픽셀의 개수를 의미한다.\n코드로 구현한다면 다음과 같이 구현할 수도 있을것이다.\n\n```cpp:.cpp\nunsigned int Histogram[256] = {0};\n\nfor (h=0; h<H; h++) {\n  for (w=0; w<W; w++) {\n    Histogram[img[w][h]]++;\n  }\n}\n```\n\n하지만 단순 픽셀 수를 세기만 한다면, 매우 큰 영상의 경우 평균적인 빛의 밝기가 어두움에도 값이 크게 나오는 문제가 발생할 수 있다.\n따라서 영상 크기에 따라 자료해석의 차이를 없애도록 영상 크기로 나누어 확률로서 일반화하게 된다.\n\n$$\np(r_k) = \\frac{n_k}{WH}\n$$\n\n이걸 왜 하는건지 알아보기 전에 우선 서로 다른 영상별로 수집된 히스토그램을 살펴보자.\n\n![231016-220848](/posts/mid_03/231016-220848.png)\n\n히스토그램의 분포를 살펴보면 모든 영역에 골고루 분배된 영상이 가장 보기 좋음을 알 수 있다.\n그렇다면 히스토그램 분포를 분산시키는게 영상 품질 개선에 도움이 된다는 것을 알게 되었다.\n\n### Equalization\n\n그렇다면 히스토그램 분포를 골고루 분배할 수 있을까?\n\n![231016-221610](/posts/mid_03/231016-221610.png)\n\n결론부터 말하면 이렇게 이상적으로 분배는 불가능하다.\n0이었던 데이터를 0과 1로 적절히 분산하는 방법이 없기 때문이다.\n\n![231016-222414](/posts/mid_03/231016-222414.png)\n\n이렇게 구현하는 것이 최선일 것이다.\n\n구현에 있어 중요한 점은 **일정 범위 내**의 변환 전과 변환 후의 `확률 분포는 같아야 한다`는 점이다.\n예로 들어 변환 전의 범위 `0~1`은 변환 후의 범위 `0~3`으로 대응되는데, `각 구간의 확률의 합은 동일`함을 알 수 있다.\n이 사실을 식으로 일반화 하면 다음과 같아진다.\n\n$$\n\\sum_{i=0}^{r}p_r(i) = \\sum_{i=0}^{s}p_s(i)\n$$\n\n이를 연속적인 값으로 표현하기 위해 적분식으로 변환하면 다음과 같아진다.\n\n$$\n\\int_{0}^{r}p_r(w)dw = \\int_{0}^{s}p_s(w)dw\n$$\n\n여기서 다시 상기해보자면 $p_r$은 원본 히스토그램 분포(확률 함수)이고, $p_s$는 목표로 하는 히스토그램 분포이다.\n이상적인 확률 함수는 다음 그림과 같을 것이다.\n\n![231016-222950](/posts/mid_03/231016-222950.png)\n\n해당 함수는 $p_s = \\frac{1}{L-1}$ 로 표현 가능한데 이를 위의 적분식에 대입하면 다음과 같이 정리할 수 있다.\n\n$$\n\\int_{0}^{r}p_r(w)dw = \\int_{0}^{s}p_s(w)dw = \\int_{0}^{s}\\frac{1}{L-1}dw = \\frac{s}{L-1} \\\\\n{} \\\\\ns = T(r) = (L-1)\\int_{0}^{r}p_r(w)dw\n$$\n\n이제 이 공식을 이용해서 프로그래밍하기 위해 다시 불연속적인 값의 합으로 바꿔보자.\n\n$$\ns_k = T(r_k) = (L-1)\\sum_{j=0}^{k}p_r(r_j)\n$$\n($k$는 일정 범위에 해당하는 x축의 값이다.)\n\n이 때, $p_r(r_j)$는 위에서 히스토그램의 확률로서 일반화 한 식을 대입하면 된다.\n즉 최종 변환식은 다음과 같다.\n\n$$\ns_k = T(r_k) = \\frac{L-1}{MN}\\sum_{j=0}^{k}n_j \\; , \\;\\; k=0, 1, ..., L-1\n$$\n\n아래 표를 기준으로 연습을 해보자.\n\n| $r_k$ | $n_k$ | $p_r(r_k) = n_k/MN$ | s_k\n|---|---|---|---|\n| $r_0$ = 0 | 790 | 0.19 | $s_0$ = 1.33 &rarr; 1 |\n| $r_1$ = 1 | 1023 | 0.25 | $s_1$ = 3.08 &rarr; 3 |\n| $r_2$ = 2 | 850 | 0.21 | $s_2$ = 4.55 &rarr; 5 |\n| $r_3$ = 3 | 656 | 0.16 | $s_3$ = 5.67 &rarr; 6 |\n| $r_4$ = 4 | 329 | 0.08 | $s_4$ = 6.23 &rarr; 6 |\n| $r_5$ = 5 | 245 | 0.06 | $s_5$ = 6.65 &rarr; 7 |\n| $r_6$ = 6 | 122 | 0.03 | $s_6$ = 6.86 &rarr; 7 |\n| $r_7$ = 7 | 81 | 0.02 | $s_7$ = 7.00 &rarr; 7 |\n$L=8$\n\n$$\ns_0 = T(r_0) = (8-1)\\sum_{j=0}^{0}p_r(r_j) = 7 \\times 0.19 = 1.33 \\\\\ns_1 = T(r_1) = (8-1)\\sum_{j=0}^{1}p_r(r_j) = 7 \\times (0.19 + 0.25) = 3.08 \\\\\n$$\n\n즉, $s_0$가 1이기 때문에, $r_0$(0)에 존재하던 에너지 레벨을 1로 올리고,\n$s_1$가 3이기 때문에, $r_0$(1)에 존재하던 에너지 레벨을 3로 올리는 과정을 거치면 Equalization을 달성할 수 있다.\n\n이련 변환의 경우 히스토그램과 $T(r)$의 그래프는 다음과 같은 모양을 갖게 된다.\n\n![231016-225134](/posts/mid_03/231016-225134.png)\n\n이런 경우 Equalization을 진행한 영상은 원본 영상에 비해 물리적인 정보량은 줄어들게 된다.\n하지만, 사람의 눈으로 보기에는 더 보기 좋은 영상이 된다.\n\n서로 다른 영상에 대해 Equalization을 적용한 예시와 그 $T(r)$ 함수를 살펴보자.\n\n![231016-225624](/posts/mid_03/231016-225624.png)\n![231016-225636](/posts/mid_03/231016-225636.png)\n\n여기서 알 수 있는 점은 원본의 히스토그램 분포가 빽빽하게 모여있을 수록 변환된 영상의 히스토그램 분포에 빈공간이 많이 생긴다는 것이다. (정보량의 손실이 많아진다)\n\n### Specification\n\n하지만 히스토그램을 이용한 Equalization이 만능인 것은 아니다.\n\n![231016-225928](/posts/mid_03/231016-225928.png)\n\n이런 영상처럼 너무 극단으로 몰린 경우에 적용한 결과는 다음과 같이 나올 수 있는데,\n\n![231016-230011](/posts/mid_03/231016-230011.png)\n\n이런 경우에는 단순히 $p_s = \\frac{1}{L-1}$ 를 사용하여 변환 함수를 구하는 것 보다,\n사용자 정의 함수 $p_z$를 만들어서 처리하는게 더 좋은 영상을 만들 수 있다.\n\n![231016-230350](/posts/mid_03/231016-230350.png)","slug":"univ_com-vision/mid_03","readingMinutes":11,"wordCount":936},{"title":"Singal Processing Fundamentals","description":"신호 처리에 대한 기초적인 정보입니다.","icon":"","image":"","tags":["LTI System","Convolution","Fourier Transform"],"draft":false,"date":"2023-10-15 / 21:57","content":"\n## LTI System\n\nLinear Time Invariant System은 다음과 같은 성질을 갖는다.\n\n1. Linear\n  선형성을 유지한다.\n\n  <tip>\n    `선형성`\n\n    $$\n    H[a_if_i(x,y) + a_jf_j(x,y)] \\\\\n    = a_iH[f_i(x,y)] + a_jH[f_j(x,y)] \\\\\n    = a_ig_i(x,y) + a_jg_j(x,y)\n    $$\n  </tip>\n\n2. Time Invariant\n  시간에 대해 불변성을 갖는다.\n  즉, 시간이 변해도 delay만 있을 뿐, 동일한 input에 대해 동일한 output을 내보낸다.\n\n### System Response\n\n신호 처리를 위해 신호를 디지털화 한 다음 변환(filter)을 가해서 다시 연속적인 신호로 변환하기 위한 과정을 살펴보자.\n\n![231015-222017](/posts/mid_02/231015-222017.png)\n\n우선 신호를 특정 구간에서 일정한 값으로 근사한다.\n그리고 특정 구간에 대해 근사된 데이터에 변환(filter)를 가한다. \n(참고로 filtering에 대해선 추후에 소개할 예정. 지금은 LTI System을 이용해서 신호를 변환하는 과정만 살펴보자.)\n\n그렇게 변환된 데이터를 다시 연속적인 신호로 변환하기 위해선 LTI System에 Pulse를 적용한 결과를 응용하면 된다.\n\n![231015-222538](/posts/mid_02/231015-222538.png)\n\n넓이가 1인 Pulse를 LTI System에 통과시키면 위와 같은 그래프로 변형된다고 하자.\n이 때, LTI System은 선형성을 유지하고 시간 불변성을 갖기 때문에 Pulse의 세기가 커지거나, 시간이 shift돼도,\nLTI System을 통과해도 그 변화가 유지된다.\n\n그렇기에 위에서 변환된 데이터를 특정 구간에 대해 Pulse라고 생각한다면,\n그 데이터를 LTI System에 통과시키면 다음과 같이 변환될 것이다.\n\n![231015-222954](/posts/mid_02/231015-222954.png)\n\n## Convolution\n\n위에서 언급한 Pulse에 대해 단위 시간(T)를 0에 가깝게 보내면 연속적인 신호에 대한 Pulse가 되는데, 이를 Impulse라고 한다.\n이런 Impulse를 LTI System에 통과시키면 위에서 봤던 그래프 형태로 나오게 되는데, 이를 임펄스 반응 이라고 하고, $h(t)$ 라고 하자.\n\n![231015-223956](/posts/mid_02/231015-223956.png)\n\n입력 신호 $f$와 출력 신호 $y$는 다음과 같은 관계를 갖게 된다.\n\n$$\ny(t) = f(t) * h(t)\n$$\n\n즉, LTI System의 출력($y$)은 시스텝의 임펄스 반응($h$)과 입력($f$)의 Convolution이다.\n\n## Fourier Transform\n\n![231015-224927](/posts/mid_02/231015-224927.png)\n\n푸리에 변환의 기본적인 아이디어는 주기적인 어떠한 함수는 모두 sin파 또는 cos파의 합으로 표현(근사)될 수 있다에서 출발한다.\n\n푸리에 변환을 거치면 시간에 대한 함수가 주파수에 대한 함수로 변환되는데,\n시간 축이 주파수 축으로 변환된다는 뜻이다.\n단적인 예로, 주기가 $2\\pi$이고, 크기가 1인 sin함수는 크기가 1이고, $u=1 (2\\pi)$인 Impulse 형태로 그려진다.\n\n<tip>\n  `푸리에 변환`\n  $$\n  F(u) = \\int_{-\\infty}^{\\infty} f(x)e^{-i2\\pi ux}dx\n  $$\n\n  `역 푸리에 변환`\n  $$\n  f(x) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} F(u)e^{iux}dx\n  $$\n</tip>\n\n그런데 왜 푸리에 변환을 알아야 할까?\n바로 푸리에 변환을 사용하면 Convolution 연산이 매우 간단한 형태로 변환되기 때문이다.\n\n$$\nG(u) = \\int_{-\\infty}^{\\infty}g(x)e^{-i2\\pi ux}dx \\\\\n= \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(\\tau)h(x-\\tau)e^{-i2\\pi ux}dx \\\\\n= \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}[f(\\tau)e^{-i2\\pi u\\tau}d\\tau][h(x-\\tau)e^{-i2\\pi u(x-\\tau)}dx] \\\\\n= \\int_{-\\infty}^{\\infty}[f(\\tau)e^{-i2\\pi u\\tau}d\\tau]\\int_{-\\infty}^{\\infty}[h(x')e^{-i2\\pi ux'}dx'] \\\\ \n= F(u)H(u)\n$$\n\n즉, 기존 도메인($x$)에서의 Convolution 연산이 푸리에 변환된 주파수 도메인($u$)에서는 단순 곱셈으로 표현된다.\n\n![231015-230238](/posts/mid_02/231015-230238.png)\n\n따라서 Convolution 연산을 간단하게 하기 위해서는 일단 푸리에 변환 후 곱연산을 수행해서 다시 역 푸리에 변환을 거치는 과정을 수행하는게 좋다.\n\n### Sampling\n\n[**`이전 포스트`**](https://wjlee611.github.io/blog/univ_com-vision/mid_01#aliasing)에서 Sampling이 적으면 Aliasing이 발생한다고 했었는데, 그 이유을 알아보자.\n\n![231015-230835](/posts/mid_02/231015-230835.png)\n\n왼쪽은 시간 도메인 기준으로 입력 신호에 적절하게 샘플링된 Impulse를 Convolution하면 좌하단처럼 샘플링이 이루어진다.\n오른쪽은 왼쪽을 푸리에 변환한 결과로 Convolution 대신 곱연산한 결과이다.\n\n~~(본인도 이해는 안되지만)~~ 여기서 중요한 것은 샘플링이 촘촘할 수록\n푸리에 변환된 스펙트럼이 듬성듬성 해진다는 점이다.\n\n만약, 샘플링이 적은수가 되었다면 우하단의 입력 신호의 스펙트럼 봉우리(?)가 오버랩될 것이다.\n오버랩 되는 경우 원본을 복구할 수 없기에 Aliasing이 발생하는 것이다.","slug":"univ_com-vision/mid_02","readingMinutes":6,"wordCount":449},{"title":"Digital Image Fundamentals","description":"디지털 이미지에 대한 기초적인 정보입니다.","icon":"","image":"","tags":["Sampling","Quantization","Interpolation"],"draft":false,"date":"2023-10-15 / 20:05","content":"\n## Sampling & Quantization\n\n연속적인 자연계의 현상을 기록하기 위해서는 이미지를 불 연속적인 형태. 즉, 디지털로 변환해야 한다.\n\n예로 들어 이미지의 좌표가 100.32라면? 반올림을 하던지 적당히 100과 같은 불 연속적인 값으로 치환해야 하며,\n에너지레벨 역시 이와 같은 방식으로 디지털화 해야한다.\n\n이렇게 자연계의 연속적인(무한한) 값을 `디지털화 하기 위해 유한하게` 자르는 과정을 `Sampling`이라 하고,\n무한 소수의 데이터를 `양자화시켜 비트에 저장할 수 있게` 자르는 과정을 `Quantization`라고 한다.\n\n![231015-201653](/posts/mid_01/231015-201653.png)\n\n**좌상단**의 이미지 중에서 $\\overline{AB}$ 를 디지털화 해본다면,\n**우상단**의 그래프처럼 에너지레벨(빛의 밝기)이 표현될 것이다. (지글지글 거리는 것은 센서의 한계로인한 노이즈)\n샘플링을 일정 구간으로 잘라 네모난 점으로 표현하면 **좌하단**의 이미지처럼 될 것이고,\n이를 양자화하면 **우하단**의 이미지처렴 변화하여 디지털로 저장할 수 있게 된다.\n\n![231015-202204](/posts/mid_01/231015-202204.png)\n\n이런 방식으로 2차원 이미지를 디지털화 하면 위와 같은 모양이 될텐데,\n연속적인 데이터를 불연속적인 데이터로 변환하면서 어쩔 수 없는 데이터의 손실이 발생할 수 있다.\n\n<tip>\n  픽셀의 가로축은 x축, 세로축은 y축이며,\n  x좌표는 늘 보던 좌표계와 마찬가지로 오른쪽으로 갈 수록 커지지만,\n  y좌표는 반대로 내려갈수록 커진다. **(y축 반전 주의)**\n  <br />\n  M행 N열(M$\\times$N)의 이미지는 다음과 같은 배열에 저장할 수 있다.\n\n  $$\n  f(x,y) = \\begin{bmatrix}\n  f(0,0) & f(0,1) & ... & f(0,N-1) \\\\\n  f(1,0) & f(1,1) & ... & f(1,N-1) \\\\\n  ... & ... & ... & ... \\\\\n  f(M-1,0) & f(M-1,1) & ... & f(M-1,N-1) \\\\\n  \\end{bmatrix}\n  $$\n</tip>\n\n### Aliasing\n\n![231015-205116](/posts/mid_01/231015-205116.png)\n\n샘플링을 위 이미지와 같이 극단적으로 적게 할 경우, 조건이 없다면 원본 데이터를 유추할 수 없게 된다.\n또는 변화량이 너무 큰 경우에도 위와 같은 Aliasing 현상이 발생할 수 있다.\n예로 들어서 선풍기를 영상으로 찍으면 멈춰있는 듯한 현상이 그런 경우이다.\n\n### Quantization Level\n\n![231015-204846](/posts/mid_01/231015-204846.png)\n\n양자화를 얼마나 세밀하게 할지를 Quantization Level이 결정한다.\n레벨이 적을수록 듬성듬성 양자화하게 되고(점선 간격이 늘어남), 이는 화질 저하로 이어진다.\n하지만 용량은 절약될 것이다.\n\n### Size (Storage bits)\n\n이렇게 저장된 영상의 크기를 구해보자.\n\n<notice>\n  이미지의 화질은 M$\\times$N으로 가정하고,\n  각 픽셀은 0~255, 즉, 8 bits의 에너지 레벨을 갖는다고 가정하자.\n</notice>\n\n단색 이미지(Gray Image)의 경우 1픽셀은 8bits가 필요하기에 1byte.\n이 픽셀이 M$\\times$N개 있으니 M$\\times$Nbytes.\n컬러 이미지의 경우 RGB 3개의 색상 채널이 있으니 3을 곱해서 M$\\times$N$\\times$3bytes 가 된다.\n\n위 계산 결과는 하나의 이미지에 대한 사이즈로, 동영상의 경우에는 30프레임의 경우 추가로 30을 더 곱해줘야 할 것이다.\n\n### Saturation\n\n![231015-203543](/posts/mid_01/231015-203543.png)\n\n센서까지 차이가 있던 데이터가 샘플링 과정에서 차이가 없어지는, Saturation 현상이 발생할 수 있다.\n\n### Gray Level\n\n![231015-203931](/posts/mid_01/231015-203931.png)\n![231015-203946](/posts/mid_01/231015-203946.png)\n\nGray Level이 높을 수록 에너지 레벨을 세분화해서 표현할 수 있다.\n따라서 디스플레이 장치가 좋지 않아서 Gray Level이 낮을 경우 같은 이미지라도 위 사진처럼 다르게 표현될 수 있다.\n\n## Interpolation\n\n디지털화된 이미지의 사잇값을 적절히 채워 실제 데이터를 추측하는 과정,\n또는, 저화질의 영상의 픽셀값을 채워 고화질로 바꾸거나, 영상의 회전, 축소시 픽셀값을 추측하는 과정을 Interpolation 라고 한다.\n\n### Pixel math\n\n보통 아래와 같은 행렬간의 연산 혹은 픽셀별 계산으로 처리된다.\n\n$$\n\\begin{bmatrix}\na_{11} & a_{12} \\\\\na_{21} & a_{22} \\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nb_{11} & b_{12} \\\\\nb_{21} & b_{22} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11} + b_{11} & a_{12} + b_{12} \\\\\na_{21} + b_{21} & a_{22} + b_{22} \\\\\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\na_{11} & a_{12} \\\\\na_{21} & a_{22} \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nb_{11} & b_{12} \\\\\nb_{21} & b_{22} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11}b_{11} + a_{12}b_{21} & a_{11}b_{12} + a_{12}b_{22} \\\\\na_{21}b_{11} + a_{22}b_{21} & a_{21}b_{12} + a_{22}b_{22} \\\\\n\\end{bmatrix}\n$$\n\n단, 보통 픽셀값은 0~255 사이의 값을 갖기 때문에, overflow, underflow에 대해 적절하게 처리해줘야 한다.\n\n### Linear\n\n$H[f(x,y)] = g(x,y)$ 와 같은 변환 함수 $H$가 있을 때,\n아래의 특성을 만족하면 $H$가 선형이라고 한다.\n\n$$\nH[a_if_i(x,y) + a_jf_j(x,y)] \\\\\n= a_iH[f_i(x,y)] + a_jH[f_j(x,y)] \\\\\n= a_ig_i(x,y) + a_jg_j(x,y)\n$$\n\n즉 연산 순서에 상관없다면 선형이라 하며, 대부분의 이미지 처리 연산은 선형이다.\n\n### Image Rotation\n\n![231015-212235](/posts/mid_01/231015-212235.png)\n\n특정 픽셀을 $\\theta$만큼 반 시계방향으로 회전시킬 경우 아래와 같은 연산을 가해주면 된다.\n\n$$\n\\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n=\nR(\\theta)\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ncos\\theta & -sin\\theta \\\\\nsin\\theta & cos\\theta\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n$$\n\n하지만, 이 경우에는 원점을 중심으로 회전되기 때문에,\n영상을 중심으로 회전시켜야 하는 경우에는 다음과 같은 스탭을 거쳐야 한다.\n\n1. 영상을 중심으로 평행 이동 시킨다.\n2. 삼각함수를 이용해 영상을 회전시킨다.\n3. 다시 영상을 원위치로 평행 이동 시킨다.\n\n하지만, 위 연산은 선형이기 때문에 각 픽셀별로 아래 하나의 연산으로 처리해도 상관없다.\n\n$$\n\\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ncos\\theta & -sin\\theta \\\\\nsin\\theta & cos\\theta\n\\end{bmatrix}\n\\begin{bmatrix}\nx - W/2\\\\\ny - H/2\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nW/2\\\\\nH/2\n\\end{bmatrix}\n$$\n\n<notice>\n  영상 변환을 하기 위해서는 `변환 후(x, y)`의 좌표를 연산을 통해 `변환 전(x', y')`의 좌표를 구하고,\n  그 좌표의 데이터를 가져와 Quantization하여 변환 후의 좌표에 대입하는 과정을 거쳐야 한다.\n</notice>\n\n### Image Interpolation\n\n![231015-214108](/posts/mid_01/231015-214108.png)\n\n검은색 input 영상을 흰색 output 영상으로 upscaling하거나, 영상 회전과 같이\n변환 후의 영상의 좌표가 픽셀에 정확히 들어가지 않는 경우, 검은색 픽셀값을 이용해 흰색 픽셀값을 추측해야 한다.\n추측하는 방식에는 보통 아래와 같은 방법들이 있다.\n\n1. Replication\n  이전 픽셀값의 데이터를 그대로 사용하는 방법이다.\n2. Nearest Neighbor\n  본인과 가까운 픽셀의 데이터를 그대로 사용하는 방법이다.\n\n위 두 방법의 경우 Interpolation은 가능하지만, 이미지 화질의 개선이 이루어지지는 않는다.\n적당한 화질 개선을 위해서는 아래의 방법을 고려해볼 수 있다.\n\n3. (Bi)linear Interpolation\n  근처 픽셀값을 이용해 평균 데이터를 계산하여 사용하는 방법이다.\n\n![231015-214947](/posts/mid_01/231015-214947.png)\n\n$$\nq_1 = (1-a)p_1 + ap_2 \\\\\nq_2 = (1-a)p_3 + ap_4 \\\\\n{} \\\\ \nq = (1-b)q_1 + bq_2\n$$\n","slug":"univ_com-vision/mid_01","readingMinutes":10,"wordCount":824},{"title":"Adapter Pattern","description":"Adapter 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Adapter Pattern"],"draft":false,"date":"2023-10-11 / 17:13","content":"\n## 필요성\n\n개발하다 보면, 이전에 개발했던 코드가 있는데, 새로 개발된 코드 사양에 맞게 변경시켜야 하는 상황이 많을 것이다.\n마음같아선 새로 짜고 싶지만, dependency가 높은 코드나 배포가 진행된 코드의 경우 수정하는데 부담이 클 수 밖에 없다.\n이런 경우에 오래된 코드를 새로운 코드 사양에 맞게 변형시켜줘야 할 필요성이 생기는데, 이 때 `Adapter Pattern`을 사용하게 된다.\n\n## Adapter Pattern\n\n예를 들어보기 위해 우리의 오랜 친구(?) Duck 시뮬레이터를 다시 불러와보자.\n\n```java:Duck.java\npublic interface Duck {\n  public void quack();\n  public void fly();\n}\n```\n\n이제 새로운 동물을 시뮬레이터에 추가해보자. 바로 Turkey!\n\n```java:Turkey.java\npublic interface Turkey {\n  public void gobble();\n  public void fly();\n}\n```\n\n인터페이스를 보면 알겠지만, 울음 소리가 다르다.\n따라서 기존에 많은 곳에서 사용되었던 quack() 메서드를 사용하는 곳에선 Turkey 인터페이스를 구현한 클래스의 인스턴스를 사용할 수가 없게된다.\n이 경우 **코드의 재사용성**을 높이기 위해 `Adapter`를 구현해서 사용하게 된다!\n\n```java:TurkeyAdapter.java {1 8-10}\npublic class TurkeyAdapter implements Duck {\n  Turkey turkey;\n\n  public TurkeyAdapter(Turkey turkey) {\n    this.turkey = turkey;\n  }\n\n  public void quack() {\n    turkey.gobble();\n  }\n\n  public void fly() {\n    turkey.fly();\n  }\n}\n```\n\n이렇게 TurkeyAdapter를 만들어주면 이 어댑터의 인스턴스는 Duck 취급을 받기에 quack() 메서드를 사용하는 부분에 이 인스턴스를 넣을 수 있다.\n즉, Turkey를 Duck 처럼 사용할 수 있다는 뜻이다!\n\n```java:DuckSimulator.java {6}\npublic class DuckSimulator {\n  public static void main(String[] args) {\n    MallardDuck duck = new MallardDuck(); // implement Duck\n    WildTurkey turkey = new WildTurkey(); // inplement Turkey\n\n    Duck turkeyAdapter = new TurkeyAdapter(turkey);\n\n    // 둘 다 가능.\n    duck.quack();\n    turkeyAdapter.quack(); // 내부적으로 turkey.gobble() 호출\n  }\n}\n```\n\n## IRL\n\n실제로 Adapter Pattern이 적용되는 사례를 살펴보자.\n\njava에서 일련의 객체를 나타낼 때 `Iterator`를 많이들 사용하는데, 예전에 Iterator가 없을 때는 `Enumerators`을 사용했다고 한다.\n버전업이 되고 Iterator를 사용하는게 권장됐는데, legacy system에서는 아직도 Enumerators를 사용했기에 이를 강제할 수는 없었다.\n따라서 이를 위해 EnumerationAdapter를 만들었다고 한다.\n\n```java:Enumerators.java\npublic interface Enumerators {\n  public boolean hasMoreElements();\n  public T nextElement();\n}\n```\n\n```java:Iterator.java\npublic interface Iterator {\n  public boolean hasNext();\n  public T next();\n  public void remove();\n}\n```\n\n```java:EnumerationAdapter.java\npublic class EnumerationAdapter implements Iterator {\n  Enumerators enumerators;\n\n  public EnumerationAdapter(Enumerators enumerators) {\n    this.enumerators = enumerators;\n  }\n\n  public boolean hasNext() {\n    return enumerators.hasMoreElements();\n  }\n\n  public T next() {\n    return enumerators.nextElement();\n  }\n\n  public void remove() {\n    throw new UnsupportedOperationException();\n  }\n}\n```\n\n","slug":"univ_design-pattern/mid_06","readingMinutes":4,"wordCount":352},{"title":"Command Pattern","description":"Command 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Command Pattern"],"draft":false,"date":"2023-10-10 / 14:45","content":"\n## 필요성\n\n개발하다보면, 특정 버튼을 누르면 이벤트가 발생하도록 처리하는 패턴을 구현해야 하는 경우가 생길 것이다.\n예로들어 만능 리모컨을 만든다고 가정해보자.\n\n버튼 1 - ON을 누르면 tv가 켜지고 OFF를 누르면 꺼지고,\n\n```java:TV.java\npublic class TV {\n  private boolean isOn;\n  private int channel;\n\n  public TV() {\n    this.isOn = false;\n    this.channel = 1;\n  }\n\n  public void on() {\n    this.isOn = true\n  }\n\n  public void off() {\n    this.isOn = false;\n  }\n\n  public void changeChannel(int channel) {\n    this.channel = channel;\n  }\n}\n```\n\n버튼 2는 전등, 3은 선풍기 등등...\n\n이런 경우에 보통의 경우 `if - else`로 처리하는 경우가 많을 것이다.\n\n```java:Example\nif (버튼 1 - ON) {\n  tv.on();\n} else if (버튼 2 - OFF) {\n  tv.off();\n}\n```\n\n하지만 이런 경우에는 새로운 기능을 추가하거나, 기존에 있는 기능을 수정하려면 그 유지보수가 매우 불편하다.\n\n따라서 이를 해결하기 위한 디자인 패턴을 소개한다.\n\n## Command Pattern\n\nCommand Pattern의 기본적인 아이디어는 모든 기능 요청들을 `하나의 명령어(Command)`로서 관리하여 은닉화 하는데에 있다.\n바로 코드를 보며 이해해보자.\n\n```java:Command.java\npublic interface Command {\n  public void execute();\n}\n```\n\n```java:TVOnCommand.java {1, 8-10}\npublic class TVOnCommand implements Command {\n  TV tv;\n\n  public TVOnCommand(TV tv) {\n    this.tv = tv;\n  }\n\n  public void execute() {\n    tv.on();\n  }\n}\n```\n\n모든 명령어는 무조건 `execute()`로 실행하고, 각 명령어의 실행 방법은 그 명령어가 어떤 장치를 조작하는지에 따라 다르게 구현한다.\n따라서 이렇게 구현한다면 TV를 켜든 끄든 전등을 제어하든 모든 명령은 `execute()`를 호출하면 되는 것이다.\n\n```java:RemoteController.java {2-3}\npublic class RemoteController {\n  Command[] onCommands;\n  Command[] offCommands;\n\n  public RemoteController() {\n    onCommands = new Command[7];\n    offCommands = new Command[7];\n\n    Command empty = new Command();\n    for (int i=0; i<onCommands.length; i++) {\n      onCommands[i] = empty;\n      offCommands[i] = empty;\n    }\n  }\n\n  public void setCommand(int slot, Command onCom, Command offCom) {\n    onCommands[slot] = onCom;\n    offCommands[slot] = offCom;\n  }\n\n  public void onBtnPushed(int slot) {\n    onCommands[slot].execute();\n  }\n\n  public void offBtnPushed(int slot) {\n    offCommands[slot].execute();\n  }\n}\n```\n\n그리고 만능 리모컨을 이렇게 구현한다면, 사용자 입장에서는 원하는 기능을 `Command interface`로 구현하고, 원하는 slot에 `setCommand()`를 이용해 넣어주기만 하면 된다.\n\n### 추가 기능\n\n명령어 인터페이스를 이용해 하나로 구현하면 다른 기능을 추가하고 싶을 때도 용이하다.\n예로 들어 undo 기능을 구현해보자.\n\n```diff-java:Command.java\n  public interface Command {\n    public void execute();\n+   public void undo();\n  }\n```\n\n그럼 각 명령어에서 수행할 undo 기능을 추가만 하면 된다.\n\n```diff-java:TVOnCommand.java\n  public class TVOnCommand implements Command {\n    TV tv;\n\n    public TVOnCommand(TV tv) {\n      this.tv = tv;\n    }\n\n    public void execute() {\n      tv.on();\n    }\n\n+   public void undo() {\n+     tv.off(); // on의 반대는 off\n+   }\n  }\n```\n\n그렇다면 컨드롤러의 구현은 이렇게만 수정되면 undo 기능을 쉽게 구현할 수 있게된다!\n\n```diff-java:RemoteController.java\n  public class RemoteController {\n    Command[] onCommands;\n    Command[] offCommands;\n+   Command undoCommand;\n\n    ...\n\n    public void onBtnPushed(int slot) {\n      onCommands[slot].execute();\n+     undoCommand = onCommands[slot];\n    }\n\n    public void offBtnPushed(int slot) {\n      offCommands[slot].execute();\n+     undoCommand = offCommands[slot];\n    }\n\n+   public void undoBtnPushed() {\n+     undoCommand.undo();\n+   }\n  }\n```\n\nundo 뿐만 아니라, 매크로 기능과 같은 서드파티 기능도 쉽게 구현할 수 있을 것이다.\n\n```java:MacroCommand.java\npublic class MacroCommand implements Command {\n  Command[] commands;\n\n  public MacroCommand(Command[] commands) {\n    this.commands = commands;\n  }\n\n  public void execute() {\n    for (int i=0; i<commands.length; i++) {\n      commands[i].execute();\n    }\n  }\n\n  public void undo() {\n    for (int i=commands.length-1; i>=0 i--) {\n      commands[i].undo();\n    }\n  }\n}\n```\n\n### IRL\n\nIn Real Life에서는 Command Pattern이 어떻게 쓰이고 있을까?\n\n1. 명령어 queuing\n**Command queue**를 만들어 `enqueue`, `dequeue`를 구현하여, 각각의 명령어를 순차처리, 스레드에 할당하는 방식으로 사용하는 경우가 있다.\n\n2. logging\n**Command**에 `store`, `load` 따위의 메서드를 추가하여 명령어가 실행되면 disk에 로깅 및 불러올 수 있도록 기능을 추가하여 에러 및 데이터 분석을 용이하게 하는 경우도 있다.\n\n\n## 결론\n\n클라이언트 별로 다른 요청을 처리하는 경우나, 요청 queue, 로깅이 필요한 경우에는\n명령어, 요청을 `은닉화(encapsulates)`하는 Command Pattern을 활용해보자.","slug":"univ_design-pattern/mid_05","readingMinutes":6,"wordCount":583},{"title":"Singleton Pattern","description":"Singleton 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Singleton Pattern"],"draft":false,"date":"2023-10-08 / 21:31","content":"\n## 필요성\n\n시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용한다.\n\n## Singleton Pattern\n\n```java:Singleton.java {2, 4} showLineNumbers\n  public class Singleton {\n    private static Singleton _instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      if (_instance == null) {\n        _instance = new Singleton();\n      }\n      return _instance;\n    }\n  }\n```\n\n기존에 봐오던 클래스들과 많이 다르게 클래스 내부에 본인의 인스턴스를 저장하는 공간이 있으며,\n**생성자가 외부로 노출되지 않는다**.\n\n인스턴스 생성은 오직 `getInstance()` 메서드 호출을 통해서만 이루어지며,\n내부적으로 null값인 경우에만 인스턴스를 생성하기 때문에 `1개의 인스턴스만 생성`이 된다.\n\n### Multithreading\n\n하지만 멀티스레딩 환경에서는 인스턴스가 2개 이상 생성되는 경우가 발생할 수 있다.\n`Line 7`과 `Line 8` 사이에서 `Context switching`이 일어나는 경우가 그러하다.\n\n이런 경우를 막기 위해서 getInstance()는 `동기화 처리`를 해주는 편이 좋다.\n\n```java:Singleton.java {2}\npublic class Singleton {\n  private static Singleton _instance = new Singleton();\n  ...\n}\n```\n\n이렇게 하면 프로그램 실행시점에 인스턴스가 생성되어 반드시 1개의 인스턴스만 생성할 수 있다.\n하지만, 해당 클래스의 생성시점을 제어할 수 없기에 프로그램 성능이 저하되는 문제가 발생할 수 있다.\n\n```java:Singleton.java {6}\n  public class Singleton {\n    private static Singleton _instance;\n\n    private Singleton() {}\n\n    public static synchronized Singleton getInstance() {\n      if (_instance == null) {\n        _instance = new Singleton();\n      }\n      return _instance;\n    }\n  }\n```\n\njava처럼 동기화 키워드를 제공하는 경우 인스턴스를 생성하는 함수를 동기화 걸어주면 된다.\n하지만 이 경우에도 해당 함수가 매우 무거운 기능을 수행하는 경우에는 동기화 시간이 매우 길어져 성능 저하의 원인이 될 수 있다.\n\n\n```java:Singleton.java {6}\n  public class Singleton {\n    private volatile static Singleton _instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      if (_instance == null) {\n        synchronized (Singleton.class) {\n          if (_instance == null) {\n            _instance = new Singleton();\n          }\n        }\n      }\n      return _instance;\n    }\n  }\n```\n\n위의 코드는 인스턴스 생성 함수 내부에서 정확히 인스턴스를 생성하는 부분만 동기화되기 때문에\n성능상의 이슈도 없앨 수 있다.\n\n## 결론\n\n필요성과 같다.\n시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용하자.","slug":"univ_design-pattern/mid_04","readingMinutes":4,"wordCount":300},{"title":"Decorator Pattern","description":"Decorator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Decorator Pattern","OCP","Java I/O"],"draft":false,"date":"2023-10-08 / 14:49","content":"\n## 필요성\n\n키오스크 개발자라고 가정하고 음료를 정의할 인터페이스를 만들어보자.\n\n```java:Beverage.java\npublic abstract class Beverage {\n  private String description;\n\n  public Beverage(String des) {\n    this.description = des;\n  }\n\n  public String getDescription() {\n      return description;\n  }\n  public abstract double cost();\n}\n```\n\n그렇다면 음료들은 이 클래스를 상속받아서 구현하면 될 것이다.\n하지만 이 경우에 다음과 같은 문제점이 발생할 수 있다.\n\n아아, 아아 샷추가, 아아 우유추가 등 여러 `베리에이션 음료`에 대해 모두 **각각** 클래스로 구현해야 한다는 점이다.\n단순히 샷추가나 우유추가의 경우에는 가격만 좀 더 받으면 될터인데 이를 각각 따로 구현하는거는 코드의 중복 뿐만 아니라, 유지보수도 어렵게 만든다.\n\n### OCP\n\n그렇다면 Beverage에서 옵션도 관리하게 하면 되지 않을까?\n\n```diff-java:Beverage.java\n  public abstract class Beverage {\n    private String description;\n+   private boolean milk;\n+   private boolean soy;\n\n    public Beverage(String des) {\n      this.description = des;\n    }\n\n    public abstract String getDescription() {\n      return description;\n    }\n    public abstract double cost();\n\n+   setMilk();\n+   hasMilk();\n+   setSoy();\n+   hasSoy();\n  }\n```\n\n처음 생각해볼 수 있는 간단한 해결법이지만, 좋은 방법은 아니다.\n다른 옵션을 추가하거나 옵션에 따른 가격 변동을 수정하려는 경우에는 Beverage 클래스에 대한 전면적인 수정이 필요해지기 때문이다.\n\n`새로운 옵션`에 대해서는 **변수 추가 및 get, set을 추가**해야 하고,\n`가격 변동`의 경우에는 **cost 함수가 전면적으로 수정**되어야 한다.\n이 과정에 Beverage를 상속받은 `모든 클래스`에서 일어나야 한다.\n\n이런 경우를 방지하기 위해 `OCP` 방법론을 준수하여 코딩하는게 좋다.\n\nOCP는 Open-Closed Principle의 약어로, 확장엔 유연하게, 변경엔 엄격하게 디자인 해야함을 추구하는 원칙이다.\n\n## Decorator Pattern\n\n이를 해결하기 위해 `Decorator Pattern`을 사용할 수 있다.\n\n우선 Beverage는 다시 원상복구를 시키고, 옵션에 대한 클래스를 구현하자.\n\n```java:CondimentDecorator.java\npublic abstract class CondimentDecorator extends Beverage {\n  public abstract String getDescription();\n}\n```\n\n이제 음료는 Beverage를 상속받아 구현하고, 옵션은 CondimentDecorator를 상속받아 구현하면 된다.\n계속 예시를 살펴보며 이해하자.\n\n```java:Espresso.java\npublic class Espresso extends Beverage {\n  public Espresso() {\n    description = 'Espresso';\n  }\n\n  public double cost() {\n    return 0.89;\n  }\n}\n```\n\n```java:Milk.java\npublic class Milk extends CondimentDecorator {\n  Beverage beverage;\n\n  public Milk(Beverage beverage) {\n    this.beverage = beverage;\n  }\n\n  public String getDescription() {\n    return beverage.getDescription() + ', Milk';\n  }\n\n  public double cost() {\n    return beverage.cost() + 0.20;\n  }\n}\n```\n\n이런식으로 구현한다면 사용할 때는 Espresso를 Milk가 감싸는 방식으로 옵션을 추가할 수 있게된다.\n\n```java:Kiosk.java\npublic class Kiosk {\n  public static void main(String args[]) {\n    Beverage espressoWithMilk = new Milk(new Espresso());\n    System.out.println(espressoWithMilk.getDescription() + “ $” + espressoWithMilk.cost());\n    ...\n  }\n}\n```\n\n> Espresso, Milk $1.09\n\n실제로 Java의 I/O를 사용하다보면 이런 코드를 많이 본 적이 있을 것이다.\n\n```java:FileIO.java\nInputStream in = new LineNumberInputStream(\n                    new BufferedInputStream(\n                       new FileInputStream('text.txt')));\n```\n\n이런 Stream도 모두 Decorator Pattern이 적용된 것이다.\n\n## 결론\n\nDecorator Pattern은 `새로운 기능이 추가`되거나, `적용 순서를 자유롭게` 해야하는 경우에 사용하는 것이 좋다.","slug":"univ_design-pattern/mid_03","readingMinutes":5,"wordCount":417},{"title":"Dart 언어 마스터","description":"Dart 언어에 대한 보다 심화된 내용을 정리해봤습니다.","icon":"","image":"","tags":["Dart","factory","get","set","stream","async*","yield","mixin","with"],"draft":false,"date":"2023-09-25 / 14:55","content":"\n## factory constructor\n\n`factory` 키워드를 사용하면 아래와 같은 기능을 구현할 수 있다고 공식문서에 나와 있습니다.\n\n1. 인스턴스를 `캐시에서 반환`하여 클래스의 인스턴스를 한 번만 생성할 수 있도록 합니다. (일종의 Singleton 패턴 구현법)\n2. 생성자에서 `서브 클래스`(상속 받은 클래스)의 인스턴스를 반환할 수 있습니다.\n\n둘 다 신기한 기능입니다. (다만 언제 사용하는게 적재적소인지는 잘 모르겠네요..)\n1번부터 알아봅시다.\n\n### caching\n\n```dart:.dart\nclass Singleton {\n  static final Singleton _instance = Singleton._internal();\n\n  Singleton._internal() {}\n\n  factory Singleton() {\n    return _instance;\n  }\n\n  void getHash() {\n    print(this.hashCode);\n  }\n}\n\nvoid main() {\n  Singleton s1 = new Singleton();\n  Singleton s2 = new Singleton();\n\n  s1.getHash(); // 302000605\n  s2.getHash(); // 302000605\n}\n```\n\n위와 같이 구현한다면, Singleton 클래스의 인스턴스는 `단 한개`만 생성되게 됩니다.\n클래스 로드 시점에 static으로 이미 인스턴스가 만들어지기 때문이죠.\n하지만 이런 사용용법은 의미가 없어보입니다.\n차라리 아래의 예시가 더 의미 있어보입니다.\n\n```dart:.dart\nclass SingletonLog {\n  final String value;\n\n  static final Map<String, SingletonLog> _cache = {};\n\n  SingletonLog._internal(this.value);\n\n  factory SingletonLog(String value) {\n    return _cache.putIfAbsent(value, () => SingletonLog._internal(value));\n  }\n\n  void getHash() {\n    print(this.hashCode);\n  }\n\n  String getValue() {\n    return value;\n  }\n\n  Map<String, String> getLogs() {\n    Map<String, String> result = {};\n    _cache.forEach((key, value) {\n      result[key] = value.value;\n    });\n    return result;\n  }\n}\n\nvoid main() {\n  SingletonLog s1 = new SingletonLog('log1');\n  SingletonLog s2 = new SingletonLog('log2');\n\n  s1.getHash();        // 888013580\n  s2.getHash();        // 870182876\n\n  print(s1.value);     // log1\n  print(s2.value);     // log2\n\n  print(s1.getLogs()); // {log1: log1, log2: log2}\n  print(s2.getLogs()); // {log1: log1, log2: log2}\n}\n```\n\n이렇게 하면 s1, s2가 같은 인스턴스를 반환받기 때문에, 어디에서 로그를 추가해도 모든 객체가 같은 로그기록을 보관할 수 있습니다.\n\n<tip>\n  그럼 이런 의문이 듭니다.\n  hashCode가 다르게 나오는데, 그럼 다른 객체 아닌가요?\n  <br />\n  실제로 s1 == s2의 값은 `false`입니다. 따라서 `다른 객체`가 맞습니다.\n  하지만 **약간 변형**이 이루어지긴 했으나, `싱글톤 패턴` 역시 맞습니다.\n  <br />\n  왜냐하면, 인스턴스의 생성을 **클래스 내부**에서 `_internal`로 생성하고, 생성자를 외부에서 호출하지 못합니다.\n  또한, static으로 선언된 `_cache` 내부에서 인스턴스를 보관하기 때문에 _cache를 통해서 **전역적으로 인스턴스를 공유**하게 됩니다.\n  <br />\n  그렇다고 항상 다른 객체를 반환하는 것은 아닙니다.\n  실제로, s2를 생성할 때, s1과 동일하게 `'log1'`을 주입시키면 s1, s2 동일한 hashCode를 갖게 됩니다.\n  왜냐하면, factory 생성자는 일단 캐시되어있는 인스턴스를 반환하기 때문에,\n  _cache 내부에 인스턴스를 저장하고 있고, s1, s2 모두 같은 데이터를 갖고 있기에 메모리주소 역시 같아집니다.\n</tip>\n\n### return subclass constructor\n\n그럼 2번도 알아봐야겠죠?\n\n```dart:.dart\nclass Human {\n  final String name;\n\n  Human(this.name);\n\n  factory Human.create(String name, {required bool isMan}) {\n    if (isMan) {\n      return Male(name);\n    }\n    return Female(name);\n  }\n}\n\nclass Male extends Human {\n  Male(String name) : super(name);\n}\n\nclass Female extends Human {\n  Female(String name) : super(name);\n}\n\nvoid main() {\n  Human man = new Human.create('h1', isMan: true);\n  Human woman = new Human.create('h2', isMan: false);\n\n  print(man.name);   // h1\n  print(woman.name); // h2\n}\n```\n\n이 방식은 객체지향 프로그래밍의 다형성의 원리를 충족시키기에 좋은 문법입니다.\n\n신기한 점은 부모 클래스 생성자에서 자식 클래스의 생성자를 호출해 반환한다는 점입니다.\n이렇게하면 인스턴스 생성 시점에 조건을 달아 다른 인스턴스를 반환하는 것이 가능해집니다.\n_(상태나 이벤트를 클래스로 관리할 때 유용해 보이네요!)_\n\n### constructor body\n\n사실 공식문서에는 자세히 설명하진 않지만, factory 생성자의 가장 큰 이점은 `final variable`을 생성자에서 `initialize list`로 **초기화하지 않아도 된다는 점** 이라고 생각합니다.\n정확히 말하자면, 생성자를 내부에서 호출함으로서 생성자 호출 전, `전처리`를 할 수 있다는 점이 이점이라고 생각합니다.\n\n예시를 봐야겠죠?\n\n```dart:.dart {7-10}\nclass Human {\n  final String name;\n\n  Human(this.name);\n\n  // Human.withSir(String name) : this.name = 'Sir - ' + name;\n  factory Human.withSir(String name) {\n    String newName = 'Sir - ' + name;\n    return Human(newName);\n  }\n}\n\nvoid main() {\n  Human man = new Human.withSir('h1');\n\n  print(man.name);\n}\n```\n\n위 코드에서 주석처리 된 부분과 하이라이트 된 부분 모두 동일한 기능을 수행합니다.\n지금은 간단하게 문자열 앞에 `Sir - `을 붙이도록 했지만, 만약 배열을 직렬화 해야하는 상황이라면?\n한 줄로 처리하기 복잡한 기능은 분명 일반 생성자의 initialize list로 처리하는덴 한계가 있을 것입니다.\n\n<tip>\n  한 줄로 처리하기 복잡한 코드는 예로들어 `json serialize` 부분이 있겠죠?\n  <br />\n  그래서 우리가 무의식적으로 사용하던 factory가 사실은 인스턴스 생성을 편-안하게 생성하기 위해 사용했던 것이었습니다!\n</tip>\n\n---\n\n## get, set\n\ngetter, setter 메서드를 이용해서 객체의 가상 멤버변수(`property`)를 읽고 쓰는게 가능해진다는 건 다른 객체지향 언어에도 있는 기능입니다.\ndart에선 이를 가능케 하는 키워드가 `get`, `set` 입니다.\n\n공식문서에 있는 코드를 분석해봅시다.\n\n```dart:.dart\nclass Rectangle {\n  double left, top, width, height;\n\n  Rectangle(this.left, this.top, this.width, this.height);\n\n  // right, bottom 이라는 두 개의 계산된 프로퍼티 정의.\n  double get right => left + width;\n  set right(double value) => left = value - width;\n  double get bottom => top + height;\n  set bottom(double value) => top = value - height;\n}\n\nvoid main() {\n  var rect = Rectangle(3, 4, 20, 15);\n\n  print(rect.right); // 23.0\n  print(rect.left);  // 3.0\n  rect.right = 20;\n  print(rect.right); // 20.0\n  print(rect.left);  // 0.0\n}\n```\n\n제 개인적인 생각에는 get은 가상의 멤버변수를 만들어서 이를 사용하게 해주고,\nset은 이 가상의 멤버변수를 위해 처리해야 하는 기능을 함수 내부에서 별도로 처리하게 해준다가 주된 사용법인거 같습니다.\n\n<notice>\n  제가 `가상`의 멤버변수라고 표현한 이유는, get으로 정의된 변수는 그 자체가 특정 값을 저장할 수 없고, 별도로 정의된 멤버변수에 의존해야 하기 때문입니다.\n</notice>\n\n### interface\n\n그렇다면 get, set을 언제 사용해야 잘 사용한걸까요?\n보통은 멤버변수를 `은닉화`하고 이를 `접근제어`를 할 때 사용하는 방식이 대부분일 것입니다.\n\n하지만, 개인적으로 `인터페이스`를 구현할 때 역시 get의 적절한 사용처라고 개인적으로 생각합니다.\n예를 들어봅시다.\n\n```dart:.dart {2}\nabstract class IColor {\n  String get color;\n}\n\nclass Car implements IColor {\n  final String name;\n  @override\n  final String color;\n\n  Car(this.name, this.color);\n}\n\nclass Boat implements IColor {\n  final String name;\n  @override\n  final String color;\n\n  Boat(this.name, this.color);\n}\n\nvoid main() {\n  Car car = Car('car1', 'red');\n  Boat boat = Boat('boat1', 'red');\n\n  print(car.color == boat.color); // true\n}\n```\n\n<tip>\n  dart에선 abstract class로 구현해도 될 정도로 interface의 의미가 약합니다.\n  최근에는 interface 키워드가 추가되었으나, implements 하는 것이 아닌 extends 해도 에러가 안 날정도로 중요하진 않은 거 같습니다.\n  abstract interface와 같이 키워드를 중복해서 쓰는 경우도 있으므로 자세한 내용은 [**`공식문서`**](https://dart.dev/language/class-modifiers#interface)를 참고해주세요.\n</tip>\n\n두 클래스간 `필요에 따라` 공통속성을 갖고싶게 할 때 interface를 사용하곤 하는데요,\ndart는 `null-safety` 언어이기 떄문에, get 키워드가 없다면 **abstract class라 하더라도 멤버변수를 초기화** 해줘야만 합니다.\n그러면 코드가 아래처럼 복잡해지겠죠.\n\n```diff-dart:.dart {2}\n  abstract class IColor {\n    String color;\n\n+   IColor(this.color);\n  }\n\n  class Car implements IColor {\n    final String name;\n    @override\n    final String color;\n\n    Car(this.name, this.color);\n\n+   @override\n+   set color(String _color) {\n+     color = _color;\n+   }\n  }\n```\n\n## stream\n\n비동기의 4번타자, `future`는 완료되지 않은 연산을 나타냅니다.\n비동기 함수가 return을 해야만 future은 연산이 완료되었다는 것을 알려줍니다.\n\n그에 반면, `stream`은 **일련, iterable**한 비동기 이벤트입니다.\n따라서 iterable과 같이 동작하게 됩니다만, 그 과정이 비동기인 것이죠.\n\n즉, future은 요청시 다음에 올 이벤트를 받는 방식이라면,\nstream은 준비가 된 후 이벤트가 있음을 알려주는 방식입니다.\n\n### async* / yield\n\n`async*`는 async와 마찬가치로 이 함수가 비동기 함수라는 것임을 선언하는 키워드 입니다.\n차이점은 이 함수는 `Stream<T>`을 반환하기 때문에 일련의 비동기로 연산된 결과를 반환하게 됩니다.\n즉, **지속적으로 값을 반환**하기 위해 `yield` 키워드가 return을 대신하여 값을 반환합니다.\n_(return 키워드는 여기서 사용 불가합니다)_\n\n예시를 살펴봅시다.\n\n```dart:.dart\nFuture<int> sumStream(Stream<int> stream) async {\n  var sum = 0;\n  await for (final value in stream) {\n    print('get stream value $value');\n    sum += value;\n  }\n  return sum;\n}\n\nStream<int> countStream(int to) async* {\n  for (int i = 1; i <= to; i++) {\n    await Future.delayed(Duration(milliseconds: 200));\n    print('stream $i ready');\n    yield i;\n  }\n}\n\nvoid main() async {\n  var stream = countStream(3);\n  var sum = await sumStream(stream);\n  print(sum);\n}\n```\n\n> (0.2초 대기)\n> stream 1 ready\n> get stream value 1\n> (0.2초 대기)\n> stream 2 ready\n> get stream value 2\n> (0.2초 대기)\n> stream 3 ready\n> get stream value 3\n> 6\n\nStream 역시 비동기로 처리되는 **일련**의 연산이라는 것을 알려주는 객체이기 때문에,\n실제 연산 결과를 받으려면 await을 사용해서 값이 전달받을 때 까지 대기해야 합니다.\n\n따라서, dart에서는 `await for` 키워드를 제공하여 iterable한 비동기 이벤트를 처리할 수 있도록 도와줍니다.\n\n<tip>\n  동기적은 `Iterable<T>` 객체를 반환하고 싶다면 `sync*` / `yield` 키워드를 사용하면 됩니다.\n</tip>\n\n<tip>\n  stream은 파일읽기와 같이 한 번의 요청이 있으면 처음부터 끝까지 끊김없이 진행되어야 하는 `Single subscription streams`, \n  브라우저의 마우스 이벤트와 같이 Observer pattern을 사용하기에 언제든지 누구나 stream을 들을 수 있는 `Broadcast streams` 으로 나뉩니다.\n  <br />\n  뿐만 아니라, stream은 iterable한 성격을 갖는다 했었는데, 이런 stream을 제어할 수 있는 여러 메서드 또한 존재합니다.\n  따라서 자세한 내용은 [**`공식문서`**](https://dart-ko.dev/tutorials/language/streams#working-with-streams)를 참고하시는걸 추천 드립니다.\n</tip>\n\n## mixin, with\n\n간단하게 말하면 class &rarr; `mixin`, extends &rarr; `with`와 같은 개념입니다.\n물론 이해를 돕기위해 위와같이 적었을 뿐, 완전히 다른 키워드이니 혼동하지 마시길 바랍니다.\n\n클래스를 상속할 때는 부모 클래스에서 미리 정의된 변수나 메서드를 자식 클래스에서 구현하지 않아도 바로 사용할 수 있습니다.\n하지만, 계층구조를 나타내기 위해 **반드시 한 개의 클래스를 상속**해야 한다는 단점이 있죠.\n\n여러개의 자료 구조를 공유하기 위해서는 인터페이스를 구현 하는 방법으로 사용해야 합니다.\n하지만, 인터페이스는 말 그대로 틀만 제공하고 **구현은 별도로 해야한다**는 단점이 있습니다.\n\n이 떄, extends와 implements의 **중간 포지션**에 위치한 키워드가 with이고, with은 mixin을 받을 수 있습니다.\n\n```dart:.dart\nmixin SwimBehabior {\n  void swim() {\n    print('swim');\n  }\n}\n\nmixin FlyBehiabior {\n  void fly() {\n    print('fly');\n  }\n}\n\nclass Duck {\n  final String name;\n\n  Duck(this.name);\n}\n\nclass RealDuck extends Duck with SwimBehabior, FlyBehiabior {\n  RealDuck(super.name);\n}\n\nclass RubberDuck extends Duck with SwimBehabior {\n  RubberDuck(super.name);\n}\n\nvoid main() {\n  RealDuck duck = RealDuck('duck');\n\n  duck.fly();\n  duck.swim();\n}\n```\n\n이런식으로 implements 처럼 여러 인터페이스를 사용할 수 있지만, extends 처럼 재정의할 필요 없이 사용할 수 있습니다.\n하지만, mixin을 사용할 때는 클래스 구성요소가 `매우 세분화` 되어있는게 좋습니다.\n이런저런 메서드를 잔뜩 만들어놓으면 상속했을 때 **필요없는 기능도 수행**할 수 있는 상황이 발생할 수 있기 때문입니다.\n\n이런 상황이 생길 가능성이 있는 코드는 mixin 보단 `Strategy pattern`으로 구현하는 것이 더 좋습니다.\n\n```dart:.dart {18, 22-24}\nabstract class SwimBehavior {\n  void swim();\n}\n\nabstract class FlyBehavior {\n  void fly();\n}\n\nclass CanSwim implements SwimBehavior {\n  @override\n  void swim() {\n    print('swim');\n  }\n}\n\nclass Duck {\n  final String name;\n  SwimBehavior swimBehavior;\n\n  Duck(this.name, this.swimBehavior);\n\n  void performSwim() {\n    swimBehavior.swim();\n  }\n}\n\nclass RealDuck extends Duck implements FlyBehavior {\n  RealDuck(String name) : super(name, CanSwim());\n\n  @override\n  void fly() {\n    print('fly');\n  }\n}\n\nclass RubberDuck extends Duck {\n  RubberDuck(String name) : super(name, CanSwim());\n}\n\nvoid main() {\n  RealDuck real = RealDuck('duck');\n  RubberDuck rubber = RubberDuck('duck');\n\n  real.performSwim();\n  real.fly();\n  rubber.performSwim();\n}\n```\n\n사실 mixin을 사용하지 않더라도 class의 `상속 depth를 깊게` 하는 방법도 있으니, 본인의 상황에 맞게 취사선택을 잘 하는 것이 좋은 개발습관이 될 것입니다.","slug":"flutter/005_dart_expert","readingMinutes":17,"wordCount":1610},{"title":"Dart 언어 심화","description":"Dart 언어에 대한 심화된 내용을 정리해봤습니다.","icon":"","image":"","tags":["Dart","Asynchronous","Isolate","Callback"],"draft":false,"date":"2023-09-15 / 11:24","content":"\n<notice>\n  기초적인 지식이 필요하신 분들은 [**`Dart 언어 기초`**](https://wjlee611.github.io/blog/flutter/003_dart_basic) 포스트를 읽어보시길 권장드립니다.\n</notice>\n\n## async / await\n\n`async`, `await` 키워드는 **비동기 프로그래밍**시 빠지지 않는 키워드입니다.\n여기서 `.then()` 메서드나 Dart 에서 `Future<T>` 도 포함해서 원리와 적절한 사용법까지 알아보고자 합니다.\n\n<tip>\n  `비동기 프로그래밍`\n  특정 코드가 완료되기 전, 다른 코드를 수행함으로서 코드의 실행 순서가 순차적(동기적)으로 실행되지 않는 프로그래밍 방식입니다.\n  보통 처리완료까지 시간이 많이 걸리는 네트워크 통신이나 파일 입출력 등에 많이 사용됩니다.\n</tip>\n\n<notice>\n  비동기 처리는 `단일 스레드(Dart의 경우 단일 Isolate) 환경`에서 이루어집니다.\n  따라서 비동기 처리를 한다고 해도, 비동기 함수가 `컴퓨팅 자원 사용량이 많다`면 해당 스레드(Isolate)는 `일시 정지`되는 현상이 발생할 수 있습니다.\n  <br />\n  이와 관련한 자세한 내용은 아래 [**`Isolate`**](https://wjlee611.github.io/blog/flutter/004_dart_advanced#isolate) 파트에서 다루겠습니다.\n</notice>\n\n### Future\n\n`Future` 객체는 지금 당장은 처리되지 않았지만, 미래에 처리가 완료될 데이터를 알려주는 객체입니다.\n예를 들어봅시다.\n\n```dart:.dart\nFuture<String> futureStr() async {\n  print('do something');\n  return Future.delayed(Duration(seconds: 2), () => 'future string');\n}\n\nvoid main() {\n  print('start');\n  print(futureStr());\n}\n```\n\n위의 futureStr() 함수는 호출 후 2초뒤에 'future string'을 반환하는 함수입니다.\n실행결과는 어떻게 될까요?\n\n> start\n> do something\n> Instance of 'Future\\<String\\>'\n> (2초 후 종료)\n\n답은 `future 객체` 입니다.\n어찌보면 당연합니다. `main` 함수는 비동기 함수도 아닐 뿐더러 futureStr의 리턴값은 `Future<String>` 이라고 명시해두었으니 말이죠.\n\n![230917-211924](/posts/004_dart_advanced/230917-211924.png)\n\nfuture는 `Uncompleted`, `Completed` 상태를 갖습니다.\n비동기 함수 호출시에 future은 Uncompleted 상태를 갖습니다.\n따라서 `Instance of 'Future<String>'`와 같은 결과를 출력한 것이죠.\n하지만 함수가 성공적으로 종료되면 future은 비로소 Completed 상태를 갖습니다.\n따라서 `future string`과 같은 결과를 출력하게 될 것입니다.\n\n사용자 입장에서는 Future 객체는 중요하지 않습니다. 중요한 것은 Future 객체가 처리되고 나서 반환되는 데이터인거죠.\n따라서, Future 객체의 처리(비동기 함수)를 원활히 하기위해 `async`, `await` 키워드를 사용하는 것입니다.\n\n### async\n\nasync 키워드는 이 함수가 비동기 처리를 수행하는 함수임을 명시하는 키워드 입니다.\n다만 위의 예시에서 보듯, 반드시 `Future<T>` 객체 또는 `void`를 반환해야만 합니다.\n\n그렇다면, main 함수를 async 키워드를 붙여 실행한다면 제대로된 결과가 나올까요?\n\n```dart:.dart\nFuture<String> futureStr() async {\n  print('do something');\n  return Future.delayed(Duration(seconds: 2), () => 'future string');\n}\n\nvoid main() async {\n  print('start');\n  print(futureStr());\n}\n```\n\n> start\n> do something\n> Instance of 'Future\\<String\\>'\n> (2초 후 종료)\n\n그렇습니다. 함수를 비동기 처리하는 함수로 선언한다고 해서 해결되지는 않습니다.\n함수 내부에서 비동기 처리가 진행될 수 있다는 것을 암시할 뿐, `어디서` 비동기 처리를 해야하는 지는 명시하지 않았기 때문이죠.\n\n### await\n\nawait 키워드는 **해당 키워드가 명시된 비동기 처리**(futureStr)가 완료될 때 까지 **비동기 함수**(main)의 처리를 `멈추겠다`는 의미입니다.\n그렇기에 await 키워드는 반드시 async 키워드가 명시된 함수 내부에서만 사용할 수 있는 것입니다.\n\n그렇다면 futureStr의 함수 앞에 await를 명시하여 비동기 함수가 끝날 때 까지 대기시킨다면 어떨까요?\n\n```dart:.dart\nFuture<String> futureStr() async {\n  print('do something');\n  // return Future.delayed(Duration(seconds: 2), () => 'future string');\n  await Future.delayed(Duration(seconds: 2));\n  return 'future string';\n}\n\n\nvoid main() async {\n  print('start');\n  print(await futureStr());\n}\n```\n\n> start\n> do something\n> (2초 대기)\n> future string\n> (즉시 종료)\n\n비로소 원하던 결과가 나왔습니다.\n\n---\n\n## Isolate\n\n`Isolate`는 Dart에서 스레드를 부르는 용어라고 생각하시면 됩니다.\n\n![230917-221122](/posts/004_dart_advanced/230917-221122.png)\n\nIsolate는 스레드와 마찬가지로 멀티 코어 CPU의 장점을 살리는 프로그래밍 기법으로 `별도의 이벤트 루프`를 갖는 실행 흐름을 만들어 `병렬적인 처리`를 가능케 합니다.\n하지만, 스레드와 용어에서의 차이점을 두는 이유가 있습니다.\n\n보통 **스레드**라 하면 `메모리 영역을 공유`한다고 배웠습니다. 하지만 그 때문에 `race-condition`이 발생하는 문제점을 고려하여 프로그래밍을 했어야 합니다.\n\n하지만, **Isolate**는 스레드와 다르게 `메모리 영역 또한 공유하지 않습니다`.(물론 코드 영역은 공유합니다) \n그렇기에 mutex, lock 등을 고려할 필요가 없는 편의성이 있습니다.\n\n하지만 왜 Isolate를 알아야 하고, 사용해야만 할까요?\n\n### Isolate vs Async\n\n아래의 영상을 확인해봅시다.\n\n<YT id='HkBaS098BrE' />\n\n`Main isolate`부분은 json 데이터 파싱과 화면 빌드를 `하나의 isolate`에서 구동한 결과입니다.\n영상에서 보시는 바와 같듯 십몇만줄의 json 파싱은 단일 isolate 환경에서 구동하기에는 다소 무리가 있습니다.\n아무리 async로 실행 결과를 뒤로 미룬다 할지라도 실제 데이터 파싱하는 동작과 화면을 그리는 동작 모두 `동일한 isolate`에서 처리되기 때문에 `성능상 이슈`가 생길 수 밖에 없습니다.\n\n하지만 `Worker isolate`부분은 json 데이터 파싱을 `별도의 worker isolate`에서 구동한 결과입니다.\n차이는 명확합니다. 화면에 그리는 동작과 파싱 동작이 `별도의 isolate`에서 처리되기 때문에 화면을 그리는 부분에서 `랙이 걸리지 않습니다`.\n\n이렇듯 단일 isolate에서 동작이 버벅일 정도로 무거운 기능을 수행해야 한다면, 해당 기능은 별도의 isolate로 빼서 처리하는 것이 사용자에게 더 나은 경험을 제공하게 됩니다.\n\n해당 영상에서 구동하는 코드는 [**`Arkhive repo`**](https://github.com/wjlee611/arkhive/blob/main/lib/bloc/enemy/enemy_data/enemy_data_bloc.dart)에서 확인하실 수 있습니다.\n\n---\n\n## function\n\n### callback function\n\n콜백 함수는 함수의 인자로 넘겨주어 넘겨받은 함수 내부에서 실행 가능한 함수를 의미합니다.\n예시를 살펴봅시다.\n\n```dart:.dart\nvoid main() {\n  int value = 0;\n\n  print(valueModifire(value: value, modifire: add1)); // 1\n  print(valueModifire(value: value, modifire: sub1)); // -1\n}\n\nint add1(int value) => value + 1;\nint sub1(int value) => value - 1;\n\nint valueModifire({\n  required int value,\n  required Function(int) modifire,\n}) {\n  return modifire(value);\n}\n```\n\n위 코드에서는 `valueModifire`의 인자로서 `add1`, `sub1`을 전달했습니다.\n이 때, 이 두 함수를 `callback function`라고 부르고, 이 함수는 valueModifire 내부에서 `modifire`의 형태로 호출됩니다.\n\n보통은 이런식으로 `동일한 함수` 내부에서 `서로 다른 기능`을 수행해야 할 때 콜백 함수로서 전달하는 경우가 많습니다.\n\n```dart:.dart\nvoid main() async {\n  int value = 0;\n\n  print(await valueModifire(value: value, modifire: add1)); // await 1 second -> 1\n  print(await valueModifire(value: value, modifire: sub1)); // await 1 second -> -1\n}\n\nint add1(int value) => value + 1;\nint sub1(int value) => value - 1;\n\nFuture<int> valueModifire({\n  required int value,\n  required Function(int) modifire,\n}) async {\n  await Future.delayed(Duration(seconds: 1)); // something actions\n  return modifire(value);\n}\n```\n\n또는, `특정 함수의 동작이 끝난 후` 수행해야 할 기능이 있을 때 많이 사용되곤 합니다.","slug":"flutter/004_dart_advanced","readingMinutes":10,"wordCount":836},{"title":"Dart 언어 기초","description":"Dart 언어에 대한 기초지식을 정리해봤습니다.","icon":"","image":"","tags":["Dart"],"draft":false,"date":"2023-09-14 / 17:41","content":"\n<warning>\n  제가 생각하기에 **너무 기초지식**이다 하는 부분은 과감하게 **제외**했습니다.\n  다만, 기초지식이다 하더라도 `개념적으로 매우 중요`하거나 `많이들 알려주지 않는 내용`은 포함하였습니다.\n</warning>\n\n## variables\n\n변수 네이밍 방법은 다음과 같습니다.\n\n```dart:.dart\n  <제어자> <타입> <변수이름> = <값>;\n```\n\n타입은 int, String 과 같은 타입들이 오거나, `var` 와 같은 타입 추론 키워드도 사용할 수 있습니다.\n제어자에는 `final`, `const`, `late`, `static` 와 같은 키워드가 오게 됩니다.\n\n### var\n\ndart에선 var는 타입 추론 키워드로 사용되는 예약어입니다.\n따라서 `<값>`에 어떤 데이터가 오는지에 따라 변수의 타입이 결정됩니다.\n단, 값을 지정하지 않을 때는 `dynamic` 타입으로 자동 결정됩니다.\n\n<tip>\n  `dynamic?`\n  타입 안정성이 보장되지 않지만, 모든 타입의 데이터를 할당할 수 있도록 해줍니다.\n  보통 json 파일을 파싱할 때 임시로 데이터 형식을 지정할 때 많이 사용합니다.\n</tip>\n\n### final vs const\n\n`final`과 `const` 둘 모두 데이터의 불변성을 보장하고 싶을 때 사용하는 키워드 라는 점에서는 공통점을 갖습니다.\n또한, 이 키워드를 사용한다면 타입을 굳이 지정하지 않아도 알아서 `var`로 타입을 지정하는 효과가 있습니다.\n하지만 둘 사이의 중요한 차이점이 있습니다.\n\n`final`은 런타임에 값이 지정됩니다.\n따라서 메모리상의 `heap 영역`에 데이터가 저장됩니다.\n그렇기에 생명주기는 스코프 내부로 한정되기 떄문에 flutter 에서 **build 메서드**가 호출될 때 이 부분은 `반복적`으로 메모리에 올라왔다 내려갔다를 반복하게 됩니다.\n\n`const`는 컴파일타임에 값이 지정됩니다.\n특이한 점인 const 키워드로 지정된 데이터는 메모리상에 별도로 적재되지 않고, `컴파일된 코드의 상수 풀(constant pool)`상에 저장됩니다.\n따라서 별도의 인스턴스가 생성되지 않고, 생명주기도 프로그램 수명과 동잃하기에 flutter 에서 **build 메서드**가 호출될 때 이 부분은 `다시 랜더링되지 않습니다`.\n\n### late\n\ndart는 **null-safety** 언어입니다.\n따라서 `<타입>?` 와 같이 `?`로 null값이 가능하다고 지정해 주지 않는한 변수 선언시(혹은 인스턴스 생성시) 반드시 값을 지정해야 합니다.\n하지만, `late`의 경우에는 인스턴스 생성 시점에 null값을 허용하지만, 이후에 `단 한번` 값을 할당할 수 있도록 해주는 키워드입니다.\n\n물론, null값이 임시 허용이 되는만큼 사용에 주의가 필요합니다.\n\n### static\n\n`static`은 클래스가 로드될 때 값이 지정됩니다.\n따라서 heap영역이 아닌 `클래스 자체 메모리 영역`에 저장됩니다.\n그렇기에 일반 메서드에선 static 변수에 접근할 수 있지만, static 메서드에선 일반 변수에 접근할 수 없습니다.\n하지만 그렇기에 클래스를 인스턴스화 하지 않아도 바로 접근이 가능합니다.\n\n---\n\n## function\n\ndart는 사실 js를 대체하기 위해 나온 언어라고 합니다.\n그래서일까요, dart의 모든 데이터 타입도 사실은 모두 `Object`입니다.\n\n뿐만 아니라, `변수에 함수를 할당`하거나, `익명 함수`, `람다 함수` 모두 사용 가능합니다.\n\n### named parameter\n\n보통 함수의 파라미터는 아래와 같이 작성하곤 합니다.\n\n```dart:.dart\n  void myFunction(int num) {\n    ...\n  }\n  ...\n  myFunction(1);\n```\n\n하지만 입력받고자 하는 파라미터가 많아진다면, 인자를 넘겨줄 때 어느 자리에 어느 데이터를 넘겨야 할지 알기가 어렵습니다.\n특히 flutter에서는 위젯을 만들 때 인자를 십수개씩 넘기는 경우가 많죠...\n\n그렇기에 `named parameter` 기능을 제공합니다. (마치 js에서 객체를 인자로 넘기 듯)\n\n```dart:.dart\n  void myFunction({required int myNum}) {\n    ...\n  }\n  ...\n  myFunction(myNum: 1);\n```\n\n이렇게 하면 함수 호출이나, 클래스 생성자 호출시 어느 인자에 어느 데이터를 넘겨야 하는지 명확해집니다.\n\n물론, 위 두 방식을 `혼합`하여 사용할 수도 있습니다.\n\n```dart:.dart\n  void myFunction(String str, {required int val}) {\n    ...\n  }\n  ...\n  myFunction(\"string\", myNum: 1);\n```\n\n---\n\n## class\n\n### constructor\n\n```dart:.dart\nclass Car {\n  final String color;\n  int wheels;\n  String? name;\n\n  Car({\n    required this.color,\n    required this.wheels,\n    this.name,\n  });\n}\n```\n\n기본적으로 생성자는 위와 같이 정의할 수 있습니다.\n`named parameter` 형식으로도 사용이 가능합니다. (대부분의 flutter 위젯은 위와 같이 정의합니다)\n\n### named constructor\n\n```dart:.dart\nCar {\n  final String color;\n  late int wheels;\n  String? name;\n\n  Car.fourWheels({required this.color, this.name}) {\n    this.wheels = 4;\n  }\n}\n```\n\n클래스를 생성할 때 특별한 기능을 붙인채로 인스턴스화 할 수 있도록 `named constructor`를 지원합니다.\n보통 초기상태를 위한 `.init`, 모델링을 위한 `.fromJson`와 같이 쓰이곤 합니다.\n(참고로 이 때 factory 키워드를 이용해서 싱글톤 패턴으로 많이 구현하는데 이는 다음에 소개하겠습니다)\n\n### initializer list\n\n위에 `wheels`을 별도로 초기화하기 위해 late 한정자를 사용했는데요, 보기가 안좋습니다.\n`final` 멤버변수는 생성자 body에서 값을 지정할 수 없기에 저런식으로 표현했는데요,\n`initializer list`를 이용하면 final 멤버변수도 생성자 호출시 별도로 처리할 수 있습니다.\n\n```dart:.dart\nclass Car {\n  final String color;\n  final int wheels;\n  String? name;\n\n  Car.prototype({required this.color}) : wheels = 4 {\n    this.name = 'proto';\n  }\n}\n```\n\n`:`를 붙여 `: wheels = 4`와 같이 사용할 수 있습니다.\n또한, 뒤에 body를 붙여 추가작업 또한 할 수 있습니다.\n\ninitializer **list**에서 알 수 있듯 `wheels = 4` 와 같은 initializer를 `,`를 이용해서 여려개 연달아 초기화할 수 있습니다.\n\n### redirecting constructor\n\n```dart:.dart\nclass Car {\n  final String color;\n  final int wheels;\n  String? name;\n\n  Car({\n    required this.color,\n    required this.wheels,\n    this.name,\n  });\n\n  Car.fourWheels({required String color, String? name})\n      : this(\n          color: color,\n          wheels: 4,\n          name: name,\n        );\n}\n```\n\n기존의 생성자를 `this`로 호출하여 named constructor를 구현한 방식입니다.\n다만, 이 경우에는 생성자의 body를 구현할 수 없습니다.\n","slug":"flutter/003_dart_basic","readingMinutes":9,"wordCount":703},{"title":"플러터 프로젝트 만들기","description":"플러터 프로젝트 생성 가이드 입니다.","icon":"","image":"","tags":["Flutter","Getting started"],"draft":false,"date":"2023-09-14 / 16:37","content":"\n## 시작 전 주의사항\n\n<notice>\n  이 포스트에선 플러터 프로젝트를 생성하는 방법을 다뤄봅니다.\n  따라서 플러터 SDK 설치나, 관련 환경설정이 안되신 분은 [**`플러터 시작하기`**](https://wjlee611.github.io/blog/flutter/001_installation)를 꼭 읽어보시고 다시 와주시기 바랍니다.\n</notice>\n\n<notice>\n  본 블로그의 플러터 개발환경은 `VSCode`와 `터미널`로 고정됩니다.\n  따라서 다른 개발환경에 대한 정보는 없으므로 이 점 참고 부탁드립니다.\n</notice>\n\n## 프로젝트 생성\n\n프로젝트 생성을 위해 우선 본인이 프로젝트를 관리할 폴더로 이동해주세요.\n제 경우에는 깃허브로 버전관리를 하는 프로젝트의 경우 `~/Documents/GitHub` 폴더에서 일괄적으로 관리하는 편입니다.\n\n```bash:Terminal\ncd ~/Documents/GitHub\n```\n\n이후에는 아래의 명령어로 플러터 프로젝트를 생성합니다.\n\n```bash:Terminal\nflutter create <proj_name>\n```\n\n이 때, 프로젝트를 생성할 때 알아두면 유용한 (거의 필수) 몇 가지 옵션을 소개드립니다.\n\n### --org\n\n이 옵션을 지정하면 프로젝트를 생성할 때 패키지명을 지정할 수 있습니다.\n\n```bash:Terminal\nflutter create <proj_name> --org <package_name>\n```\n\n<notice>\n  \\<package_name\\>이 100% 동일하게 패키지 이름이 되는 것은 아닙니다.\n  옵션명에서 유추할 수 있듯 기관의 이름을 적는 것입니다.\n\n  따라서 진짜 패키지 이름은 `<package_name>.<proj_name>` 형식이 됩니다.\n</notice>\n\n예로들어 아래와 같이 프로젝트를 생성했다고 가정해봅시다.\n\n![230914-164837](/posts/002_project_initalize/230914-164837.png)\n\n이 경우에는 프로젝트명 - `gdsc_study` / 패키지명 - `com.gmail.wjlee611` 입니다.\n따라서 프로젝트에서 실제로 적용되는 패키지명은 아래와 같아집니다.\n\n![230914-165226](/posts/002_project_initalize/230914-165226.png)\n\n> Android - `com.gmail.wjlee611.gdsc_study`\n> iOS - `com.gmail.wjlee611.gdscStudy`\n\n같은 명령어라도 다른 패키지명이 생성되니 나중에 앱을 배포할 때 반드시 패키지명을 확인하도록 합시다.\n\n### -i swift\n\n기본적으로 생성되는 iOS 코드는 `Objective-C` 입니다.\n하지만 이 옵션을 추가하면 `Swift`로 생성되게 됩니다.\n\n### -a kotlin\n\n기본적으로 생성되는 Android 코드는 `Java` 입니다.\n하지만 이 옵션을 추가하면 `Kotlin`으로 생성되게 됩니다.\n\n\n","slug":"flutter/002_project_initalize","readingMinutes":3,"wordCount":223},{"title":"플러터 시작하기","description":"플러터 설치 및 VSCode 세팅 가이드입니다.","icon":"","image":"","tags":["Flutter","VSCode","Package manager"],"draft":false,"date":"2023-09-13 / 21:12","content":"\n## 들어가며...\n\n이 포스트에선 플러터(Flutter) 개발을 시작할 때 세팅해야할 전 과정에 대해 설명합니다.\nFlutter SDK 설치부터 에뮬레이터 세팅, VSCode 세팅, 추가로 유용한 단축키에 대해서 알아봅니다.\n다만, 단축키는 운영체제, 에디터 환경, 설정에 따라 다를 수 있으니 이점 참고 바랍니다.\n\n<notice>\n  **이미 설치를 완료하신 분들도 시간 내셔서 [**`VSCode 세팅`**](https://wjlee611.github.io/blog/flutter/001_installation#vscode-%EC%84%B8%ED%8C%85)부터 읽어보시는 것을 강력 추천드립니다.**\n</notice>\n\n블로그 주인장은 M1 Mac 환경에서 세팅하였기에 리눅스 계열 세팅방법을 기준으로 다뤄봅니다만,\n윈도우 머신에서의 세팅도 다뤄볼 겁니다. (다만, 실제 테스트는 하지 않았기에 오류가 있을지도 모릅니다)\n\n참고로 아래의 모든 설치과정은 [**노마드코더**](https://nomadcoders.co/flutter-for-beginners)의 강좌를 정리한 자료입니다.\n\n- https://nomadcoders.co/flutter-for-beginners/lectures/4133\n- https://nomadcoders.co/flutter-for-beginners/lectures/4142\n\n---\n\n## Flutter SDK 설치\n\nFlutter SDK를 설치할 때 방법이 크게 두 가지로 나뉩니다.\n첫 번째는 Flutter 공식 사이트에서 제공하는 방식을 따라가는 방법\n두 번째는 패키지 매니저를 이용해서 설치하는 방법\n\n제 개인적인 생각에는 패키지 매니저를 이용하는 방법이 더 간단해 보입니다.\n첫 번째 방법을 따라하려면 환경 PATH도 설정해야 하기에 좀 무서워 보이기 때문이죠...\n~_(그리고 제가 이 방법밖에 안해보기도 했구요...)_~\n\n그래도 일단은 두 방법 모두 소개해 드리겠습니다.\n\n### 공식 사이트\n\n1. [**플러터 공식 페이지**](https://flutter.dev)로 접속합니다.\n\n2. `Get started`로 들어갑니다.\n   ![230913-211858](/posts/001_installation/230913-211858.png)\n\n3. 본인 운영체제에 맞는 Flutter SDK를 설치합니다.\n   ![230913-212121](/posts/001_installation/230913-212121.png)\n\n   이후에는 공식 사이트에서 제공하는 문서를 천천히 따라하시면 됩니다.\n\n---\n\n### 패키지 매니저 (MacOS)\n\n1. [**Homebrew**](https://brew.sh/)에 들어갑니다.\n   ![230913-214251](/posts/001_installation/230913-214251.png)\n\n<notice>\n  _참고로 Homebrew는 MacOS에서 사용할 수 있는 **대부분의 개발자도구를 터미널로 설치할 수 있는 강력한 도구**입니다._\n  _Flutter가 아니더라도 **반드시** 설치하는게 정신건강에 이롭습니다._\n</notice>\n\n2. `터미널`을 열어줍니다.\n\n3. 아래의 명령어를 입력하여 Homebrew를 설치합니다.\n   (공식 사이트에서 복사하는 것을 권장합니다)\n\n```bash:Terminal\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n4. 아래의 명령어로 Flutter SDK를 설치합니다.\n\n```bash:Terminal\nbrew install --cask flutter\n```\n\n---\n\n### 패키지 매니저 (Windows)\n\n1. [**Chocolatey - individual**](https://chocolatey.org/install#individual)에 들어갑니다.\n   ![230913-213419](/posts/001_installation/230913-213419.png)\n\n2. `PowerShell`을 관리자 권한으로 실행합니다.\n\n3. 아래의 명령어를 입력하여 Chocolatey를 설치합니다.\n\n```shell:PowerShell\nGet-ExecutionPolicy\n```\n\n만약 `Restricted` 라고 뜬다면 아래의 명령어 중 하나를 입력하면 됩니다.\n\n```shell:PowerShell\nSet-ExecutionPolicy AllSigned\n또는\nSet-ExecutionPolicy Bypass -Scope Process\n```\n\n그 이후에 아래의 긴- 명령어를 입력합니다.\n(공식 사이트에서 복사하는 것을 권장합니다)\n\n```shell:PowerShell\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n```\n\n`Chocolatey` 설치가 완료되었다면 `choco` 라는 명령어가 실행 가능할 겁니다.\n\n4. 아래의 명령어로 Flutter SDK를 설치합니다.\n\n```shell:PowerShell\nchoco install flutter\n```\n\n### 설치 확인 방법 (1)\n\n터미널 창에 `flutter` 를 입력해봅시다.\n`Command not found` 와 같은 에러를 제외하고 뭐라도 뜬다면 설치가 완료된 것입니다.\n\n---\n\n## 애뮬레이터 설치\n\n아래의 공식 문서를 통해 설치하는 것이 가장 바람직합니다.\n설명도 친절해서 왠만하면 설치하는데 문제가 없을겁니다. (아예 없진 않음...)\n관련 링크를 아래에 정리합니다.\n\n🫧[**MacOS - ios setup**](https://docs.flutter.dev/get-started/install/macos#ios-setup)\n🫧[**MacOS - android setup**](https://docs.flutter.dev/get-started/install/macos#android-setup)\n\n🫧[**Windows - android setup**](https://docs.flutter.dev/get-started/install/windows#android-setup)\n\n### 설치 확인 방법 (2)\n\n터미널 창에 `flutter doctor` 를 입력해봅시다.\n![230913-220216](/posts/001_installation/230913-220216.png)\n\nSDK, 애뮬레이터, 에디터까지 발생하는 문제사항을 한 눈에 파악할 수 있습니다.\n\n<tip>\n  참고로 최초 실행시 안드로이드 라이센스에 동의하라는 에러 혹은 경고가 나타날 수 있습니다. \n  그럴 땐 당황하지 마시고 아래의 명령어를 입력하면 됩니다.\n  (_설치할 때 꼼꼼히 읽어보면 이런 내용도 있다는 걸 확인할 수 있죠..._)\n\n  <br />\n\n  ```bash:Terminal\n  flutter doctor --android-licenses\n  ```\n</tip>\n\n### Troubleshooting\n\n간혹가다 Xcode `command line tools`에서 문제가 발생하는 경우가 있습니다.\n명령어 라인 도구는 Xcode를 설치할 때 자동적으로 설치됩니다.\n\n하지만 제 경우에는 Xcode를 설치하기 전에 아래의 명령어로 미리 설치한 적이 있었습니다.\n\n```bash:Terminal\nxcode-select --install\n```\n\n명령어 라인 도구를 먼저 설치하고 Xcode를 설치하면 가끔 정상동작하지 않는 에러가 발생하는 거 같습니다.\n이런 경우에는 명령어 라인 도구를 제거하고 다시 설치하면 해결됩니다.\n\n---\n\n## VSCode 세팅\n\n사실 마켓플레이스에서 `Flutter`, `Dart` 확장을 설치하기만 하면 개발할 준비가 끝나긴 합니다.\n하지만, 개발 편의성과 코드 통일을 위해서 필요한, 혹은 유용한 `확장`과 `setting.json`을 공유할까 합니다.\n\n### setting.json\n\n아래와 같은 키값을 추가하면 개발에 있어 편의성이 증진됩니다.\n하지만, 설정을 건드릴 땐, 본인의 설정과 충돌이 생기는지 반드시 확인한 후에 추가하시는 것을 권장합니다.\n\n참고로, setting.json은 `명령 팔레트`를 열고 `settings.json`을 검색하면 바로 나옵니다.\n또 참고로, 명령 팔레트는 `Command(Window) + Shift + P` 명령어 조합으로 열 수 있습니다.\n\n```json:settings.json showLineNumbers\n{\n  ...\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll\": true\n  },\n  \"dart.previewFlutterUiGuides\": true,\n}\n```\n\n`Line 3-5`의 설정은 자동으로 필요한 모든 곳에 `const` 키워드를 삽입해주는 설정입니다.\nflutter에서 const를 사용하는 것은 매우 중요한데 그 이유에 대해서는 다음에 설명하도록 하겠습니다.\n일단은 가능하다면 반드시 const를 붙이는게 좋고, 이를 자동으로 붙여줄 수 있다는 것만 기억합니다.\n\n`Line 6`의 설정은 flutter 위젯을 트리 구조로 선으로 연결해주는 설정입니다.\n![230913-222546](/posts/001_installation/230913-222546.png)\n\nflutter은 위젯의 depth가 깊어지는 단점이 있는데 이를 어느정도 극복하게 해주는 유용한 설정입니다.\n\n### Error Lens\n\n![230913-223129](/posts/001_installation/230913-223129.png)\n\nError Lens는 코드 문제의 원인을 에디터상에 바로 띄워주는 확장입니다.\n실시간으로 무슨 에러가 있는지 한 눈에 확인할 수 있는게 개인적으로 매우 만족하면서 사용하고 있습니다.\n\n![230913-223528](/posts/001_installation/230913-223528.png)\n\n개인적으로 눈뽕(?) 방지를 위해 `line` 이 아닌, `message` 로 설정하는 것을 추천드립니다.\n\n![230913-224036](/posts/001_installation/230913-224036.png)\n\n또한, 분석 레벨에서 `info` 는 제거해주시는 것을 추천 드립니다.\n\nflutter의 경우 info가 중첩되서 뜨는 경우가 많기에 위 두 세팅을 바꾸지 않으면 아래와 같은 눈뽕(?)을 자주 겪게 될 지도 모릅니다...\n![230913-223954](/posts/001_installation/230913-223954.png)\n\n### Image preview\n\n![230913-224456](/posts/001_installation/230913-224456.png)\n\nImage preview는 로컬, 네트워크 이미지를 미리보기 형식으로 띄워주는 확장입니다.\nFE 개발 입장에서 이미지나 svg, icon을 사용할 일이 많은데, 이를 미리볼 수 있다는 것 만으로도 많은 시간을 절약할 수 있습니다.\n\n---\n\n## VSCode 단축키\n\n개발 시간을 줄여주는 유용한 단축키 및 snippets 를 소개합니다.\n\n### Code Action\n\n![230913-224956](/posts/001_installation/230913-224956.png)\n\nflutter 개발을 하다보면 중간에 위젯을 다른 위젯으로 감싸거나, 부모 위젯을 통째로 드러내야 하는 경우가 잦은데,\n이를 일일이 코드를 잘라내고 붙여넣기 하는건 매우 귀찮은 작업입니다.\n\n하지만 이 기능을 수행하는데 있어 Code Action은 매우 유용한 도구들을 제공합니다.\n\n기능을 수행하고자 하는 위젯의 좌측에 `💡(전구) 모양 아이콘`을 클릭하면 해당 위젯에서 수행할 수 있는 여러 기능들을 보여줍니다.\n\n또는 `Command(Window) + .` 단축키로 빠르게 Code Action에 접근할 수 있습니다.\n매우매우 자주쓰는 기능이니 본인 에디터 환경에 맞는 단축키를 외우도록 합시다.\n~_(사실 외울 필요도 없이 쓰다보면 손가락이 알아서 움직이게 된다는...)_~\n\n### Intellisense\n\n쉽게 말하면 `코드 추천 + 자동완성` 기능입니다.\n\n코드를 입력하다 보면 자동으로 코드를 추천해줄텐데, 실수로 이를 꺼버리는 일이 발생합니다.\n이 경우 코드를 지웠다가 다시 치는 것 보단, `Option(Alt) + Space`로 다시 활성화 시키는 것이 더 유용합니다.\n\n### st + (intellisense)\n\n![230913-230035](/posts/001_installation/230913-230035.png)\n\n플러터의 위젯의 대부분은 Stateful, Stateless 위젯을 상속 받습니다.\n그에 따라 여러 메서드를 override해서 사용해야만 하는데요,\n이 모든 코드를 일일이 입력하는 것도, 기억하는 것도 쉽지 않습니다.\n\n이 경우에는 `st`를 입력하고 intellisense 기능을 이용하면 VSCode가 알아서\nStateful, Stateless 위젯의 필수 부분을 알아서 완성해주고,\n클래스 이름과 관련한 부분 모두를 선택한 상태로 사용자의 입력을 기다리게 됩니다.\n\n따라서 사용자는 아래의 절차를 밟으면 간단하게 위젯 하나를 생성할 수 있게 됩니다.\n\n1. st + (intellisense)\n2. 원하는 부모위젯(Stateful, Stateless) 선택\n3. 원하는 클래스 이름 입력\n\n## 마무리\n\n지금까지 Flutter SDK 설치부터 VSCode 단축키까지 개발에 앞서 필요한 모든 준비단계를 알아봤습니다.\n추가로 필요한 설정이나 기능은 알아보시고 추가하여 사용하신다면, 개발이 조금이라도 더 즐거워지리라 생각됩니다.\n\n긴 글 읽어주셔서 감사드리고, 모두 알찬 `Flutt-er` 생활 되시길 바랍니다!\n","slug":"flutter/001_installation","readingMinutes":14,"wordCount":1023},{"title":"상태공간 & 탐색","description":"상태공간과 탐색의 의미와 예시를 알아봅니다.","icon":"","image":"","tags":["Depth First Search","Breadth First Search","Depth Limited Search","Best First Search","Beam Search","A* Algorithm"],"draft":false,"date":"2023-09-12 / 15:44","content":"\n## 상태공간\n\n문제 해결 과정에서 초기 상태로부터 도달할 수 있는 모든 상태들의 집합을 의미한다.\n한 마디로 `문제의 해가 될 가능성`이 있는 모든 상태들의 집합을 의미한다.\n\n## 탐색\n\n상태공간에서 최적의 해를 찾기위해 공간을 체계적으로 찾아보는 것을 의미한다.\n탐색은 아래와 같은 방식으로 크게 구분지을 수 있다.\n\n1. 맹목적 탐색\n2. 정보이용 탐색\n\n이렇게 구분짓는 이유는 탐색의 방식에 따라 달라지는데,\n탐색 방식이 다양해 질 수 밖에 없는 이유는 일반적인 문제에서는 상태공간이 매우 크기 때문에\n미리 공간 그래프를 그릴 수 없어 탐색 과정에서 그래프를 생성할 수 밖에 없기 때문이다.\n\n---\n\n## 맹목적 탐색\n\n정해진 순서에 따라 상태공간 그래프를 점차 생성해 가면서 해를 탐색하는 방법을 의미한다.\n\n### 깊이 우선 탐색 (Depth-first search)\n\n![231021-223045](/posts/mid_01/231021-223045.png)\n\n초기 노드부터 깊이가 깊어지는 방향으로 우선 탐색하는 기법.\n더이상 진행할 수 없다면 백 트리킹으로 돌아와 다음 노드 탐색.\n\n루트 노드에서 현재 노드까지의 경로 하나만 유지한다는 특징이 있기에 메모리 공간 사용이 효율적이라는 장점이 있다.\n하지만, 깊이가 무한히 깊어지는 무한루프의 가능성 때문에 항상 최단 경로의 해를 보장할 수 없다는 단점이 있다.\n\n### 너비 우선 탐색 (Breadth-first search)\n\n![231021-223311](/posts/mid_01/231021-223311.png)\n\n초기 노드부터 시작하여 모든 자식 노드를 확장하여 탐색하는 기법.\n목표 노드가 없다면 단말 노드에서 다시 자식노드 확장 탐색.\n\n최단 경로의 해를 보장하지만, 메모리 효율적이지 못하다.\n\n### 깊이 제한 탐색 (Depth-limited search)\n\n![231021-223510](/posts/mid_01/231021-223510.png)\n\n기본적인 탐색 방식은 깊이 우선 탐색 방식임.\n단, 깊이에 제한을 둬서 특정 깊이 이하로는 탐색을 진행하지 않고 백 트래킹 하는 것이 특징임.\n특정 깊이에서 목표를 찾지 못한 경우 깊이를 늘려가며 처음부터 다시 탐색을 진행함.\n\n최단 경로의 해를 보장하며, 메모리 사용도 효율적이다.\n상위 노드는 반복해서 탐색하기에 약간의 비효율성이 있으나, 무시할만한 수준임.\n\n즉 맹목적 탐색시에는 이 방식을 우선적으로 고려하는 것이 좋음.\n\n---\n\n## 정보이용 탐색\n\n휴리스틱한 방법으로 목표까지의 예상 비용을 구하고, 그 값에 의거해 순간순간 최선의 선택을 해가며 탐색하는 방법을 의미한다.\n\n<tip>\n  `휴리스틱 (heuristic)`\n  신속하게 어림짐작 하는 것.\n</tip>\n\n### 언덕 오르기 방법 (Hill climbing method)\n\n![231021-224206](/posts/mid_01/231021-224206.png)\n\n현재 노드에서 휴리스틱에 의한 평가값이 가장 좋은 이웃 노드 하나를 확장해가는 탐색기법.\n단, 국소 최적해에 빠질 가능성이 있다.\n(경사 하강법과 유사)\n\n### 최상 우선 탐색 (Best-first search)\n\n확장 중인 노드들 중에서 목표 노드까지 남은 거리가 가장 짧은 노드를 확장하여 탐색하는 기법.\n일종의 그리디한 방식임.\n\n![231021-224403](/posts/mid_01/231021-224403.png)\n\n예시로 휴리스틱 함수를 제자리가 아닌 타일의 개수라고 할 때, 다음과 같은 순서로 탐색을 진행하게 된다.\n\n> a &rarr; c &rarr; e/f &rarr; h &rarr; j\n\n### 빔 탐색 (Beam search)\n\n최상 우선 탐색(BFS) 의 확장판으로, 휴리스틱에 의한 평가값이 우수한 일정 개수(K개)의 확장 가능한 노드만을 메모리에서 관리하면서 탐색.\n\n![231021-224723](/posts/mid_01/231021-224723.png)\n\n예시로 K=2일 때, A~E를 일단 탐색하고, 평가값이 우수한 B, E를 제외한 노드는 메모리에서 제거하며 B, E에서 그 자식노드에 대해 같은 방식을 적용하며 탐색한다.\n\n### A* 알고리즘 (A-star algorithm)\n\n최상 우선 탐색(BFS) 의 개선판으로, 휴리스틱에 의한 평가값 + 현재까지의 코스트의 결과인 휴리스틱한 전체 비용을 기준으로 탐색하는 기법.\n\n![231021-225028](/posts/mid_01/231021-225028.png)\n\n최초 상태를 탐색한 후, 그 자식 노드 3개의 휴리스틱한 전체 비용을 계산하면 `1(현재까지의 코스트)+3(휴리스틱 평가값)`의 값을 갖는 가운데 자식 노드가 비용이 가장 작기에 다음 탐색 대상으로 한다.\n\n이런 식으로 **탐색한 모든 노드를 메모리 상에서 관리**하며, 그 순간 휴리스틱 전체 비용이 가장 낮은 노드를 다음 탐색 대상으로 삼는다.","slug":"univ_ai/mid_01","readingMinutes":7,"wordCount":479},{"title":"Observer Pattern","description":"Observer 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Observer Pattern","interface"],"draft":false,"date":"2023-09-11 / 10:33","content":"\n## Strategy Pattern\n\n[**저번 포스트**](https://wjlee611.github.io/blog/univ_design-pattern/mid_01)에서 배운 `Strategy 디자인 패턴`을 이용해서 한 가지 예를 살펴보자.\n\n```java:WeatherData.java {7} showLineNumbers\npublic class WeatherData {\n  public void measurementsChanged() {\n    float temp = getTemperature();\n    float humidity = getHumidity();\n    float pressure = getPressure();\n\n     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n    currentConditionsDisplay.update(temp, humidity, pressure);\n    statisticsDisplay.update(temp, humidity, pressure);\n    forecastDisplay.update(temp, humidity, pressure);\n  }\n}\n```\n\n이 코드는 `Display`장치들이 `WeatherData`에서 제공하는 데이터를 이용하려는 코드이다.\n\n예로 들어 `forecastDisplay`에서 날씨 정보를 출력하기 위해서는\n`WeatherData`에서 `forecastDisplay.update()` 메서드를 호출해야\n날씨 정보가 비로소 `forecastDisplay`로 전달되는 것이다.\n\n### 문제점\n\n여기서 문제가 발생한다.\n만약 새로운 장치 futureDisplay를 구현하려면 Strategy Pattern을 사용하는 코드는 아래와 같은 코드수정이 필요해진다.\n\n1. update() 전략을 갖고있는 인터페이스로 구현한 전략(Display) 클래스를 만든다.\n2. `Line 7`에 새로운 장치를 등록한다.\n\n지금 당장은 문제될게 없어 보이지만, 만약 당신이 WeatherData를 `라이브러리화 해서 배포`하는 입장일 경우를 고려해보자.\n`사용자`는 단지 새로운 Display를 추가하여 바로 날씨 정보를 받아오고 싶을 것이다.\n하지만, 위와 같은 코드라면 사용자는 라이브러리 파일을 뜯어서 WeatherData 클래스 내부에\n직접적으로 `새로운 Display를 의존성 주입`을 해줘야만 할 것이다.\n\n이 경우는 꽤나 치명적이다.\n생각해보면 우리가 사용하는 대부분의 라이브러리는 이런 과정을 겪지 않으니 말이다.\n\n따라서 이런 문제를 해결하기 위한 디자인 패턴이 필요하다.\n\n## Observer Pattern\n\nObserver Pattern의 정의는 다음과 같다.\n\n> 객체들이 1:N의 관계를 갖을 때, 한 객체의 상태가 변하면 다른 모든 객체들에 업데이트 통지가 떨어지는 관계로,\n> `객체(Subject)`와 `객체들(Observers)`간의 `종속성이 없는 관계`를 의미한다.\n\n코드로 살펴보며 이해해보자.\n\n### interface\n\n```java:IObserverPattern.java {1-5, 7-9}\npublic interface Subject {\n    public void registerObserver(Observer o);\n    public void removeObserver(Observer o);\n    public void notifyObservers();\n}\n\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\n\npublic interface DisplayElement {\n    public void display();\n}\n```\n\n위 코드는 Observer Pattern에서 사용하는 인터페이스이다.\n`1`의 입장인 클래스(Subject)는 `Subject 인터페이스`를 구현해야 하고,\n`N`의 입장인 클래스(Observers)는 `Observer 인터페이스`를 구현해야 한다.\n\n### Subject class\n\n```diff-java:WeatherData.java {24, 35}\n  public class WeatherData implements Subject {\n+   private ArrayList<Observer> observers;\n\n    public WeatherData() {\n      observers = new ArrayList<Observer>();\n    }\n\n+   @implements\n+   public void registerObserver(Observer o) {\n+     observers.add(o);\n+   }\n+\n+   @implements\n+   public void removeObserver(Observer o) {\n+     int i = observers.indexOf(o);\n+     if (i < 0) return;\n+     observers.remove(i);\n+   }\n+\n+   @implements\n+   public void notifyObservers() {\n+     for (int i=0; i<observers.length; i++) {\n+       Observer o = observers.get(i);\n+       o.update(temp, humidity, pressure);\n+     }\n+   }\n\n    public void setMeasurements(float temp, float humidity, float pressure) {\n      this.temp = temp;\n      this.humidity = humidity;\n      this.pressure = pressure;\n      measurementsChanged();\n    }\n\n    // 더이상 WeatherData 클래스는 수정할 일이 없어진다.\n    public void measurementsChanged() {\n+     notifyObservers()\n-     float temp = getTemperature();\n-     float humidity = getHumidity();\n-     float pressure = getPressure();\n-\n-     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n-     currentConditionsDisplay.update(temp, humidity, pressure);\n-     statisticsDisplay.update(temp, humidity, pressure);\n-     forecastDisplay.update(temp, humidity, pressure);\n    }\n  }\n```\n\nSubject class의 역할은 Observer의 `구독과 해지`하는 역할을 담당하고,\n구독된 Observers에게 `본인의 변경사항을 알려`주는 역할을 한다.\n\n본인의 변경사항을 알려주기 위해 `Observer는 update 전략`을 포함하고 있어야 한다.\n\n이제 Subject 클래스는 `구독된 Observer를 배열로 관리`하고, `관리되고 있는 Observer를 대상`으로 `변경사항을 emit(update)`하기 때문에\n**더이상 Subject 클래스를 수정할 필요가 없어진다.**\n\n### Observer class\n\n```java:FutureDisplay.java {6-8}\npublic class FutureDisplay implements Observer, DisplayElement {\n  private Subject weatherData;\n\n  public FutureDisplay(Subject weatherData) {\n    this.weatherData = weatherData;\n    // Observer가 Subject를 구독한다.\n    // 비로소 Subject가 update를 쏴줄 수 있다.\n    weatherData .registerObserver(this);\n  }\n\n  public void update(float temp, float humidity, float pressure) {\n    this.temp = temp;\n    this.humidity = humidity;\n    this.pressure = pressure;\n    display();\n  }\n\n  @implements\n  public void display() {\n    // ...\n  }\n}\n```\n\nObserver는 생성시 자동으로 `Subject를 구독`하게 되고,\n구독했기에 Subject의 상태 변경시 자동으로 Observer를 업데이트 할 수 있다.\n_Subject의 observers 배열에 추가되어 관리됨_\n\n> 여기서 눈여겨 봐야 할 점은 `Observer의 update` 전략 메서드는 `Subject`에서,\n> `Subject의 register, remove` 전략 메서드는 `Observer`에서 호출된다는 점이다.\n> 서로 `크로스`되어 메서드를 호출한다는 점을 주목하자.\n\n### main (사용자 입장)\n\n```diff-java:WeatherStation.java {5-6}\n  public class WeatherStation {\n    public static void main(String[] args) {\n      WeatherData weatherData = new WeatherData();\n\n      // another displays\n+     FutureDisplay futureDisplay = new FutureDisplay(weatherData);\n\n      weatherData.setMeasurements(80, 65, 30.4f);\n      weatherData.setMeasurements(82, 70, 29.2f);\n      weatherData.setMeasurements(78, 90, 29.3f);\n    }\n  }\n```\n\n사용자 입장에서는 새로운 Display객체 생성시 WeatherData를 의존성 주입만 해주면,\n그 뒤의 모든 과정은 Observer Pattern에 의해 자동으로 업데이트가 가능해진다.\n\n## 결론\n\n`의존성이 없어`야 하지만 `여러 클래스와 관계`를 가져야하고,\n동시에 `코드가 수정되는 일이 적어`야만 하는 클래스는\nObserver Pattern을 그 클리스와 관계를 갖는 여러 클래스에 적용하는 것이 좋다.\n","slug":"univ_design-pattern/mid_02","readingMinutes":7,"wordCount":693},{"title":"Strategy Pattern","description":"Strategy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Strategy Pattern","extends","implements"],"draft":false,"date":"2023-09-11 / 09:09","content":"\n## 상속\n\n### extends\n\n오리 시뮬레이터를 만든다고 가정해보자.\n그렇다면 일단 오리 객체를 만들어야 할 것이다.\n\n```java:Duck.java {5}\nclass Duck() {\n  quack() {};\n  swim() {};\n  fly() {};\n  display() {};\n  // other duck-like methods\n}\n```\n\n그리고 여러 종류의 오리는 이 `Duck` 클래스를 상속받아서 사용하면 될 것이다.\n\n```java:Ducks.java {2-3, 7-8}\nclass MallardDuck extends Duck {\n  @override\n  display() {};\n}\n\nclass RedheadDuck extends Duck {\n  @override\n  display() {};\n}\n```\n\n물론 생김새는 다르기에 일부 메서드는 `override`해서 사용해야 할 것이다.\n이 때 자식 클래스와 부모 클래스는 `is a` 관계를 갖는다고 말한다.\n_e.g. MallardDuck is a Duck_\n\n### implements (interface)\n\n이제 고무 오리를 만들어보자.\n\n```java:Ducks.java {4-7}\nclass RubberDuck extends Duck {\n  @override\n  display() {}\n  @override\n  quack() {}\n  @override\n  fly() {}\n}\n```\n\n고무 오리는 `꽥` 소리를 내지 않고 `삑`소리를 내기 때문에 `quack()` 메서드 역시 override 해야한다.\n또한, 날지도 않기에 `fly()` 메서드 역시 override 해야한다.\n\nDecoyDuck을 또 만든다면?\n이 역시 quack, fly 메서드를 override 해야한다.\n\n이렇게 모든 Duck들이 공유하지 않는 속성은 매번 override 해야하는 문제점이 있다.\n\n이 때, `interface`를 사용하면 이 문제를 해결할 수 있다.\n\n```diff-java:DucksWithInterfece.java {12, 18}\n  class Duck() {\n    swim() {};\n    display() {};\n  }\n+ interface Flyable() {\n+   fly();\n+ }\n+ interface Quackable() {\n+   quack();\n+ }\n\n  class MallardDuck extends Duck implements Flyable, Quackable {\n+   fly() {};\n+   quack() {};\n    @override\n    display() {};\n  }\n  class RubberDuck extends Duck implements Quackable {\n+   quack() {};\n    @override\n    display() {};\n  }\n```\n\n이렇게 변할 수 있는 부분은 interface로 띄어내면 쓸데없이 메서드를 override할 일이 줄어든다.\n이 때 구현 클래스와 인터페이스는 `has a` 관계를 갖는다고 한다.\n_e.g. RubberDuck has a Quackable_\n\n_참고:_\n_class, interfece의 차이는 사실 거의 없다._\n\n### interface 다형성\n\n하지만 위 방식 역시 문제가 존재한다.\nMallardDuck, RedheadDuck 두 오리 모두 같은 quack 메서드로 동작해야 하지만,\n이를 implements 하는 과정에서 두 메서드를 중복해서 구현해야 한다는 문제점이 발생한다.\n\n이를 해결하기 위해서는 인터페이스의 다형성의 원리를 이용하는게 좋다.\n\n```diff-java:DucksWithPolymorphism.java {18, 20-24}\n  interface QuackBehavior {\n    quack();\n  }\n+ class Quack implements QuackBehavior {\n    @override\n    quack() {'꽥'};\n  }\n+ class Squack implements QuackBehavior {\n    @override\n    quack() {'삑'};\n  }\n+ class MuteQuack implements QuackBehavior {\n    @override\n    quack() {};\n  }\n\n  class Duck {\n    QuackBehavior quackBehavior;\n\n    performQuack() {\n      // delegate to the behavior class\n      // 한 마디로 짬때리기...\n      quackBehavior.quack();\n    }\n    // ...\n  }\n\n  class MallardDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Quack 객체를 지정할 수 있다.\n+     quackBehavior = new Quack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(꽥)를 사용할 수 있음.\n    // ...\n  }\n  class RubberDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Squack 객체를 지정할 수 있다.\n+     quackBehavior = new Squack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(삑)를 사용할 수 있음.\n    // ...\n  }\n```\n\n이렇게 하면 필요한 부분에만 기능을 추가할 수 있고, 코드의 재사용성도 올라간다.\n뿐만 아니라 새로운 기능 (예로 들어 새로운 울음 소리)의 추가도 쉬워진다.\n\n## Strategy Pattern\n\n위에서 알아본 적절한 상속관계를 준수한 패턴을 `Strategy Pattern` 라고 한다.\n정확한 정의는 다음과 같다.\n\n> 객체들이 할 수 있는 행위 각각에 대해 `전략 클래스 (Quack, Squack)`를 생성하고,\n> `유사한 행위들을 캡슐화` 하는 `인터페이스 (QuackBehavior)`를 정의하여,\n> 객체의 행위를 동적으로 바꾸고 싶은 경우 `직접 행위를 수정하지 않고 (performQuack())`\n> 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.\n\n간단히 말해서 객체가 할 수 있는 행위들을 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것만으로 행위의 수정이 가능하도록 만든 패턴이다.\n\n## 결론\n\n`has a (구현)`관계가 `is a (상속)`관계보다 낫다.\n\n상속은 뭘 상속해야 하는지 일일이 파악해야 하는 귀찮음이 있기 때문이다.\n하지만, 구현은 필요한 기능만 가져다 쓰면 되기에 사용및 개발적 측면에서 좋고,\n새로운 기능은 인터페이스를 추가로 구현하면 끝이기에 유지보수 측면에서도 좋다.\n\n따라서 단순히 상속을 이용한 객체지향 프로그래밍 보단,\n전략 패턴을 적용한 코딩 습관을 기르도록 하자.\n","slug":"univ_design-pattern/mid_01","readingMinutes":6,"wordCount":594}]},"__N_SSG":true}