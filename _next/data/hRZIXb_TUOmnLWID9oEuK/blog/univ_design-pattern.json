{"pageProps":{"posts":[{"title":"대학 - 프로그래밍 언어론","description":"3학년 2학기 프로그래밍 언어론 수업 아카이브","icon":"","image":"","tags":[],"draft":false,"date":"2023-09-11","content":"","slug":"univ_design-pattern/index","readingMinutes":0,"wordCount":1},{"title":"Strategy Pattern","description":"Strategy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Strategy Pattern","extends","implements"],"draft":false,"date":"2023-09-11","content":"\n## 상속\n\n### extends\n\n오리 시뮬레이터를 만든다고 가정해보자.\n그렇다면 일단 오리 객체를 만들어야 할 것이다.\n\n```java:Duck.java {5}\nclass Duck() {\n  quack() {};\n  swim() {};\n  fly() {};\n  display() {};\n  // other duck-like methods\n}\n```\n\n그리고 여러 종류의 오리는 이 `Duck` 클래스를 상속받아서 사용하면 될 것이다.\n\n```java:Ducks.java {2-3, 7-8}\nclass MallardDuck extends Duck {\n  @override\n  display() {};\n}\n\nclass RedheadDuck extends Duck {\n  @override\n  display() {};\n}\n```\n\n물론 생김새는 다르기에 일부 메서드는 `override`해서 사용해야 할 것이다.\n이 때 자식 클래스와 부모 클래스는 `is a` 관계를 갖는다고 말한다.\n_e.g. MallardDuck is a Duck_\n\n### implements (interface)\n\n이제 고무 오리를 만들어보자.\n\n```java:Ducks.java {4-7}\nclass RubberDuck extends Duck {\n  @override\n  display() {}\n  @override\n  quack() {}\n  @override\n  fly() {}\n}\n```\n\n고무 오리는 `꽥` 소리를 내지 않고 `삑`소리를 내기 때문에 `quack()` 메서드 역시 override 해야한다.\n또한, 날지도 않기에 `fly()` 메서드 역시 override 해야한다.\n\nDecoyDuck을 또 만든다면?\n이 역시 quack, fly 메서드를 override 해야한다.\n\n이렇게 모든 Duck들이 공유하지 않는 속성은 매번 override 해야하는 문제점이 있다.\n\n이 때, `interface`를 사용하면 이 문제를 해결할 수 있다.\n\n```diff-java:DucksWithInterfece.java {12, 18}\n  class Duck() {\n    swim() {};\n    display() {};\n  }\n+ interface Flyable() {\n+   fly();\n+ }\n+ interface Quackable() {\n+   quack();\n+ }\n\n  class MallardDuck extends Duck implements Flyable, Quackable {\n+   fly() {};\n+   quack() {};\n    @override\n    display() {};\n  }\n  class RubberDuck extends Duck implements Quackable {\n+   quack() {};\n    @override\n    display() {};\n  }\n```\n\n이렇게 변할 수 있는 부분은 interface로 띄어내면 쓸데없이 메서드를 override할 일이 줄어든다.\n이 때 구현 클래스와 인터페이스는 `has a` 관계를 갖는다고 한다.\n_e.g. RubberDuck has a Quackable_\n\n_참고:_\n_class, interfece의 차이는 사실 거의 없다._\n\n### interface 다형성\n\n하지만 위 방식 역시 문제가 존재한다.\nMallardDuck, RedheadDuck 두 오리 모두 같은 quack 메서드로 동작해야 하지만,\n이를 implements 하는 과정에서 두 메서드를 중복해서 구현해야 한다는 문제점이 발생한다.\n\n이를 해결하기 위해서는 인터페이스의 다형성의 원리를 이용하는게 좋다.\n\n```diff-java:DucksWithPolymorphism.java {18, 20-24}\n  interface QuackBehavior {\n    quack();\n  }\n+ class Quack implements QuackBehavior {\n    @override\n    quack() {'꽥'};\n  }\n+ class Squack implements QuackBehavior {\n    @override\n    quack() {'삑'};\n  }\n+ class MuteQuack implements QuackBehavior {\n    @override\n    quack() {};\n  }\n\n  class Duck {\n    QuackBehavior quackBehavior;\n\n    performQuack() {\n      // delegate to the behavior class\n      // 한 마디로 짬때리기...\n      quackBehavior.quack();\n    }\n    // ...\n  }\n\n  class MallardDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Quack 객체를 지정할 수 있다.\n+     quackBehavior = new Quack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(꽥)를 사용할 수 있음.\n    // ...\n  }\n  class RubberDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Squack 객체를 지정할 수 있다.\n+     quackBehavior = new Squack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(삑)를 사용할 수 있음.\n    // ...\n  }\n```\n\n이렇게 하면 필요한 부분에만 기능을 추가할 수 있고, 코드의 재사용성도 올라간다.\n뿐만 아니라 새로운 기능 (예로 들어 새로운 울음 소리)의 추가도 쉬워진다.\n\n## Strategy Pattern\n\n위에서 알아본 적절한 상속관계를 준수한 패턴을 `Strategy Pattern` 라고 한다.\n정확한 정의는 다음과 같다.\n\n> 객체들이 할 수 있는 행위 각각에 대해 `전략 클래스 (Quack, Squack)`를 생성하고,\n> `유사한 행위들을 캡슐화` 하는 `인터페이스 (QuackBehavior)`를 정의하여,\n> 객체의 행위를 동적으로 바꾸고 싶은 경우 `직접 행위를 수정하지 않고 (performQuack())`\n> 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.\n\n간단히 말해서 객체가 할 수 있는 행위들을 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것만으로 행위의 수정이 가능하도록 만든 패턴이다.\n\n## 결론\n\n`has a (구현)`관계가 `is a (상속)`관계보다 낫다.\n\n상속은 뭘 상속해야 하는지 일일이 파악해야 하는 귀찮음이 있기 때문이다.\n하지만, 구현은 필요한 기능만 가져다 쓰면 되기에 사용및 개발적 측면에서 좋고,\n새로운 기능은 인터페이스를 추가로 구현하면 끝이기에 유지보수 측면에서도 좋다.\n\n따라서 단순히 상속을 이용한 객체지향 프로그래밍 보단,\n전략 패턴을 적용한 코딩 습관을 기르도록 하자.\n","slug":"univ_design-pattern/mid_01","readingMinutes":6,"wordCount":594},{"title":"Observer Pattern","description":"Observer 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Observer Pattern","interface"],"draft":false,"date":"2023-09-11","content":"\n## Strategy Pattern\n\n[**저번 포스트**](https://wjlee611.github.io/blog/univ_design-pattern/mid_01)에서 배운 `Strategy 디자인 패턴`을 이용해서 한 가지 예를 살펴보자.\n\n```java:WeatherData.java {7} showLineNumbers\npublic class WeatherData {\n  public void measurementsChanged() {\n    float temp = getTemperature();\n    float humidity = getHumidity();\n    float pressure = getPressure();\n\n     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n    currentConditionsDisplay.update(temp, humidity, pressure);\n    statisticsDisplay.update(temp, humidity, pressure);\n    forecastDisplay.update(temp, humidity, pressure);\n  }\n}\n```\n\n이 코드는 `Display`장치들이 `WeatherData`에서 제공하는 데이터를 이용하려는 코드이다.\n\n예로 들어 `forecastDisplay`에서 날씨 정보를 출력하기 위해서는\n`WeatherData`에서 `forecastDisplay.update()` 메서드를 호출해야\n날씨 정보가 비로소 `forecastDisplay`로 전달되는 것이다.\n\n### 문제점\n\n여기서 문제가 발생한다.\n만약 새로운 장치 futureDisplay를 구현하려면 Strategy Pattern을 사용하는 코드는 아래와 같은 코드수정이 필요해진다.\n\n1. update() 전략을 갖고있는 인터페이스로 구현한 전략(Display) 클래스를 만든다.\n2. `Line 7`에 새로운 장치를 등록한다.\n\n지금 당장은 문제될게 없어 보이지만, 만약 당신이 WeatherData를 `라이브러리화 해서 배포`하는 입장일 경우를 고려해보자.\n`사용자`는 단지 새로운 Display를 추가하여 바로 날씨 정보를 받아오고 싶을 것이다.\n하지만, 위와 같은 코드라면 사용자는 라이브러리 파일을 뜯어서 WeatherData 클래스 내부에\n직접적으로 `새로운 Display를 의존성 주입`을 해줘야만 할 것이다.\n\n이 경우는 꽤나 치명적이다.\n생각해보면 우리가 사용하는 대부분의 라이브러리는 이런 과정을 겪지 않으니 말이다.\n\n따라서 이런 문제를 해결하기 위한 디자인 패턴이 필요하다.\n\n## Observer Pattern\n\nObserver Pattern의 정의는 다음과 같다.\n\n> 객체들이 1:N의 관계를 갖을 때, 한 객체의 상태가 변하면 다른 모든 객체들에 업데이트 통지가 떨어지는 관계로,\n> `객체(Subject)`와 `객체들(Observers)`간의 `종속성이 없는 관계`를 의미한다.\n\n코드로 살펴보며 이해해보자.\n\n### interface\n\n```java:IObserverPattern.java {1-5, 7-9}\npublic interface Subject {\n    public void registerObserver(Observer o);\n    public void removeObserver(Observer o);\n    public void notifyObservers();\n}\n\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\n\npublic interface DisplayElement {\n    public void display();\n}\n```\n\n위 코드는 Observer Pattern에서 사용하는 인터페이스이다.\n`1`의 입장인 클래스(Subject)는 `Subject 인터페이스`를 구현해야 하고,\n`N`의 입장인 클래스(Observers)는 `Observer 인터페이스`를 구현해야 한다.\n\n### Subject class\n\n```diff-java:WeatherData.java {24, 35}\n  public class WeatherData implements Subject {\n+   private ArrayList<Observer> observers;\n\n    public WeatherData() {\n      observers = new ArrayList<Observer>();\n    }\n\n+   @implements\n+   public void registerObserver(Observer o) {\n+     observers.add(o);\n+   }\n+\n+   @implements\n+   public void removeObserver(Observer o) {\n+     int i = observers.indexOf(o);\n+     if (i < 0) return;\n+     observers.remove(i);\n+   }\n+\n+   @implements\n+   public void notifyObservers() {\n+     for (int i=0; i<observers.length; i++) {\n+       Observer o = observers.get(i);\n+       o.update(temp, humidity, pressure);\n+     }\n+   }\n\n    public void setMeasurements(float temp, float humidity, float pressure) {\n      this.temp = temp;\n      this.humidity = humidity;\n      this.pressure = pressure;\n      measurementsChanged();\n    }\n\n    // 더이상 WeatherData 클래스는 수정할 일이 없어진다.\n    public void measurementsChanged() {\n+     notifyObservers()\n-     float temp = getTemperature();\n-     float humidity = getHumidity();\n-     float pressure = getPressure();\n-\n-     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n-     currentConditionsDisplay.update(temp, humidity, pressure);\n-     statisticsDisplay.update(temp, humidity, pressure);\n-     forecastDisplay.update(temp, humidity, pressure);\n    }\n  }\n```\n\nSubject class의 역할은 Observer의 `구독과 해지`하는 역할을 담당하고,\n구독된 Observers에게 `본인의 변경사항을 알려`주는 역할을 한다.\n\n본인의 변경사항을 알려주기 위해 `Observer는 update 전략`을 포함하고 있어야 한다.\n\n이제 Subject 클래스는 `구독된 Observer를 배열로 관리`하고, `관리되고 있는 Observer를 대상`으로 `변경사항을 emit(update)`하기 때문에\n**더이상 Subject 클래스를 수정할 필요가 없어진다.**\n\n### Observer class\n\n```java:FutureDisplay.java {6-8}\npublic class FutureDisplay implements Observer, DisplayElement {\n  private Subject weatherData;\n\n  public FutureDisplay(Subject weatherData) {\n    this.weatherData = weatherData;\n    // Observer가 Subject를 구독한다.\n    // 비로소 Subject가 update를 쏴줄 수 있다.\n    weatherData .registerObserver(this);\n  }\n\n  public void update(float temp, float humidity, float pressure) {\n    this.temp = temp;\n    this.humidity = humidity;\n    this.pressure = pressure;\n    display();\n  }\n\n  @implements\n  public void display() {\n    // ...\n  }\n}\n```\n\nObserver는 생성시 자동으로 `Subject를 구독`하게 되고,\n구독했기에 Subject의 상태 변경시 자동으로 Observer를 업데이트 할 수 있다.\n_Subject의 observers 배열에 추가되어 관리됨_\n\n> 여기서 눈여겨 봐야 할 점은 `Observer의 update` 전략 메서드는 `Subject`에서,\n> `Subject의 register, remove` 전략 메서드는 `Observer`에서 호출된다는 점이다.\n> 서로 `크로스`되어 메서드를 호출한다는 점을 주목하자.\n\n### main (사용자 입장)\n\n```diff-java:WeatherStation.java {5-6}\n  public class WeatherStation {\n    public static void main(String[] args) {\n      WeatherData weatherData = new WeatherData();\n\n      // another displays\n+     FutureDisplay futureDisplay = new FutureDisplay(weatherData);\n\n      weatherData.setMeasurements(80, 65, 30.4f);\n      weatherData.setMeasurements(82, 70, 29.2f);\n      weatherData.setMeasurements(78, 90, 29.3f);\n    }\n  }\n```\n\n사용자 입장에서는 새로운 Display객체 생성시 WeatherData를 의존성 주입만 해주면,\n그 뒤의 모든 과정은 Observer Pattern에 의해 자동으로 업데이트가 가능해진다.\n\n## 결론\n\n`의존성이 없어`야 하지만 `여러 클래스와 관계`를 가져야하고,\n동시에 `코드가 수정되는 일이 적어`야만 하는 클래스는\nObserver Pattern을 그 클리스와 관계를 갖는 여러 클래스에 적용하는 것이 좋다.\n","slug":"univ_design-pattern/mid_02","readingMinutes":7,"wordCount":693}]},"__N_SSG":true}