{"pageProps":{"post":{"title":"Singleton Pattern","description":"Singleton Pattern 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Singleton Pattern"],"draft":false,"date":"2023-10-08 / 21:31","content":"\n## 필요성\n\n시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용한다.\n\n## Singleton Pattern\n\n```java:Singleton.java {2, 4} showLineNumbers\n  public class Singleton {\n    private static Singleton _instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      if (_instance == null) {\n        _instance = new Singleton();\n      }\n      return _instance;\n    }\n  }\n```\n\n기존에 봐오던 클래스들과 많이 다르게 클래스 내부에 본인의 인스턴스를 저장하는 공간이 있으며,\n**생성자가 외부로 노출되지 않는다**.\n\n인스턴스 생성은 오직 `getInstance()` 메서드 호출을 통해서만 이루어지며,\n내부적으로 null값인 경우에만 인스턴스를 생성하기 때문에 `1개의 인스턴스만 생성`이 된다.\n\n### Multithreading\n\n하지만 멀티스레딩 환경에서는 인스턴스가 2개 이상 생성되는 경우가 발생할 수 있다.\n`Line 7`과 `Line 8` 사이에서 `Context switching`이 일어나는 경우가 그러하다.\n\n이런 경우를 막기 위해서 getInstance()는 `동기화 처리`를 해주는 편이 좋다.\n\n```java:Singleton.java {2}\npublic class Singleton {\n  private static Singleton _instance = new Singleton();\n  ...\n}\n```\n\n이렇게 하면 프로그램 실행시점에 인스턴스가 생성되어 반드시 1개의 인스턴스만 생성할 수 있다.\n하지만, 해당 클래스의 생성시점을 제어할 수 없기에 프로그램 성능이 저하되는 문제가 발생할 수 있다.\n\n```java:Singleton.java {6}\n  public class Singleton {\n    private static Singleton _instance;\n\n    private Singleton() {}\n\n    public static synchronized Singleton getInstance() {\n      if (_instance == null) {\n        _instance = new Singleton();\n      }\n      return _instance;\n    }\n  }\n```\n\njava처럼 동기화 키워드를 제공하는 경우 인스턴스를 생성하는 함수를 동기화 걸어주면 된다.\n하지만 이 경우에도 해당 함수가 매우 무거운 기능을 수행하는 경우에는 동기화 시간이 매우 길어져 성능 저하의 원인이 될 수 있다.\n\n\n```java:Singleton.java {6}\n  public class Singleton {\n    private volatile static Singleton _instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      if (_instance == null) {\n        synchronized (Singleton.class) {\n          if (_instance == null) {\n            _instance = new Singleton();\n          }\n        }\n      }\n      return _instance;\n    }\n  }\n```\n\n위의 코드는 인스턴스 생성 함수 내부에서 정확히 인스턴스를 생성하는 부분만 동기화되기 때문에\n성능상의 이슈도 없앨 수 있다.\n\n## 결론\n\n필요성과 같다.\n시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용하자.","slug":"univ_design-pattern/mid_04","readingMinutes":4,"wordCount":300},"posts":[{"title":"Command Pattern","description":"Command Pattern 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Command Pattern"],"draft":false,"date":"2023-10-10 / 14:45","content":"\n## 필요성\n\nLift($L$) can be determined by Lift Coefficient ($C_L$) like the following\nequation.\n\n$$\nL = \\frac{1}{2} \\rho v^2 S C_L\n$$\n\n## asd","slug":"univ_design-pattern/mid_05","readingMinutes":1,"wordCount":26},{"title":"Singleton Pattern","description":"Singleton Pattern 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Singleton Pattern"],"draft":false,"date":"2023-10-08 / 21:31","content":"\n## 필요성\n\n시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용한다.\n\n## Singleton Pattern\n\n```java:Singleton.java {2, 4} showLineNumbers\n  public class Singleton {\n    private static Singleton _instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      if (_instance == null) {\n        _instance = new Singleton();\n      }\n      return _instance;\n    }\n  }\n```\n\n기존에 봐오던 클래스들과 많이 다르게 클래스 내부에 본인의 인스턴스를 저장하는 공간이 있으며,\n**생성자가 외부로 노출되지 않는다**.\n\n인스턴스 생성은 오직 `getInstance()` 메서드 호출을 통해서만 이루어지며,\n내부적으로 null값인 경우에만 인스턴스를 생성하기 때문에 `1개의 인스턴스만 생성`이 된다.\n\n### Multithreading\n\n하지만 멀티스레딩 환경에서는 인스턴스가 2개 이상 생성되는 경우가 발생할 수 있다.\n`Line 7`과 `Line 8` 사이에서 `Context switching`이 일어나는 경우가 그러하다.\n\n이런 경우를 막기 위해서 getInstance()는 `동기화 처리`를 해주는 편이 좋다.\n\n```java:Singleton.java {2}\npublic class Singleton {\n  private static Singleton _instance = new Singleton();\n  ...\n}\n```\n\n이렇게 하면 프로그램 실행시점에 인스턴스가 생성되어 반드시 1개의 인스턴스만 생성할 수 있다.\n하지만, 해당 클래스의 생성시점을 제어할 수 없기에 프로그램 성능이 저하되는 문제가 발생할 수 있다.\n\n```java:Singleton.java {6}\n  public class Singleton {\n    private static Singleton _instance;\n\n    private Singleton() {}\n\n    public static synchronized Singleton getInstance() {\n      if (_instance == null) {\n        _instance = new Singleton();\n      }\n      return _instance;\n    }\n  }\n```\n\njava처럼 동기화 키워드를 제공하는 경우 인스턴스를 생성하는 함수를 동기화 걸어주면 된다.\n하지만 이 경우에도 해당 함수가 매우 무거운 기능을 수행하는 경우에는 동기화 시간이 매우 길어져 성능 저하의 원인이 될 수 있다.\n\n\n```java:Singleton.java {6}\n  public class Singleton {\n    private volatile static Singleton _instance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n      if (_instance == null) {\n        synchronized (Singleton.class) {\n          if (_instance == null) {\n            _instance = new Singleton();\n          }\n        }\n      }\n      return _instance;\n    }\n  }\n```\n\n위의 코드는 인스턴스 생성 함수 내부에서 정확히 인스턴스를 생성하는 부분만 동기화되기 때문에\n성능상의 이슈도 없앨 수 있다.\n\n## 결론\n\n필요성과 같다.\n시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용하자.","slug":"univ_design-pattern/mid_04","readingMinutes":4,"wordCount":300},{"title":"Decorator Pattern","description":"Decorator 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Decorator Pattern","OCP","Java I/O"],"draft":false,"date":"2023-10-08 / 14:49","content":"\n## 필요성\n\n키오스크 개발자라고 가정하고 음료를 정의할 인터페이스를 만들어보자.\n\n```java:Beverage.java\npublic abstract class Beverage {\n  private String description;\n\n  public Beverage(String des) {\n    this.description = des;\n  }\n\n  public String getDescription() {\n      return description;\n  }\n  public abstract double cost();\n}\n```\n\n그렇다면 음료들은 이 클래스를 상속받아서 구현하면 될 것이다.\n하지만 이 경우에 다음과 같은 문제점이 발생할 수 있다.\n\n아아, 아아 샷추가, 아아 우유추가 등 여러 `베리에이션 음료`에 대해 모두 **각각** 클래스로 구현해야 한다는 점이다.\n단순히 샷추가나 우유추가의 경우에는 가격만 좀 더 받으면 될터인데 이를 각각 따로 구현하는거는 코드의 중복 뿐만 아니라, 유지보수도 어렵게 만든다.\n\n### OCP\n\n그렇다면 Beverage에서 옵션도 관리하게 하면 되지 않을까?\n\n```diff-java:Beverage.java\n  public abstract class Beverage {\n    private String description;\n+   private boolean milk;\n+   private boolean soy;\n\n    public Beverage(String des) {\n      this.description = des;\n    }\n\n    public abstract String getDescription() {\n      return description;\n    }\n    public abstract double cost();\n\n+   setMilk();\n+   hasMilk();\n+   setSoy();\n+   hasSoy();\n  }\n```\n\n처음 생각해볼 수 있는 간단한 해결법이지만, 좋은 방법은 아니다.\n다른 옵션을 추가하거나 옵션에 따른 가격 변동을 수정하려는 경우에는 Beverage 클래스에 대한 전면적인 수정이 필요해지기 때문이다.\n\n`새로운 옵션`에 대해서는 **변수 추가 및 get, set을 추가**해야 하고,\n`가격 변동`의 경우에는 **cost 함수가 전면적으로 수정**되어야 한다.\n이 과정에 Beverage를 상속받은 `모든 클래스`에서 일어나야 한다.\n\n이런 경우를 방지하기 위해 `OCP` 방법론을 준수하여 코딩하는게 좋다.\n\nOCP는 Open-Closed Principle의 약어로, 확장엔 유연하게, 변경엔 엄격하게 디자인 해야함을 추구하는 원칙이다.\n\n## Decorator Pattern\n\n이를 해결하기 위해 `Decorator Pattern`을 사용할 수 있다.\n\n우선 Beverage는 다시 원상복구를 시키고, 옵션에 대한 클래스를 구현하자.\n\n```java:CondimentDecorator.java\npublic abstract class CondimentDecorator extends Beverage {\n  public abstract String getDescription();\n}\n```\n\n이제 음료는 Beverage를 상속받아 구현하고, 옵션은 CondimentDecorator를 상속받아 구현하면 된다.\n계속 예시를 살펴보며 이해하자.\n\n```java:Espresso.java\npublic class Espresso extends Beverage {\n  public Espresso() {\n    description = 'Espresso';\n  }\n\n  public double cost() {\n    return 0.89;\n  }\n}\n```\n\n```java:Milk.java\npublic class Milk extends CondimentDecorator {\n  Beverage beverage;\n\n  public Milk(Beverage beverage) {\n    this.beverage = beverage;\n  }\n\n  public String getDescription() {\n    return beverage.getDescription() + ', Milk';\n  }\n\n  public double cost() {\n    return beverage.cost() + 0.20;\n  }\n}\n```\n\n이런식으로 구현한다면 사용할 때는 Espresso를 Milk가 감싸는 방식으로 옵션을 추가할 수 있게된다.\n\n```java:Kiosk.java\npublic class Kiosk {\n  public static void main(String args[]) {\n    Beverage espressoWithMilk = new Milk(new Espresso());\n    System.out.println(espressoWithMilk.getDescription() + “ $” + espressoWithMilk.cost());\n    ...\n  }\n}\n```\n\n> Espresso, Milk $1.09\n\n실제로 Java의 I/O를 사용하다보면 이런 코드를 많이 본 적이 있을 것이다.\n\n```java:FileIO.java\nInputStream in = new LineNumberInputStream(\n                    new BufferedInputStream(\n                       new FileInputStream('text.txt')));\n```\n\n이런 Stream도 모두 Decorator Pattern이 적용된 것이다.\n\n## 결론\n\nDecorator Pattern은 `새로운 기능이 추가`되거나, `적용 순서를 자유롭게` 해야하는 경우에 사용하는 것이 좋다.","slug":"univ_design-pattern/mid_03","readingMinutes":5,"wordCount":417},{"title":"Observer Pattern","description":"Observer 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Observer Pattern","interface"],"draft":false,"date":"2023-09-11 / 10:33","content":"\n## Strategy Pattern\n\n[**저번 포스트**](https://wjlee611.github.io/blog/univ_design-pattern/mid_01)에서 배운 `Strategy 디자인 패턴`을 이용해서 한 가지 예를 살펴보자.\n\n```java:WeatherData.java {7} showLineNumbers\npublic class WeatherData {\n  public void measurementsChanged() {\n    float temp = getTemperature();\n    float humidity = getHumidity();\n    float pressure = getPressure();\n\n     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n    currentConditionsDisplay.update(temp, humidity, pressure);\n    statisticsDisplay.update(temp, humidity, pressure);\n    forecastDisplay.update(temp, humidity, pressure);\n  }\n}\n```\n\n이 코드는 `Display`장치들이 `WeatherData`에서 제공하는 데이터를 이용하려는 코드이다.\n\n예로 들어 `forecastDisplay`에서 날씨 정보를 출력하기 위해서는\n`WeatherData`에서 `forecastDisplay.update()` 메서드를 호출해야\n날씨 정보가 비로소 `forecastDisplay`로 전달되는 것이다.\n\n### 문제점\n\n여기서 문제가 발생한다.\n만약 새로운 장치 futureDisplay를 구현하려면 Strategy Pattern을 사용하는 코드는 아래와 같은 코드수정이 필요해진다.\n\n1. update() 전략을 갖고있는 인터페이스로 구현한 전략(Display) 클래스를 만든다.\n2. `Line 7`에 새로운 장치를 등록한다.\n\n지금 당장은 문제될게 없어 보이지만, 만약 당신이 WeatherData를 `라이브러리화 해서 배포`하는 입장일 경우를 고려해보자.\n`사용자`는 단지 새로운 Display를 추가하여 바로 날씨 정보를 받아오고 싶을 것이다.\n하지만, 위와 같은 코드라면 사용자는 라이브러리 파일을 뜯어서 WeatherData 클래스 내부에\n직접적으로 `새로운 Display를 의존성 주입`을 해줘야만 할 것이다.\n\n이 경우는 꽤나 치명적이다.\n생각해보면 우리가 사용하는 대부분의 라이브러리는 이런 과정을 겪지 않으니 말이다.\n\n따라서 이런 문제를 해결하기 위한 디자인 패턴이 필요하다.\n\n## Observer Pattern\n\nObserver Pattern의 정의는 다음과 같다.\n\n> 객체들이 1:N의 관계를 갖을 때, 한 객체의 상태가 변하면 다른 모든 객체들에 업데이트 통지가 떨어지는 관계로,\n> `객체(Subject)`와 `객체들(Observers)`간의 `종속성이 없는 관계`를 의미한다.\n\n코드로 살펴보며 이해해보자.\n\n### interface\n\n```java:IObserverPattern.java {1-5, 7-9}\npublic interface Subject {\n    public void registerObserver(Observer o);\n    public void removeObserver(Observer o);\n    public void notifyObservers();\n}\n\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\n\npublic interface DisplayElement {\n    public void display();\n}\n```\n\n위 코드는 Observer Pattern에서 사용하는 인터페이스이다.\n`1`의 입장인 클래스(Subject)는 `Subject 인터페이스`를 구현해야 하고,\n`N`의 입장인 클래스(Observers)는 `Observer 인터페이스`를 구현해야 한다.\n\n### Subject class\n\n```diff-java:WeatherData.java {24, 35}\n  public class WeatherData implements Subject {\n+   private ArrayList<Observer> observers;\n\n    public WeatherData() {\n      observers = new ArrayList<Observer>();\n    }\n\n+   @implements\n+   public void registerObserver(Observer o) {\n+     observers.add(o);\n+   }\n+\n+   @implements\n+   public void removeObserver(Observer o) {\n+     int i = observers.indexOf(o);\n+     if (i < 0) return;\n+     observers.remove(i);\n+   }\n+\n+   @implements\n+   public void notifyObservers() {\n+     for (int i=0; i<observers.length; i++) {\n+       Observer o = observers.get(i);\n+       o.update(temp, humidity, pressure);\n+     }\n+   }\n\n    public void setMeasurements(float temp, float humidity, float pressure) {\n      this.temp = temp;\n      this.humidity = humidity;\n      this.pressure = pressure;\n      measurementsChanged();\n    }\n\n    // 더이상 WeatherData 클래스는 수정할 일이 없어진다.\n    public void measurementsChanged() {\n+     notifyObservers()\n-     float temp = getTemperature();\n-     float humidity = getHumidity();\n-     float pressure = getPressure();\n-\n-     // 각 장치는 update라는 전략을 사용하는 전략 클래스를 갖고있는 클래스이다.\n-     currentConditionsDisplay.update(temp, humidity, pressure);\n-     statisticsDisplay.update(temp, humidity, pressure);\n-     forecastDisplay.update(temp, humidity, pressure);\n    }\n  }\n```\n\nSubject class의 역할은 Observer의 `구독과 해지`하는 역할을 담당하고,\n구독된 Observers에게 `본인의 변경사항을 알려`주는 역할을 한다.\n\n본인의 변경사항을 알려주기 위해 `Observer는 update 전략`을 포함하고 있어야 한다.\n\n이제 Subject 클래스는 `구독된 Observer를 배열로 관리`하고, `관리되고 있는 Observer를 대상`으로 `변경사항을 emit(update)`하기 때문에\n**더이상 Subject 클래스를 수정할 필요가 없어진다.**\n\n### Observer class\n\n```java:FutureDisplay.java {6-8}\npublic class FutureDisplay implements Observer, DisplayElement {\n  private Subject weatherData;\n\n  public FutureDisplay(Subject weatherData) {\n    this.weatherData = weatherData;\n    // Observer가 Subject를 구독한다.\n    // 비로소 Subject가 update를 쏴줄 수 있다.\n    weatherData .registerObserver(this);\n  }\n\n  public void update(float temp, float humidity, float pressure) {\n    this.temp = temp;\n    this.humidity = humidity;\n    this.pressure = pressure;\n    display();\n  }\n\n  @implements\n  public void display() {\n    // ...\n  }\n}\n```\n\nObserver는 생성시 자동으로 `Subject를 구독`하게 되고,\n구독했기에 Subject의 상태 변경시 자동으로 Observer를 업데이트 할 수 있다.\n_Subject의 observers 배열에 추가되어 관리됨_\n\n> 여기서 눈여겨 봐야 할 점은 `Observer의 update` 전략 메서드는 `Subject`에서,\n> `Subject의 register, remove` 전략 메서드는 `Observer`에서 호출된다는 점이다.\n> 서로 `크로스`되어 메서드를 호출한다는 점을 주목하자.\n\n### main (사용자 입장)\n\n```diff-java:WeatherStation.java {5-6}\n  public class WeatherStation {\n    public static void main(String[] args) {\n      WeatherData weatherData = new WeatherData();\n\n      // another displays\n+     FutureDisplay futureDisplay = new FutureDisplay(weatherData);\n\n      weatherData.setMeasurements(80, 65, 30.4f);\n      weatherData.setMeasurements(82, 70, 29.2f);\n      weatherData.setMeasurements(78, 90, 29.3f);\n    }\n  }\n```\n\n사용자 입장에서는 새로운 Display객체 생성시 WeatherData를 의존성 주입만 해주면,\n그 뒤의 모든 과정은 Observer Pattern에 의해 자동으로 업데이트가 가능해진다.\n\n## 결론\n\n`의존성이 없어`야 하지만 `여러 클래스와 관계`를 가져야하고,\n동시에 `코드가 수정되는 일이 적어`야만 하는 클래스는\nObserver Pattern을 그 클리스와 관계를 갖는 여러 클래스에 적용하는 것이 좋다.\n","slug":"univ_design-pattern/mid_02","readingMinutes":7,"wordCount":693},{"title":"Strategy Pattern","description":"Strategy 디자인 패턴의 필요성과 그 구조에 대해 알아봅니다.","icon":"","image":"","tags":["Design Pattern","Strategy Pattern","extends","implements"],"draft":false,"date":"2023-09-11 / 09:09","content":"\n## 상속\n\n### extends\n\n오리 시뮬레이터를 만든다고 가정해보자.\n그렇다면 일단 오리 객체를 만들어야 할 것이다.\n\n```java:Duck.java {5}\nclass Duck() {\n  quack() {};\n  swim() {};\n  fly() {};\n  display() {};\n  // other duck-like methods\n}\n```\n\n그리고 여러 종류의 오리는 이 `Duck` 클래스를 상속받아서 사용하면 될 것이다.\n\n```java:Ducks.java {2-3, 7-8}\nclass MallardDuck extends Duck {\n  @override\n  display() {};\n}\n\nclass RedheadDuck extends Duck {\n  @override\n  display() {};\n}\n```\n\n물론 생김새는 다르기에 일부 메서드는 `override`해서 사용해야 할 것이다.\n이 때 자식 클래스와 부모 클래스는 `is a` 관계를 갖는다고 말한다.\n_e.g. MallardDuck is a Duck_\n\n### implements (interface)\n\n이제 고무 오리를 만들어보자.\n\n```java:Ducks.java {4-7}\nclass RubberDuck extends Duck {\n  @override\n  display() {}\n  @override\n  quack() {}\n  @override\n  fly() {}\n}\n```\n\n고무 오리는 `꽥` 소리를 내지 않고 `삑`소리를 내기 때문에 `quack()` 메서드 역시 override 해야한다.\n또한, 날지도 않기에 `fly()` 메서드 역시 override 해야한다.\n\nDecoyDuck을 또 만든다면?\n이 역시 quack, fly 메서드를 override 해야한다.\n\n이렇게 모든 Duck들이 공유하지 않는 속성은 매번 override 해야하는 문제점이 있다.\n\n이 때, `interface`를 사용하면 이 문제를 해결할 수 있다.\n\n```diff-java:DucksWithInterfece.java {12, 18}\n  class Duck() {\n    swim() {};\n    display() {};\n  }\n+ interface Flyable() {\n+   fly();\n+ }\n+ interface Quackable() {\n+   quack();\n+ }\n\n  class MallardDuck extends Duck implements Flyable, Quackable {\n+   fly() {};\n+   quack() {};\n    @override\n    display() {};\n  }\n  class RubberDuck extends Duck implements Quackable {\n+   quack() {};\n    @override\n    display() {};\n  }\n```\n\n이렇게 변할 수 있는 부분은 interface로 띄어내면 쓸데없이 메서드를 override할 일이 줄어든다.\n이 때 구현 클래스와 인터페이스는 `has a` 관계를 갖는다고 한다.\n_e.g. RubberDuck has a Quackable_\n\n_참고:_\n_class, interfece의 차이는 사실 거의 없다._\n\n### interface 다형성\n\n하지만 위 방식 역시 문제가 존재한다.\nMallardDuck, RedheadDuck 두 오리 모두 같은 quack 메서드로 동작해야 하지만,\n이를 implements 하는 과정에서 두 메서드를 중복해서 구현해야 한다는 문제점이 발생한다.\n\n이를 해결하기 위해서는 인터페이스의 다형성의 원리를 이용하는게 좋다.\n\n```diff-java:DucksWithPolymorphism.java {18, 20-24}\n  interface QuackBehavior {\n    quack();\n  }\n+ class Quack implements QuackBehavior {\n    @override\n    quack() {'꽥'};\n  }\n+ class Squack implements QuackBehavior {\n    @override\n    quack() {'삑'};\n  }\n+ class MuteQuack implements QuackBehavior {\n    @override\n    quack() {};\n  }\n\n  class Duck {\n    QuackBehavior quackBehavior;\n\n    performQuack() {\n      // delegate to the behavior class\n      // 한 마디로 짬때리기...\n      quackBehavior.quack();\n    }\n    // ...\n  }\n\n  class MallardDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Quack 객체를 지정할 수 있다.\n+     quackBehavior = new Quack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(꽥)를 사용할 수 있음.\n    // ...\n  }\n  class RubberDuck extends Duck {\n    MallardDuck() {\n      // 다형성의 원리에 의해 QuackBehavior 타입에 Squack 객체를 지정할 수 있다.\n+     quackBehavior = new Squack();\n    }\n\n    // 구현 없이 바로 performQuack 메서드(삑)를 사용할 수 있음.\n    // ...\n  }\n```\n\n이렇게 하면 필요한 부분에만 기능을 추가할 수 있고, 코드의 재사용성도 올라간다.\n뿐만 아니라 새로운 기능 (예로 들어 새로운 울음 소리)의 추가도 쉬워진다.\n\n## Strategy Pattern\n\n위에서 알아본 적절한 상속관계를 준수한 패턴을 `Strategy Pattern` 라고 한다.\n정확한 정의는 다음과 같다.\n\n> 객체들이 할 수 있는 행위 각각에 대해 `전략 클래스 (Quack, Squack)`를 생성하고,\n> `유사한 행위들을 캡슐화` 하는 `인터페이스 (QuackBehavior)`를 정의하여,\n> 객체의 행위를 동적으로 바꾸고 싶은 경우 `직접 행위를 수정하지 않고 (performQuack())`\n> 전략을 바꿔주기만 함으로써 행위를 유연하게 확장하는 방법을 말합니다.\n\n간단히 말해서 객체가 할 수 있는 행위들을 각각을 전략으로 만들어 놓고, 동적으로 행위의 수정이 필요한 경우 전략을 바꾸는 것만으로 행위의 수정이 가능하도록 만든 패턴이다.\n\n## 결론\n\n`has a (구현)`관계가 `is a (상속)`관계보다 낫다.\n\n상속은 뭘 상속해야 하는지 일일이 파악해야 하는 귀찮음이 있기 때문이다.\n하지만, 구현은 필요한 기능만 가져다 쓰면 되기에 사용및 개발적 측면에서 좋고,\n새로운 기능은 인터페이스를 추가로 구현하면 끝이기에 유지보수 측면에서도 좋다.\n\n따라서 단순히 상속을 이용한 객체지향 프로그래밍 보단,\n전략 패턴을 적용한 코딩 습관을 기르도록 하자.\n","slug":"univ_design-pattern/mid_01","readingMinutes":6,"wordCount":594},{"title":"대학 - 프로그래밍 언어론","description":"3학년 2학기 프로그래밍 언어론 수업 아카이브","icon":"","image":"","tags":[],"draft":false,"date":"2023-09-11 / 09:04","content":"","slug":"univ_design-pattern/index","readingMinutes":0,"wordCount":1}],"mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    span: \"span\",\n    p: \"p\",\n    div: \"div\",\n    pre: \"pre\",\n    code: \"code\",\n    br: \"br\",\n    strong: \"strong\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"필요성\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#필요성\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"필요성\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용한다.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"singleton-pattern\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#singleton-pattern\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Singleton Pattern\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \"Singleton.java\"\n    }), _jsx(_components.pre, {\n      className: \"language-java\",\n      children: _jsxs(_components.code, {\n        className: \"language-java code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line line-number\",\n          line: \"1\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"class\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line line-number highlight-line\",\n          line: \"2\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"static\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), \" _instance\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line line-number\",\n          line: \"3\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line line-number highlight-line\",\n          line: \"4\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line line-number\",\n          line: \"5\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line line-number\",\n          line: \"6\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"static\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"getInstance\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line line-number\",\n          line: \"7\",\n          children: [\"      \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"if\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"_instance \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"==\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"null\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line line-number\",\n          line: \"8\",\n          children: [\"        _instance \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line line-number\",\n          line: \"9\",\n          children: [\"      \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line line-number\",\n          line: \"10\",\n          children: [\"      \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"return\"\n          }), \" _instance\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line line-number\",\n          line: \"11\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line line-number\",\n          line: \"12\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"기존에 봐오던 클래스들과 많이 다르게 클래스 내부에 본인의 인스턴스를 저장하는 공간이 있으며,\", _jsx(_components.br, {}), \"\\n\", _jsx(_components.strong, {\n        children: \"생성자가 외부로 노출되지 않는다\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"인스턴스 생성은 오직 \", _jsx(_components.code, {\n        children: \"getInstance()\"\n      }), \" 메서드 호출을 통해서만 이루어지며,\", _jsx(_components.br, {}), \"\\n\", \"내부적으로 null값인 경우에만 인스턴스를 생성하기 때문에 \", _jsx(_components.code, {\n        children: \"1개의 인스턴스만 생성\"\n      }), \"이 된다.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"multithreading\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#multithreading\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Multithreading\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"하지만 멀티스레딩 환경에서는 인스턴스가 2개 이상 생성되는 경우가 발생할 수 있다.\", _jsx(_components.br, {}), \"\\n\", _jsx(_components.code, {\n        children: \"Line 7\"\n      }), \"과 \", _jsx(_components.code, {\n        children: \"Line 8\"\n      }), \" 사이에서 \", _jsx(_components.code, {\n        children: \"Context switching\"\n      }), \"이 일어나는 경우가 그러하다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이런 경우를 막기 위해서 getInstance()는 \", _jsx(_components.code, {\n        children: \"동기화 처리\"\n      }), \"를 해주는 편이 좋다.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \"Singleton.java\"\n    }), _jsx(_components.pre, {\n      className: \"language-java\",\n      children: _jsxs(_components.code, {\n        className: \"language-java code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"class\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line highlight-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"static\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), \" _instance \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이렇게 하면 프로그램 실행시점에 인스턴스가 생성되어 반드시 1개의 인스턴스만 생성할 수 있다.\", _jsx(_components.br, {}), \"\\n\", \"하지만, 해당 클래스의 생성시점을 제어할 수 없기에 프로그램 성능이 저하되는 문제가 발생할 수 있다.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \"Singleton.java\"\n    }), _jsx(_components.pre, {\n      className: \"language-java\",\n      children: _jsxs(_components.code, {\n        className: \"language-java code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"class\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"static\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), \" _instance\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line highlight-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"static\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"synchronized\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"getInstance\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"      \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"if\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"_instance \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"==\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"null\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"        _instance \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"      \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"      \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"return\"\n          }), \" _instance\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"java처럼 동기화 키워드를 제공하는 경우 인스턴스를 생성하는 함수를 동기화 걸어주면 된다.\", _jsx(_components.br, {}), \"\\n\", \"하지만 이 경우에도 해당 함수가 매우 무거운 기능을 수행하는 경우에는 동기화 시간이 매우 길어져 성능 저하의 원인이 될 수 있다.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \"Singleton.java\"\n    }), _jsx(_components.pre, {\n      className: \"language-java\",\n      children: _jsxs(_components.code, {\n        className: \"language-java code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"class\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"volatile\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"static\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), \" _instance\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line highlight-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"static\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"getInstance\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"      \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"if\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"_instance \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"==\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"null\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"        \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"synchronized\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"class\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"          \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"if\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"_instance \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"==\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"null\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"            _instance \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Singleton\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"          \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"        \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"      \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"      \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"return\"\n          }), \" _instance\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"    \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"위의 코드는 인스턴스 생성 함수 내부에서 정확히 인스턴스를 생성하는 부분만 동기화되기 때문에\", _jsx(_components.br, {}), \"\\n\", \"성능상의 이슈도 없앨 수 있다.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"결론\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#결론\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"결론\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"필요성과 같다.\", _jsx(_components.br, {}), \"\\n\", \"시스템 전체에서 하나의 클래스가 하나의 인스턴스만 생성해야 하는 경우 사용하자.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"toc":[{"slug":"필요성","text":"필요성","subSections":[]},{"slug":"singleton-pattern","text":"Singleton Pattern","subSections":[{"slug":"multithreading","text":"Multithreading"}]},{"slug":"결론","text":"결론","subSections":[]}]},"__N_SSG":true}