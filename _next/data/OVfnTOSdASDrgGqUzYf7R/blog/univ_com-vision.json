{"pageProps":{"posts":[{"title":"Singal Processing Fundamentals","description":"신호 처리에 대한 기초적인 정보입니다.","icon":"","image":"","tags":["LTI System","Convolution","Fourier Transform"],"draft":false,"date":"2023-10-15 / 21:57","content":"\n## LTI System\n\nLinear Time Invariant System은 다음과 같은 성질을 갖는다.\n\n1. Linear\n  선형성을 유지한다.\n\n  <tip>\n    `선형성`\n\n    $$\n    H[a_if_i(x,y) + a_jf_j(x,y)] \\\\\n    = a_iH[f_i(x,y)] + a_jH[f_j(x,y)] \\\\\n    = a_ig_i(x,y) + a_jg_j(x,y)\n    $$\n  </tip>\n\n2. Time Invariant\n  시간에 대해 불변성을 갖는다.\n  즉, 시간이 변해도 delay만 있을 뿐, 동일한 input에 대해 동일한 output을 내보낸다.\n\n### System Response\n\n신호 처리를 위해 신호를 디지털화 한 다음 변환(filter)을 가해서 다시 연속적인 신호로 변환하기 위한 과정을 살펴보자.\n\n![231015-222017](/posts/mid_02/231015-222017.png)\n\n우선 신호를 특정 구간에서 일정한 값으로 근사한다.\n그리고 특정 구간에 대해 근사된 데이터에 변환(filter)를 가한다. \n(참고로 filtering에 대해선 추후에 소개할 예정. 지금은 LTI System을 이용해서 신호를 변환하는 과정만 살펴보자.)\n\n그렇게 변환된 데이터를 다시 연속적인 신호로 변환하기 위해선 LTI System에 Pulse를 적용한 결과를 응용하면 된다.\n\n![231015-222538](/posts/mid_02/231015-222538.png)\n\n넓이가 1인 Pulse를 LTI System에 통과시키면 위와 같은 그래프로 변형된다고 하자.\n이 때, LTI System은 선형성을 유지하고 시간 불변성을 갖기 때문에 Pulse의 세기가 커지거나, 시간이 shift돼도,\nLTI System을 통과해도 그 변화가 유지된다.\n\n그렇기에 위에서 변환된 데이터를 특정 구간에 대해 Pulse라고 생각한다면,\n그 데이터를 LTI System에 통과시키면 다음과 같이 변환될 것이다.\n\n![231015-222954](/posts/mid_02/231015-222954.png)\n\n## Convolution\n\n위에서 언급한 Pulse에 대해 단위 시간(T)를 0에 가깝게 보내면 연속적인 신호에 대한 Pulse가 되는데, 이를 Impulse라고 한다.\n이런 Impulse를 LTI System에 통과시키면 위에서 봤던 그래프 형태로 나오게 되는데, 이를 임펄스 반응 이라고 하고, $h(t)$ 라고 하자.\n\n![231015-223956](/posts/mid_02/231015-223956.png)\n\n입력 신호 $f$와 출력 신호 $y$는 다음과 같은 관계를 갖게 된다.\n\n$$\ny(t) = f(t) * h(t)\n$$\n\n즉, LTI System의 출력($y$)은 시스텝의 임펄스 반응($h$)과 입력($f$)의 Convolution이다.\n\n## Fourier Transform\n\n![231015-224927](/posts/mid_02/231015-224927.png)\n\n푸리에 변환의 기본적인 아이디어는 주기적인 어떠한 함수는 모두 sin파 또는 cos파의 합으로 표현(근사)될 수 있다에서 출발한다.\n\n푸리에 변환을 거치면 시간에 대한 함수가 주파수에 대한 함수로 변환되는데,\n시간 축이 주파수 축으로 변환된다는 뜻이다.\n단적인 예로, 주기가 $2\\pi$이고, 크기가 1인 sin함수는 크기가 1이고, $u=1 (2\\pi)$인 Impulse 형태로 그려진다.\n\n<tip>\n  `푸리에 변환`\n  $$\n  F(u) = \\int_{-\\infty}^{\\infty} f(x)e^{-i2\\pi ux}dx\n  $$\n\n  `역 푸리에 변환`\n  $$\n  f(x) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} F(u)e^{iux}dx\n  $$\n</tip>\n\n그런데 왜 푸리에 변환을 알아야 할까?\n바로 푸리에 변환을 사용하면 Convolution 연산이 매우 간단한 형태로 변환되기 때문이다.\n\n$$\nG(u) = \\int_{-\\infty}^{\\infty}g(x)e^{-i2\\pi ux}dx \\\\\n= \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(\\tau)h(x-\\tau)e^{-i2\\pi ux}dx \\\\\n= \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}[f(\\tau)e^{-i2\\pi u\\tau}d\\tau][h(x-\\tau)e^{-i2\\pi u(x-\\tau)}dx] \\\\\n= \\int_{-\\infty}^{\\infty}[f(\\tau)e^{-i2\\pi u\\tau}d\\tau]\\int_{-\\infty}^{\\infty}[h(x')e^{-i2\\pi ux'}dx'] \\\\ \n= F(u)H(u)\n$$\n\n즉, 기존 도메인($x$)에서의 Convolution 연산이 푸리에 변환된 주파수 도메인($u$)에서는 단순 곱셈으로 표현된다.\n\n![231015-230238](/posts/mid_02/231015-230238.png)\n\n따라서 Convolution 연산을 간단하게 하기 위해서는 일단 푸리에 변환 후 곱연산을 수행해서 다시 역 푸리에 변환을 거치는 과정을 수행하는게 좋다.\n\n### Sampling\n\n[**`이전 포스트`**](https://wjlee611.github.io/blog/univ_com-vision/mid_01#aliasing)에서 Sampling이 적으면 Aliasing이 발생한다고 했었는데, 그 이유을 알아보자.\n\n![231015-230835](/posts/mid_02/231015-230835.png)\n\n왼쪽은 시간 도메인 기준으로 입력 신호에 적절하게 샘플링된 Impulse를 Convolution하면 좌하단처럼 샘플링이 이루어진다.\n오른쪽은 왼쪽을 푸리에 변환한 결과로 Convolution 대신 곱연산한 결과이다.\n\n~~(본인도 이해는 안되지만)~~ 여기서 중요한 것은 샘플링이 촘촘할 수록\n푸리에 변환된 스펙트럼이 듬성듬성 해진다는 점이다.\n\n만약, 샘플링이 적은수가 되었다면 우하단의 입력 신호의 스펙트럼 봉우리(?)가 오버랩될 것이다.\n오버랩 되는 경우 원본을 복구할 수 없기에 Aliasing이 발생하는 것이다.","slug":"univ_com-vision/mid_02","readingMinutes":6,"wordCount":449},{"title":"Digital Image Fundamentals","description":"디지털 이미지에 대한 기초적인 정보입니다.","icon":"","image":"","tags":["Sampling","Quantization","Interpolation"],"draft":false,"date":"2023-10-15 / 20:05","content":"\n## Sampling & Quantization\n\n연속적인 자연계의 현상을 기록하기 위해서는 이미지를 불 연속적인 형태. 즉, 디지털로 변환해야 한다.\n\n예로 들어 이미지의 좌표가 100.32라면? 반올림을 하던지 적당히 100과 같은 불 연속적인 값으로 치환해야 하며,\n에너지레벨 역시 이와 같은 방식으로 디지털화 해야한다.\n\n이렇게 자연계의 연속적인(무한한) 값을 `디지털화 하기 위해 유한하게` 자르는 과정을 `Sampling`이라 하고,\n무한 소수의 데이터를 `양자화시켜 비트에 저장할 수 있게` 자르는 과정을 `Quantization`라고 한다.\n\n![231015-201653](/posts/mid_01/231015-201653.png)\n\n**좌상단**의 이미지 중에서 $\\overline{AB}$ 를 디지털화 해본다면,\n**우상단**의 그래프처럼 에너지레벨(빛의 밝기)이 표현될 것이다. (지글지글 거리는 것은 센서의 한계로인한 노이즈)\n샘플링을 일정 구간으로 잘라 네모난 점으로 표현하면 **좌하단**의 이미지처럼 될 것이고,\n이를 양자화하면 **우하단**의 이미지처렴 변화하여 디지털로 저장할 수 있게 된다.\n\n![231015-202204](/posts/mid_01/231015-202204.png)\n\n이런 방식으로 2차원 이미지를 디지털화 하면 위와 같은 모양이 될텐데,\n연속적인 데이터를 불연속적인 데이터로 변환하면서 어쩔 수 없는 데이터의 손실이 발생할 수 있다.\n\n<tip>\n  픽셀의 가로축은 x축, 세로축은 y축이며,\n  x좌표는 늘 보던 좌표계와 마찬가지로 오른쪽으로 갈 수록 커지지만,\n  y좌표는 반대로 내려갈수록 커진다. **(y축 반전 주의)**\n  <br />\n  M행 N열(M$\\times$N)의 이미지는 다음과 같은 배열에 저장할 수 있다.\n\n  $$\n  f(x,y) = \\begin{bmatrix}\n  f(0,0) & f(0,1) & ... & f(0,N-1) \\\\\n  f(1,0) & f(1,1) & ... & f(1,N-1) \\\\\n  ... & ... & ... & ... \\\\\n  f(M-1,0) & f(M-1,1) & ... & f(M-1,N-1) \\\\\n  \\end{bmatrix}\n  $$\n</tip>\n\n### Aliasing\n\n![231015-205116](/posts/mid_01/231015-205116.png)\n\n샘플링을 위 이미지와 같이 극단적으로 적게 할 경우, 조건이 없다면 원본 데이터를 유추할 수 없게 된다.\n또는 변화량이 너무 큰 경우에도 위와 같은 Aliasing 현상이 발생할 수 있다.\n예로 들어서 선풍기를 영상으로 찍으면 멈춰있는 듯한 현상이 그런 경우이다.\n\n### Quantization Level\n\n![231015-204846](/posts/mid_01/231015-204846.png)\n\n양자화를 얼마나 세밀하게 할지를 Quantization Level이 결정한다.\n레벨이 적을수록 듬성듬성 양자화하게 되고(점선 간격이 늘어남), 이는 화질 저하로 이어진다.\n하지만 용량은 절약될 것이다.\n\n### Size (Storage bits)\n\n이렇게 저장된 영상의 크기를 구해보자.\n\n<notice>\n  이미지의 화질은 M$\\times$N으로 가정하고,\n  각 픽셀은 0~255, 즉, 8 bits의 에너지 레벨을 갖는다고 가정하자.\n</notice>\n\n단색 이미지(Gray Image)의 경우 1픽셀은 8bits가 필요하기에 1byte.\n이 픽셀이 M$\\times$N개 있으니 M$\\times$Nbytes.\n컬러 이미지의 경우 RGB 3개의 색상 채널이 있으니 3을 곱해서 M$\\times$N$\\times$3bytes 가 된다.\n\n위 계산 결과는 하나의 이미지에 대한 사이즈로, 동영상의 경우에는 30프레임의 경우 추가로 30을 더 곱해줘야 할 것이다.\n\n### Saturation\n\n![231015-203543](/posts/mid_01/231015-203543.png)\n\n센서까지 차이가 있던 데이터가 샘플링 과정에서 차이가 없어지는, Saturation 현상이 발생할 수 있다.\n\n### Gray Level\n\n![231015-203931](/posts/mid_01/231015-203931.png)\n![231015-203946](/posts/mid_01/231015-203946.png)\n\nGray Level이 높을 수록 에너지 레벨을 세분화해서 표현할 수 있다.\n따라서 디스플레이 장치가 좋지 않아서 Gray Level이 낮을 경우 같은 이미지라도 위 사진처럼 다르게 표현될 수 있다.\n\n## Interpolation\n\n디지털화된 이미지의 사잇값을 적절히 채워 실제 데이터를 추측하는 과정,\n또는, 저화질의 영상의 픽셀값을 채워 고화질로 바꾸거나, 영상의 회전, 축소시 픽셀값을 추측하는 과정을 Interpolation 라고 한다.\n\n### Pixel math\n\n보통 아래와 같은 행렬간의 연산 혹은 픽셀별 계산으로 처리된다.\n\n$$\n\\begin{bmatrix}\na_{11} & a_{12} \\\\\na_{21} & a_{22} \\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nb_{11} & b_{12} \\\\\nb_{21} & b_{22} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11} + b_{11} & a_{12} + b_{12} \\\\\na_{21} + b_{21} & a_{22} + b_{22} \\\\\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\na_{11} & a_{12} \\\\\na_{21} & a_{22} \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nb_{11} & b_{12} \\\\\nb_{21} & b_{22} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_{11}b_{11} + a_{12}b_{21} & a_{11}b_{12} + a_{12}b_{22} \\\\\na_{21}b_{11} + a_{22}b_{21} & a_{21}b_{12} + a_{22}b_{22} \\\\\n\\end{bmatrix}\n$$\n\n단, 보통 픽셀값은 0~255 사이의 값을 갖기 때문에, overflow, underflow에 대해 적절하게 처리해줘야 한다.\n\n### Linear\n\n$H[f(x,y)] = g(x,y)$ 와 같은 변환 함수 $H$가 있을 때,\n아래의 특성을 만족하면 $H$가 선형이라고 한다.\n\n$$\nH[a_if_i(x,y) + a_jf_j(x,y)] \\\\\n= a_iH[f_i(x,y)] + a_jH[f_j(x,y)] \\\\\n= a_ig_i(x,y) + a_jg_j(x,y)\n$$\n\n즉 연산 순서에 상관없다면 선형이라 하며, 대부분의 이미지 처리 연산은 선형이다.\n\n### Image Rotation\n\n![231015-212235](/posts/mid_01/231015-212235.png)\n\n특정 픽셀을 $\\theta$만큼 반 시계방향으로 회전시킬 경우 아래와 같은 연산을 가해주면 된다.\n\n$$\n\\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n=\nR(\\theta)\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ncos\\theta & -sin\\theta \\\\\nsin\\theta & cos\\theta\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n$$\n\n하지만, 이 경우에는 원점을 중심으로 회전되기 때문에,\n영상을 중심으로 회전시켜야 하는 경우에는 다음과 같은 스탭을 거쳐야 한다.\n\n1. 영상을 중심으로 평행 이동 시킨다.\n2. 삼각함수를 이용해 영상을 회전시킨다.\n3. 다시 영상을 원위치로 평행 이동 시킨다.\n\n하지만, 위 연산은 선형이기 때문에 각 픽셀별로 아래 하나의 연산으로 처리해도 상관없다.\n\n$$\n\\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ncos\\theta & -sin\\theta \\\\\nsin\\theta & cos\\theta\n\\end{bmatrix}\n\\begin{bmatrix}\nx - W/2\\\\\ny - H/2\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nW/2\\\\\nH/2\n\\end{bmatrix}\n$$\n\n<notice>\n  영상 변환을 하기 위해서는 `변환 후(x, y)`의 좌표를 연산을 통해 `변환 전(x', y')`의 좌표를 구하고,\n  그 좌표의 데이터를 가져와 Quantization하여 변환 후의 좌표에 대입하는 과정을 거쳐야 한다.\n</notice>\n\n### Image Interpolation\n\n![231015-214108](/posts/mid_01/231015-214108.png)\n\n검은색 input 영상을 흰색 output 영상으로 upscaling하거나, 영상 회전과 같이\n변환 후의 영상의 좌표가 픽셀에 정확히 들어가지 않는 경우, 검은색 픽셀값을 이용해 흰색 픽셀값을 추측해야 한다.\n추측하는 방식에는 보통 아래와 같은 방법들이 있다.\n\n1. Replication\n  이전 픽셀값의 데이터를 그대로 사용하는 방법이다.\n2. Nearest Neighbor\n  본인과 가까운 픽셀의 데이터를 그대로 사용하는 방법이다.\n\n위 두 방법의 경우 Interpolation은 가능하지만, 이미지 화질의 개선이 이루어지지는 않는다.\n적당한 화질 개선을 위해서는 아래의 방법을 고려해볼 수 있다.\n\n3. (Bi)linear Interpolation\n  근처 픽셀값을 이용해 평균 데이터를 계산하여 사용하는 방법이다.\n\n![231015-214947](/posts/mid_01/231015-214947.png)\n\n$$\nq_1 = (1-a)p_1 + ap_2 \\\\\nq_2 = (1-a)p_3 + ap_4 \\\\\n{} \\\\ \nq = (1-b)q_1 + bq_2\n$$\n","slug":"univ_com-vision/mid_01","readingMinutes":10,"wordCount":824},{"title":"대학 - 컴퓨터비전","description":"3학년 2학기 컴퓨터비전 수업 아카이브","icon":"","image":"","tags":[],"draft":false,"date":"2023-09-06 / 12:20","content":"","slug":"univ_com-vision/index","readingMinutes":0,"wordCount":1}]},"__N_SSG":true}