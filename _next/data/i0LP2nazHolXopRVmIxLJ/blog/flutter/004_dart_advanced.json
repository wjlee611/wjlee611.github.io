{"pageProps":{"post":{"title":"Dart 언어 심화","description":"Dart 언어에 대한 심화된 내용을 정리해봤습니다.","icon":"","image":"","tags":["Dart","Asynchronous","Isolate","Callback"],"draft":false,"date":"2023-09-15 / 11:24","content":"\n<notice>\n  기초적인 지식이 필요하신 분들은 [**`Dart 언어 기초`**](https://wjlee611.github.io/blog/flutter/003_dart_basic) 포스트를 읽어보시길 권장드립니다.\n</notice>\n\n## async / await\n\n`async`, `await` 키워드는 **비동기 프로그래밍**시 빠지지 않는 키워드입니다.\n여기서 `.then()` 메서드나 Dart 에서 `Future<T>` 도 포함해서 원리와 적절한 사용법까지 알아보고자 합니다.\n\n<tip>\n  `비동기 프로그래밍`\n  특정 코드가 완료되기 전, 다른 코드를 수행함으로서 코드의 실행 순서가 순차적(동기적)으로 실행되지 않는 프로그래밍 방식입니다.\n  보통 처리완료까지 시간이 많이 걸리는 네트워크 통신이나 파일 입출력 등에 많이 사용됩니다.\n</tip>\n\n<notice>\n  비동기 처리는 `단일 스레드(Dart의 경우 단일 Isolate) 환경`에서 이루어집니다.\n  따라서 비동기 처리를 한다고 해도, 비동기 함수가 `컴퓨팅 자원 사용량이 많다`면 해당 스레드(Isolate)는 `일시 정지`되는 현상이 발생할 수 있습니다.\n  <br />\n  이와 관련한 자세한 내용은 아래 [**`Isolate`**](https://wjlee611.github.io/blog/flutter/004_dart_advanced#isolate) 파트에서 다루겠습니다.\n</notice>\n\n### Future\n\n`Future` 객체는 지금 당장은 처리되지 않았지만, 미래에 처리가 완료될 데이터를 알려주는 객체입니다.\n예를 들어봅시다.\n\n```dart:.dart\nFuture<String> futureStr() async {\n  print('do something');\n  return Future.delayed(Duration(seconds: 2), () => 'future string');\n}\n\nvoid main() {\n  print('start');\n  print(futureStr());\n}\n```\n\n위의 futureStr() 함수는 호출 후 2초뒤에 'future string'을 반환하는 함수입니다.\n실행결과는 어떻게 될까요?\n\n> start\n> do something\n> Instance of 'Future\\<String\\>'\n> (2초 후 종료)\n\n답은 `future 객체` 입니다.\n어찌보면 당연합니다. `main` 함수는 비동기 함수도 아닐 뿐더러 futureStr의 리턴값은 `Future<String>` 이라고 명시해두었으니 말이죠.\n\n![230917-211924](/posts/004_dart_advanced/230917-211924.png)\n\nfuture는 `Uncompleted`, `Completed` 상태를 갖습니다.\n비동기 함수 호출시에 future은 Uncompleted 상태를 갖습니다.\n따라서 `Instance of 'Future<String>'`와 같은 결과를 출력한 것이죠.\n하지만 함수가 성공적으로 종료되면 future은 비로소 Completed 상태를 갖습니다.\n따라서 `future string`과 같은 결과를 출력하게 될 것입니다.\n\n사용자 입장에서는 Future 객체는 중요하지 않습니다. 중요한 것은 Future 객체가 처리되고 나서 반환되는 데이터인거죠.\n따라서, Future 객체의 처리(비동기 함수)를 원활히 하기위해 `async`, `await` 키워드를 사용하는 것입니다.\n\n### async\n\nasync 키워드는 이 함수가 비동기 처리를 수행하는 함수임을 명시하는 키워드 입니다.\n다만 위의 예시에서 보듯, 반드시 `Future<T>` 객체 또는 `void`를 반환해야만 합니다.\n\n그렇다면, main 함수를 async 키워드를 붙여 실행한다면 제대로된 결과가 나올까요?\n\n```dart:.dart\nFuture<String> futureStr() async {\n  print('do something');\n  return Future.delayed(Duration(seconds: 2), () => 'future string');\n}\n\nvoid main() async {\n  print('start');\n  print(futureStr());\n}\n```\n\n> start\n> do something\n> Instance of 'Future\\<String\\>'\n> (2초 후 종료)\n\n그렇습니다. 함수를 비동기 처리하는 함수로 선언한다고 해서 해결되지는 않습니다.\n함수 내부에서 비동기 처리가 진행될 수 있다는 것을 암시할 뿐, `어디서` 비동기 처리를 해야하는 지는 명시하지 않았기 때문이죠.\n\n### await\n\nawait 키워드는 **해당 키워드가 명시된 비동기 처리**(futureStr)가 완료될 때 까지 **비동기 함수**(main)의 처리를 `멈추겠다`는 의미입니다.\n그렇기에 await 키워드는 반드시 async 키워드가 명시된 함수 내부에서만 사용할 수 있는 것입니다.\n\n그렇다면 futureStr의 함수 앞에 await를 명시하여 비동기 함수가 끝날 때 까지 대기시킨다면 어떨까요?\n\n```dart:.dart\nFuture<String> futureStr() async {\n  print('do something');\n  // return Future.delayed(Duration(seconds: 2), () => 'future string');\n  await Future.delayed(Duration(seconds: 2));\n  return 'future string';\n}\n\n\nvoid main() async {\n  print('start');\n  print(await futureStr());\n}\n```\n\n> start\n> do something\n> (2초 대기)\n> future string\n> (즉시 종료)\n\n비로소 원하던 결과가 나왔습니다.\n\n---\n\n## Isolate\n\n`Isolate`는 Dart에서 스레드를 부르는 용어라고 생각하시면 됩니다.\n\n![230917-221122](/posts/004_dart_advanced/230917-221122.png)\n\nIsolate는 스레드와 마찬가지로 멀티 코어 CPU의 장점을 살리는 프로그래밍 기법으로 `별도의 이벤트 루프`를 갖는 실행 흐름을 만들어 `병렬적인 처리`를 가능케 합니다.\n하지만, 스레드와 용어에서의 차이점을 두는 이유가 있습니다.\n\n보통 **스레드**라 하면 `메모리 영역을 공유`한다고 배웠습니다. 하지만 그 때문에 `race-condition`이 발생하는 문제점을 고려하여 프로그래밍을 했어야 합니다.\n\n하지만, **Isolate**는 스레드와 다르게 `메모리 영역 또한 공유하지 않습니다`.(물론 코드 영역은 공유합니다) \n그렇기에 mutex, lock 등을 고려할 필요가 없는 편의성이 있습니다.\n\n하지만 왜 Isolate를 알아야 하고, 사용해야만 할까요?\n\n### Isolate vs Async\n\n아래의 영상을 확인해봅시다.\n\n<YT id='HkBaS098BrE' />\n\n`Main isolate`부분은 json 데이터 파싱과 화면 빌드를 `하나의 isolate`에서 구동한 결과입니다.\n영상에서 보시는 바와 같듯 십몇만줄의 json 파싱은 단일 isolate 환경에서 구동하기에는 다소 무리가 있습니다.\n아무리 async로 실행 결과를 뒤로 미룬다 할지라도 실제 데이터 파싱하는 동작과 화면을 그리는 동작 모두 `동일한 isolate`에서 처리되기 때문에 `성능상 이슈`가 생길 수 밖에 없습니다.\n\n하지만 `Worker isolate`부분은 json 데이터 파싱을 `별도의 worker isolate`에서 구동한 결과입니다.\n차이는 명확합니다. 화면에 그리는 동작과 파싱 동작이 `별도의 isolate`에서 처리되기 때문에 화면을 그리는 부분에서 `랙이 걸리지 않습니다`.\n\n이렇듯 단일 isolate에서 동작이 버벅일 정도로 무거운 기능을 수행해야 한다면, 해당 기능은 별도의 isolate로 빼서 처리하는 것이 사용자에게 더 나은 경험을 제공하게 됩니다.\n\n해당 영상에서 구동하는 코드는 [**`Arkhive repo`**](https://github.com/wjlee611/arkhive/blob/main/lib/bloc/enemy/enemy_data/enemy_data_bloc.dart)에서 확인하실 수 있습니다.\n\n---\n\n## function\n\n### callback function\n\n콜백 함수는 함수의 인자로 넘겨주어 넘겨받은 함수 내부에서 실행 가능한 함수를 의미합니다.\n예시를 살펴봅시다.\n\n```dart:.dart\nvoid main() {\n  int value = 0;\n\n  print(valueModifire(value: value, modifire: add1)); // 1\n  print(valueModifire(value: value, modifire: sub1)); // -1\n}\n\nint add1(int value) => value + 1;\nint sub1(int value) => value - 1;\n\nint valueModifire({\n  required int value,\n  required Function(int) modifire,\n}) {\n  return modifire(value);\n}\n```\n\n위 코드에서는 `valueModifire`의 인자로서 `add1`, `sub1`을 전달했습니다.\n이 때, 이 두 함수를 `callback function`라고 부르고, 이 함수는 valueModifire 내부에서 `modifire`의 형태로 호출됩니다.\n\n보통은 이런식으로 `동일한 함수` 내부에서 `서로 다른 기능`을 수행해야 할 때 콜백 함수로서 전달하는 경우가 많습니다.\n\n```dart:.dart\nvoid main() async {\n  int value = 0;\n\n  print(await valueModifire(value: value, modifire: add1)); // await 1 second -> 1\n  print(await valueModifire(value: value, modifire: sub1)); // await 1 second -> -1\n}\n\nint add1(int value) => value + 1;\nint sub1(int value) => value - 1;\n\nFuture<int> valueModifire({\n  required int value,\n  required Function(int) modifire,\n}) async {\n  await Future.delayed(Duration(seconds: 1)); // something actions\n  return modifire(value);\n}\n```\n\n또는, `특정 함수의 동작이 끝난 후` 수행해야 할 기능이 있을 때 많이 사용되곤 합니다.","slug":"flutter/004_dart_advanced","readingMinutes":10,"wordCount":836},"posts":[{"title":"Lerp (애니메이션 선형 보간)","description":"애니메이션을 이용해서 선형 보간(Linear Interpolation)를 쉽게 구현해봅시다.","icon":"","image":"","tags":["Animation","AnimationController"],"draft":false,"date":"2024-02-15 / 21:04","content":"\n<notice>\n  Flutter Color의 `lerp()` 와 연결되는 내용은 **아닙니다**.\n  (이론적인 부분은 일맥상통 하지만, 정확히는 애니메이션에 대한 포스트 입니다)\n</notice>\n\n우선 시작하기에 앞서 [**`gyro_provider`**](https://pub.dev/packages/gyro_provider) 플러그인을 소개합니다~\n저의 첫 라이브러리이자, pub.dev 데뷔 작품(?)입니다 ㅎㅎ\n\n![gyro_provider_demo](/posts/lerp/gyro_provider_demo.gif)\n\n모바일 기기의 자이로스코프 센서를 이용해서 위젯을 변형시키거나, 센서 값을 제공하는 라이브러리 입니다.\n이번 포스트는 이 플러그인을 개발하며 배웠던 내용을 소개 하겠습니다.\n\n## 문제 인지\n\nFlutter Animation은 AnimationController가 지정한 시간(Duration)동안 동작합니다.\n\n```dart:.dart\n_animationController = AnimationController(\n  vsync: this,\n  duration: Duration(seconds: 1),\n)\n```\n\n그리고 Animation은 AnimationController에 의해 변화되는 값을 보관하고 있죠.\n\n```dart:.dart\n_xAnimation = Tween<double>(\n  begin: 0,\n  end: _xTarget,\n).animate(_animationController);\n```\n\n예로 들어 AnimationController의 값이 **0**에서 **1**로 _1초 동안_ 변할 동안 _xAnimation의 값은 **0**에서 **_xTarget**까지 _1초 동안_ 변화하는 것이죠.\n즉, AnimationController에 의해 Animation의 값이 **선형 보간**되는 것입니다.\n\n만약 _xTarget의 값이 도중에 변한다면 어떻게 될까요?\n\n### 문제 발생\n\n여기서 문제가 발생합니다.\n\n애니메이션은 새로운 _xTarget 값을 향해 바뀌는 것이 아닌, 바뀌기 전의 _xTarget값을 향해 선형 보간될 것입니다.\n\n---\n\n## Lerp\n\n바뀐 후의 _xTarget값을 향하여 선형 보간을 하기 위해서는 AnimatedContainer를 리셋시키고 Animation을 재정의 해야 합니다.\n\n```dart:.dart\n_animationController.reset();\n\n_xAnimation = Tween<double>(\n  begin: 0,\n  end: _xTarget, // new value\n).animate(_animationController);\n\n_animationController.forward();\n```\n\n하지만 이런식으로 코드를 짠다면 문제가 발생하겠죠.\n시작점(begin)이 0으로 초기화 되기 때문입니다.\n\n따라서 begin의 값은 AnimationController를 초기화 하기 직전의 Animation의 값을 가지고 있어야 할 것 입니다.\n\n```dart:.dart\nvar currX = _animation.value;\n\n_animationController.reset();\n\n_xAnimation = Tween<double>(\n  begin: currX,\n  end: _xTarget, // new value\n).animate(_animationController);\n\n_animationController.forward();\n```\n\n위와 같이 코드를 수정한다면, _xTarget가 변경되었을 때, 위 코드를 실행하면 \n진행되던 애니메이션이 이어서 부드럽게 새로운 애니메이션이 되어 새로운 _xTarget를 향하여 진행할 것입니다.\n\n### 장점\n\nAnimatedContainer의 Duration보다 짧은 시간안에 _xTarget 값이 변하더라도 애니메이션을 부드럽게 진행시킬 수 있습니다.\n\n즉, _xTarget이 변할 때마다 새로운 선형 보간을 적용할 수 있게 되는 것입니다.\n\n### 단점\n\nAnimatedContainer의 Duration이 길수록 _'뭔가 늦게 반응한다'_ 라는 느낌을 받으실 수 있습니다.\n\n그렇다고 Duration을 _xTarget이 변화하는 주기보다 짧게 설정할 경우에는 애니메이션 중간마다 끊기는 느낌을 받을 수 있습니다.\n\n---\n\n## 코드 리뷰\n\n그럼 선형 보간과 관련한 [**`gyro_provider`**](https://pub.dev/packages/gyro_provider)의 코드를 리뷰해보며 이해를 굳혀봅시다.\n\n### forward\n\n우선 애니메이션이 진행 중입니다.\n\n```dart:gyro_provider.dart {30}\n  @override\n  void initState() {\n    super.initState();\n    ...\n    // Initialize animation\n    _animationController = AnimationController(\n      vsync: this,\n      duration: widget.animationDuration,\n    )\n      ..addListener(_animationListener)\n      ..addStatusListener(_animationStatusListener);\n\n    _linearCurve = CurvedAnimation(\n      parent: _animationController,\n      curve: Curves.linear,\n    );\n    _easeCurve = CurvedAnimation(\n      parent: _animationController,\n      curve: Curves.easeOut,\n    );\n\n    _xAnimation = Tween<double>(\n      begin: 0,\n      end: _xTarget,\n    ).animate(_linearCurve);\n    _yAnimation = Tween<double>(\n      begin: 0,\n      end: _yTarget,\n    ).animate(_linearCurve);\n    _animationController.forward();\n  }\n```\n\n0에서 _xTarget 으로 이동 중이겠죠.\n\n### change target\n\n그러다 _xTarget의 값이 변화합니다.\n\n```dart:gyro_provider.dart {12}\n  void _gyroListener() {\n    var value = _gyroscopeController.value;\n    _gyroData.value = value;\n    widget.gyroscope?.call(value);\n\n    if (value.x.abs() < 0.1 && value.y.abs() < 0.1 && !widget.centerLock) {\n      ...\n    }\n    // Change the target rotation angle by the amount the sensor value changes\n    // and animate toward that value.\n    else {\n      _xTarget += value.x;\n      _yTarget += value.y;\n    }\n    // The animation only changes when the widget is not being moved to the center.\n    if (!_onCenter) {\n      _animation(curve: _linearCurve);\n    }\n  }\n```\n\n하지만, 현재 AnimatedContainer가 변형시키는 Animation의 _xTarget 값은 변화하지 않았습니다.\n\n### reset\n\n따라서 애니메이션을 중지시키고 재설정을 합니다.\n하지만, 중지 시키기 전에 현재까지 변화한 Animation의 값을 보관합니다.\n\n```dart:gyro_provider.dart {4, 6}\n  void _animation({required CurvedAnimation curve}) {\n    if (!mounted) return;\n\n    var xCurr = _xAnimation.value;\n    var yCurr = _yAnimation.value;\n    _animationController.reset();\n    _xAnimation = Tween<double>(\n      begin: xCurr,\n      end: _xTarget,\n    ).animate(curve);\n    _yAnimation = Tween<double>(\n      begin: yCurr,\n      end: _yTarget,\n    ).animate(curve);\n    _animationController.forward();\n  }\n```\n\n### (re)forward\n\n그리고 다시 애니메이션을 동작 시킵니다.\n\n```dart:gyro_provider.dart {8, 15}\n  void _animation({required CurvedAnimation curve}) {\n    if (!mounted) return;\n\n    var xCurr = _xAnimation.value;\n    var yCurr = _yAnimation.value;\n    _animationController.reset();\n    _xAnimation = Tween<double>(\n      begin: xCurr,\n      end: _xTarget,\n    ).animate(curve);\n    _yAnimation = Tween<double>(\n      begin: yCurr,\n      end: _yTarget,\n    ).animate(curve);\n    _animationController.forward();\n  }\n```\n\n---\n\n## 마무리\n\n코드 전문은 오픈소스로 공개된 [**`gyro_provider`**](https://pub.dev/packages/gyro_provider) 레포에서 확인하실 수 있습니다.\n\nFlutter Animation에 대해 잘 모르는 상태로 플러그인 개발 프로젝트를 시작했는데,\n무작정 시도하긴 했지만, 배워가는 점도 많았던거 같습니다. \n(적어도 AnimationController, Animation은 나름 자유자재로 사용할 수 있게 되었다는 거?)\n\n사실 네이티브 코드에서 센서의 인터벌(interval)을 매우 빠르게 설정하면(초당 60 이상) 애니메이션을 구현할 필요도 없을 것입니다.\n\n하지만, 초당 60번의 통신은 성능 저하의 원인이 될 수 있다는 생각이 들었고,\n기기 사양이 안좋은 경우에는 초당 60회의 통신이 불가능할 수도 있을지도 몰랐기에 이런 방식으로 구현했습니다.\n(초당 10~15회 통신, 기기 주사율에 맞도록 사이의 값은 애니메이션을 이용해 lerp(선형 보간))\n~_이 부분을 문제 인지에 적는게 나았을지도.._~\n\n사실 신경 쓸 필요도 없을지도 모르지만, 이런 고민 덕분에 새로운 시도를 할 수 있게 되어 오히려 좋았던 거 같습니다.","slug":"flutter/lerp","readingMinutes":8,"wordCount":689},{"title":"Ticker","description":"Ticker와 TickerProvider mixin에 대해 알아봅니다.","icon":"","image":"","tags":["Ticker","TickerProvider","Controller"],"draft":false,"date":"2024-02-02 / 15:14","content":"\nFlutter로 개발하다보면 TabController, AnimationController와 같은 Controller에 `vsync: this` 를 반드시 종속성 주입해야 하는 경우가 있습니다.\n이럴 때 마다 TickerProviderStateMixin 을 상속받아 사용해서 this를 사용할 수 있게 되는데, 이게 항상 궁금했었죠...\n\n그러다, Flutter 애니메이션을 공부하다 그 이유를 알게되었고, 그 내용을 정리해보고자 합니다.\n\n## Ticker\n\n우선 Ticker에 대해 알아야 합니다.\n\nTicker는 매 프레임마다 함수를 호출하는 역할을 수행하는데, 아래의 코드를 살펴봅시다.\n\n```dart:stateful_widget.dart {7}\nlate final Ticker _ticker;\n\n@override\nvoid initState() {\n  super.initState();\n  _ticker = Ticker(\n    (elapsed) => print(elapsed);\n  );\n  _ticker.start();\n}\n\n@override\nvoid dispose() {\n  _ticker.dispose();\n  super.dispose();\n}\n```\n\n이렇게 하면, 이 위젯이 위젯트리에 올라가서 상태가 컨텍스트에 등록되는 순간부터 매 프레임마다 elapsed가 찍히게 됩니다. (대략 60fps)\n만약, `_ticker.dispose()` 를 호출하지 않는다면, 위젯트리에서 내려가도 Ticker가 계속 함수를 매 프레임마다 호출하게 될 겁니다.\n\n정리하자면, 매 프레임마다 함수를 호출하게 해주는 클래스가 Ticker 입니다.\n하지만, 왜 Ticker를 사용하는 걸까요?\n\n바로 **부드러운 화면 모션** 때문입니다.\n매 프레임마다 함수를 실행한다는 것은, 매 프레임마다 화면을 업데이트 시킬 수도 있다는 뜻입니다.\n자원을 많이 잡아먹긴 하겠지만, 최적화만 잘 한다면, 부드러운 애니메이션을 보여줄 수 있겠죠!\n\n### TickerProvider\n\n이제, Ticker가 뭔지, 왜 사용하는지를 알았습니다.\n하지만, 강력한 기능을 가진 만큼, 취급에 주의해야 하겠죠...\n생성하고, 함수를 등록하고, 반드시 dispose 해야하는...\n\n이런 과정을 개발자에게 맡겼다간 반드시 실수가 발생할 것입니다.\n따라서 Ticker의 사용을 은닉화 하기위해 우선 Ticker을 생성하는 인터페이스(정확히는 abstract class)가 제공되는데, 이게 바로 TickerProvider 입니다.\n\n```dart:ticker.dart\nabstract class TickerProvider {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const TickerProvider();\n\n  /// Creates a ticker with the given callback.\n  ///\n  /// The kind of ticker provided depends on the kind of ticker provider.\n  @factory\n  Ticker createTicker(TickerCallback onTick);\n}\n\n```\n\n이 클래스를 상속받은 클래스는 반드시 createTicker 구현해서 사용해야 하며, 이름에서 알 수 있듯 이 함수는 Ticker를 반환하게 됩니다.\n\n예로 들어, TickerProvider의 구현체 중 하나인 SingleTickerProviderStateMixin의 내부를 살펴보겠습니다.\n\n```dart:ticker_provider.dart {5}\nmixin SingleTickerProviderStateMixin<T extends StatefulWidget> on State<T> implements TickerProvider {\n  Ticker? _ticker;\n\n  @override\n  Ticker createTicker(TickerCallback onTick) {\n    _ticker = Ticker(onTick, debugLabel: kDebugMode ? 'created by ${describeIdentity(this)}' : null);\n    _updateTickerModeNotifier();\n    _updateTicker(); // Sets _ticker.mute correctly.\n    return _ticker!;\n  }\n\n  @override\n  void dispose() {\n    _tickerModeNotifier?.removeListener(_updateTicker);\n    _tickerModeNotifier = null;\n    super.dispose();\n  }\n}\n```\n\n간단하게만 보면 해당 mixin에서 Ticker 생성과 삭제에 필요한 모든 기능을 수행한다고 볼 수 있습니다.\n\n<tip>\n  필요한 모든 기능 중, 가장 중요한 기능은 `자원 관리` 라고 생각됩니다.\n  실제로 설명의 최상단에도 언급되어 있습니다.\n  > Provides a single [Ticker] that is configured to only tick while the current tree is enabled, as defined by [TickerMode].\n\n  즉, 사용을 강제하는 주된 이유는 위젯이 위젯 트리에 등록된 상태에서만 Ticker를 제공함으로서 자원을 효율적으로 실수 없이 관리하기 위함이라고 생각됩니다.\n</tip>\n\n### Controller\n\n생성했으면 이를 사용해야겠죠?\n이 때, vsync 가 사용됩니다.\n\n```dart:animation_controller.dart {12, 15}\nclass AnimationController extends Animation<double>\n  with AnimationEagerListenerMixin, AnimationLocalListenersMixin, AnimationLocalStatusListenersMixin {\n\n  AnimationController({\n    double? value,\n    this.duration,\n    this.reverseDuration,\n    this.debugLabel,\n    this.lowerBound = 0.0,\n    this.upperBound = 1.0,\n    this.animationBehavior = AnimationBehavior.normal,\n    required  TickerProvider vsync,\n  }) : assert(upperBound >= lowerBound),\n       _direction = _AnimationDirection.forward {\n    _ticker = vsync.createTicker(_tick);\n    _internalSetValue(value ?? lowerBound);\n  }\n}\n```\n\nvsync는 TickerProvider를 인자로 받게 되는데, TickerProviderStateMixin을 상속받은 클래스(위젯)에서 `vsync: this` 를 다형성의 원리에 의해 종속성 주입하면 해당 클래스(위젯)의 createTicker 함수를 호출할 수 있게 되는 것입니다.\n\n즉, Controller는 부드러운 애니메이션을 위해 Ticker를 사용해야 하는데, 개발자에게 이를 맡겼다간 실수가 발생할 수도 있고, 기타 여러 이유 때문에 TickerProvider 로부터 ticker를 받도록 구현되었고, 그 과정에서 vsync로 종속성을 주입받게 되었다고 정리해볼 수 있겠습니다.\n\n---\n\n## Animation 엿보기\n\n정리하는 차원에서 `_animationController.forward()` 의 과정을 추적해봅시다.\n\n```dart:animation_controller.dart\nTickerFuture forward({ double? from }) {\n  _direction = _AnimationDirection.forward;\n  if (from != null) {\n    value = from;\n  }\n  return _animateToInternal(upperBound);\n}\n```\n\n애니메이션의 방향(_direction)을 설정하고 `_animateToInternal` 함수를 실행합니다.\n\n```dart:animation_controller.dart\nTickerFuture _animateToInternal(double target, { Duration? duration, Curve curve = Curves.linear }) {\n  double scale = 1.0;\n  if (SemanticsBinding.instance.disableAnimations) {\n    switch (animationBehavior) {\n      case AnimationBehavior.normal:\n        scale = 0.05;\n      case AnimationBehavior.preserve:\n        break;\n    }\n  }\n  Duration? simulationDuration = duration;\n  if (simulationDuration == null) {\n    final double range = upperBound - lowerBound;\n    final double remainingFraction = range.isFinite ? (target - _value).abs() / range : 1.0;\n    final Duration directionDuration =\n      (_direction == _AnimationDirection.reverse && reverseDuration != null)\n      ? reverseDuration!\n      : this.duration!;\n    simulationDuration = directionDuration * remainingFraction;\n  } else if (target == value) {\n    simulationDuration = Duration.zero;\n  }\n  stop();\n  if (simulationDuration == Duration.zero) {\n    if (value != target) {\n      _value = clampDouble(target, lowerBound, upperBound);\n      notifyListeners();\n    }\n    _status = (_direction == _AnimationDirection.forward) ?\n      AnimationStatus.completed :\n      AnimationStatus.dismissed;\n    _checkStatusChanged();\n    return TickerFuture.complete();\n  }\n  return _startSimulation(_InterpolationSimulation(_value, target, simulationDuration, curve, scale));\n}\n```\n\n`_startSimulation` 실행에 필요한 값들을 연산하고, 기존에 실행 중이던 애니메이션을 stop 하는 것으로 보입니다.\n이 후, `_startSimulation` 함수를 실행합니다.\n\n```dart:animation_controller.dart {5}\nTickerFuture _startSimulation(Simulation simulation) {\n  _simulation = simulation;\n  _lastElapsedDuration = Duration.zero;\n  _value = clampDouble(simulation.x(0.0), lowerBound, upperBound);\n  final TickerFuture result = _ticker!.start();\n  _status = (_direction == _AnimationDirection.forward) ?\n    AnimationStatus.forward :\n    AnimationStatus.reverse;\n  _checkStatusChanged();\n  return result;\n}\n```\n\n초기 값을 설정하고 _ticker를 시작하는 모습입니다.\n참고로 위 코드를 보면 아시겠지만, _ticker는 `_tick` 함수를 매 프레임마다 호출하게 됩니다.\n따라서 `_tick` 함수도 살펴봅시다.\n\n```dart:animation_controller.dart\nvoid _tick(Duration elapsed) {\n  _lastElapsedDuration = elapsed;\n  final double elapsedInSeconds = elapsed.inMicroseconds.toDouble() / Duration.microsecondsPerSecond;\n  _value = clampDouble(_simulation!.x(elapsedInSeconds), lowerBound, upperBound);\n  if (_simulation!.isDone(elapsedInSeconds)) {\n    _status = (_direction == _AnimationDirection.forward) ?\n      AnimationStatus.completed :\n      AnimationStatus.dismissed;\n    stop(canceled: false);\n  }\n  notifyListeners();\n  _checkStatusChanged();\n}\n```\n\n매 프레임마다 _value값이 업데이트 되고, notifyListeners를 통해 화면을 업데이트 하는 모양새입니다.","slug":"flutter/ticker","readingMinutes":8,"wordCount":828},{"title":"Freezed에서 제네릭 사용하기","description":"API 응답 모델링에서 사용하면 좋은 Freezed 제네릭 테크닉에 대해 소개합니다.","icon":"","image":"","tags":["Freezed","Generic"],"draft":false,"date":"2024-01-24 / 22:20","content":"\n기존 JsonSerializable로 아래와 같은 응답을 모델링 하였습니다.\n\n```json:json\n{\n  'code': 1000,\n  'message': '성공',\n  'data': { ... }\n}\n```\n\n이런 식으로, code, message(선택) 가 반드시 포함된 응답이 오는 상황이어서\ncode, message를 갖고있는 ResModel,\n그리고 ResModel을 상속받아 만든 DataModel 이런식으로 구현하였습니다.\n\n하지만, JsonSerializable로 구현했던 모델들을 Freezed로 마이그레이션 하는 과정에서 문제가 발생했습니다.\n바로, Freezed는 상속이 불가능하다는 점..!\n\n그래서 해결책을 몰색하던 중 ResModel에 제네릭 타입의 data 멤버를 추가하면 어떤가 하는 조언을 받았습니다.\n\n좋은 해결책인거 같기도 하고, 마침 Freezed에 대해 딥하게 알아보고 공부할 겸 이 해결책을 적용해보기로 하였습니다.\n\n## 구현\n\n### DataModel\n\n우선 Data에 해당하는 객체를 모델링 하였습니다.\n\n```dart:diary_model.dart\npart 'diary_model.freezed.dart';\npart 'diary_model.g.dart';\n\n@freezed\nclass DiaryModel with _$DiaryModel {\n  factory DiaryModel({\n    @JsonKey(name: 'diaryid') int? id,\n    @JsonKey(name: 'dcontent') String? content,\n    @JsonKey(name: 'dtime') DateTime? time,\n    @JsonKey(name: 'dtag') EEmotion? emotion,\n    @JsonKey(name: 'userid') int? userId,\n    @JsonKey(\n      name: 'openable',\n      fromJson: openableFromJson,\n      toJson: openableToJson,\n    )\n    bool? isOpen,\n  }) = _DiaryModel;\n\n  factory DiaryModel.fromJson(Map<String, dynamic> json) =>\n      _$DiaryModelFromJson(json);\n}\n```\n\n`@JsonKey` 어노테이션을 통해 API에서 전달하는 key와 모델링의 변수명을 변환했습니다.\n또한, openable key의 value가 0 or 1 로 표현하는 bool 형식이라\n0 &rarr; false, 1 &rarr; true 로 변환하는 함수(openableFromJson/ToJson)를 적용하였습니다.\n\n### ResModel\n\n그 다음 공통 응답 모델을 맡을 ResModel을 제네릭으로 모델링합니다.\n\n```dart:res_model.dart\npart 'res_model.freezed.dart';\npart 'res_model.g.dart';\n\n@Freezed(genericArgumentFactories: true)\nclass ResModel<T> with _$ResModel<T> {\n  factory ResModel({\n    required int code,\n    String? message,\n    T? data,\n  }) = _ResModel;\n\n  factory ResModel.fromJson(\n    Map<String, dynamic> json,\n    T Function(dynamic json) fromJsonT,\n  ) =>\n      _$ResModelFromJson<T>(json, fromJsonT);\n}\n```\n\n여기서 눈여겨 봐야 할 점은 fromJson의 인자로 fromJsonT 함수를 전달한다는 것입니다.\n\n보통은 fromJson에 json 만 인자로 넘기는데, 제네릭을 포함하는 경우 문제가 발생합니다.\n바로 제네릭에 해당하는 객체의 직렬화, 역직렬화 로직을 프로그램은 모른다는 것이죠.\n\n따라서 해당 로직을 대신 수행할 fromJsonT 함수를 인자로 추가로 받는 것입니다.\n(toJsonT는 freezed에 의해 자동 생성되며, 마찬가지로 toJsonT를 인자로 받습니다.)\n\n이를 build_runner가 알도록 하기 위해 **@freezed** 어노테이션 대신 **@Freezed** 를 사용하며,\n`genericArgumentFactories`을 true로 설정합니다.\n\n### fromJson / toJson\n\n이제 실제로 사용도 해봐야겠죠?\n\n```dart:diray_repository.dart\nvar resModel = ResModel<DiaryModel>.fromJson(\n  res.data,\n  (json) => DiaryModel.fromJson(json),\n);\n```\n\n첫 번째 인자로 API의 응답으로 온 json 이 들어갑니다.\n두 번째 인자로는 제네릭 타입의 역직렬화를 수행하는 함수가 들어가는데, 제네릭이 DiaryModel 이므로, DiaryModel.fromJson를 넣어주면 됩니다.\n(참고로 파라미터로 전달되는 json 인자에는 data의 value가 전달됩니다.)\n\ntoJson도 살펴봅시다.\n\n```dart:diray_repository.dart\nvar reqJson = resModel.toJson(\n  (model) => DiaryModel.fromJson(model),\n);\n```\n\n인자로는 제네릭 타입의 직렬화를 수행하는 함수가 들어가는데, 제네릭이 DiaryModel 이므로, DiaryModel.toJson를 넣어주면 됩니다.\n(참고로 파라미터로 전달되는 model 인자에는 diaryModel의 인스턴스가 전달됩니다.)\n\n### 결과물\n\ndata가 없는 경우, 또는 필요 없는 경우에는 아래와 같이 fromJson을 사용할 수 있습니다.\n\n```dart:auth_interceptor.dart\nvar res = ResModel.fromJson(response.data, (json) => null);\nif (res.code == 2000) {\n  AuthBlocSingleton.bloc.add(AuthSignoutEvent());\n}\n...\n```\n\n또한, data가 있는 경우, 또는 필요한 경우에는 아래와 같이 fromJson을 사용할 수 있습니다.\n\n```dart:diray_repository.dart\nDio dio = Dio();\ndio.interceptors.add(AuthInterceptor());\nvar res = await dio.get(\n  '/diary',\n  queryParameters: {\n    'emotion': emotion.key,\n  },\n  data: {\n    'page': page,\n  },\n);\n\nvar resModel = ResModel<DiaryModel>.fromJson(\n  res.data,\n  (json) => DiaryModel.fromJson(json),\n);\n```\n\n코드의 재사용성을 최대로 하고, 로직간의 의존성을 최소화 하도록 구현해본 유익한 시간이었습니다 ㅎㅎ.","slug":"flutter/generic_freezed","readingMinutes":5,"wordCount":469},{"title":"BLoC, context 외부에서 관리하기","description":"BuildContext 없이 BLoC에 접근하고, listen 하는 방법을 알아봅니다.","icon":"","image":"","tags":["BLoC","Singleton Pattern"],"draft":false,"date":"2024-01-24 / 19:15","content":"\n보통 Bloc은 BlocProvider로 context(위젯트리)에서 관리하고, `context.read<Bloc>()` 형태로 읽어오죠?\n하지만, 이 경우 문제가, context 밖에서는 Bloc에 접근할 방법이 없다는 것입니다.\n\n제 경우에는, dio interceptor에서 Bloc에 접근하고 싶은 상황이었죠..\n\n이런 상황, 혹은 앱 실행시간동안 계속 필요한 Bloc의 경우 Singleton Pattern을 이용하여 관리하는 유용한 방법에 대해 설명하려 합니다.\n\n## BlocBuilder\n\n우선 BlocBuilder, Listern의 bloc 파라미터를 먼저 살펴봅시다.\n보통은 bloc 파라미터를 null값으로 놔두고 사용합니다.\n\n하지만, 아래의 bloc 소스 코드를 살펴보겠습니다.\n\n```dart:bloc_builder.dart {9}\nclass _BlocBuilderBaseState<B extends StateStreamable<S>, S>\n    extends State<BlocBuilderBase<B, S>> {\n  late B _bloc;\n  late S _state;\n\n  @override\n  void initState() {\n    super.initState();\n    _bloc = widget.bloc ?? context.read<B>();\n    _state = _bloc.state;\n  }\n  ...\n}\n```\n\n보이는 바와 같이, bloc이 null값이면 context에서, notnull이면 bloc 에서 bloc을 가져오는 방식으로 작동합니다.\n\n즉, context에서 bloc에 접근할 수 없는 경우에는 bloc 파라미터에 bloc을 직접 주입시키면 되는 것입니다.\n이를 응용해서 코드 어디에서나 Singleton Pattern을 통해서 bloc에 접근하는 방법을 사용해 볼 수 있겠습니다.\n\n## 구현\n\n### Singleton\n\n우선, context 외부에서 관리할 Bloc의 인스턴스를 보관할 Singleton 객체를 하나 만들어줍니다.\n\n```dart\nclass AuthBlocSingleton {\n  AuthBlocSingleton._constructor();\n  static final AuthBlocSingleton _signleton = AuthBlocSingleton._constructor();\n  static AuthBlocSingleton get instance => _signleton;\n\n  static late final AuthBloc _bloc;\n  static AuthBloc get bloc => _bloc;\n\n  static initializer({required AuthenticationRepository repository}) {\n    _bloc = AuthBloc(authenticationRepository: repository);\n  }\n}\n```\n\n이렇게하면, AuthBlocSingleton.bloc 으로 코드 전역에서 접근할 수 있습니다.\n(물론 사용하기 전에 initializer 메서드를 호출해야만 합니다)\n\n### Initialized\n\n그리고, bloc에 종속성을 주입해야 하는 경우, 사용하기 전에 주입하도록 합시다.\n\n```dart:app_routes.dart\n\nclass _AppRoutesState extends State<AppRoutes> {\n  late GoRouter _routerConfig;\n\n  @override\n  void initState() {\n    super.initState();\n\n    // Initialize AuthBloc\n    AuthBlocSingleton.initializer(\n      repository: context.read<AuthenticationRepository>(),\n    );\n    ...\n  }\n  ...\n}\n```\n\n제 경우에는 repository를 context에 주입하여 사용하고 있기 때문에, context에 접근 가능한 최상위 위젯에서 bloc에 주입시켜 초기화를 진행하였습니다.\n\n### 결과물\n\n이제 BlocBuilder, Listener는 아래와 같이 코드 한 줄만 추가하면 됩니다.\n\n```dart {2}\nBlocBuilder<AuthBloc, AuthState>(\n  bloc: AuthBlocSingleton.bloc,\n  builder: (context, state) {\n  ...\n```\n\n이렇게 하면, BlocProvider로 Bloc을 생성하지 않고도 Bloc을 사용할 수 있습니다.\n아래와 같은 장점도 챙길 수 있죠!\n1. 위젯트리가 가벼워진다.\n2. 싱글톤으로 코드 어디서나 Bloc에 접근할 수 있다. (state, add() 모두 가능)\n\n따라서 dio의 interceptor 클래스에서 아래와 같은 코드로 가능해집니다.\n\n```dart:auth_interceptor.dart {17}\nclass AuthInterceptor extends Interceptor {\n  ...\n  @override\n  void onResponse(\n    Response response,\n    ResponseInterceptorHandler handler,\n  ) async {\n    // Logging\n    debugPrint(\n      '[RES] [${response.requestOptions.method}] ${response.requestOptions.uri}',\n    );\n\n    // Error handling\n    var res = ResModel.fromJson(response.data, (json) => null);\n    if (res.code != 1000) {\n      if (res.code == 2000) {\n        AuthBlocSingleton.bloc.add(AuthSignoutEvent());\n      }\n      handler.reject(\n        DioException.connectionError(\n          requestOptions: response.requestOptions,\n          reason: res.message ?? Strings.unknownFail,\n          error: res,\n        ),\n      );\n      return;\n    }\n\n    handler.next(response);\n  }\n  ...\n}\n```\n\napi 응답 중 jwt관련 인증 문제가 발생하는 경우, 자동으로 로그아웃 하는 로직도 이런식으로 구현할 수 있습니다.","slug":"flutter/bloc_outof_context","readingMinutes":5,"wordCount":412},{"title":"FCM, BLoC으로 관리하기","description":"FCM 응답을 BLoC을 이용해서 상태관리 하는 방법에 대해 알아봅니다.","icon":"","image":"","tags":["Firebase Cloud Message","FCM","BLoC","Cubit"],"draft":false,"date":"2024-01-21 / 22:41","content":"\nFCM을 구현하는데 있어, FCM 세팅이나 수신하는 방법에 대한 글은 많이 봤는데,\n이를 상태관리와 엮어서 소개하는 글은 못봤던거 같습니다.\n\n제 경우에는 코드 스타일을 통일하는 것을 좋아하기 때문에, FCM 역시 상태관리를 이용해서 관리하고 싶었습니다.\n\n또한, 저는 Bloc을 애용하기 때문에, 이번에는 FCM이 수신되면 Bloc을 통해 해당 상태를 관리하는 방법에 대해 알아보려 합니다.\n(정확히는 Cubit을 사용할 예정입니다)\n\n<notice>\n  해당 방식은 부족한 제 지식으로 자체 구현한 방법이기 때문에 다소 어설프게 보일 수 있음을 알려 드립니다.\n</notice>\n\n## FirebaseMessaging\n\n우선 FCM을 사용하기 앞서, FirebaseMessaging 객체를 조금만 살펴봅시다.\n\n앱의 상태(fore/background, terminate)에 따라 FCM 수신 방법이 달라지는데, 각 상태에 따른 수신 방법은 아래와 같습니다.\n\n- **foreground**\n\n    앱이 화면위에서 실행중인 경우에 해당하며, 수신 방법은 다음과 같습니다.\n\n    ```dart:.dart\n      FirebaseMessaging.onMessage.listen(listenFCM);\n\n      void listenFCM(RemoteMessage? message) { ... }\n    ```\n\n- **background**\n\n    앱이 죽지는 않았지만 화면위에 없는 경우. \n    즉, 태스크매니져 상에만 존재하는 백그라운드 상태에 해당하며, 수신 방법은 다음과 같습니다.\n\n    ```dart:.dart\n      FirebaseMessaging.onMessageOpenedApp.listen(listenFCM);\n\n      void listenFCM(RemoteMessage? message) { ... }\n    ```\n\n- **terminate**\n\n    앱이 완전히 종료된 상태에 해당하며, 수신 방법은 다음과 같습니다.\n\n    ```dart:.dart\n      FirebaseMessaging.onBackgroundMessage(onBackgroundMessage);\n      ...\n      Future<void> onBackgroundMessage(RemoteMessage message) async { ... }\n    ```\n\n    <notice>\n      fore/background 와 다르게, terminate의 이벤트핸들러는 static 형식, 또는 전역으로 관리되는 비동기 함수여야 합니다.\n    </notice>\n\n<tip>\n  fore/background의 경우에는 onBlah getter를 이용해서 stream을 반환하고, stream의 listen을 이용해서 stream을 구독합니다.\n  즉, 인스턴스가 존재하는한, 스트림 형식으로 지속해서 FCM과 같은 이벤트를 수신할 수 있습니다.\n  <br />\n  반면에 terminate의 경우에는 앱이 죽은 상태에서의 FCM 수신을 담당하기 때문에, stream 형식으로 지속적으로 수신할 필요가 없습니다.\n</tip>\n\n---\n\n## 구현\n\n### State\n\nCubit에서 관리할 상태 클래스를 우선 정의합니다.\n\n```dart:fcm_cubit.dart\nclass FCMState extends Equatable {\n  final FCMEvent state;\n  final String? body;\n  final FCMDataModel? data;\n\n  const FCMState({\n    this.state = FCMEvent.none,\n    this.body,\n    this.data,\n  });\n\n  factory FCMState.fromBgMessage(RemoteMessage? message) {\n    if (message != null) {\n      if (message.notification != null) {\n        return FCMState(\n          state: FCMEvent.message,\n          body: message.notification!.body,\n          data: FCMDataModel.fromJson(message.data),\n        );\n      }\n    }\n    return const FCMState();\n  }\n\n  @override\n  List<Object?> get props => [\n        state,\n        body,\n        data,\n      ];\n}\n```\n\n`FCMEvent`는 자체 정의한 해당 fcm의 타입을 관리하는 enum 타입입니다. (option)\n\n`body`는 앱의 푸쉬 알림에서 보여지는 문자열을 보관하는 멤버 변수입니다.\n\n<tip>\n  기본 firebase_messaging 에서 FCM이 수신되었을 때, 푸쉬알림은 background, terminate 상태에서만 표시되고, foreground 상태에서는 푸쉬알림이 발생하지 않습니다 (FCM 자체는 수신됨).\n  <br />\n  따라서, body에 데이터를 보관하고, 상태가 변화했을 때 Snackbar 와 같은 방식으로 사용자에게 알려줄 수 있습니다.\n</tip>\n\n`FCMDataModel`은 FCM의 data 객체의 정보를 저장하는 자체 모델입니다.\n이 모델은 int `code`, String `data`을 갖고있습니다.\n`code`는 일종의 응답코드로, code에 따라 FCM이 수신되었을 때의 앱의 동작이 달라지게 됩니다.\n`data`는 직렬화된 객체의 json 문자열으로, code에 따라 파싱 방법이 달라지며, 필요한 정보를 보관합니다.\n\n모든 FCM 이벤트 핸들러는 `RemoteMessage` 객체를 파라미터로 넘겨받기 때문에, 해당 객체를 이용한 생성자를 구현하여 상태를 업데이트 합니다.\n\n### Cubit\n\n다음으로 위에서 언급했던 fore/background는 Cubit 생성자에서 스트림을 구독받도록 구현합니다.\n\n```dart:fcm_cubit.dart\nclass FCMCubit extends Cubit<FCMState> {\n  final String _fcmToken;\n\n  FCMCubit(\n    this._fcmToken,\n    RemoteMessage? bgMessage,\n  ) : super(FCMState.fromBgMessage(bgMessage)) {\n    // fcm listening\n    // at foground\n    FirebaseMessaging.onMessage.listen(listenFCM);\n    // at background\n    FirebaseMessaging.onMessageOpenedApp.listen(listenFCM);\n  }\n\n  // token getter\n  String get token => _fcmToken;\n  \n  void listenFCM(RemoteMessage? message) {\n    if (message != null) {\n      emit(FCMState(\n        state: FCMEvent.message,\n        body: message.notification?.body,\n        data: FCMDataModel.fromJson(message.data),\n      ));\n    }\n    emit(const FCMState());\n  }\n}\n```\n\n이렇게 하면 fore/background 에서 FCM이 수신될 때 마다 listenFCM 리스너가 실행이 되고,\n해당 리스너 안에서 emit을 2회 호출하게 됩니다.\n\n첫 번째 emit에서는 위에서 정의한, RemoteMessage의 데이터를 활용해 초기화된 FCMState 상태로 업데이트 되고,\n두 번째 emit에서는 init 상태의 FCMState 상태로 되돌립니다.\n\n두 번째 emit이 필요한 이유는, 동일한 FCM이 2번 연속 수신되는 일도 존재할 수 있기 때문에 상태를 초기화 시켜 2번 모두 정상적으로 수신시켜 주기 위함입니다.\n\n### main\n\n이제 main에서 FCM Token과 권한 요청, terminate의 동작을 정의하도록 합니다.\n\n```dart:main.dart\nRemoteMessage? bgMessage;\n\nvoid main() async {\n  // flutter ensure initialized\n  WidgetsFlutterBinding.ensureInitialized();\n\n  // request FCM permission\n  FirebaseMessaging.instance.requestPermission(\n    badge: true,\n    alert: true,\n    sound: true,\n  );\n\n  // listening fcm from background\n  FirebaseMessaging.onBackgroundMessage(_onBackgroundMessage);\n\n  // get fcm token\n  String? fcmToken = await FirebaseMessaging.instance.getToken();\n  debugPrint('FCM Token: $fcmToken');\n\n  runApp(MyApp(\n    fcmToken: fcmToken ?? '',\n    bgMessage: bgMessage,\n  ));\n}\n\nFuture<void> _onBackgroundMessage(RemoteMessage message) async {\n  bgMessage = message;\n}\n```\n\n제가 구현했을 때는, terminate 에서의 FCM 수신은 앱의 최초 화면을 제어하는 용도로만 사용했었습니다.\n\n따라서, bgMessage에 임시 보관하여 runApp으로 넘겨주었습니다.\n이후에 별도 처리를 통해 go_router의 initialRoute를 설정하였습니다.\n\n### BlocProvider\n\n이제 FCMCubit을 BuildContext에 등록을 시킵시다.\n\n```dart:main.dart\nclass MyApp extends StatelessWidget {\n  final String fcmToken;\n  final RemoteMessage? bgMessage;\n\n  const MyApp({\n    super.key,\n    required this.fcmToken,\n    this.bgMessage,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return MultiRepositoryProvider(\n      providers: [ ... ],\n      child: MultiBlocProvider(\n        providers: [\n          BlocProvider(\n            create: (context) => FCMCubit(\n              fcmToken,\n              bgMessage,\n            ),\n            lazy: false,\n          ),\n          ...\n        ],\n        child: const App(),\n      ),\n    );\n  }\n}\n```\n\n이렇게 하면 Bloc을 통해 FCM의 상태를 관리할 준비가 모두 끝납니다.\n\n### 결과물\n\n```dart:.dart {1}\nBlocListener<FCMCubit, FCMState>(\n  listener: (context, state) {\n    if (state.data?.code == \"10000\") {\n      // action for res code 10000\n    }\n    if (state.data?.code == '10001') {\n      // action for res code 10001\n    }\n    if (state.data?.code == '10002') {\n      // action for res code 10002\n    }\n  },\n  ...\n),\n```\nFCM이 수신될 경우, `BlocListener<FCMCubit, FCMState>`를 통해 FCM에 의한 state에 접근할 수 있고,\n\n```dart:.dart {6}\nBlocProvider(\n  create: (context) => SignalStateBloc(\n    homeSignalBoxRepository: context.read<HomeSignalBoxRepository>(),\n    myIdx: context.read<UserCubit>().state.user!.userIdx!,\n    jwt: context.read<UserCubit>().state.user!.jwt!,\n    fcmToken: context.read<FCMCubit>().token,\n  ),\n),\n```\n\n서버에서 FCM Token이 필요한 경우 `FCMCubit.token`을 통해 해당 클라이언트의 FCM Token을 조회할 수 있습니다.\n\nBloc으로 FCM까지 관리 완료!","slug":"flutter/fcm_with_bloc","readingMinutes":9,"wordCount":819},{"title":"ValueNotifier","description":"setState 없이 일부분만 리랜더링 할 수 있도록 해주는 ValueNotifier, ValueListenableBuilder 에 대해 알아봅니다.","icon":"","image":"","tags":["ValueNotifier","ValueListenableBuilder"],"draft":false,"date":"2024-01-17 / 15:08","content":"\n저는 게임이나, 깃허브(깃허브 서비스 그 자체)에서 영감을 많이 얻는 편입니다.\n그 중에 깃허브 앱에서 꼭 따라해보고 싶은 UI가 있었습니다.\n\n![github_app](/posts/valuenotifier/github_app.gif)\n\n바로 AppBar가 스크롤함에 따라 움직이는 애니메이션이죠!\n\n그래서 구글링 해보니까 ScrollController와 `ValueNotifier` 만 있으면 쉽게 구현이 가능했기에 오늘은 이 방법에 대해 적어보려 합니다.\n\n## ValueNotifier\n\n[공식문서](https://api.flutter.dev/flutter/foundation/ValueNotifier-class.html) 의 내용을 요약하면 다음과 같습니다.\n\n> ChangeNotifier를 상속 받았으며, 단일 value를 갖고 있습니다.\n> oldValue와 newValue를 == 연산자를 통해 비교하며,\n> 그 값이 다를 경우 listener 에게 notify 하게 됩니다. (notifyListeners를 호출하는 방식)\n\n따라서 ValueNotifier는 일종의 observer pattern으로 구현되어 있기 떄문에 stateful widget의 상태주기에 의해 제어되지 않을 수 있습니다.\n\n\n\n### ValueListenableBuilder\n\n이 위젯은 필수로 valueListenable 인자를 받게 되어있습니다.\n이 인자로는 반드시 Listenable 을 상속받은 `ValueListenable` 객체를 넘겨주어야 합니다.\n\n이 때, ValueNotifier는 **ValueListenable의 구현체**이기 때문에 ValueNotifier를 인자로 넘겨주면 이 빌더 위젯이 ValueNotifier 상태가 변화하면 알아서 이 부분만 재랜더링 하게 되는 것입니다.\n\n```dart:value_listenable_builder.dart\n@override\nvoid didUpdateWidget(ValueListenableBuilder<T> oldWidget) {\n  super.didUpdateWidget(oldWidget);\n  if (oldWidget.valueListenable != widget.valueListenable) {\n    oldWidget.valueListenable.removeListener(_valueChanged);\n    value = widget.valueListenable.value;\n    widget.valueListenable.addListener(_valueChanged);\n  }\n}\n\nvoid _valueChanged() {\n  setState(() { value = widget.valueListenable.value; });\n}\n```\n\n실제로 위젯을 까(?)보면 valueListenable이 변경될 때 마다 stateful 위젯이 재랜더링 됨을 볼 수 있었네요!\n\n---\n\n## 구현\n\n이제 이론적인 내용은 다뤄봤으니 실제로 구현을 해봅시다.\n\n### 컨트롤러\n\n```dart:myinfo_screen.dart {4, 5}\nclass _MyinfoScreenState extends State<MyinfoScreen> {\n  static const double _expandedHeight = 250;\n  static const double _appbarHeight = Sizes.size52;\n  late ScrollController _scrollController;\n  final ValueNotifier<double> _titleBottomPadding = ValueNotifier(0);\n\n  @override\n  void initState() {\n    super.initState();\n    _scrollController = ScrollController();\n    _scrollController.addListener(_scrollListener);\n  }\n```\n\n우선 ScrollController와 ValueNotifier를 생성 및 초기화 해줍니다.\ndispose도 잊지 마세요!\n\n### 위젯\n\n```dart:myinfo_screen.dart {6, 19}\noverride\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: ValueListenableBuilder(\n          valueListenable: _titleBottomPadding,\n          builder: (context, value, child) => AnimatedContainer(\n            duration: const Duration(milliseconds: 1),\n            margin: EdgeInsets.only(\n              bottom: value * 2,\n              top: _appbarHeight,\n            ),\n            child: child,\n          ),\n          child: ... \n        ),\n      ),\n      body: CustomScrollView(\n        controller: _scrollController,\n      ...\n```\n\n그리고, 스크롤이 되는 위젯에는 ScrollController 객체를 넣어주고,\n스크롤에 따라 애니메이션 되어야 할 부분은 ValueListenableBuilder 위젯으로 구현합니다.\n이 떄, valueListenable의 인자로 ValueNotifier 객체를 넣어줍니다.\n\n<tip>\n  여기서 ValueListenableBuilder의 builder 함수의 파라미터로 넘어오는 value로\n  ValueNotifier에 보관되어있는 value의 값에 접근할 수 있습니다.\n</tip>\n\n### 이벤트 리스너\n\n```dart:myinfo_screen.dart\nvoid _scrollListener() {\n  const ratio = 0.3;\n  if (_expandedHeight - _appbarHeight * ratio > _scrollController.offset) {\n    _titleBottomPadding.value = 0;\n  }\n  if (_expandedHeight - _appbarHeight * ratio <= _scrollController.offset &&\n      _expandedHeight + _appbarHeight * (1 - ratio) >=\n          _scrollController.offset) {\n    _titleBottomPadding.value =\n        _scrollController.offset - _expandedHeight + _appbarHeight * ratio;\n  }\n  if (_expandedHeight + _appbarHeight * (1 - ratio) <\n      _scrollController.offset) {\n    _titleBottomPadding.value = _appbarHeight;\n  }\n}\n```\n\n마지막으로 ScrollController의 listener 함수를 구현하면 깃허브 앱 AppBar 구현 완료!\n\n### 결과물\n\n![my_app](/posts/valuenotifier/my_app.gif)\n\n라이브러리 안쓰고 직접 구현하고, 코드 분석해보는...\n조금은 성장하는 맛이 있는 시간이었습니다 ㅎㅎ","slug":"flutter/valuenotifier","readingMinutes":4,"wordCount":425},{"title":"Dart 언어 마스터","description":"Dart 언어에 대한 보다 심화된 내용을 정리해봤습니다.","icon":"","image":"","tags":["Dart","factory","get","set","stream","async*","yield","mixin","with"],"draft":false,"date":"2023-09-25 / 14:55","content":"\n## factory constructor\n\n`factory` 키워드를 사용하면 아래와 같은 기능을 구현할 수 있다고 공식문서에 나와 있습니다.\n\n1. 인스턴스를 `캐시에서 반환`하여 클래스의 인스턴스를 한 번만 생성할 수 있도록 합니다. (일종의 Singleton 패턴 구현법)\n2. 생성자에서 `서브 클래스`(상속 받은 클래스)의 인스턴스를 반환할 수 있습니다.\n\n둘 다 신기한 기능입니다. (다만 언제 사용하는게 적재적소인지는 잘 모르겠네요..)\n1번부터 알아봅시다.\n\n### caching\n\n```dart:.dart\nclass Singleton {\n  static final Singleton _instance = Singleton._internal();\n\n  Singleton._internal() {}\n\n  factory Singleton() {\n    return _instance;\n  }\n\n  void getHash() {\n    print(this.hashCode);\n  }\n}\n\nvoid main() {\n  Singleton s1 = new Singleton();\n  Singleton s2 = new Singleton();\n\n  s1.getHash(); // 302000605\n  s2.getHash(); // 302000605\n}\n```\n\n위와 같이 구현한다면, Singleton 클래스의 인스턴스는 `단 한개`만 생성되게 됩니다.\n클래스 로드 시점에 static으로 이미 인스턴스가 만들어지기 때문이죠.\n하지만 이런 사용용법은 의미가 없어보입니다.\n차라리 아래의 예시가 더 의미 있어보입니다.\n\n```dart:.dart\nclass SingletonLog {\n  final String value;\n\n  static final Map<String, SingletonLog> _cache = {};\n\n  SingletonLog._internal(this.value);\n\n  factory SingletonLog(String value) {\n    return _cache.putIfAbsent(value, () => SingletonLog._internal(value));\n  }\n\n  void getHash() {\n    print(this.hashCode);\n  }\n\n  String getValue() {\n    return value;\n  }\n\n  Map<String, String> getLogs() {\n    Map<String, String> result = {};\n    _cache.forEach((key, value) {\n      result[key] = value.value;\n    });\n    return result;\n  }\n}\n\nvoid main() {\n  SingletonLog s1 = new SingletonLog('log1');\n  SingletonLog s2 = new SingletonLog('log2');\n\n  s1.getHash();        // 888013580\n  s2.getHash();        // 870182876\n\n  print(s1.value);     // log1\n  print(s2.value);     // log2\n\n  print(s1.getLogs()); // {log1: log1, log2: log2}\n  print(s2.getLogs()); // {log1: log1, log2: log2}\n}\n```\n\n이렇게 하면 s1, s2가 같은 인스턴스를 반환받기 때문에, 어디에서 로그를 추가해도 모든 객체가 같은 로그기록을 보관할 수 있습니다.\n\n<tip>\n  그럼 이런 의문이 듭니다.\n  hashCode가 다르게 나오는데, 그럼 다른 객체 아닌가요?\n  <br />\n  실제로 s1 == s2의 값은 `false`입니다. 따라서 `다른 객체`가 맞습니다.\n  하지만 **약간 변형**이 이루어지긴 했으나, `싱글톤 패턴` 역시 맞습니다.\n  <br />\n  왜냐하면, 인스턴스의 생성을 **클래스 내부**에서 `_internal`로 생성하고, 생성자를 외부에서 호출하지 못합니다.\n  또한, static으로 선언된 `_cache` 내부에서 인스턴스를 보관하기 때문에 _cache를 통해서 **전역적으로 인스턴스를 공유**하게 됩니다.\n  <br />\n  그렇다고 항상 다른 객체를 반환하는 것은 아닙니다.\n  실제로, s2를 생성할 때, s1과 동일하게 `'log1'`을 주입시키면 s1, s2 동일한 hashCode를 갖게 됩니다.\n  왜냐하면, factory 생성자는 일단 캐시되어있는 인스턴스를 반환하기 때문에,\n  _cache 내부에 인스턴스를 저장하고 있고, s1, s2 모두 같은 데이터를 갖고 있기에 메모리주소 역시 같아집니다.\n</tip>\n\n### return subclass constructor\n\n그럼 2번도 알아봐야겠죠?\n\n```dart:.dart\nclass Human {\n  final String name;\n\n  Human(this.name);\n\n  factory Human.create(String name, {required bool isMan}) {\n    if (isMan) {\n      return Male(name);\n    }\n    return Female(name);\n  }\n}\n\nclass Male extends Human {\n  Male(String name) : super(name);\n}\n\nclass Female extends Human {\n  Female(String name) : super(name);\n}\n\nvoid main() {\n  Human man = new Human.create('h1', isMan: true);\n  Human woman = new Human.create('h2', isMan: false);\n\n  print(man.name);   // h1\n  print(woman.name); // h2\n}\n```\n\n이 방식은 객체지향 프로그래밍의 다형성의 원리를 충족시키기에 좋은 문법입니다.\n\n신기한 점은 부모 클래스 생성자에서 자식 클래스의 생성자를 호출해 반환한다는 점입니다.\n이렇게하면 인스턴스 생성 시점에 조건을 달아 다른 인스턴스를 반환하는 것이 가능해집니다.\n_(상태나 이벤트를 클래스로 관리할 때 유용해 보이네요!)_\n\n### constructor body\n\n사실 공식문서에는 자세히 설명하진 않지만, factory 생성자의 가장 큰 이점은 `final variable`을 생성자에서 `initialize list`로 **초기화하지 않아도 된다는 점** 이라고 생각합니다.\n정확히 말하자면, 생성자를 내부에서 호출함으로서 생성자 호출 전, `전처리`를 할 수 있다는 점이 이점이라고 생각합니다.\n\n예시를 봐야겠죠?\n\n```dart:.dart {7-10}\nclass Human {\n  final String name;\n\n  Human(this.name);\n\n  // Human.withSir(String name) : this.name = 'Sir - ' + name;\n  factory Human.withSir(String name) {\n    String newName = 'Sir - ' + name;\n    return Human(newName);\n  }\n}\n\nvoid main() {\n  Human man = new Human.withSir('h1');\n\n  print(man.name);\n}\n```\n\n위 코드에서 주석처리 된 부분과 하이라이트 된 부분 모두 동일한 기능을 수행합니다.\n지금은 간단하게 문자열 앞에 `Sir - `을 붙이도록 했지만, 만약 배열을 직렬화 해야하는 상황이라면?\n한 줄로 처리하기 복잡한 기능은 분명 일반 생성자의 initialize list로 처리하는덴 한계가 있을 것입니다.\n\n<tip>\n  한 줄로 처리하기 복잡한 코드는 예로들어 `json serialize` 부분이 있겠죠?\n  <br />\n  그래서 우리가 무의식적으로 사용하던 factory가 사실은 인스턴스 생성을 편-안하게 생성하기 위해 사용했던 것이었습니다!\n</tip>\n\n---\n\n## get, set\n\ngetter, setter 메서드를 이용해서 객체의 가상 멤버변수(`property`)를 읽고 쓰는게 가능해진다는 건 다른 객체지향 언어에도 있는 기능입니다.\ndart에선 이를 가능케 하는 키워드가 `get`, `set` 입니다.\n\n공식문서에 있는 코드를 분석해봅시다.\n\n```dart:.dart\nclass Rectangle {\n  double left, top, width, height;\n\n  Rectangle(this.left, this.top, this.width, this.height);\n\n  // right, bottom 이라는 두 개의 계산된 프로퍼티 정의.\n  double get right => left + width;\n  set right(double value) => left = value - width;\n  double get bottom => top + height;\n  set bottom(double value) => top = value - height;\n}\n\nvoid main() {\n  var rect = Rectangle(3, 4, 20, 15);\n\n  print(rect.right); // 23.0\n  print(rect.left);  // 3.0\n  rect.right = 20;\n  print(rect.right); // 20.0\n  print(rect.left);  // 0.0\n}\n```\n\n제 개인적인 생각에는 get은 가상의 멤버변수를 만들어서 이를 사용하게 해주고,\nset은 이 가상의 멤버변수를 위해 처리해야 하는 기능을 함수 내부에서 별도로 처리하게 해준다가 주된 사용법인거 같습니다.\n\n<notice>\n  제가 `가상`의 멤버변수라고 표현한 이유는, get으로 정의된 변수는 그 자체가 특정 값을 저장할 수 없고, 별도로 정의된 멤버변수에 의존해야 하기 때문입니다.\n</notice>\n\n### interface\n\n그렇다면 get, set을 언제 사용해야 잘 사용한걸까요?\n보통은 멤버변수를 `은닉화`하고 이를 `접근제어`를 할 때 사용하는 방식이 대부분일 것입니다.\n\n하지만, 개인적으로 `인터페이스`를 구현할 때 역시 get의 적절한 사용처라고 개인적으로 생각합니다.\n예를 들어봅시다.\n\n```dart:.dart {2}\nabstract class IColor {\n  String get color;\n}\n\nclass Car implements IColor {\n  final String name;\n  @override\n  final String color;\n\n  Car(this.name, this.color);\n}\n\nclass Boat implements IColor {\n  final String name;\n  @override\n  final String color;\n\n  Boat(this.name, this.color);\n}\n\nvoid main() {\n  Car car = Car('car1', 'red');\n  Boat boat = Boat('boat1', 'red');\n\n  print(car.color == boat.color); // true\n}\n```\n\n<tip>\n  dart에선 abstract class로 구현해도 될 정도로 interface의 의미가 약합니다.\n  최근에는 interface 키워드가 추가되었으나, implements 하는 것이 아닌 extends 해도 에러가 안 날정도로 중요하진 않은 거 같습니다.\n  abstract interface와 같이 키워드를 중복해서 쓰는 경우도 있으므로 자세한 내용은 [**`공식문서`**](https://dart.dev/language/class-modifiers#interface)를 참고해주세요.\n</tip>\n\n두 클래스간 `필요에 따라` 공통속성을 갖고싶게 할 때 interface를 사용하곤 하는데요,\ndart는 `null-safety` 언어이기 떄문에, get 키워드가 없다면 **abstract class라 하더라도 멤버변수를 초기화** 해줘야만 합니다.\n그러면 코드가 아래처럼 복잡해지겠죠.\n\n```diff-dart:.dart {2}\n  abstract class IColor {\n    String color;\n\n+   IColor(this.color);\n  }\n\n  class Car implements IColor {\n    final String name;\n    @override\n    final String color;\n\n    Car(this.name, this.color);\n\n+   @override\n+   set color(String _color) {\n+     color = _color;\n+   }\n  }\n```\n\n## stream\n\n비동기의 4번타자, `future`는 완료되지 않은 연산을 나타냅니다.\n비동기 함수가 return을 해야만 future은 연산이 완료되었다는 것을 알려줍니다.\n\n그에 반면, `stream`은 **일련, iterable**한 비동기 이벤트입니다.\n따라서 iterable과 같이 동작하게 됩니다만, 그 과정이 비동기인 것이죠.\n\n즉, future은 요청시 다음에 올 이벤트를 받는 방식이라면,\nstream은 준비가 된 후 이벤트가 있음을 알려주는 방식입니다.\n\n### async* / yield\n\n`async*`는 async와 마찬가치로 이 함수가 비동기 함수라는 것임을 선언하는 키워드 입니다.\n차이점은 이 함수는 `Stream<T>`을 반환하기 때문에 일련의 비동기로 연산된 결과를 반환하게 됩니다.\n즉, **지속적으로 값을 반환**하기 위해 `yield` 키워드가 return을 대신하여 값을 반환합니다.\n_(return 키워드는 여기서 사용 불가합니다)_\n\n예시를 살펴봅시다.\n\n```dart:.dart\nFuture<int> sumStream(Stream<int> stream) async {\n  var sum = 0;\n  await for (final value in stream) {\n    print('get stream value $value');\n    sum += value;\n  }\n  return sum;\n}\n\nStream<int> countStream(int to) async* {\n  for (int i = 1; i <= to; i++) {\n    await Future.delayed(Duration(milliseconds: 200));\n    print('stream $i ready');\n    yield i;\n  }\n}\n\nvoid main() async {\n  var stream = countStream(3);\n  var sum = await sumStream(stream);\n  print(sum);\n}\n```\n\n> (0.2초 대기)\n> stream 1 ready\n> get stream value 1\n> (0.2초 대기)\n> stream 2 ready\n> get stream value 2\n> (0.2초 대기)\n> stream 3 ready\n> get stream value 3\n> 6\n\nStream 역시 비동기로 처리되는 **일련**의 연산이라는 것을 알려주는 객체이기 때문에,\n실제 연산 결과를 받으려면 await을 사용해서 값이 전달받을 때 까지 대기해야 합니다.\n\n따라서, dart에서는 `await for` 키워드를 제공하여 iterable한 비동기 이벤트를 처리할 수 있도록 도와줍니다.\n\n<tip>\n  동기적은 `Iterable<T>` 객체를 반환하고 싶다면 `sync*` / `yield` 키워드를 사용하면 됩니다.\n</tip>\n\n<tip>\n  stream은 파일읽기와 같이 한 번의 요청이 있으면 처음부터 끝까지 끊김없이 진행되어야 하는 `Single subscription streams`, \n  브라우저의 마우스 이벤트와 같이 Observer pattern을 사용하기에 언제든지 누구나 stream을 들을 수 있는 `Broadcast streams` 으로 나뉩니다.\n  <br />\n  뿐만 아니라, stream은 iterable한 성격을 갖는다 했었는데, 이런 stream을 제어할 수 있는 여러 메서드 또한 존재합니다.\n  따라서 자세한 내용은 [**`공식문서`**](https://dart-ko.dev/tutorials/language/streams#working-with-streams)를 참고하시는걸 추천 드립니다.\n</tip>\n\n## mixin, with\n\n간단하게 말하면 class &rarr; `mixin`, extends &rarr; `with`와 같은 개념입니다.\n물론 이해를 돕기위해 위와같이 적었을 뿐, 완전히 다른 키워드이니 혼동하지 마시길 바랍니다.\n\n클래스를 상속할 때는 부모 클래스에서 미리 정의된 변수나 메서드를 자식 클래스에서 구현하지 않아도 바로 사용할 수 있습니다.\n하지만, 계층구조를 나타내기 위해 **반드시 한 개의 클래스를 상속**해야 한다는 단점이 있죠.\n\n여러개의 자료 구조를 공유하기 위해서는 인터페이스를 구현 하는 방법으로 사용해야 합니다.\n하지만, 인터페이스는 말 그대로 틀만 제공하고 **구현은 별도로 해야한다**는 단점이 있습니다.\n\n이 떄, extends와 implements의 **중간 포지션**에 위치한 키워드가 with이고, with은 mixin을 받을 수 있습니다.\n\n```dart:.dart\nmixin SwimBehabior {\n  void swim() {\n    print('swim');\n  }\n}\n\nmixin FlyBehiabior {\n  void fly() {\n    print('fly');\n  }\n}\n\nclass Duck {\n  final String name;\n\n  Duck(this.name);\n}\n\nclass RealDuck extends Duck with SwimBehabior, FlyBehiabior {\n  RealDuck(super.name);\n}\n\nclass RubberDuck extends Duck with SwimBehabior {\n  RubberDuck(super.name);\n}\n\nvoid main() {\n  RealDuck duck = RealDuck('duck');\n\n  duck.fly();\n  duck.swim();\n}\n```\n\n이런식으로 implements 처럼 여러 인터페이스를 사용할 수 있지만, extends 처럼 재정의할 필요 없이 사용할 수 있습니다.\n하지만, mixin을 사용할 때는 클래스 구성요소가 `매우 세분화` 되어있는게 좋습니다.\n이런저런 메서드를 잔뜩 만들어놓으면 상속했을 때 **필요없는 기능도 수행**할 수 있는 상황이 발생할 수 있기 때문입니다.\n\n이런 상황이 생길 가능성이 있는 코드는 mixin 보단 `Strategy pattern`으로 구현하는 것이 더 좋습니다.\n\n```dart:.dart {18, 22-24}\nabstract class SwimBehavior {\n  void swim();\n}\n\nabstract class FlyBehavior {\n  void fly();\n}\n\nclass CanSwim implements SwimBehavior {\n  @override\n  void swim() {\n    print('swim');\n  }\n}\n\nclass Duck {\n  final String name;\n  SwimBehavior swimBehavior;\n\n  Duck(this.name, this.swimBehavior);\n\n  void performSwim() {\n    swimBehavior.swim();\n  }\n}\n\nclass RealDuck extends Duck implements FlyBehavior {\n  RealDuck(String name) : super(name, CanSwim());\n\n  @override\n  void fly() {\n    print('fly');\n  }\n}\n\nclass RubberDuck extends Duck {\n  RubberDuck(String name) : super(name, CanSwim());\n}\n\nvoid main() {\n  RealDuck real = RealDuck('duck');\n  RubberDuck rubber = RubberDuck('duck');\n\n  real.performSwim();\n  real.fly();\n  rubber.performSwim();\n}\n```\n\n사실 mixin을 사용하지 않더라도 class의 `상속 depth를 깊게` 하는 방법도 있으니, 본인의 상황에 맞게 취사선택을 잘 하는 것이 좋은 개발습관이 될 것입니다.","slug":"flutter/005_dart_expert","readingMinutes":17,"wordCount":1610},{"title":"Dart 언어 심화","description":"Dart 언어에 대한 심화된 내용을 정리해봤습니다.","icon":"","image":"","tags":["Dart","Asynchronous","Isolate","Callback"],"draft":false,"date":"2023-09-15 / 11:24","content":"\n<notice>\n  기초적인 지식이 필요하신 분들은 [**`Dart 언어 기초`**](https://wjlee611.github.io/blog/flutter/003_dart_basic) 포스트를 읽어보시길 권장드립니다.\n</notice>\n\n## async / await\n\n`async`, `await` 키워드는 **비동기 프로그래밍**시 빠지지 않는 키워드입니다.\n여기서 `.then()` 메서드나 Dart 에서 `Future<T>` 도 포함해서 원리와 적절한 사용법까지 알아보고자 합니다.\n\n<tip>\n  `비동기 프로그래밍`\n  특정 코드가 완료되기 전, 다른 코드를 수행함으로서 코드의 실행 순서가 순차적(동기적)으로 실행되지 않는 프로그래밍 방식입니다.\n  보통 처리완료까지 시간이 많이 걸리는 네트워크 통신이나 파일 입출력 등에 많이 사용됩니다.\n</tip>\n\n<notice>\n  비동기 처리는 `단일 스레드(Dart의 경우 단일 Isolate) 환경`에서 이루어집니다.\n  따라서 비동기 처리를 한다고 해도, 비동기 함수가 `컴퓨팅 자원 사용량이 많다`면 해당 스레드(Isolate)는 `일시 정지`되는 현상이 발생할 수 있습니다.\n  <br />\n  이와 관련한 자세한 내용은 아래 [**`Isolate`**](https://wjlee611.github.io/blog/flutter/004_dart_advanced#isolate) 파트에서 다루겠습니다.\n</notice>\n\n### Future\n\n`Future` 객체는 지금 당장은 처리되지 않았지만, 미래에 처리가 완료될 데이터를 알려주는 객체입니다.\n예를 들어봅시다.\n\n```dart:.dart\nFuture<String> futureStr() async {\n  print('do something');\n  return Future.delayed(Duration(seconds: 2), () => 'future string');\n}\n\nvoid main() {\n  print('start');\n  print(futureStr());\n}\n```\n\n위의 futureStr() 함수는 호출 후 2초뒤에 'future string'을 반환하는 함수입니다.\n실행결과는 어떻게 될까요?\n\n> start\n> do something\n> Instance of 'Future\\<String\\>'\n> (2초 후 종료)\n\n답은 `future 객체` 입니다.\n어찌보면 당연합니다. `main` 함수는 비동기 함수도 아닐 뿐더러 futureStr의 리턴값은 `Future<String>` 이라고 명시해두었으니 말이죠.\n\n![230917-211924](/posts/004_dart_advanced/230917-211924.png)\n\nfuture는 `Uncompleted`, `Completed` 상태를 갖습니다.\n비동기 함수 호출시에 future은 Uncompleted 상태를 갖습니다.\n따라서 `Instance of 'Future<String>'`와 같은 결과를 출력한 것이죠.\n하지만 함수가 성공적으로 종료되면 future은 비로소 Completed 상태를 갖습니다.\n따라서 `future string`과 같은 결과를 출력하게 될 것입니다.\n\n사용자 입장에서는 Future 객체는 중요하지 않습니다. 중요한 것은 Future 객체가 처리되고 나서 반환되는 데이터인거죠.\n따라서, Future 객체의 처리(비동기 함수)를 원활히 하기위해 `async`, `await` 키워드를 사용하는 것입니다.\n\n### async\n\nasync 키워드는 이 함수가 비동기 처리를 수행하는 함수임을 명시하는 키워드 입니다.\n다만 위의 예시에서 보듯, 반드시 `Future<T>` 객체 또는 `void`를 반환해야만 합니다.\n\n그렇다면, main 함수를 async 키워드를 붙여 실행한다면 제대로된 결과가 나올까요?\n\n```dart:.dart\nFuture<String> futureStr() async {\n  print('do something');\n  return Future.delayed(Duration(seconds: 2), () => 'future string');\n}\n\nvoid main() async {\n  print('start');\n  print(futureStr());\n}\n```\n\n> start\n> do something\n> Instance of 'Future\\<String\\>'\n> (2초 후 종료)\n\n그렇습니다. 함수를 비동기 처리하는 함수로 선언한다고 해서 해결되지는 않습니다.\n함수 내부에서 비동기 처리가 진행될 수 있다는 것을 암시할 뿐, `어디서` 비동기 처리를 해야하는 지는 명시하지 않았기 때문이죠.\n\n### await\n\nawait 키워드는 **해당 키워드가 명시된 비동기 처리**(futureStr)가 완료될 때 까지 **비동기 함수**(main)의 처리를 `멈추겠다`는 의미입니다.\n그렇기에 await 키워드는 반드시 async 키워드가 명시된 함수 내부에서만 사용할 수 있는 것입니다.\n\n그렇다면 futureStr의 함수 앞에 await를 명시하여 비동기 함수가 끝날 때 까지 대기시킨다면 어떨까요?\n\n```dart:.dart\nFuture<String> futureStr() async {\n  print('do something');\n  // return Future.delayed(Duration(seconds: 2), () => 'future string');\n  await Future.delayed(Duration(seconds: 2));\n  return 'future string';\n}\n\n\nvoid main() async {\n  print('start');\n  print(await futureStr());\n}\n```\n\n> start\n> do something\n> (2초 대기)\n> future string\n> (즉시 종료)\n\n비로소 원하던 결과가 나왔습니다.\n\n---\n\n## Isolate\n\n`Isolate`는 Dart에서 스레드를 부르는 용어라고 생각하시면 됩니다.\n\n![230917-221122](/posts/004_dart_advanced/230917-221122.png)\n\nIsolate는 스레드와 마찬가지로 멀티 코어 CPU의 장점을 살리는 프로그래밍 기법으로 `별도의 이벤트 루프`를 갖는 실행 흐름을 만들어 `병렬적인 처리`를 가능케 합니다.\n하지만, 스레드와 용어에서의 차이점을 두는 이유가 있습니다.\n\n보통 **스레드**라 하면 `메모리 영역을 공유`한다고 배웠습니다. 하지만 그 때문에 `race-condition`이 발생하는 문제점을 고려하여 프로그래밍을 했어야 합니다.\n\n하지만, **Isolate**는 스레드와 다르게 `메모리 영역 또한 공유하지 않습니다`.(물론 코드 영역은 공유합니다) \n그렇기에 mutex, lock 등을 고려할 필요가 없는 편의성이 있습니다.\n\n하지만 왜 Isolate를 알아야 하고, 사용해야만 할까요?\n\n### Isolate vs Async\n\n아래의 영상을 확인해봅시다.\n\n<YT id='HkBaS098BrE' />\n\n`Main isolate`부분은 json 데이터 파싱과 화면 빌드를 `하나의 isolate`에서 구동한 결과입니다.\n영상에서 보시는 바와 같듯 십몇만줄의 json 파싱은 단일 isolate 환경에서 구동하기에는 다소 무리가 있습니다.\n아무리 async로 실행 결과를 뒤로 미룬다 할지라도 실제 데이터 파싱하는 동작과 화면을 그리는 동작 모두 `동일한 isolate`에서 처리되기 때문에 `성능상 이슈`가 생길 수 밖에 없습니다.\n\n하지만 `Worker isolate`부분은 json 데이터 파싱을 `별도의 worker isolate`에서 구동한 결과입니다.\n차이는 명확합니다. 화면에 그리는 동작과 파싱 동작이 `별도의 isolate`에서 처리되기 때문에 화면을 그리는 부분에서 `랙이 걸리지 않습니다`.\n\n이렇듯 단일 isolate에서 동작이 버벅일 정도로 무거운 기능을 수행해야 한다면, 해당 기능은 별도의 isolate로 빼서 처리하는 것이 사용자에게 더 나은 경험을 제공하게 됩니다.\n\n해당 영상에서 구동하는 코드는 [**`Arkhive repo`**](https://github.com/wjlee611/arkhive/blob/main/lib/bloc/enemy/enemy_data/enemy_data_bloc.dart)에서 확인하실 수 있습니다.\n\n---\n\n## function\n\n### callback function\n\n콜백 함수는 함수의 인자로 넘겨주어 넘겨받은 함수 내부에서 실행 가능한 함수를 의미합니다.\n예시를 살펴봅시다.\n\n```dart:.dart\nvoid main() {\n  int value = 0;\n\n  print(valueModifire(value: value, modifire: add1)); // 1\n  print(valueModifire(value: value, modifire: sub1)); // -1\n}\n\nint add1(int value) => value + 1;\nint sub1(int value) => value - 1;\n\nint valueModifire({\n  required int value,\n  required Function(int) modifire,\n}) {\n  return modifire(value);\n}\n```\n\n위 코드에서는 `valueModifire`의 인자로서 `add1`, `sub1`을 전달했습니다.\n이 때, 이 두 함수를 `callback function`라고 부르고, 이 함수는 valueModifire 내부에서 `modifire`의 형태로 호출됩니다.\n\n보통은 이런식으로 `동일한 함수` 내부에서 `서로 다른 기능`을 수행해야 할 때 콜백 함수로서 전달하는 경우가 많습니다.\n\n```dart:.dart\nvoid main() async {\n  int value = 0;\n\n  print(await valueModifire(value: value, modifire: add1)); // await 1 second -> 1\n  print(await valueModifire(value: value, modifire: sub1)); // await 1 second -> -1\n}\n\nint add1(int value) => value + 1;\nint sub1(int value) => value - 1;\n\nFuture<int> valueModifire({\n  required int value,\n  required Function(int) modifire,\n}) async {\n  await Future.delayed(Duration(seconds: 1)); // something actions\n  return modifire(value);\n}\n```\n\n또는, `특정 함수의 동작이 끝난 후` 수행해야 할 기능이 있을 때 많이 사용되곤 합니다.","slug":"flutter/004_dart_advanced","readingMinutes":10,"wordCount":836},{"title":"Dart 언어 기초","description":"Dart 언어에 대한 기초지식을 정리해봤습니다.","icon":"","image":"","tags":["Dart"],"draft":false,"date":"2023-09-14 / 17:41","content":"\n<warning>\n  제가 생각하기에 **너무 기초지식**이다 하는 부분은 과감하게 **제외**했습니다.\n  다만, 기초지식이다 하더라도 `개념적으로 매우 중요`하거나 `많이들 알려주지 않는 내용`은 포함하였습니다.\n</warning>\n\n## variables\n\n변수 네이밍 방법은 다음과 같습니다.\n\n```dart:.dart\n  <제어자> <타입> <변수이름> = <값>;\n```\n\n타입은 int, String 과 같은 타입들이 오거나, `var` 와 같은 타입 추론 키워드도 사용할 수 있습니다.\n제어자에는 `final`, `const`, `late`, `static` 와 같은 키워드가 오게 됩니다.\n\n### var\n\ndart에선 var는 타입 추론 키워드로 사용되는 예약어입니다.\n따라서 `<값>`에 어떤 데이터가 오는지에 따라 변수의 타입이 결정됩니다.\n단, 값을 지정하지 않을 때는 `dynamic` 타입으로 자동 결정됩니다.\n\n<tip>\n  `dynamic?`\n  타입 안정성이 보장되지 않지만, 모든 타입의 데이터를 할당할 수 있도록 해줍니다.\n  보통 json 파일을 파싱할 때 임시로 데이터 형식을 지정할 때 많이 사용합니다.\n</tip>\n\n### final vs const\n\n`final`과 `const` 둘 모두 데이터의 불변성을 보장하고 싶을 때 사용하는 키워드 라는 점에서는 공통점을 갖습니다.\n또한, 이 키워드를 사용한다면 타입을 굳이 지정하지 않아도 알아서 `var`로 타입을 지정하는 효과가 있습니다.\n하지만 둘 사이의 중요한 차이점이 있습니다.\n\n`final`은 런타임에 값이 지정됩니다.\n따라서 메모리상의 `heap 영역`에 데이터가 저장됩니다.\n그렇기에 생명주기는 스코프 내부로 한정되기 떄문에 flutter 에서 **build 메서드**가 호출될 때 이 부분은 `반복적`으로 메모리에 올라왔다 내려갔다를 반복하게 됩니다.\n\n`const`는 컴파일타임에 값이 지정됩니다.\n특이한 점인 const 키워드로 지정된 데이터는 메모리상에 별도로 적재되지 않고, `컴파일된 코드의 상수 풀(constant pool)`상에 저장됩니다.\n따라서 별도의 인스턴스가 생성되지 않고, 생명주기도 프로그램 수명과 동잃하기에 flutter 에서 **build 메서드**가 호출될 때 이 부분은 `다시 랜더링되지 않습니다`.\n\n### late\n\ndart는 **null-safety** 언어입니다.\n따라서 `<타입>?` 와 같이 `?`로 null값이 가능하다고 지정해 주지 않는한 변수 선언시(혹은 인스턴스 생성시) 반드시 값을 지정해야 합니다.\n하지만, `late`의 경우에는 인스턴스 생성 시점에 null값을 허용하지만, 이후에 `단 한번` 값을 할당할 수 있도록 해주는 키워드입니다.\n\n물론, null값이 임시 허용이 되는만큼 사용에 주의가 필요합니다.\n\n### static\n\n`static`은 클래스가 로드될 때 값이 지정됩니다.\n따라서 heap영역이 아닌 `클래스 자체 메모리 영역`에 저장됩니다.\n그렇기에 일반 메서드에선 static 변수에 접근할 수 있지만, static 메서드에선 일반 변수에 접근할 수 없습니다.\n하지만 그렇기에 클래스를 인스턴스화 하지 않아도 바로 접근이 가능합니다.\n\n---\n\n## function\n\ndart는 사실 js를 대체하기 위해 나온 언어라고 합니다.\n그래서일까요, dart의 모든 데이터 타입도 사실은 모두 `Object`입니다.\n\n뿐만 아니라, `변수에 함수를 할당`하거나, `익명 함수`, `람다 함수` 모두 사용 가능합니다.\n\n### named parameter\n\n보통 함수의 파라미터는 아래와 같이 작성하곤 합니다.\n\n```dart:.dart\n  void myFunction(int num) {\n    ...\n  }\n  ...\n  myFunction(1);\n```\n\n하지만 입력받고자 하는 파라미터가 많아진다면, 인자를 넘겨줄 때 어느 자리에 어느 데이터를 넘겨야 할지 알기가 어렵습니다.\n특히 flutter에서는 위젯을 만들 때 인자를 십수개씩 넘기는 경우가 많죠...\n\n그렇기에 `named parameter` 기능을 제공합니다. (마치 js에서 객체를 인자로 넘기 듯)\n\n```dart:.dart\n  void myFunction({required int myNum}) {\n    ...\n  }\n  ...\n  myFunction(myNum: 1);\n```\n\n이렇게 하면 함수 호출이나, 클래스 생성자 호출시 어느 인자에 어느 데이터를 넘겨야 하는지 명확해집니다.\n\n물론, 위 두 방식을 `혼합`하여 사용할 수도 있습니다.\n\n```dart:.dart\n  void myFunction(String str, {required int val}) {\n    ...\n  }\n  ...\n  myFunction(\"string\", myNum: 1);\n```\n\n---\n\n## class\n\n### constructor\n\n```dart:.dart\nclass Car {\n  final String color;\n  int wheels;\n  String? name;\n\n  Car({\n    required this.color,\n    required this.wheels,\n    this.name,\n  });\n}\n```\n\n기본적으로 생성자는 위와 같이 정의할 수 있습니다.\n`named parameter` 형식으로도 사용이 가능합니다. (대부분의 flutter 위젯은 위와 같이 정의합니다)\n\n### named constructor\n\n```dart:.dart\nCar {\n  final String color;\n  late int wheels;\n  String? name;\n\n  Car.fourWheels({required this.color, this.name}) {\n    this.wheels = 4;\n  }\n}\n```\n\n클래스를 생성할 때 특별한 기능을 붙인채로 인스턴스화 할 수 있도록 `named constructor`를 지원합니다.\n보통 초기상태를 위한 `.init`, 모델링을 위한 `.fromJson`와 같이 쓰이곤 합니다.\n(참고로 이 때 factory 키워드를 이용해서 싱글톤 패턴으로 많이 구현하는데 이는 다음에 소개하겠습니다)\n\n### initializer list\n\n위에 `wheels`을 별도로 초기화하기 위해 late 한정자를 사용했는데요, 보기가 안좋습니다.\n`final` 멤버변수는 생성자 body에서 값을 지정할 수 없기에 저런식으로 표현했는데요,\n`initializer list`를 이용하면 final 멤버변수도 생성자 호출시 별도로 처리할 수 있습니다.\n\n```dart:.dart\nclass Car {\n  final String color;\n  final int wheels;\n  String? name;\n\n  Car.prototype({required this.color}) : wheels = 4 {\n    this.name = 'proto';\n  }\n}\n```\n\n`:`를 붙여 `: wheels = 4`와 같이 사용할 수 있습니다.\n또한, 뒤에 body를 붙여 추가작업 또한 할 수 있습니다.\n\ninitializer **list**에서 알 수 있듯 `wheels = 4` 와 같은 initializer를 `,`를 이용해서 여려개 연달아 초기화할 수 있습니다.\n\n### redirecting constructor\n\n```dart:.dart\nclass Car {\n  final String color;\n  final int wheels;\n  String? name;\n\n  Car({\n    required this.color,\n    required this.wheels,\n    this.name,\n  });\n\n  Car.fourWheels({required String color, String? name})\n      : this(\n          color: color,\n          wheels: 4,\n          name: name,\n        );\n}\n```\n\n기존의 생성자를 `this`로 호출하여 named constructor를 구현한 방식입니다.\n다만, 이 경우에는 생성자의 body를 구현할 수 없습니다.\n","slug":"flutter/003_dart_basic","readingMinutes":9,"wordCount":703},{"title":"플러터 프로젝트 만들기","description":"플러터 프로젝트 생성 가이드 입니다.","icon":"","image":"","tags":["Flutter","Getting started"],"draft":false,"date":"2023-09-14 / 16:37","content":"\n## 시작 전 주의사항\n\n<notice>\n  이 포스트에선 플러터 프로젝트를 생성하는 방법을 다뤄봅니다.\n  따라서 플러터 SDK 설치나, 관련 환경설정이 안되신 분은 [**`플러터 시작하기`**](https://wjlee611.github.io/blog/flutter/001_installation)를 꼭 읽어보시고 다시 와주시기 바랍니다.\n</notice>\n\n<notice>\n  본 블로그의 플러터 개발환경은 `VSCode`와 `터미널`로 고정됩니다.\n  따라서 다른 개발환경에 대한 정보는 없으므로 이 점 참고 부탁드립니다.\n</notice>\n\n## 프로젝트 생성\n\n프로젝트 생성을 위해 우선 본인이 프로젝트를 관리할 폴더로 이동해주세요.\n제 경우에는 깃허브로 버전관리를 하는 프로젝트의 경우 `~/Documents/GitHub` 폴더에서 일괄적으로 관리하는 편입니다.\n\n```bash:Terminal\ncd ~/Documents/GitHub\n```\n\n이후에는 아래의 명령어로 플러터 프로젝트를 생성합니다.\n\n```bash:Terminal\nflutter create <proj_name>\n```\n\n이 때, 프로젝트를 생성할 때 알아두면 유용한 (거의 필수) 몇 가지 옵션을 소개드립니다.\n\n### --org\n\n이 옵션을 지정하면 프로젝트를 생성할 때 패키지명을 지정할 수 있습니다.\n\n```bash:Terminal\nflutter create <proj_name> --org <package_name>\n```\n\n<notice>\n  \\<package_name\\>이 100% 동일하게 패키지 이름이 되는 것은 아닙니다.\n  옵션명에서 유추할 수 있듯 기관의 이름을 적는 것입니다.\n\n  따라서 진짜 패키지 이름은 `<package_name>.<proj_name>` 형식이 됩니다.\n</notice>\n\n예로들어 아래와 같이 프로젝트를 생성했다고 가정해봅시다.\n\n![230914-164837](/posts/002_project_initalize/230914-164837.png)\n\n이 경우에는 프로젝트명 - `gdsc_study` / 패키지명 - `com.gmail.wjlee611` 입니다.\n따라서 프로젝트에서 실제로 적용되는 패키지명은 아래와 같아집니다.\n\n![230914-165226](/posts/002_project_initalize/230914-165226.png)\n\n> Android - `com.gmail.wjlee611.gdsc_study`\n> iOS - `com.gmail.wjlee611.gdscStudy`\n\n같은 명령어라도 다른 패키지명이 생성되니 나중에 앱을 배포할 때 반드시 패키지명을 확인하도록 합시다.\n\n### -i swift\n\n기본적으로 생성되는 iOS 코드는 `Objective-C` 입니다.\n하지만 이 옵션을 추가하면 `Swift`로 생성되게 됩니다.\n\n### -a kotlin\n\n기본적으로 생성되는 Android 코드는 `Java` 입니다.\n하지만 이 옵션을 추가하면 `Kotlin`으로 생성되게 됩니다.\n\n\n","slug":"flutter/002_project_initalize","readingMinutes":3,"wordCount":223},{"title":"플러터 시작하기","description":"플러터 설치 및 VSCode 세팅 가이드입니다.","icon":"","image":"","tags":["Flutter","VSCode","Package manager"],"draft":false,"date":"2023-09-13 / 21:12","content":"\n## 들어가며...\n\n이 포스트에선 플러터(Flutter) 개발을 시작할 때 세팅해야할 전 과정에 대해 설명합니다.\nFlutter SDK 설치부터 에뮬레이터 세팅, VSCode 세팅, 추가로 유용한 단축키에 대해서 알아봅니다.\n다만, 단축키는 운영체제, 에디터 환경, 설정에 따라 다를 수 있으니 이점 참고 바랍니다.\n\n<notice>\n  **이미 설치를 완료하신 분들도 시간 내셔서 [**`VSCode 세팅`**](https://wjlee611.github.io/blog/flutter/001_installation#vscode-%EC%84%B8%ED%8C%85)부터 읽어보시는 것을 강력 추천드립니다.**\n</notice>\n\n블로그 주인장은 M1 Mac 환경에서 세팅하였기에 리눅스 계열 세팅방법을 기준으로 다뤄봅니다만,\n윈도우 머신에서의 세팅도 다뤄볼 겁니다. (다만, 실제 테스트는 하지 않았기에 오류가 있을지도 모릅니다)\n\n참고로 아래의 모든 설치과정은 [**노마드코더**](https://nomadcoders.co/flutter-for-beginners)의 강좌를 정리한 자료입니다.\n\n- https://nomadcoders.co/flutter-for-beginners/lectures/4133\n- https://nomadcoders.co/flutter-for-beginners/lectures/4142\n\n---\n\n## Flutter SDK 설치\n\nFlutter SDK를 설치할 때 방법이 크게 두 가지로 나뉩니다.\n첫 번째는 Flutter 공식 사이트에서 제공하는 방식을 따라가는 방법\n두 번째는 패키지 매니저를 이용해서 설치하는 방법\n\n제 개인적인 생각에는 패키지 매니저를 이용하는 방법이 더 간단해 보입니다.\n첫 번째 방법을 따라하려면 환경 PATH도 설정해야 하기에 좀 무서워 보이기 때문이죠...\n~_(그리고 제가 이 방법밖에 안해보기도 했구요...)_~\n\n그래도 일단은 두 방법 모두 소개해 드리겠습니다.\n\n### 공식 사이트\n\n1. [**플러터 공식 페이지**](https://flutter.dev)로 접속합니다.\n\n2. `Get started`로 들어갑니다.\n   ![230913-211858](/posts/001_installation/230913-211858.png)\n\n3. 본인 운영체제에 맞는 Flutter SDK를 설치합니다.\n   ![230913-212121](/posts/001_installation/230913-212121.png)\n\n   이후에는 공식 사이트에서 제공하는 문서를 천천히 따라하시면 됩니다.\n\n---\n\n### 패키지 매니저 (MacOS)\n\n1. [**Homebrew**](https://brew.sh/)에 들어갑니다.\n   ![230913-214251](/posts/001_installation/230913-214251.png)\n\n<notice>\n  _참고로 Homebrew는 MacOS에서 사용할 수 있는 **대부분의 개발자도구를 터미널로 설치할 수 있는 강력한 도구**입니다._\n  _Flutter가 아니더라도 **반드시** 설치하는게 정신건강에 이롭습니다._\n</notice>\n\n2. `터미널`을 열어줍니다.\n\n3. 아래의 명령어를 입력하여 Homebrew를 설치합니다.\n   (공식 사이트에서 복사하는 것을 권장합니다)\n\n```bash:Terminal\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n4. 아래의 명령어로 Flutter SDK를 설치합니다.\n\n```bash:Terminal\nbrew install --cask flutter\n```\n\n---\n\n### 패키지 매니저 (Windows)\n\n1. [**Chocolatey - individual**](https://chocolatey.org/install#individual)에 들어갑니다.\n   ![230913-213419](/posts/001_installation/230913-213419.png)\n\n2. `PowerShell`을 관리자 권한으로 실행합니다.\n\n3. 아래의 명령어를 입력하여 Chocolatey를 설치합니다.\n\n```shell:PowerShell\nGet-ExecutionPolicy\n```\n\n만약 `Restricted` 라고 뜬다면 아래의 명령어 중 하나를 입력하면 됩니다.\n\n```shell:PowerShell\nSet-ExecutionPolicy AllSigned\n또는\nSet-ExecutionPolicy Bypass -Scope Process\n```\n\n그 이후에 아래의 긴- 명령어를 입력합니다.\n(공식 사이트에서 복사하는 것을 권장합니다)\n\n```shell:PowerShell\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n```\n\n`Chocolatey` 설치가 완료되었다면 `choco` 라는 명령어가 실행 가능할 겁니다.\n\n4. 아래의 명령어로 Flutter SDK를 설치합니다.\n\n```shell:PowerShell\nchoco install flutter\n```\n\n### 설치 확인 방법 (1)\n\n터미널 창에 `flutter` 를 입력해봅시다.\n`Command not found` 와 같은 에러를 제외하고 뭐라도 뜬다면 설치가 완료된 것입니다.\n\n---\n\n## 애뮬레이터 설치\n\n아래의 공식 문서를 통해 설치하는 것이 가장 바람직합니다.\n설명도 친절해서 왠만하면 설치하는데 문제가 없을겁니다. (아예 없진 않음...)\n관련 링크를 아래에 정리합니다.\n\n🫧[**MacOS - ios setup**](https://docs.flutter.dev/get-started/install/macos#ios-setup)\n🫧[**MacOS - android setup**](https://docs.flutter.dev/get-started/install/macos#android-setup)\n\n🫧[**Windows - android setup**](https://docs.flutter.dev/get-started/install/windows#android-setup)\n\n### 설치 확인 방법 (2)\n\n터미널 창에 `flutter doctor` 를 입력해봅시다.\n![230913-220216](/posts/001_installation/230913-220216.png)\n\nSDK, 애뮬레이터, 에디터까지 발생하는 문제사항을 한 눈에 파악할 수 있습니다.\n\n<tip>\n  참고로 최초 실행시 안드로이드 라이센스에 동의하라는 에러 혹은 경고가 나타날 수 있습니다. \n  그럴 땐 당황하지 마시고 아래의 명령어를 입력하면 됩니다.\n  (_설치할 때 꼼꼼히 읽어보면 이런 내용도 있다는 걸 확인할 수 있죠..._)\n\n  <br />\n\n  ```bash:Terminal\n  flutter doctor --android-licenses\n  ```\n</tip>\n\n### Troubleshooting\n\n간혹가다 Xcode `command line tools`에서 문제가 발생하는 경우가 있습니다.\n명령어 라인 도구는 Xcode를 설치할 때 자동적으로 설치됩니다.\n\n하지만 제 경우에는 Xcode를 설치하기 전에 아래의 명령어로 미리 설치한 적이 있었습니다.\n\n```bash:Terminal\nxcode-select --install\n```\n\n명령어 라인 도구를 먼저 설치하고 Xcode를 설치하면 가끔 정상동작하지 않는 에러가 발생하는 거 같습니다.\n이런 경우에는 명령어 라인 도구를 제거하고 다시 설치하면 해결됩니다.\n\n---\n\n## VSCode 세팅\n\n사실 마켓플레이스에서 `Flutter`, `Dart` 확장을 설치하기만 하면 개발할 준비가 끝나긴 합니다.\n하지만, 개발 편의성과 코드 통일을 위해서 필요한, 혹은 유용한 `확장`과 `setting.json`을 공유할까 합니다.\n\n### setting.json\n\n아래와 같은 키값을 추가하면 개발에 있어 편의성이 증진됩니다.\n하지만, 설정을 건드릴 땐, 본인의 설정과 충돌이 생기는지 반드시 확인한 후에 추가하시는 것을 권장합니다.\n\n참고로, setting.json은 `명령 팔레트`를 열고 `settings.json`을 검색하면 바로 나옵니다.\n또 참고로, 명령 팔레트는 `Command(Window) + Shift + P` 명령어 조합으로 열 수 있습니다.\n\n```json:settings.json showLineNumbers\n{\n  ...\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll\": true\n  },\n  \"dart.previewFlutterUiGuides\": true,\n}\n```\n\n`Line 3-5`의 설정은 자동으로 필요한 모든 곳에 `const` 키워드를 삽입해주는 설정입니다.\nflutter에서 const를 사용하는 것은 매우 중요한데 그 이유에 대해서는 다음에 설명하도록 하겠습니다.\n일단은 가능하다면 반드시 const를 붙이는게 좋고, 이를 자동으로 붙여줄 수 있다는 것만 기억합니다.\n\n`Line 6`의 설정은 flutter 위젯을 트리 구조로 선으로 연결해주는 설정입니다.\n![230913-222546](/posts/001_installation/230913-222546.png)\n\nflutter은 위젯의 depth가 깊어지는 단점이 있는데 이를 어느정도 극복하게 해주는 유용한 설정입니다.\n\n### Error Lens\n\n![230913-223129](/posts/001_installation/230913-223129.png)\n\nError Lens는 코드 문제의 원인을 에디터상에 바로 띄워주는 확장입니다.\n실시간으로 무슨 에러가 있는지 한 눈에 확인할 수 있는게 개인적으로 매우 만족하면서 사용하고 있습니다.\n\n![230913-223528](/posts/001_installation/230913-223528.png)\n\n개인적으로 눈뽕(?) 방지를 위해 `line` 이 아닌, `message` 로 설정하는 것을 추천드립니다.\n\n![230913-224036](/posts/001_installation/230913-224036.png)\n\n또한, 분석 레벨에서 `info` 는 제거해주시는 것을 추천 드립니다.\n\nflutter의 경우 info가 중첩되서 뜨는 경우가 많기에 위 두 세팅을 바꾸지 않으면 아래와 같은 눈뽕(?)을 자주 겪게 될 지도 모릅니다...\n![230913-223954](/posts/001_installation/230913-223954.png)\n\n### Image preview\n\n![230913-224456](/posts/001_installation/230913-224456.png)\n\nImage preview는 로컬, 네트워크 이미지를 미리보기 형식으로 띄워주는 확장입니다.\nFE 개발 입장에서 이미지나 svg, icon을 사용할 일이 많은데, 이를 미리볼 수 있다는 것 만으로도 많은 시간을 절약할 수 있습니다.\n\n---\n\n## VSCode 단축키\n\n개발 시간을 줄여주는 유용한 단축키 및 snippets 를 소개합니다.\n\n### Code Action\n\n![230913-224956](/posts/001_installation/230913-224956.png)\n\nflutter 개발을 하다보면 중간에 위젯을 다른 위젯으로 감싸거나, 부모 위젯을 통째로 드러내야 하는 경우가 잦은데,\n이를 일일이 코드를 잘라내고 붙여넣기 하는건 매우 귀찮은 작업입니다.\n\n하지만 이 기능을 수행하는데 있어 Code Action은 매우 유용한 도구들을 제공합니다.\n\n기능을 수행하고자 하는 위젯의 좌측에 `💡(전구) 모양 아이콘`을 클릭하면 해당 위젯에서 수행할 수 있는 여러 기능들을 보여줍니다.\n\n또는 `Command(Window) + .` 단축키로 빠르게 Code Action에 접근할 수 있습니다.\n매우매우 자주쓰는 기능이니 본인 에디터 환경에 맞는 단축키를 외우도록 합시다.\n~_(사실 외울 필요도 없이 쓰다보면 손가락이 알아서 움직이게 된다는...)_~\n\n### Intellisense\n\n쉽게 말하면 `코드 추천 + 자동완성` 기능입니다.\n\n코드를 입력하다 보면 자동으로 코드를 추천해줄텐데, 실수로 이를 꺼버리는 일이 발생합니다.\n이 경우 코드를 지웠다가 다시 치는 것 보단, `Option(Alt) + Space`로 다시 활성화 시키는 것이 더 유용합니다.\n\n### st + (intellisense)\n\n![230913-230035](/posts/001_installation/230913-230035.png)\n\n플러터의 위젯의 대부분은 Stateful, Stateless 위젯을 상속 받습니다.\n그에 따라 여러 메서드를 override해서 사용해야만 하는데요,\n이 모든 코드를 일일이 입력하는 것도, 기억하는 것도 쉽지 않습니다.\n\n이 경우에는 `st`를 입력하고 intellisense 기능을 이용하면 VSCode가 알아서\nStateful, Stateless 위젯의 필수 부분을 알아서 완성해주고,\n클래스 이름과 관련한 부분 모두를 선택한 상태로 사용자의 입력을 기다리게 됩니다.\n\n따라서 사용자는 아래의 절차를 밟으면 간단하게 위젯 하나를 생성할 수 있게 됩니다.\n\n1. st + (intellisense)\n2. 원하는 부모위젯(Stateful, Stateless) 선택\n3. 원하는 클래스 이름 입력\n\n## 마무리\n\n지금까지 Flutter SDK 설치부터 VSCode 단축키까지 개발에 앞서 필요한 모든 준비단계를 알아봤습니다.\n추가로 필요한 설정이나 기능은 알아보시고 추가하여 사용하신다면, 개발이 조금이라도 더 즐거워지리라 생각됩니다.\n\n긴 글 읽어주셔서 감사드리고, 모두 알찬 `Flutt-er` 생활 되시길 바랍니다!\n","slug":"flutter/001_installation","readingMinutes":14,"wordCount":1023},{"title":"Flutter & Dart","description":"스스로 배우며 깨달은 플러터 지식의 산실입니다.","icon":"","image":"","tags":[],"draft":false,"date":"2023-09-13 / 21:09","content":"","slug":"flutter/index","readingMinutes":0,"wordCount":1}],"mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    strong: \"strong\",\n    code: \"code\",\n    h2: \"h2\",\n    span: \"span\",\n    br: \"br\",\n    h3: \"h3\",\n    div: \"div\",\n    pre: \"pre\",\n    blockquote: \"blockquote\",\n    img: \"img\",\n    hr: \"hr\"\n  }, _provideComponents(), props.components), {YT} = _components;\n  if (!YT) _missingMdxReference(\"YT\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"notice\", {\n      children: _jsxs(_components.p, {\n        children: [\"기초적인 지식이 필요하신 분들은 \", _jsx(_components.a, {\n          href: \"https://wjlee611.github.io/blog/flutter/003_dart_basic\",\n          children: _jsx(_components.strong, {\n            children: _jsx(_components.code, {\n              children: \"Dart 언어 기초\"\n            })\n          })\n        }), \" 포스트를 읽어보시길 권장드립니다.\"]\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"async--await\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#async--await\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"async / await\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"async\"\n      }), \", \", _jsx(_components.code, {\n        children: \"await\"\n      }), \" 키워드는 \", _jsx(_components.strong, {\n        children: \"비동기 프로그래밍\"\n      }), \"시 빠지지 않는 키워드입니다.\", _jsx(_components.br, {}), \"\\n\", \"여기서 \", _jsx(_components.code, {\n        children: \".then()\"\n      }), \" 메서드나 Dart 에서 \", _jsx(_components.code, {\n        children: \"Future<T>\"\n      }), \" 도 포함해서 원리와 적절한 사용법까지 알아보고자 합니다.\"]\n    }), \"\\n\", _jsx(\"tip\", {\n      children: _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"비동기 프로그래밍\"\n        }), _jsx(_components.br, {}), \"\\n\", \"특정 코드가 완료되기 전, 다른 코드를 수행함으로서 코드의 실행 순서가 순차적(동기적)으로 실행되지 않는 프로그래밍 방식입니다.\", _jsx(_components.br, {}), \"\\n\", \"보통 처리완료까지 시간이 많이 걸리는 네트워크 통신이나 파일 입출력 등에 많이 사용됩니다.\"]\n      })\n    }), \"\\n\", _jsxs(\"notice\", {\n      children: [_jsxs(_components.p, {\n        children: [\"비동기 처리는 \", _jsx(_components.code, {\n          children: \"단일 스레드(Dart의 경우 단일 Isolate) 환경\"\n        }), \"에서 이루어집니다.\", _jsx(_components.br, {}), \"\\n\", \"따라서 비동기 처리를 한다고 해도, 비동기 함수가 \", _jsx(_components.code, {\n          children: \"컴퓨팅 자원 사용량이 많다\"\n        }), \"면 해당 스레드(Isolate)는 \", _jsx(_components.code, {\n          children: \"일시 정지\"\n        }), \"되는 현상이 발생할 수 있습니다.\"]\n      }), _jsx(\"br\", {}), _jsxs(_components.p, {\n        children: [\"이와 관련한 자세한 내용은 아래 \", _jsx(_components.a, {\n          href: \"https://wjlee611.github.io/blog/flutter/004_dart_advanced#isolate\",\n          children: _jsx(_components.strong, {\n            children: _jsx(_components.code, {\n              children: \"Isolate\"\n            })\n          })\n        }), \" 파트에서 다루겠습니다.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"future\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#future\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Future\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Future\"\n      }), \" 객체는 지금 당장은 처리되지 않았지만, 미래에 처리가 완료될 데이터를 알려주는 객체입니다.\", _jsx(_components.br, {}), \"\\n\", \"예를 들어봅시다.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \".dart\"\n    }), _jsx(_components.pre, {\n      className: \"language-dart\",\n      children: _jsxs(_components.code, {\n        className: \"language-dart code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Future\"\n          }), _jsxs(_components.span, {\n            className: \"token generics\",\n            children: [_jsx(_components.span, {\n              className: \"token punctuation\",\n              children: \"<\"\n            }), _jsx(_components.span, {\n              className: \"token class-name\",\n              children: \"String\"\n            }), _jsx(_components.span, {\n              className: \"token punctuation\",\n              children: \">\"\n            })]\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"futureStr\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"async\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token string-literal\",\n            children: _jsx(_components.span, {\n              className: \"token string\",\n              children: \"'do something'\"\n            })\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"return\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Future\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), _jsx(_components.span, {\n            className: \"token function\",\n            children: \"delayed\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Duration\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"seconds\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \":\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token number\",\n            children: \"2\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), _jsx(_components.span, {\n            className: \"token operator\",\n            children: \">\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token string-literal\",\n            children: _jsx(_components.span, {\n              className: \"token string\",\n              children: \"'future string'\"\n            })\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"main\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token string-literal\",\n            children: _jsx(_components.span, {\n              className: \"token string\",\n              children: \"'start'\"\n            })\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token function\",\n            children: \"futureStr\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"위의 futureStr() 함수는 호출 후 2초뒤에 'future string'을 반환하는 함수입니다.\", _jsx(_components.br, {}), \"\\n\", \"실행결과는 어떻게 될까요?\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"start\", _jsx(_components.br, {}), \"\\n\", \"do something\", _jsx(_components.br, {}), \"\\n\", \"Instance of 'Future<String>'\", _jsx(_components.br, {}), \"\\n\", \"(2초 후 종료)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"답은 \", _jsx(_components.code, {\n        children: \"future 객체\"\n      }), \" 입니다.\", _jsx(_components.br, {}), \"\\n\", \"어찌보면 당연합니다. \", _jsx(_components.code, {\n        children: \"main\"\n      }), \" 함수는 비동기 함수도 아닐 뿐더러 futureStr의 리턴값은 \", _jsx(_components.code, {\n        children: \"Future<String>\"\n      }), \" 이라고 명시해두었으니 말이죠.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/posts/004_dart_advanced/230917-211924.png\",\n        alt: \"230917-211924\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"future는 \", _jsx(_components.code, {\n        children: \"Uncompleted\"\n      }), \", \", _jsx(_components.code, {\n        children: \"Completed\"\n      }), \" 상태를 갖습니다.\", _jsx(_components.br, {}), \"\\n\", \"비동기 함수 호출시에 future은 Uncompleted 상태를 갖습니다.\", _jsx(_components.br, {}), \"\\n\", \"따라서 \", _jsx(_components.code, {\n        children: \"Instance of 'Future<String>'\"\n      }), \"와 같은 결과를 출력한 것이죠.\", _jsx(_components.br, {}), \"\\n\", \"하지만 함수가 성공적으로 종료되면 future은 비로소 Completed 상태를 갖습니다.\", _jsx(_components.br, {}), \"\\n\", \"따라서 \", _jsx(_components.code, {\n        children: \"future string\"\n      }), \"과 같은 결과를 출력하게 될 것입니다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"사용자 입장에서는 Future 객체는 중요하지 않습니다. 중요한 것은 Future 객체가 처리되고 나서 반환되는 데이터인거죠.\", _jsx(_components.br, {}), \"\\n\", \"따라서, Future 객체의 처리(비동기 함수)를 원활히 하기위해 \", _jsx(_components.code, {\n        children: \"async\"\n      }), \", \", _jsx(_components.code, {\n        children: \"await\"\n      }), \" 키워드를 사용하는 것입니다.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"async\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#async\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"async\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"async 키워드는 이 함수가 비동기 처리를 수행하는 함수임을 명시하는 키워드 입니다.\", _jsx(_components.br, {}), \"\\n\", \"다만 위의 예시에서 보듯, 반드시 \", _jsx(_components.code, {\n        children: \"Future<T>\"\n      }), \" 객체 또는 \", _jsx(_components.code, {\n        children: \"void\"\n      }), \"를 반환해야만 합니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그렇다면, main 함수를 async 키워드를 붙여 실행한다면 제대로된 결과가 나올까요?\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \".dart\"\n    }), _jsx(_components.pre, {\n      className: \"language-dart\",\n      children: _jsxs(_components.code, {\n        className: \"language-dart code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Future\"\n          }), _jsxs(_components.span, {\n            className: \"token generics\",\n            children: [_jsx(_components.span, {\n              className: \"token punctuation\",\n              children: \"<\"\n            }), _jsx(_components.span, {\n              className: \"token class-name\",\n              children: \"String\"\n            }), _jsx(_components.span, {\n              className: \"token punctuation\",\n              children: \">\"\n            })]\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"futureStr\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"async\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token string-literal\",\n            children: _jsx(_components.span, {\n              className: \"token string\",\n              children: \"'do something'\"\n            })\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"return\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Future\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), _jsx(_components.span, {\n            className: \"token function\",\n            children: \"delayed\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Duration\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"seconds\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \":\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token number\",\n            children: \"2\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), _jsx(_components.span, {\n            className: \"token operator\",\n            children: \">\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token string-literal\",\n            children: _jsx(_components.span, {\n              className: \"token string\",\n              children: \"'future string'\"\n            })\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"main\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"async\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token string-literal\",\n            children: _jsx(_components.span, {\n              className: \"token string\",\n              children: \"'start'\"\n            })\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token function\",\n            children: \"futureStr\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"start\", _jsx(_components.br, {}), \"\\n\", \"do something\", _jsx(_components.br, {}), \"\\n\", \"Instance of 'Future<String>'\", _jsx(_components.br, {}), \"\\n\", \"(2초 후 종료)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"그렇습니다. 함수를 비동기 처리하는 함수로 선언한다고 해서 해결되지는 않습니다.\", _jsx(_components.br, {}), \"\\n\", \"함수 내부에서 비동기 처리가 진행될 수 있다는 것을 암시할 뿐, \", _jsx(_components.code, {\n        children: \"어디서\"\n      }), \" 비동기 처리를 해야하는 지는 명시하지 않았기 때문이죠.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"await\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#await\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"await\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"await 키워드는 \", _jsx(_components.strong, {\n        children: \"해당 키워드가 명시된 비동기 처리\"\n      }), \"(futureStr)가 완료될 때 까지 \", _jsx(_components.strong, {\n        children: \"비동기 함수\"\n      }), \"(main)의 처리를 \", _jsx(_components.code, {\n        children: \"멈추겠다\"\n      }), \"는 의미입니다.\", _jsx(_components.br, {}), \"\\n\", \"그렇기에 await 키워드는 반드시 async 키워드가 명시된 함수 내부에서만 사용할 수 있는 것입니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그렇다면 futureStr의 함수 앞에 await를 명시하여 비동기 함수가 끝날 때 까지 대기시킨다면 어떨까요?\"\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \".dart\"\n    }), _jsx(_components.pre, {\n      className: \"language-dart\",\n      children: _jsxs(_components.code, {\n        className: \"language-dart code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Future\"\n          }), _jsxs(_components.span, {\n            className: \"token generics\",\n            children: [_jsx(_components.span, {\n              className: \"token punctuation\",\n              children: \"<\"\n            }), _jsx(_components.span, {\n              className: \"token class-name\",\n              children: \"String\"\n            }), _jsx(_components.span, {\n              className: \"token punctuation\",\n              children: \">\"\n            })]\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"futureStr\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"async\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token string-literal\",\n            children: _jsx(_components.span, {\n              className: \"token string\",\n              children: \"'do something'\"\n            })\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token comment\",\n            children: \"// return Future.delayed(Duration(seconds: 2), () => 'future string');\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"await\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Future\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), _jsx(_components.span, {\n            className: \"token function\",\n            children: \"delayed\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Duration\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"seconds\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \":\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token number\",\n            children: \"2\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"return\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token string-literal\",\n            children: _jsx(_components.span, {\n              className: \"token string\",\n              children: \"'future string'\"\n            })\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"main\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"async\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token string-literal\",\n            children: _jsx(_components.span, {\n              className: \"token string\",\n              children: \"'start'\"\n            })\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"await\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"futureStr\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"start\", _jsx(_components.br, {}), \"\\n\", \"do something\", _jsx(_components.br, {}), \"\\n\", \"(2초 대기)\", _jsx(_components.br, {}), \"\\n\", \"future string\", _jsx(_components.br, {}), \"\\n\", \"(즉시 종료)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"비로소 원하던 결과가 나왔습니다.\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h2, {\n      id: \"isolate\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#isolate\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Isolate\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Isolate\"\n      }), \"는 Dart에서 스레드를 부르는 용어라고 생각하시면 됩니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/posts/004_dart_advanced/230917-221122.png\",\n        alt: \"230917-221122\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Isolate는 스레드와 마찬가지로 멀티 코어 CPU의 장점을 살리는 프로그래밍 기법으로 \", _jsx(_components.code, {\n        children: \"별도의 이벤트 루프\"\n      }), \"를 갖는 실행 흐름을 만들어 \", _jsx(_components.code, {\n        children: \"병렬적인 처리\"\n      }), \"를 가능케 합니다.\", _jsx(_components.br, {}), \"\\n\", \"하지만, 스레드와 용어에서의 차이점을 두는 이유가 있습니다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"보통 \", _jsx(_components.strong, {\n        children: \"스레드\"\n      }), \"라 하면 \", _jsx(_components.code, {\n        children: \"메모리 영역을 공유\"\n      }), \"한다고 배웠습니다. 하지만 그 때문에 \", _jsx(_components.code, {\n        children: \"race-condition\"\n      }), \"이 발생하는 문제점을 고려하여 프로그래밍을 했어야 합니다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"하지만, \", _jsx(_components.strong, {\n        children: \"Isolate\"\n      }), \"는 스레드와 다르게 \", _jsx(_components.code, {\n        children: \"메모리 영역 또한 공유하지 않습니다\"\n      }), \".(물론 코드 영역은 공유합니다)\", _jsx(_components.br, {}), \"\\n\", \"그렇기에 mutex, lock 등을 고려할 필요가 없는 편의성이 있습니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 왜 Isolate를 알아야 하고, 사용해야만 할까요?\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"isolate-vs-async\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#isolate-vs-async\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Isolate vs Async\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래의 영상을 확인해봅시다.\"\n    }), \"\\n\", _jsx(YT, {\n      id: \"HkBaS098BrE\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Main isolate\"\n      }), \"부분은 json 데이터 파싱과 화면 빌드를 \", _jsx(_components.code, {\n        children: \"하나의 isolate\"\n      }), \"에서 구동한 결과입니다.\", _jsx(_components.br, {}), \"\\n\", \"영상에서 보시는 바와 같듯 십몇만줄의 json 파싱은 단일 isolate 환경에서 구동하기에는 다소 무리가 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"아무리 async로 실행 결과를 뒤로 미룬다 할지라도 실제 데이터 파싱하는 동작과 화면을 그리는 동작 모두 \", _jsx(_components.code, {\n        children: \"동일한 isolate\"\n      }), \"에서 처리되기 때문에 \", _jsx(_components.code, {\n        children: \"성능상 이슈\"\n      }), \"가 생길 수 밖에 없습니다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"하지만 \", _jsx(_components.code, {\n        children: \"Worker isolate\"\n      }), \"부분은 json 데이터 파싱을 \", _jsx(_components.code, {\n        children: \"별도의 worker isolate\"\n      }), \"에서 구동한 결과입니다.\", _jsx(_components.br, {}), \"\\n\", \"차이는 명확합니다. 화면에 그리는 동작과 파싱 동작이 \", _jsx(_components.code, {\n        children: \"별도의 isolate\"\n      }), \"에서 처리되기 때문에 화면을 그리는 부분에서 \", _jsx(_components.code, {\n        children: \"랙이 걸리지 않습니다\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이렇듯 단일 isolate에서 동작이 버벅일 정도로 무거운 기능을 수행해야 한다면, 해당 기능은 별도의 isolate로 빼서 처리하는 것이 사용자에게 더 나은 경험을 제공하게 됩니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"해당 영상에서 구동하는 코드는 \", _jsx(_components.a, {\n        href: \"https://github.com/wjlee611/arkhive/blob/main/lib/bloc/enemy/enemy_data/enemy_data_bloc.dart\",\n        children: _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"Arkhive repo\"\n          })\n        })\n      }), \"에서 확인하실 수 있습니다.\"]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.h2, {\n      id: \"function\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#function\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"function\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"callback-function\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#callback-function\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"callback function\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"콜백 함수는 함수의 인자로 넘겨주어 넘겨받은 함수 내부에서 실행 가능한 함수를 의미합니다.\", _jsx(_components.br, {}), \"\\n\", \"예시를 살펴봅시다.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \".dart\"\n    }), _jsx(_components.pre, {\n      className: \"language-dart\",\n      children: _jsxs(_components.code, {\n        className: \"language-dart code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"main\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  int value \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token number\",\n            children: \"0\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token function\",\n            children: \"valueModifire\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \":\"\n          }), \" value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \" modifire\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \":\"\n          }), \" add1\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token comment\",\n            children: \"// 1\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token function\",\n            children: \"valueModifire\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \":\"\n          }), \" value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \" modifire\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \":\"\n          }), \" sub1\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token comment\",\n            children: \"// -1\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"int \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"add1\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"int value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), _jsx(_components.span, {\n            className: \"token operator\",\n            children: \">\"\n          }), \" value \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"+\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token number\",\n            children: \"1\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"int \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"sub1\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"int value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), _jsx(_components.span, {\n            className: \"token operator\",\n            children: \">\"\n          }), \" value \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"-\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token number\",\n            children: \"1\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"int \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"valueModifire\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  required int value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  required \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Function\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"int\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" modifire\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"return\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"modifire\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"위 코드에서는 \", _jsx(_components.code, {\n        children: \"valueModifire\"\n      }), \"의 인자로서 \", _jsx(_components.code, {\n        children: \"add1\"\n      }), \", \", _jsx(_components.code, {\n        children: \"sub1\"\n      }), \"을 전달했습니다.\", _jsx(_components.br, {}), \"\\n\", \"이 때, 이 두 함수를 \", _jsx(_components.code, {\n        children: \"callback function\"\n      }), \"라고 부르고, 이 함수는 valueModifire 내부에서 \", _jsx(_components.code, {\n        children: \"modifire\"\n      }), \"의 형태로 호출됩니다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"보통은 이런식으로 \", _jsx(_components.code, {\n        children: \"동일한 함수\"\n      }), \" 내부에서 \", _jsx(_components.code, {\n        children: \"서로 다른 기능\"\n      }), \"을 수행해야 할 때 콜백 함수로서 전달하는 경우가 많습니다.\"]\n    }), \"\\n\", _jsx(_components.div, {\n      className: \"rehype-code-title\",\n      children: \".dart\"\n    }), _jsx(_components.pre, {\n      className: \"language-dart\",\n      children: _jsxs(_components.code, {\n        className: \"language-dart code-highlight\",\n        children: [_jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"main\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"async\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  int value \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token number\",\n            children: \"0\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"await\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"valueModifire\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \":\"\n          }), \" value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \" modifire\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \":\"\n          }), \" add1\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token comment\",\n            children: \"// await 1 second -> 1\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"print\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"await\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"valueModifire\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \":\"\n          }), \" value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \" modifire\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \":\"\n          }), \" sub1\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token comment\",\n            children: \"// await 1 second -> -1\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"int \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"add1\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"int value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), _jsx(_components.span, {\n            className: \"token operator\",\n            children: \">\"\n          }), \" value \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"+\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token number\",\n            children: \"1\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"int \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"sub1\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"int value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"=\"\n          }), _jsx(_components.span, {\n            className: \"token operator\",\n            children: \">\"\n          }), \" value \", _jsx(_components.span, {\n            className: \"token operator\",\n            children: \"-\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token number\",\n            children: \"1\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsx(_components.span, {\n          className: \"code-line\",\n          children: \"\\n\"\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Future\"\n          }), _jsxs(_components.span, {\n            className: \"token generics\",\n            children: [_jsx(_components.span, {\n              className: \"token punctuation\",\n              children: \"<\"\n            }), \"int\", _jsx(_components.span, {\n              className: \"token punctuation\",\n              children: \">\"\n            })]\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"valueModifire\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  required int value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  required \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Function\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"int\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" modifire\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \",\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"async\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"{\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"await\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Future\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \".\"\n          }), _jsx(_components.span, {\n            className: \"token function\",\n            children: \"delayed\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), _jsx(_components.span, {\n            className: \"token class-name\",\n            children: \"Duration\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"seconds\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \":\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token number\",\n            children: \"1\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token comment\",\n            children: \"// something actions\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [\"  \", _jsx(_components.span, {\n            className: \"token keyword\",\n            children: \"return\"\n          }), \" \", _jsx(_components.span, {\n            className: \"token function\",\n            children: \"modifire\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"(\"\n          }), \"value\", _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \")\"\n          }), _jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \";\"\n          }), \"\\n\"]\n        }), _jsxs(_components.span, {\n          className: \"code-line\",\n          children: [_jsx(_components.span, {\n            className: \"token punctuation\",\n            children: \"}\"\n          }), \"\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"또는, \", _jsx(_components.code, {\n        children: \"특정 함수의 동작이 끝난 후\"\n      }), \" 수행해야 할 기능이 있을 때 많이 사용되곤 합니다.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"toc":[{"slug":"async--await","text":"async / await","subSections":[{"slug":"future","text":"Future"},{"slug":"async","text":"async"},{"slug":"await","text":"await"}]},{"slug":"isolate","text":"Isolate","subSections":[{"slug":"isolate-vs-async","text":"Isolate vs Async"}]},{"slug":"function","text":"function","subSections":[{"slug":"callback-function","text":"callback function"}]}]},"__N_SSG":true}